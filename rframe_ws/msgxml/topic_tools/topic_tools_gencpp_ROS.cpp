// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:09 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "topic_tools_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace topic_tools;

rframe::ROSMessageFactory * ROS_topic_tools_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_topic_tools_gencppfactory = new topic_tools_gencppROSMessageFactory();

        return ROS_topic_tools_gencppfactory;
    };
}

rframe::ROSMessageFactory * topic_tools::allocate_topic_tools_gencpp()
{
    ROS_topic_tools_gencppfactory = new topic_tools_gencppROSMessageFactory();
    return ROS_topic_tools_gencppfactory;
};

topic_tools_gencppROSMessageFactory::topic_tools_gencppROSMessageFactory()
{
    name("topic_tools_gencpp");
    // use constructor to register data types
    topic_tools::registerLibrary();
}

topic_tools_gencppROSMessageFactory::~topic_tools_gencppROSMessageFactory()
{
}

int topic_tools_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void topic_tools_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(DemuxAddRequest::ID);
    info.name(DemuxAddRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxAddRequest::DATA_VERSION);
    info.md5Key(DemuxAddRequest::VERSION_MD5);
    info.xmlSource(DemuxAddRequest::XML_SOURCE);
    info.flat(DemuxAddRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxAddResponse::ID);
    info.name(DemuxAddResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxAddResponse::DATA_VERSION);
    info.md5Key(DemuxAddResponse::VERSION_MD5);
    info.xmlSource(DemuxAddResponse::XML_SOURCE);
    info.flat(DemuxAddResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxAdd::ID);
    info.name(DemuxAdd::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxAdd::DATA_VERSION);
    info.md5Key(DemuxAdd::VERSION_MD5);
    info.xmlSource(DemuxAdd::XML_SOURCE);
    info.flat(DemuxAdd::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxDeleteRequest::ID);
    info.name(DemuxDeleteRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxDeleteRequest::DATA_VERSION);
    info.md5Key(DemuxDeleteRequest::VERSION_MD5);
    info.xmlSource(DemuxDeleteRequest::XML_SOURCE);
    info.flat(DemuxDeleteRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxDeleteResponse::ID);
    info.name(DemuxDeleteResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxDeleteResponse::DATA_VERSION);
    info.md5Key(DemuxDeleteResponse::VERSION_MD5);
    info.xmlSource(DemuxDeleteResponse::XML_SOURCE);
    info.flat(DemuxDeleteResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxDelete::ID);
    info.name(DemuxDelete::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxDelete::DATA_VERSION);
    info.md5Key(DemuxDelete::VERSION_MD5);
    info.xmlSource(DemuxDelete::XML_SOURCE);
    info.flat(DemuxDelete::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxListRequest::ID);
    info.name(DemuxListRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxListRequest::DATA_VERSION);
    info.md5Key(DemuxListRequest::VERSION_MD5);
    info.xmlSource(DemuxListRequest::XML_SOURCE);
    info.flat(DemuxListRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxListResponse::ID);
    info.name(DemuxListResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxListResponse::DATA_VERSION);
    info.md5Key(DemuxListResponse::VERSION_MD5);
    info.xmlSource(DemuxListResponse::XML_SOURCE);
    info.flat(DemuxListResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxList::ID);
    info.name(DemuxList::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxList::DATA_VERSION);
    info.md5Key(DemuxList::VERSION_MD5);
    info.xmlSource(DemuxList::XML_SOURCE);
    info.flat(DemuxList::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxSelectRequest::ID);
    info.name(DemuxSelectRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxSelectRequest::DATA_VERSION);
    info.md5Key(DemuxSelectRequest::VERSION_MD5);
    info.xmlSource(DemuxSelectRequest::XML_SOURCE);
    info.flat(DemuxSelectRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxSelectResponse::ID);
    info.name(DemuxSelectResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxSelectResponse::DATA_VERSION);
    info.md5Key(DemuxSelectResponse::VERSION_MD5);
    info.xmlSource(DemuxSelectResponse::XML_SOURCE);
    info.flat(DemuxSelectResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxSelect::ID);
    info.name(DemuxSelect::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxSelect::DATA_VERSION);
    info.md5Key(DemuxSelect::VERSION_MD5);
    info.xmlSource(DemuxSelect::XML_SOURCE);
    info.flat(DemuxSelect::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxAddRequest::ID);
    info.name(MuxAddRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxAddRequest::DATA_VERSION);
    info.md5Key(MuxAddRequest::VERSION_MD5);
    info.xmlSource(MuxAddRequest::XML_SOURCE);
    info.flat(MuxAddRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxAddResponse::ID);
    info.name(MuxAddResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxAddResponse::DATA_VERSION);
    info.md5Key(MuxAddResponse::VERSION_MD5);
    info.xmlSource(MuxAddResponse::XML_SOURCE);
    info.flat(MuxAddResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxAdd::ID);
    info.name(MuxAdd::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxAdd::DATA_VERSION);
    info.md5Key(MuxAdd::VERSION_MD5);
    info.xmlSource(MuxAdd::XML_SOURCE);
    info.flat(MuxAdd::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxDeleteRequest::ID);
    info.name(MuxDeleteRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxDeleteRequest::DATA_VERSION);
    info.md5Key(MuxDeleteRequest::VERSION_MD5);
    info.xmlSource(MuxDeleteRequest::XML_SOURCE);
    info.flat(MuxDeleteRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxDeleteResponse::ID);
    info.name(MuxDeleteResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxDeleteResponse::DATA_VERSION);
    info.md5Key(MuxDeleteResponse::VERSION_MD5);
    info.xmlSource(MuxDeleteResponse::XML_SOURCE);
    info.flat(MuxDeleteResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxDelete::ID);
    info.name(MuxDelete::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxDelete::DATA_VERSION);
    info.md5Key(MuxDelete::VERSION_MD5);
    info.xmlSource(MuxDelete::XML_SOURCE);
    info.flat(MuxDelete::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxListRequest::ID);
    info.name(MuxListRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxListRequest::DATA_VERSION);
    info.md5Key(MuxListRequest::VERSION_MD5);
    info.xmlSource(MuxListRequest::XML_SOURCE);
    info.flat(MuxListRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxListResponse::ID);
    info.name(MuxListResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxListResponse::DATA_VERSION);
    info.md5Key(MuxListResponse::VERSION_MD5);
    info.xmlSource(MuxListResponse::XML_SOURCE);
    info.flat(MuxListResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxList::ID);
    info.name(MuxList::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxList::DATA_VERSION);
    info.md5Key(MuxList::VERSION_MD5);
    info.xmlSource(MuxList::XML_SOURCE);
    info.flat(MuxList::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxSelectRequest::ID);
    info.name(MuxSelectRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxSelectRequest::DATA_VERSION);
    info.md5Key(MuxSelectRequest::VERSION_MD5);
    info.xmlSource(MuxSelectRequest::XML_SOURCE);
    info.flat(MuxSelectRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxSelectResponse::ID);
    info.name(MuxSelectResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxSelectResponse::DATA_VERSION);
    info.md5Key(MuxSelectResponse::VERSION_MD5);
    info.xmlSource(MuxSelectResponse::XML_SOURCE);
    info.flat(MuxSelectResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxSelect::ID);
    info.name(MuxSelect::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxSelect::DATA_VERSION);
    info.md5Key(MuxSelect::VERSION_MD5);
    info.xmlSource(MuxSelect::XML_SOURCE);
    info.flat(MuxSelect::dataTypeFlat());
    ids.push_back(info);

}

int topic_tools_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case DemuxAddRequest::ID:
        {
            str = "topic_tools/DemuxAddRequest";
            break;
        }
        case DemuxAddResponse::ID:
        {
            str = "topic_tools/DemuxAddResponse";
            break;
        }
        case DemuxAdd::ID:
        {
            str = "topic_tools/DemuxAdd";
            break;
        }
        case DemuxDeleteRequest::ID:
        {
            str = "topic_tools/DemuxDeleteRequest";
            break;
        }
        case DemuxDeleteResponse::ID:
        {
            str = "topic_tools/DemuxDeleteResponse";
            break;
        }
        case DemuxDelete::ID:
        {
            str = "topic_tools/DemuxDelete";
            break;
        }
        case DemuxListRequest::ID:
        {
            str = "topic_tools/DemuxListRequest";
            break;
        }
        case DemuxListResponse::ID:
        {
            str = "topic_tools/DemuxListResponse";
            break;
        }
        case DemuxList::ID:
        {
            str = "topic_tools/DemuxList";
            break;
        }
        case DemuxSelectRequest::ID:
        {
            str = "topic_tools/DemuxSelectRequest";
            break;
        }
        case DemuxSelectResponse::ID:
        {
            str = "topic_tools/DemuxSelectResponse";
            break;
        }
        case DemuxSelect::ID:
        {
            str = "topic_tools/DemuxSelect";
            break;
        }
        case MuxAddRequest::ID:
        {
            str = "topic_tools/MuxAddRequest";
            break;
        }
        case MuxAddResponse::ID:
        {
            str = "topic_tools/MuxAddResponse";
            break;
        }
        case MuxAdd::ID:
        {
            str = "topic_tools/MuxAdd";
            break;
        }
        case MuxDeleteRequest::ID:
        {
            str = "topic_tools/MuxDeleteRequest";
            break;
        }
        case MuxDeleteResponse::ID:
        {
            str = "topic_tools/MuxDeleteResponse";
            break;
        }
        case MuxDelete::ID:
        {
            str = "topic_tools/MuxDelete";
            break;
        }
        case MuxListRequest::ID:
        {
            str = "topic_tools/MuxListRequest";
            break;
        }
        case MuxListResponse::ID:
        {
            str = "topic_tools/MuxListResponse";
            break;
        }
        case MuxList::ID:
        {
            str = "topic_tools/MuxList";
            break;
        }
        case MuxSelectRequest::ID:
        {
            str = "topic_tools/MuxSelectRequest";
            break;
        }
        case MuxSelectResponse::ID:
        {
            str = "topic_tools/MuxSelectResponse";
            break;
        }
        case MuxSelect::ID:
        {
            str = "topic_tools/MuxSelect";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case DemuxAddRequest::ID:
        {
            str = DemuxAddRequest::XML_SOURCE;
            break;
        }
        case DemuxAddResponse::ID:
        {
            str = DemuxAddResponse::XML_SOURCE;
            break;
        }
        case DemuxAdd::ID:
        {
            str = DemuxAdd::XML_SOURCE;
            break;
        }
        case DemuxDeleteRequest::ID:
        {
            str = DemuxDeleteRequest::XML_SOURCE;
            break;
        }
        case DemuxDeleteResponse::ID:
        {
            str = DemuxDeleteResponse::XML_SOURCE;
            break;
        }
        case DemuxDelete::ID:
        {
            str = DemuxDelete::XML_SOURCE;
            break;
        }
        case DemuxListRequest::ID:
        {
            str = DemuxListRequest::XML_SOURCE;
            break;
        }
        case DemuxListResponse::ID:
        {
            str = DemuxListResponse::XML_SOURCE;
            break;
        }
        case DemuxList::ID:
        {
            str = DemuxList::XML_SOURCE;
            break;
        }
        case DemuxSelectRequest::ID:
        {
            str = DemuxSelectRequest::XML_SOURCE;
            break;
        }
        case DemuxSelectResponse::ID:
        {
            str = DemuxSelectResponse::XML_SOURCE;
            break;
        }
        case DemuxSelect::ID:
        {
            str = DemuxSelect::XML_SOURCE;
            break;
        }
        case MuxAddRequest::ID:
        {
            str = MuxAddRequest::XML_SOURCE;
            break;
        }
        case MuxAddResponse::ID:
        {
            str = MuxAddResponse::XML_SOURCE;
            break;
        }
        case MuxAdd::ID:
        {
            str = MuxAdd::XML_SOURCE;
            break;
        }
        case MuxDeleteRequest::ID:
        {
            str = MuxDeleteRequest::XML_SOURCE;
            break;
        }
        case MuxDeleteResponse::ID:
        {
            str = MuxDeleteResponse::XML_SOURCE;
            break;
        }
        case MuxDelete::ID:
        {
            str = MuxDelete::XML_SOURCE;
            break;
        }
        case MuxListRequest::ID:
        {
            str = MuxListRequest::XML_SOURCE;
            break;
        }
        case MuxListResponse::ID:
        {
            str = MuxListResponse::XML_SOURCE;
            break;
        }
        case MuxList::ID:
        {
            str = MuxList::XML_SOURCE;
            break;
        }
        case MuxSelectRequest::ID:
        {
            str = MuxSelectRequest::XML_SOURCE;
            break;
        }
        case MuxSelectResponse::ID:
        {
            str = MuxSelectResponse::XML_SOURCE;
            break;
        }
        case MuxSelect::ID:
        {
            str = MuxSelect::XML_SOURCE;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case DemuxAddRequest::ID:
        {
            str = "d8f94bae31b356b24d0427f80426d0c3";
            break;
        }
        case DemuxAddResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DemuxAdd::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DemuxDeleteRequest::ID:
        {
            str = "d8f94bae31b356b24d0427f80426d0c3";
            break;
        }
        case DemuxDeleteResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DemuxDelete::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DemuxListRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DemuxListResponse::ID:
        {
            str = "b0eef9a05d4e829092fc2f2c3c2aad3d";
            break;
        }
        case DemuxList::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DemuxSelectRequest::ID:
        {
            str = "d8f94bae31b356b24d0427f80426d0c3";
            break;
        }
        case DemuxSelectResponse::ID:
        {
            str = "3db0a473debdbafea387c9e49358c320";
            break;
        }
        case DemuxSelect::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxAddRequest::ID:
        {
            str = "d8f94bae31b356b24d0427f80426d0c3";
            break;
        }
        case MuxAddResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxAdd::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxDeleteRequest::ID:
        {
            str = "d8f94bae31b356b24d0427f80426d0c3";
            break;
        }
        case MuxDeleteResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxDelete::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxListRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxListResponse::ID:
        {
            str = "b0eef9a05d4e829092fc2f2c3c2aad3d";
            break;
        }
        case MuxList::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case MuxSelectRequest::ID:
        {
            str = "d8f94bae31b356b24d0427f80426d0c3";
            break;
        }
        case MuxSelectResponse::ID:
        {
            str = "3db0a473debdbafea387c9e49358c320";
            break;
        }
        case MuxSelect::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case DemuxAddRequest::ID:
        {   
		    highOrder = 0xd8f94bae31b356b2ULL;
            lowOrder = 0x4d0427f80426d0c3ULL;
            break;
        }
        case DemuxAddResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DemuxAdd::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DemuxDeleteRequest::ID:
        {   
		    highOrder = 0xd8f94bae31b356b2ULL;
            lowOrder = 0x4d0427f80426d0c3ULL;
            break;
        }
        case DemuxDeleteResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DemuxDelete::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DemuxListRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DemuxListResponse::ID:
        {   
		    highOrder = 0xb0eef9a05d4e8290ULL;
            lowOrder = 0x92fc2f2c3c2aad3dULL;
            break;
        }
        case DemuxList::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DemuxSelectRequest::ID:
        {   
		    highOrder = 0xd8f94bae31b356b2ULL;
            lowOrder = 0x4d0427f80426d0c3ULL;
            break;
        }
        case DemuxSelectResponse::ID:
        {   
		    highOrder = 0x3db0a473debdbafeULL;
            lowOrder = 0xa387c9e49358c320ULL;
            break;
        }
        case DemuxSelect::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxAddRequest::ID:
        {   
		    highOrder = 0xd8f94bae31b356b2ULL;
            lowOrder = 0x4d0427f80426d0c3ULL;
            break;
        }
        case MuxAddResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxAdd::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxDeleteRequest::ID:
        {   
		    highOrder = 0xd8f94bae31b356b2ULL;
            lowOrder = 0x4d0427f80426d0c3ULL;
            break;
        }
        case MuxDeleteResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxDelete::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxListRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxListResponse::ID:
        {   
		    highOrder = 0xb0eef9a05d4e8290ULL;
            lowOrder = 0x92fc2f2c3c2aad3dULL;
            break;
        }
        case MuxList::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case MuxSelectRequest::ID:
        {   
		    highOrder = 0xd8f94bae31b356b2ULL;
            lowOrder = 0x4d0427f80426d0c3ULL;
            break;
        }
        case MuxSelectResponse::ID:
        {   
		    highOrder = 0x3db0a473debdbafeULL;
            lowOrder = 0xa387c9e49358c320ULL;
            break;
        }
        case MuxSelect::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case DemuxAddRequest::ID:
        case DemuxAddResponse::ID:
        case DemuxAdd::ID:
        case DemuxDeleteRequest::ID:
        case DemuxDeleteResponse::ID:
        case DemuxDelete::ID:
        case DemuxListRequest::ID:
        case DemuxListResponse::ID:
        case DemuxList::ID:
        case DemuxSelectRequest::ID:
        case DemuxSelectResponse::ID:
        case DemuxSelect::ID:
        case MuxAddRequest::ID:
        case MuxAddResponse::ID:
        case MuxAdd::ID:
        case MuxDeleteRequest::ID:
        case MuxDeleteResponse::ID:
        case MuxDelete::ID:
        case MuxListRequest::ID:
        case MuxListResponse::ID:
        case MuxList::ID:
        case MuxSelectRequest::ID:
        case MuxSelectResponse::ID:
        case MuxSelect::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case DemuxAddRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxAddRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxAddResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxAddResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxAdd::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxAdd>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxDeleteRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxDeleteRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxDeleteResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxDeleteResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxDelete::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxDelete>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxListRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxListRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxListResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxListResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxList::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxList>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxSelectRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxSelectRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxSelectResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxSelectResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxSelect::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxSelect>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxAddRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxAddRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxAddResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxAddResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxAdd::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxAdd>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxDeleteRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxDeleteRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxDeleteResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxDeleteResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxDelete::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxDelete>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxListRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxListRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxListResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxListResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxList::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxList>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxSelectRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxSelectRequest>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxSelectResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxSelectResponse>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxSelect::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxSelect>(),std::bind(&topic_tools_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case DemuxAddRequest::ID:
            {
                Message<DemuxAddRequest > & tempSrc = static_cast<Message<DemuxAddRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxAddRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxAddResponse::ID:
            {
                Message<DemuxAddResponse > & tempSrc = static_cast<Message<DemuxAddResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxAddResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxAdd::ID:
            {
                Message<DemuxAdd > & tempSrc = static_cast<Message<DemuxAdd>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxAdd buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxDeleteRequest::ID:
            {
                Message<DemuxDeleteRequest > & tempSrc = static_cast<Message<DemuxDeleteRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxDeleteRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxDeleteResponse::ID:
            {
                Message<DemuxDeleteResponse > & tempSrc = static_cast<Message<DemuxDeleteResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxDeleteResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxDelete::ID:
            {
                Message<DemuxDelete > & tempSrc = static_cast<Message<DemuxDelete>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxDelete buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxListRequest::ID:
            {
                Message<DemuxListRequest > & tempSrc = static_cast<Message<DemuxListRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxListRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxListResponse::ID:
            {
                Message<DemuxListResponse > & tempSrc = static_cast<Message<DemuxListResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxListResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxList::ID:
            {
                Message<DemuxList > & tempSrc = static_cast<Message<DemuxList>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxList buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxSelectRequest::ID:
            {
                Message<DemuxSelectRequest > & tempSrc = static_cast<Message<DemuxSelectRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxSelectRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxSelectResponse::ID:
            {
                Message<DemuxSelectResponse > & tempSrc = static_cast<Message<DemuxSelectResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxSelectResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DemuxSelect::ID:
            {
                Message<DemuxSelect > & tempSrc = static_cast<Message<DemuxSelect>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::DemuxSelect buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxAddRequest::ID:
            {
                Message<MuxAddRequest > & tempSrc = static_cast<Message<MuxAddRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxAddRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxAddResponse::ID:
            {
                Message<MuxAddResponse > & tempSrc = static_cast<Message<MuxAddResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxAddResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxAdd::ID:
            {
                Message<MuxAdd > & tempSrc = static_cast<Message<MuxAdd>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxAdd buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxDeleteRequest::ID:
            {
                Message<MuxDeleteRequest > & tempSrc = static_cast<Message<MuxDeleteRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxDeleteRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxDeleteResponse::ID:
            {
                Message<MuxDeleteResponse > & tempSrc = static_cast<Message<MuxDeleteResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxDeleteResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxDelete::ID:
            {
                Message<MuxDelete > & tempSrc = static_cast<Message<MuxDelete>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxDelete buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxListRequest::ID:
            {
                Message<MuxListRequest > & tempSrc = static_cast<Message<MuxListRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxListRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxListResponse::ID:
            {
                Message<MuxListResponse > & tempSrc = static_cast<Message<MuxListResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxListResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxList::ID:
            {
                Message<MuxList > & tempSrc = static_cast<Message<MuxList>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxList buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxSelectRequest::ID:
            {
                Message<MuxSelectRequest > & tempSrc = static_cast<Message<MuxSelectRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxSelectRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxSelectResponse::ID:
            {
                Message<MuxSelectResponse > & tempSrc = static_cast<Message<MuxSelectResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxSelectResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MuxSelect::ID:
            {
                Message<MuxSelect > & tempSrc = static_cast<Message<MuxSelect>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: topic_tools_gencpp::MuxSelect buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case DemuxAddRequest::ID:
            {
                Message<DemuxAddRequest > & tempDst = static_cast<Message<DemuxAddRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxAddResponse::ID:
            {
                Message<DemuxAddResponse > & tempDst = static_cast<Message<DemuxAddResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxAdd::ID:
            {
                Message<DemuxAdd > & tempDst = static_cast<Message<DemuxAdd>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxDeleteRequest::ID:
            {
                Message<DemuxDeleteRequest > & tempDst = static_cast<Message<DemuxDeleteRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxDeleteResponse::ID:
            {
                Message<DemuxDeleteResponse > & tempDst = static_cast<Message<DemuxDeleteResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxDelete::ID:
            {
                Message<DemuxDelete > & tempDst = static_cast<Message<DemuxDelete>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxListRequest::ID:
            {
                Message<DemuxListRequest > & tempDst = static_cast<Message<DemuxListRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxListResponse::ID:
            {
                Message<DemuxListResponse > & tempDst = static_cast<Message<DemuxListResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxList::ID:
            {
                Message<DemuxList > & tempDst = static_cast<Message<DemuxList>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxSelectRequest::ID:
            {
                Message<DemuxSelectRequest > & tempDst = static_cast<Message<DemuxSelectRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxSelectResponse::ID:
            {
                Message<DemuxSelectResponse > & tempDst = static_cast<Message<DemuxSelectResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DemuxSelect::ID:
            {
                Message<DemuxSelect > & tempDst = static_cast<Message<DemuxSelect>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxAddRequest::ID:
            {
                Message<MuxAddRequest > & tempDst = static_cast<Message<MuxAddRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxAddResponse::ID:
            {
                Message<MuxAddResponse > & tempDst = static_cast<Message<MuxAddResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxAdd::ID:
            {
                Message<MuxAdd > & tempDst = static_cast<Message<MuxAdd>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxDeleteRequest::ID:
            {
                Message<MuxDeleteRequest > & tempDst = static_cast<Message<MuxDeleteRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxDeleteResponse::ID:
            {
                Message<MuxDeleteResponse > & tempDst = static_cast<Message<MuxDeleteResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxDelete::ID:
            {
                Message<MuxDelete > & tempDst = static_cast<Message<MuxDelete>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxListRequest::ID:
            {
                Message<MuxListRequest > & tempDst = static_cast<Message<MuxListRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxListResponse::ID:
            {
                Message<MuxListResponse > & tempDst = static_cast<Message<MuxListResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxList::ID:
            {
                Message<MuxList > & tempDst = static_cast<Message<MuxList>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxSelectRequest::ID:
            {
                Message<MuxSelectRequest > & tempDst = static_cast<Message<MuxSelectRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxSelectResponse::ID:
            {
                Message<MuxSelectResponse > & tempDst = static_cast<Message<MuxSelectResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MuxSelect::ID:
            {
                Message<MuxSelect > & tempDst = static_cast<Message<MuxSelect>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int topic_tools_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // DemuxAddRequest does not have a Header as its first member 
        // DemuxAdd does not have a Header as its first member 
        // DemuxDeleteRequest does not have a Header as its first member 
        // DemuxDelete does not have a Header as its first member 
        // DemuxListResponse does not have a Header as its first member 
        // DemuxList does not have a Header as its first member 
        // DemuxSelectRequest does not have a Header as its first member 
        // DemuxSelectResponse does not have a Header as its first member 
        // DemuxSelect does not have a Header as its first member 
        // MuxAddRequest does not have a Header as its first member 
        // MuxAdd does not have a Header as its first member 
        // MuxDeleteRequest does not have a Header as its first member 
        // MuxDelete does not have a Header as its first member 
        // MuxListResponse does not have a Header as its first member 
        // MuxList does not have a Header as its first member 
        // MuxSelectRequest does not have a Header as its first member 
        // MuxSelectResponse does not have a Header as its first member 
        // MuxSelect does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
