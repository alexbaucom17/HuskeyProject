// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:09 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "topic_tools_gencpp_NML.h"
#include "topic_tools_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <DemuxAddRequest.h>
#include <DemuxAddResponse.h>
#include <DemuxAdd.h>
#include <DemuxDeleteRequest.h>
#include <DemuxDeleteResponse.h>
#include <DemuxDelete.h>
#include <DemuxListRequest.h>
#include <DemuxListResponse.h>
#include <DemuxList.h>
#include <DemuxSelectRequest.h>
#include <DemuxSelectResponse.h>
#include <DemuxSelect.h>
#include <MuxAddRequest.h>
#include <MuxAddResponse.h>
#include <MuxAdd.h>
#include <MuxDeleteRequest.h>
#include <MuxDeleteResponse.h>
#include <MuxDelete.h>
#include <MuxListRequest.h>
#include <MuxListResponse.h>
#include <MuxList.h>
#include <MuxSelectRequest.h>
#include <MuxSelectResponse.h>
#include <MuxSelect.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace topic_tools;

rframe::NMLMessageFactory * NML_topic_tools_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_topic_tools_gencppfactory = new topic_tools_gencppNMLMessageFactory();
        return NML_topic_tools_gencppfactory;
    };
}

rframe::NMLMessageFactory * topic_tools::allocate_topic_tools_gencpp()
{
    NML_topic_tools_gencppfactory = new topic_tools_gencppNMLMessageFactory();
    return NML_topic_tools_gencppfactory;
};

topic_tools_gencppNMLMessageFactory::topic_tools_gencppNMLMessageFactory()
{
    name("topic_tools_gencpp");
    // use constructor to register data types
    topic_tools::registerLibrary();
}

topic_tools_gencppNMLMessageFactory::~topic_tools_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR topic_tools_gencppNMLMessageFactory::FormatPointer()
{
    return topic_tools_gencpp_format;
}

int topic_tools_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void topic_tools_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(DemuxAddRequest::ID);
    info.name(DemuxAddRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxAddRequest::DATA_VERSION);
    info.md5Key(DemuxAddRequest::VERSION_MD5);
    info.xmlSource(DemuxAddRequest::XML_SOURCE);
    info.flat(DemuxAddRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxAddResponse::ID);
    info.name(DemuxAddResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxAddResponse::DATA_VERSION);
    info.md5Key(DemuxAddResponse::VERSION_MD5);
    info.xmlSource(DemuxAddResponse::XML_SOURCE);
    info.flat(DemuxAddResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxAdd::ID);
    info.name(DemuxAdd::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxAdd::DATA_VERSION);
    info.md5Key(DemuxAdd::VERSION_MD5);
    info.xmlSource(DemuxAdd::XML_SOURCE);
    info.flat(DemuxAdd::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxDeleteRequest::ID);
    info.name(DemuxDeleteRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxDeleteRequest::DATA_VERSION);
    info.md5Key(DemuxDeleteRequest::VERSION_MD5);
    info.xmlSource(DemuxDeleteRequest::XML_SOURCE);
    info.flat(DemuxDeleteRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxDeleteResponse::ID);
    info.name(DemuxDeleteResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxDeleteResponse::DATA_VERSION);
    info.md5Key(DemuxDeleteResponse::VERSION_MD5);
    info.xmlSource(DemuxDeleteResponse::XML_SOURCE);
    info.flat(DemuxDeleteResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxDelete::ID);
    info.name(DemuxDelete::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxDelete::DATA_VERSION);
    info.md5Key(DemuxDelete::VERSION_MD5);
    info.xmlSource(DemuxDelete::XML_SOURCE);
    info.flat(DemuxDelete::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxListRequest::ID);
    info.name(DemuxListRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxListRequest::DATA_VERSION);
    info.md5Key(DemuxListRequest::VERSION_MD5);
    info.xmlSource(DemuxListRequest::XML_SOURCE);
    info.flat(DemuxListRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxListResponse::ID);
    info.name(DemuxListResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxListResponse::DATA_VERSION);
    info.md5Key(DemuxListResponse::VERSION_MD5);
    info.xmlSource(DemuxListResponse::XML_SOURCE);
    info.flat(DemuxListResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxList::ID);
    info.name(DemuxList::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxList::DATA_VERSION);
    info.md5Key(DemuxList::VERSION_MD5);
    info.xmlSource(DemuxList::XML_SOURCE);
    info.flat(DemuxList::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxSelectRequest::ID);
    info.name(DemuxSelectRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxSelectRequest::DATA_VERSION);
    info.md5Key(DemuxSelectRequest::VERSION_MD5);
    info.xmlSource(DemuxSelectRequest::XML_SOURCE);
    info.flat(DemuxSelectRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxSelectResponse::ID);
    info.name(DemuxSelectResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxSelectResponse::DATA_VERSION);
    info.md5Key(DemuxSelectResponse::VERSION_MD5);
    info.xmlSource(DemuxSelectResponse::XML_SOURCE);
    info.flat(DemuxSelectResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DemuxSelect::ID);
    info.name(DemuxSelect::DATA_TYPE_FULL_NAME);
    info.hashKey(DemuxSelect::DATA_VERSION);
    info.md5Key(DemuxSelect::VERSION_MD5);
    info.xmlSource(DemuxSelect::XML_SOURCE);
    info.flat(DemuxSelect::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxAddRequest::ID);
    info.name(MuxAddRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxAddRequest::DATA_VERSION);
    info.md5Key(MuxAddRequest::VERSION_MD5);
    info.xmlSource(MuxAddRequest::XML_SOURCE);
    info.flat(MuxAddRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxAddResponse::ID);
    info.name(MuxAddResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxAddResponse::DATA_VERSION);
    info.md5Key(MuxAddResponse::VERSION_MD5);
    info.xmlSource(MuxAddResponse::XML_SOURCE);
    info.flat(MuxAddResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxAdd::ID);
    info.name(MuxAdd::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxAdd::DATA_VERSION);
    info.md5Key(MuxAdd::VERSION_MD5);
    info.xmlSource(MuxAdd::XML_SOURCE);
    info.flat(MuxAdd::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxDeleteRequest::ID);
    info.name(MuxDeleteRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxDeleteRequest::DATA_VERSION);
    info.md5Key(MuxDeleteRequest::VERSION_MD5);
    info.xmlSource(MuxDeleteRequest::XML_SOURCE);
    info.flat(MuxDeleteRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxDeleteResponse::ID);
    info.name(MuxDeleteResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxDeleteResponse::DATA_VERSION);
    info.md5Key(MuxDeleteResponse::VERSION_MD5);
    info.xmlSource(MuxDeleteResponse::XML_SOURCE);
    info.flat(MuxDeleteResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxDelete::ID);
    info.name(MuxDelete::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxDelete::DATA_VERSION);
    info.md5Key(MuxDelete::VERSION_MD5);
    info.xmlSource(MuxDelete::XML_SOURCE);
    info.flat(MuxDelete::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxListRequest::ID);
    info.name(MuxListRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxListRequest::DATA_VERSION);
    info.md5Key(MuxListRequest::VERSION_MD5);
    info.xmlSource(MuxListRequest::XML_SOURCE);
    info.flat(MuxListRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxListResponse::ID);
    info.name(MuxListResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxListResponse::DATA_VERSION);
    info.md5Key(MuxListResponse::VERSION_MD5);
    info.xmlSource(MuxListResponse::XML_SOURCE);
    info.flat(MuxListResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxList::ID);
    info.name(MuxList::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxList::DATA_VERSION);
    info.md5Key(MuxList::VERSION_MD5);
    info.xmlSource(MuxList::XML_SOURCE);
    info.flat(MuxList::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxSelectRequest::ID);
    info.name(MuxSelectRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxSelectRequest::DATA_VERSION);
    info.md5Key(MuxSelectRequest::VERSION_MD5);
    info.xmlSource(MuxSelectRequest::XML_SOURCE);
    info.flat(MuxSelectRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxSelectResponse::ID);
    info.name(MuxSelectResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxSelectResponse::DATA_VERSION);
    info.md5Key(MuxSelectResponse::VERSION_MD5);
    info.xmlSource(MuxSelectResponse::XML_SOURCE);
    info.flat(MuxSelectResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MuxSelect::ID);
    info.name(MuxSelect::DATA_TYPE_FULL_NAME);
    info.hashKey(MuxSelect::DATA_VERSION);
    info.md5Key(MuxSelect::VERSION_MD5);
    info.xmlSource(MuxSelect::XML_SOURCE);
    info.flat(MuxSelect::dataTypeFlat());
    ids.push_back(info);

}

int topic_tools_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case DemuxAddRequest::ID:
        {
            //DemuxAddRequestNML * newmsg = new DemuxAddRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxAddRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxAddResponse::ID:
        {
            //DemuxAddResponseNML * newmsg = new DemuxAddResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxAddResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxAdd::ID:
        {
            //DemuxAddNML * newmsg = new DemuxAddNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxAddNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxDeleteRequest::ID:
        {
            //DemuxDeleteRequestNML * newmsg = new DemuxDeleteRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxDeleteRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxDeleteResponse::ID:
        {
            //DemuxDeleteResponseNML * newmsg = new DemuxDeleteResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxDeleteResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxDelete::ID:
        {
            //DemuxDeleteNML * newmsg = new DemuxDeleteNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxDeleteNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxListRequest::ID:
        {
            //DemuxListRequestNML * newmsg = new DemuxListRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxListRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxListResponse::ID:
        {
            //DemuxListResponseNML * newmsg = new DemuxListResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxListResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxList::ID:
        {
            //DemuxListNML * newmsg = new DemuxListNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxListNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxSelectRequest::ID:
        {
            //DemuxSelectRequestNML * newmsg = new DemuxSelectRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxSelectRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxSelectResponse::ID:
        {
            //DemuxSelectResponseNML * newmsg = new DemuxSelectResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxSelectResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DemuxSelect::ID:
        {
            //DemuxSelectNML * newmsg = new DemuxSelectNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DemuxSelectNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxAddRequest::ID:
        {
            //MuxAddRequestNML * newmsg = new MuxAddRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxAddRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxAddResponse::ID:
        {
            //MuxAddResponseNML * newmsg = new MuxAddResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxAddResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxAdd::ID:
        {
            //MuxAddNML * newmsg = new MuxAddNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxAddNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxDeleteRequest::ID:
        {
            //MuxDeleteRequestNML * newmsg = new MuxDeleteRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxDeleteRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxDeleteResponse::ID:
        {
            //MuxDeleteResponseNML * newmsg = new MuxDeleteResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxDeleteResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxDelete::ID:
        {
            //MuxDeleteNML * newmsg = new MuxDeleteNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxDeleteNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxListRequest::ID:
        {
            //MuxListRequestNML * newmsg = new MuxListRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxListRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxListResponse::ID:
        {
            //MuxListResponseNML * newmsg = new MuxListResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxListResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxList::ID:
        {
            //MuxListNML * newmsg = new MuxListNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxListNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxSelectRequest::ID:
        {
            //MuxSelectRequestNML * newmsg = new MuxSelectRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxSelectRequestNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxSelectResponse::ID:
        {
            //MuxSelectResponseNML * newmsg = new MuxSelectResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxSelectResponseNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MuxSelect::ID:
        {
            //MuxSelectNML * newmsg = new MuxSelectNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MuxSelectNML(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int topic_tools_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case DemuxAddRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxAddRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxAddResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxAddResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxAdd::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxAdd>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxDeleteRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxDeleteRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxDeleteResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxDeleteResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxDelete::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxDelete>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxListRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxListRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxListResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxListResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxList::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxList>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxSelectRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxSelectRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxSelectResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxSelectResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DemuxSelect::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DemuxSelect>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxAddRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxAddRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxAddResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxAddResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxAdd::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxAdd>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxDeleteRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxDeleteRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxDeleteResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxDeleteResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxDelete::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxDelete>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxListRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxListRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxListResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxListResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxList::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxList>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxSelectRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxSelectRequest>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxSelectResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxSelectResponse>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MuxSelect::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MuxSelect>(),std::bind(&topic_tools_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int topic_tools_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int topic_tools_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case DemuxAddRequest::ID:
            {
                DemuxAddRequestNML * tempmsg = static_cast<DemuxAddRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxAddResponse::ID:
            {
                DemuxAddResponseNML * tempmsg = static_cast<DemuxAddResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxAdd::ID:
            {
                DemuxAddNML * tempmsg = static_cast<DemuxAddNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxDeleteRequest::ID:
            {
                DemuxDeleteRequestNML * tempmsg = static_cast<DemuxDeleteRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxDeleteResponse::ID:
            {
                DemuxDeleteResponseNML * tempmsg = static_cast<DemuxDeleteResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxDelete::ID:
            {
                DemuxDeleteNML * tempmsg = static_cast<DemuxDeleteNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxListRequest::ID:
            {
                DemuxListRequestNML * tempmsg = static_cast<DemuxListRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxListResponse::ID:
            {
                DemuxListResponseNML * tempmsg = static_cast<DemuxListResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxList::ID:
            {
                DemuxListNML * tempmsg = static_cast<DemuxListNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxSelectRequest::ID:
            {
                DemuxSelectRequestNML * tempmsg = static_cast<DemuxSelectRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxSelectResponse::ID:
            {
                DemuxSelectResponseNML * tempmsg = static_cast<DemuxSelectResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DemuxSelect::ID:
            {
                DemuxSelectNML * tempmsg = static_cast<DemuxSelectNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxAddRequest::ID:
            {
                MuxAddRequestNML * tempmsg = static_cast<MuxAddRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxAddResponse::ID:
            {
                MuxAddResponseNML * tempmsg = static_cast<MuxAddResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxAdd::ID:
            {
                MuxAddNML * tempmsg = static_cast<MuxAddNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxDeleteRequest::ID:
            {
                MuxDeleteRequestNML * tempmsg = static_cast<MuxDeleteRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxDeleteResponse::ID:
            {
                MuxDeleteResponseNML * tempmsg = static_cast<MuxDeleteResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxDelete::ID:
            {
                MuxDeleteNML * tempmsg = static_cast<MuxDeleteNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxListRequest::ID:
            {
                MuxListRequestNML * tempmsg = static_cast<MuxListRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxListResponse::ID:
            {
                MuxListResponseNML * tempmsg = static_cast<MuxListResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxList::ID:
            {
                MuxListNML * tempmsg = static_cast<MuxListNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxSelectRequest::ID:
            {
                MuxSelectRequestNML * tempmsg = static_cast<MuxSelectRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxSelectResponse::ID:
            {
                MuxSelectResponseNML * tempmsg = static_cast<MuxSelectResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MuxSelect::ID:
            {
                MuxSelectNML * tempmsg = static_cast<MuxSelectNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int topic_tools_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case DemuxAddRequest::ID:
            {
                DemuxAddRequestNML & tempDst = static_cast<DemuxAddRequestNML&>(dst);
                Message<DemuxAddRequest > & tempSrc = static_cast<Message<DemuxAddRequest>&>(src);

                if (tempSrc.version() != DemuxAddRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxAddRequest: " << __FILE__ << " expected: " 
                             << DemuxAddRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxAddRequest: " << __FILE__ << " expected: " 
                         << DemuxAddRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxAddResponse::ID:
            {
                DemuxAddResponseNML & tempDst = static_cast<DemuxAddResponseNML&>(dst);
                Message<DemuxAddResponse > & tempSrc = static_cast<Message<DemuxAddResponse>&>(src);

                if (tempSrc.version() != DemuxAddResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxAddResponse: " << __FILE__ << " expected: " 
                             << DemuxAddResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxAddResponse: " << __FILE__ << " expected: " 
                         << DemuxAddResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxAdd::ID:
            {
                DemuxAddNML & tempDst = static_cast<DemuxAddNML&>(dst);
                Message<DemuxAdd > & tempSrc = static_cast<Message<DemuxAdd>&>(src);

                if (tempSrc.version() != DemuxAdd::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxAdd: " << __FILE__ << " expected: " 
                             << DemuxAdd::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxAdd: " << __FILE__ << " expected: " 
                         << DemuxAdd::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxDeleteRequest::ID:
            {
                DemuxDeleteRequestNML & tempDst = static_cast<DemuxDeleteRequestNML&>(dst);
                Message<DemuxDeleteRequest > & tempSrc = static_cast<Message<DemuxDeleteRequest>&>(src);

                if (tempSrc.version() != DemuxDeleteRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxDeleteRequest: " << __FILE__ << " expected: " 
                             << DemuxDeleteRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxDeleteRequest: " << __FILE__ << " expected: " 
                         << DemuxDeleteRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxDeleteResponse::ID:
            {
                DemuxDeleteResponseNML & tempDst = static_cast<DemuxDeleteResponseNML&>(dst);
                Message<DemuxDeleteResponse > & tempSrc = static_cast<Message<DemuxDeleteResponse>&>(src);

                if (tempSrc.version() != DemuxDeleteResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxDeleteResponse: " << __FILE__ << " expected: " 
                             << DemuxDeleteResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxDeleteResponse: " << __FILE__ << " expected: " 
                         << DemuxDeleteResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxDelete::ID:
            {
                DemuxDeleteNML & tempDst = static_cast<DemuxDeleteNML&>(dst);
                Message<DemuxDelete > & tempSrc = static_cast<Message<DemuxDelete>&>(src);

                if (tempSrc.version() != DemuxDelete::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxDelete: " << __FILE__ << " expected: " 
                             << DemuxDelete::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxDelete: " << __FILE__ << " expected: " 
                         << DemuxDelete::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxListRequest::ID:
            {
                DemuxListRequestNML & tempDst = static_cast<DemuxListRequestNML&>(dst);
                Message<DemuxListRequest > & tempSrc = static_cast<Message<DemuxListRequest>&>(src);

                if (tempSrc.version() != DemuxListRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxListRequest: " << __FILE__ << " expected: " 
                             << DemuxListRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxListRequest: " << __FILE__ << " expected: " 
                         << DemuxListRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxListResponse::ID:
            {
                DemuxListResponseNML & tempDst = static_cast<DemuxListResponseNML&>(dst);
                Message<DemuxListResponse > & tempSrc = static_cast<Message<DemuxListResponse>&>(src);

                if (tempSrc.version() != DemuxListResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxListResponse: " << __FILE__ << " expected: " 
                             << DemuxListResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxListResponse: " << __FILE__ << " expected: " 
                         << DemuxListResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxList::ID:
            {
                DemuxListNML & tempDst = static_cast<DemuxListNML&>(dst);
                Message<DemuxList > & tempSrc = static_cast<Message<DemuxList>&>(src);

                if (tempSrc.version() != DemuxList::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxList: " << __FILE__ << " expected: " 
                             << DemuxList::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxList: " << __FILE__ << " expected: " 
                         << DemuxList::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxSelectRequest::ID:
            {
                DemuxSelectRequestNML & tempDst = static_cast<DemuxSelectRequestNML&>(dst);
                Message<DemuxSelectRequest > & tempSrc = static_cast<Message<DemuxSelectRequest>&>(src);

                if (tempSrc.version() != DemuxSelectRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxSelectRequest: " << __FILE__ << " expected: " 
                             << DemuxSelectRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxSelectRequest: " << __FILE__ << " expected: " 
                         << DemuxSelectRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxSelectResponse::ID:
            {
                DemuxSelectResponseNML & tempDst = static_cast<DemuxSelectResponseNML&>(dst);
                Message<DemuxSelectResponse > & tempSrc = static_cast<Message<DemuxSelectResponse>&>(src);

                if (tempSrc.version() != DemuxSelectResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxSelectResponse: " << __FILE__ << " expected: " 
                             << DemuxSelectResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxSelectResponse: " << __FILE__ << " expected: " 
                         << DemuxSelectResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DemuxSelect::ID:
            {
                DemuxSelectNML & tempDst = static_cast<DemuxSelectNML&>(dst);
                Message<DemuxSelect > & tempSrc = static_cast<Message<DemuxSelect>&>(src);

                if (tempSrc.version() != DemuxSelect::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DemuxSelect: " << __FILE__ << " expected: " 
                             << DemuxSelect::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DemuxSelect: " << __FILE__ << " expected: " 
                         << DemuxSelect::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxAddRequest::ID:
            {
                MuxAddRequestNML & tempDst = static_cast<MuxAddRequestNML&>(dst);
                Message<MuxAddRequest > & tempSrc = static_cast<Message<MuxAddRequest>&>(src);

                if (tempSrc.version() != MuxAddRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxAddRequest: " << __FILE__ << " expected: " 
                             << MuxAddRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxAddRequest: " << __FILE__ << " expected: " 
                         << MuxAddRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxAddResponse::ID:
            {
                MuxAddResponseNML & tempDst = static_cast<MuxAddResponseNML&>(dst);
                Message<MuxAddResponse > & tempSrc = static_cast<Message<MuxAddResponse>&>(src);

                if (tempSrc.version() != MuxAddResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxAddResponse: " << __FILE__ << " expected: " 
                             << MuxAddResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxAddResponse: " << __FILE__ << " expected: " 
                         << MuxAddResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxAdd::ID:
            {
                MuxAddNML & tempDst = static_cast<MuxAddNML&>(dst);
                Message<MuxAdd > & tempSrc = static_cast<Message<MuxAdd>&>(src);

                if (tempSrc.version() != MuxAdd::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxAdd: " << __FILE__ << " expected: " 
                             << MuxAdd::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxAdd: " << __FILE__ << " expected: " 
                         << MuxAdd::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxDeleteRequest::ID:
            {
                MuxDeleteRequestNML & tempDst = static_cast<MuxDeleteRequestNML&>(dst);
                Message<MuxDeleteRequest > & tempSrc = static_cast<Message<MuxDeleteRequest>&>(src);

                if (tempSrc.version() != MuxDeleteRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxDeleteRequest: " << __FILE__ << " expected: " 
                             << MuxDeleteRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxDeleteRequest: " << __FILE__ << " expected: " 
                         << MuxDeleteRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxDeleteResponse::ID:
            {
                MuxDeleteResponseNML & tempDst = static_cast<MuxDeleteResponseNML&>(dst);
                Message<MuxDeleteResponse > & tempSrc = static_cast<Message<MuxDeleteResponse>&>(src);

                if (tempSrc.version() != MuxDeleteResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxDeleteResponse: " << __FILE__ << " expected: " 
                             << MuxDeleteResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxDeleteResponse: " << __FILE__ << " expected: " 
                         << MuxDeleteResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxDelete::ID:
            {
                MuxDeleteNML & tempDst = static_cast<MuxDeleteNML&>(dst);
                Message<MuxDelete > & tempSrc = static_cast<Message<MuxDelete>&>(src);

                if (tempSrc.version() != MuxDelete::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxDelete: " << __FILE__ << " expected: " 
                             << MuxDelete::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxDelete: " << __FILE__ << " expected: " 
                         << MuxDelete::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxListRequest::ID:
            {
                MuxListRequestNML & tempDst = static_cast<MuxListRequestNML&>(dst);
                Message<MuxListRequest > & tempSrc = static_cast<Message<MuxListRequest>&>(src);

                if (tempSrc.version() != MuxListRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxListRequest: " << __FILE__ << " expected: " 
                             << MuxListRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxListRequest: " << __FILE__ << " expected: " 
                         << MuxListRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxListResponse::ID:
            {
                MuxListResponseNML & tempDst = static_cast<MuxListResponseNML&>(dst);
                Message<MuxListResponse > & tempSrc = static_cast<Message<MuxListResponse>&>(src);

                if (tempSrc.version() != MuxListResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxListResponse: " << __FILE__ << " expected: " 
                             << MuxListResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxListResponse: " << __FILE__ << " expected: " 
                         << MuxListResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxList::ID:
            {
                MuxListNML & tempDst = static_cast<MuxListNML&>(dst);
                Message<MuxList > & tempSrc = static_cast<Message<MuxList>&>(src);

                if (tempSrc.version() != MuxList::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxList: " << __FILE__ << " expected: " 
                             << MuxList::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxList: " << __FILE__ << " expected: " 
                         << MuxList::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxSelectRequest::ID:
            {
                MuxSelectRequestNML & tempDst = static_cast<MuxSelectRequestNML&>(dst);
                Message<MuxSelectRequest > & tempSrc = static_cast<Message<MuxSelectRequest>&>(src);

                if (tempSrc.version() != MuxSelectRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxSelectRequest: " << __FILE__ << " expected: " 
                             << MuxSelectRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxSelectRequest: " << __FILE__ << " expected: " 
                         << MuxSelectRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxSelectResponse::ID:
            {
                MuxSelectResponseNML & tempDst = static_cast<MuxSelectResponseNML&>(dst);
                Message<MuxSelectResponse > & tempSrc = static_cast<Message<MuxSelectResponse>&>(src);

                if (tempSrc.version() != MuxSelectResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxSelectResponse: " << __FILE__ << " expected: " 
                             << MuxSelectResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxSelectResponse: " << __FILE__ << " expected: " 
                         << MuxSelectResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MuxSelect::ID:
            {
                MuxSelectNML & tempDst = static_cast<MuxSelectNML&>(dst);
                Message<MuxSelect > & tempSrc = static_cast<Message<MuxSelect>&>(src);

                if (tempSrc.version() != MuxSelect::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MuxSelect: " << __FILE__ << " expected: " 
                             << MuxSelect::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MuxSelect: " << __FILE__ << " expected: " 
                         << MuxSelect::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int topic_tools_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case DemuxAddRequest::ID:
            {
                DemuxAddRequestNML & tempSrc = static_cast<DemuxAddRequestNML&>(src);
                Message<DemuxAddRequest > & tempDst = static_cast<Message<DemuxAddRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxAddRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxAddResponse::ID:
            {
                DemuxAddResponseNML & tempSrc = static_cast<DemuxAddResponseNML&>(src);
                Message<DemuxAddResponse > & tempDst = static_cast<Message<DemuxAddResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxAddResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxAdd::ID:
            {
                DemuxAddNML & tempSrc = static_cast<DemuxAddNML&>(src);
                Message<DemuxAdd > & tempDst = static_cast<Message<DemuxAdd>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxAdd::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxDeleteRequest::ID:
            {
                DemuxDeleteRequestNML & tempSrc = static_cast<DemuxDeleteRequestNML&>(src);
                Message<DemuxDeleteRequest > & tempDst = static_cast<Message<DemuxDeleteRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxDeleteRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxDeleteResponse::ID:
            {
                DemuxDeleteResponseNML & tempSrc = static_cast<DemuxDeleteResponseNML&>(src);
                Message<DemuxDeleteResponse > & tempDst = static_cast<Message<DemuxDeleteResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxDeleteResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxDelete::ID:
            {
                DemuxDeleteNML & tempSrc = static_cast<DemuxDeleteNML&>(src);
                Message<DemuxDelete > & tempDst = static_cast<Message<DemuxDelete>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxDelete::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxListRequest::ID:
            {
                DemuxListRequestNML & tempSrc = static_cast<DemuxListRequestNML&>(src);
                Message<DemuxListRequest > & tempDst = static_cast<Message<DemuxListRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxListRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxListResponse::ID:
            {
                DemuxListResponseNML & tempSrc = static_cast<DemuxListResponseNML&>(src);
                Message<DemuxListResponse > & tempDst = static_cast<Message<DemuxListResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxListResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxList::ID:
            {
                DemuxListNML & tempSrc = static_cast<DemuxListNML&>(src);
                Message<DemuxList > & tempDst = static_cast<Message<DemuxList>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxList::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxSelectRequest::ID:
            {
                DemuxSelectRequestNML & tempSrc = static_cast<DemuxSelectRequestNML&>(src);
                Message<DemuxSelectRequest > & tempDst = static_cast<Message<DemuxSelectRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxSelectRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxSelectResponse::ID:
            {
                DemuxSelectResponseNML & tempSrc = static_cast<DemuxSelectResponseNML&>(src);
                Message<DemuxSelectResponse > & tempDst = static_cast<Message<DemuxSelectResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxSelectResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DemuxSelect::ID:
            {
                DemuxSelectNML & tempSrc = static_cast<DemuxSelectNML&>(src);
                Message<DemuxSelect > & tempDst = static_cast<Message<DemuxSelect>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DemuxSelect::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxAddRequest::ID:
            {
                MuxAddRequestNML & tempSrc = static_cast<MuxAddRequestNML&>(src);
                Message<MuxAddRequest > & tempDst = static_cast<Message<MuxAddRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxAddRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxAddResponse::ID:
            {
                MuxAddResponseNML & tempSrc = static_cast<MuxAddResponseNML&>(src);
                Message<MuxAddResponse > & tempDst = static_cast<Message<MuxAddResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxAddResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxAdd::ID:
            {
                MuxAddNML & tempSrc = static_cast<MuxAddNML&>(src);
                Message<MuxAdd > & tempDst = static_cast<Message<MuxAdd>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxAdd::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxDeleteRequest::ID:
            {
                MuxDeleteRequestNML & tempSrc = static_cast<MuxDeleteRequestNML&>(src);
                Message<MuxDeleteRequest > & tempDst = static_cast<Message<MuxDeleteRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxDeleteRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxDeleteResponse::ID:
            {
                MuxDeleteResponseNML & tempSrc = static_cast<MuxDeleteResponseNML&>(src);
                Message<MuxDeleteResponse > & tempDst = static_cast<Message<MuxDeleteResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxDeleteResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxDelete::ID:
            {
                MuxDeleteNML & tempSrc = static_cast<MuxDeleteNML&>(src);
                Message<MuxDelete > & tempDst = static_cast<Message<MuxDelete>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxDelete::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxListRequest::ID:
            {
                MuxListRequestNML & tempSrc = static_cast<MuxListRequestNML&>(src);
                Message<MuxListRequest > & tempDst = static_cast<Message<MuxListRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxListRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxListResponse::ID:
            {
                MuxListResponseNML & tempSrc = static_cast<MuxListResponseNML&>(src);
                Message<MuxListResponse > & tempDst = static_cast<Message<MuxListResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxListResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxList::ID:
            {
                MuxListNML & tempSrc = static_cast<MuxListNML&>(src);
                Message<MuxList > & tempDst = static_cast<Message<MuxList>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxList::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxSelectRequest::ID:
            {
                MuxSelectRequestNML & tempSrc = static_cast<MuxSelectRequestNML&>(src);
                Message<MuxSelectRequest > & tempDst = static_cast<Message<MuxSelectRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxSelectRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxSelectResponse::ID:
            {
                MuxSelectResponseNML & tempSrc = static_cast<MuxSelectResponseNML&>(src);
                Message<MuxSelectResponse > & tempDst = static_cast<Message<MuxSelectResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxSelectResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MuxSelect::ID:
            {
                MuxSelectNML & tempSrc = static_cast<MuxSelectNML&>(src);
                Message<MuxSelect > & tempDst = static_cast<Message<MuxSelect>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MuxSelect::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int topic_tools_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case DemuxAddRequest::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxAddRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxAddRequest at %p\n",buffer);
                DemuxAddRequestNML * p = static_cast<DemuxAddRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxAddRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxAddRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxAddResponse::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxAddResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxAddResponse at %p\n",buffer);
                DemuxAddResponseNML * p = static_cast<DemuxAddResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxAddResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxAddResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxAdd::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxAdd::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxAdd at %p\n",buffer);
                DemuxAddNML * p = static_cast<DemuxAddNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxAddNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxAdd at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxDeleteRequest::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxDeleteRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxDeleteRequest at %p\n",buffer);
                DemuxDeleteRequestNML * p = static_cast<DemuxDeleteRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxDeleteRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxDeleteRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxDeleteResponse::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxDeleteResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxDeleteResponse at %p\n",buffer);
                DemuxDeleteResponseNML * p = static_cast<DemuxDeleteResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxDeleteResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxDeleteResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxDelete::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxDelete::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxDelete at %p\n",buffer);
                DemuxDeleteNML * p = static_cast<DemuxDeleteNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxDeleteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxDelete at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxListRequest::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxListRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxListRequest at %p\n",buffer);
                DemuxListRequestNML * p = static_cast<DemuxListRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxListRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxListRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxListResponse::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxListResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxListResponse at %p\n",buffer);
                DemuxListResponseNML * p = static_cast<DemuxListResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxListResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxListResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxList::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxList::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxList at %p\n",buffer);
                DemuxListNML * p = static_cast<DemuxListNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxListNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxList at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxSelectRequest::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxSelectRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxSelectRequest at %p\n",buffer);
                DemuxSelectRequestNML * p = static_cast<DemuxSelectRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxSelectRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxSelectRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxSelectResponse::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxSelectResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxSelectResponse at %p\n",buffer);
                DemuxSelectResponseNML * p = static_cast<DemuxSelectResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxSelectResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxSelectResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DemuxSelect::ID:
        {
            // only need to construct if data type is not flat
            if (DemuxSelect::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DemuxSelect at %p\n",buffer);
                DemuxSelectNML * p = static_cast<DemuxSelectNML*>(buffer);
                // construct the type at pointer p
                new (p) DemuxSelectNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DemuxSelect at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxAddRequest::ID:
        {
            // only need to construct if data type is not flat
            if (MuxAddRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxAddRequest at %p\n",buffer);
                MuxAddRequestNML * p = static_cast<MuxAddRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxAddRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxAddRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxAddResponse::ID:
        {
            // only need to construct if data type is not flat
            if (MuxAddResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxAddResponse at %p\n",buffer);
                MuxAddResponseNML * p = static_cast<MuxAddResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxAddResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxAddResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxAdd::ID:
        {
            // only need to construct if data type is not flat
            if (MuxAdd::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxAdd at %p\n",buffer);
                MuxAddNML * p = static_cast<MuxAddNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxAddNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxAdd at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxDeleteRequest::ID:
        {
            // only need to construct if data type is not flat
            if (MuxDeleteRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxDeleteRequest at %p\n",buffer);
                MuxDeleteRequestNML * p = static_cast<MuxDeleteRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxDeleteRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxDeleteRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxDeleteResponse::ID:
        {
            // only need to construct if data type is not flat
            if (MuxDeleteResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxDeleteResponse at %p\n",buffer);
                MuxDeleteResponseNML * p = static_cast<MuxDeleteResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxDeleteResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxDeleteResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxDelete::ID:
        {
            // only need to construct if data type is not flat
            if (MuxDelete::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxDelete at %p\n",buffer);
                MuxDeleteNML * p = static_cast<MuxDeleteNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxDeleteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxDelete at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxListRequest::ID:
        {
            // only need to construct if data type is not flat
            if (MuxListRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxListRequest at %p\n",buffer);
                MuxListRequestNML * p = static_cast<MuxListRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxListRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxListRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxListResponse::ID:
        {
            // only need to construct if data type is not flat
            if (MuxListResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxListResponse at %p\n",buffer);
                MuxListResponseNML * p = static_cast<MuxListResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxListResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxListResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxList::ID:
        {
            // only need to construct if data type is not flat
            if (MuxList::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxList at %p\n",buffer);
                MuxListNML * p = static_cast<MuxListNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxListNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxList at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxSelectRequest::ID:
        {
            // only need to construct if data type is not flat
            if (MuxSelectRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxSelectRequest at %p\n",buffer);
                MuxSelectRequestNML * p = static_cast<MuxSelectRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxSelectRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxSelectRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxSelectResponse::ID:
        {
            // only need to construct if data type is not flat
            if (MuxSelectResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxSelectResponse at %p\n",buffer);
                MuxSelectResponseNML * p = static_cast<MuxSelectResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxSelectResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxSelectResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MuxSelect::ID:
        {
            // only need to construct if data type is not flat
            if (MuxSelect::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MuxSelect at %p\n",buffer);
                MuxSelectNML * p = static_cast<MuxSelectNML*>(buffer);
                // construct the type at pointer p
                new (p) MuxSelectNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MuxSelect at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int topic_tools_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case DemuxAddRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxAddRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxAddRequest at %p\n",buffer);
                DemuxAddRequestNML * p = static_cast<DemuxAddRequestNML*>(buffer);
                p->~DemuxAddRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxAddRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxAddResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxAddResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxAddResponse at %p\n",buffer);
                DemuxAddResponseNML * p = static_cast<DemuxAddResponseNML*>(buffer);
                p->~DemuxAddResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxAddResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxAdd::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxAdd::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxAdd at %p\n",buffer);
                DemuxAddNML * p = static_cast<DemuxAddNML*>(buffer);
                p->~DemuxAddNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxAdd at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxDeleteRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxDeleteRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxDeleteRequest at %p\n",buffer);
                DemuxDeleteRequestNML * p = static_cast<DemuxDeleteRequestNML*>(buffer);
                p->~DemuxDeleteRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxDeleteRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxDeleteResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxDeleteResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxDeleteResponse at %p\n",buffer);
                DemuxDeleteResponseNML * p = static_cast<DemuxDeleteResponseNML*>(buffer);
                p->~DemuxDeleteResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxDeleteResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxDelete::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxDelete::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxDelete at %p\n",buffer);
                DemuxDeleteNML * p = static_cast<DemuxDeleteNML*>(buffer);
                p->~DemuxDeleteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxDelete at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxListRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxListRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxListRequest at %p\n",buffer);
                DemuxListRequestNML * p = static_cast<DemuxListRequestNML*>(buffer);
                p->~DemuxListRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxListRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxListResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxListResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxListResponse at %p\n",buffer);
                DemuxListResponseNML * p = static_cast<DemuxListResponseNML*>(buffer);
                p->~DemuxListResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxListResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxList::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxList::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxList at %p\n",buffer);
                DemuxListNML * p = static_cast<DemuxListNML*>(buffer);
                p->~DemuxListNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxList at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxSelectRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxSelectRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxSelectRequest at %p\n",buffer);
                DemuxSelectRequestNML * p = static_cast<DemuxSelectRequestNML*>(buffer);
                p->~DemuxSelectRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxSelectRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxSelectResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxSelectResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxSelectResponse at %p\n",buffer);
                DemuxSelectResponseNML * p = static_cast<DemuxSelectResponseNML*>(buffer);
                p->~DemuxSelectResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxSelectResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case DemuxSelect::ID:
        {
            // only need to destruct if data type is not flat
            if (DemuxSelect::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DemuxSelect at %p\n",buffer);
                DemuxSelectNML * p = static_cast<DemuxSelectNML*>(buffer);
                p->~DemuxSelectNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DemuxSelect at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxAddRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxAddRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxAddRequest at %p\n",buffer);
                MuxAddRequestNML * p = static_cast<MuxAddRequestNML*>(buffer);
                p->~MuxAddRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxAddRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxAddResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxAddResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxAddResponse at %p\n",buffer);
                MuxAddResponseNML * p = static_cast<MuxAddResponseNML*>(buffer);
                p->~MuxAddResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxAddResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxAdd::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxAdd::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxAdd at %p\n",buffer);
                MuxAddNML * p = static_cast<MuxAddNML*>(buffer);
                p->~MuxAddNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxAdd at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxDeleteRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxDeleteRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxDeleteRequest at %p\n",buffer);
                MuxDeleteRequestNML * p = static_cast<MuxDeleteRequestNML*>(buffer);
                p->~MuxDeleteRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxDeleteRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxDeleteResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxDeleteResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxDeleteResponse at %p\n",buffer);
                MuxDeleteResponseNML * p = static_cast<MuxDeleteResponseNML*>(buffer);
                p->~MuxDeleteResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxDeleteResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxDelete::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxDelete::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxDelete at %p\n",buffer);
                MuxDeleteNML * p = static_cast<MuxDeleteNML*>(buffer);
                p->~MuxDeleteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxDelete at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxListRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxListRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxListRequest at %p\n",buffer);
                MuxListRequestNML * p = static_cast<MuxListRequestNML*>(buffer);
                p->~MuxListRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxListRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxListResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxListResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxListResponse at %p\n",buffer);
                MuxListResponseNML * p = static_cast<MuxListResponseNML*>(buffer);
                p->~MuxListResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxListResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxList::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxList::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxList at %p\n",buffer);
                MuxListNML * p = static_cast<MuxListNML*>(buffer);
                p->~MuxListNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxList at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxSelectRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxSelectRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxSelectRequest at %p\n",buffer);
                MuxSelectRequestNML * p = static_cast<MuxSelectRequestNML*>(buffer);
                p->~MuxSelectRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxSelectRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxSelectResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxSelectResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxSelectResponse at %p\n",buffer);
                MuxSelectResponseNML * p = static_cast<MuxSelectResponseNML*>(buffer);
                p->~MuxSelectResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxSelectResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case MuxSelect::ID:
        {
            // only need to destruct if data type is not flat
            if (MuxSelect::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MuxSelect at %p\n",buffer);
                MuxSelectNML * p = static_cast<MuxSelectNML*>(buffer);
                p->~MuxSelectNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MuxSelect at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void topic_tools::nmlupdate(CMS * cms, DemuxAddRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxAddRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topic);

    }  
 }

DemuxAddRequestNML::DemuxAddRequestNML() : NMLmsg((NMLTYPE)DemuxAddRequest::ID,sizeof(DemuxAddRequestNML)), nmlVersion(DemuxAddRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxAddRequest()*/)
{
};

DemuxAddRequestNML::~DemuxAddRequestNML()
{
};

DemuxAddRequestNML & DemuxAddRequestNML::operator=(const DemuxAddRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxAddRequestNML & DemuxAddRequestNML::operator=(const DemuxAddRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxAddRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxAddRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxAddRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxAddRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxAddRequest> temp(new DemuxAddRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxAddRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxAddRequest Message version mismatch, expected " << DemuxAddRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxAddRequest Message version mismatch, expected " << DemuxAddRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxAddResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxAddResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

DemuxAddResponseNML::DemuxAddResponseNML() : NMLmsg((NMLTYPE)DemuxAddResponse::ID,sizeof(DemuxAddResponseNML)), nmlVersion(DemuxAddResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxAddResponse()*/)
{
};

DemuxAddResponseNML::~DemuxAddResponseNML()
{
};

DemuxAddResponseNML & DemuxAddResponseNML::operator=(const DemuxAddResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxAddResponseNML & DemuxAddResponseNML::operator=(const DemuxAddResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxAddResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxAddResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxAddResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxAddResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxAddResponse> temp(new DemuxAddResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxAddResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxAddResponse Message version mismatch, expected " << DemuxAddResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxAddResponse Message version mismatch, expected " << DemuxAddResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxAdd & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxAdd, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

DemuxAddNML::DemuxAddNML() : NMLmsg((NMLTYPE)DemuxAdd::ID,sizeof(DemuxAddNML)), nmlVersion(DemuxAdd::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxAdd()*/)
{
};

DemuxAddNML::~DemuxAddNML()
{
};

DemuxAddNML & DemuxAddNML::operator=(const DemuxAddNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxAddNML & DemuxAddNML::operator=(const DemuxAdd & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxAdd);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxAddNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxAdd&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxAddNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxAdd> temp(new DemuxAdd());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxAdd::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxAdd Message version mismatch, expected " << DemuxAdd::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxAdd Message version mismatch, expected " << DemuxAdd::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxDeleteRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxDeleteRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topic);

    }  
 }

DemuxDeleteRequestNML::DemuxDeleteRequestNML() : NMLmsg((NMLTYPE)DemuxDeleteRequest::ID,sizeof(DemuxDeleteRequestNML)), nmlVersion(DemuxDeleteRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxDeleteRequest()*/)
{
};

DemuxDeleteRequestNML::~DemuxDeleteRequestNML()
{
};

DemuxDeleteRequestNML & DemuxDeleteRequestNML::operator=(const DemuxDeleteRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxDeleteRequestNML & DemuxDeleteRequestNML::operator=(const DemuxDeleteRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxDeleteRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxDeleteRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxDeleteRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxDeleteRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxDeleteRequest> temp(new DemuxDeleteRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxDeleteRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxDeleteRequest Message version mismatch, expected " << DemuxDeleteRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxDeleteRequest Message version mismatch, expected " << DemuxDeleteRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxDeleteResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxDeleteResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

DemuxDeleteResponseNML::DemuxDeleteResponseNML() : NMLmsg((NMLTYPE)DemuxDeleteResponse::ID,sizeof(DemuxDeleteResponseNML)), nmlVersion(DemuxDeleteResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxDeleteResponse()*/)
{
};

DemuxDeleteResponseNML::~DemuxDeleteResponseNML()
{
};

DemuxDeleteResponseNML & DemuxDeleteResponseNML::operator=(const DemuxDeleteResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxDeleteResponseNML & DemuxDeleteResponseNML::operator=(const DemuxDeleteResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxDeleteResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxDeleteResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxDeleteResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxDeleteResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxDeleteResponse> temp(new DemuxDeleteResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxDeleteResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxDeleteResponse Message version mismatch, expected " << DemuxDeleteResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxDeleteResponse Message version mismatch, expected " << DemuxDeleteResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxDelete & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxDelete, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

DemuxDeleteNML::DemuxDeleteNML() : NMLmsg((NMLTYPE)DemuxDelete::ID,sizeof(DemuxDeleteNML)), nmlVersion(DemuxDelete::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxDelete()*/)
{
};

DemuxDeleteNML::~DemuxDeleteNML()
{
};

DemuxDeleteNML & DemuxDeleteNML::operator=(const DemuxDeleteNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxDeleteNML & DemuxDeleteNML::operator=(const DemuxDelete & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxDelete);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxDeleteNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxDelete&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxDeleteNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxDelete> temp(new DemuxDelete());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxDelete::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxDelete Message version mismatch, expected " << DemuxDelete::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxDelete Message version mismatch, expected " << DemuxDelete::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxListRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxListRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

DemuxListRequestNML::DemuxListRequestNML() : NMLmsg((NMLTYPE)DemuxListRequest::ID,sizeof(DemuxListRequestNML)), nmlVersion(DemuxListRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxListRequest()*/)
{
};

DemuxListRequestNML::~DemuxListRequestNML()
{
};

DemuxListRequestNML & DemuxListRequestNML::operator=(const DemuxListRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxListRequestNML & DemuxListRequestNML::operator=(const DemuxListRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxListRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxListRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxListRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxListRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxListRequest> temp(new DemuxListRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxListRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxListRequest Message version mismatch, expected " << DemuxListRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxListRequest Message version mismatch, expected " << DemuxListRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxListResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxListResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topics);

    }  
 }

DemuxListResponseNML::DemuxListResponseNML() : NMLmsg((NMLTYPE)DemuxListResponse::ID,sizeof(DemuxListResponseNML)), nmlVersion(DemuxListResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxListResponse()*/)
{
};

DemuxListResponseNML::~DemuxListResponseNML()
{
};

DemuxListResponseNML & DemuxListResponseNML::operator=(const DemuxListResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxListResponseNML & DemuxListResponseNML::operator=(const DemuxListResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxListResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxListResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxListResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxListResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxListResponse> temp(new DemuxListResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxListResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxListResponse Message version mismatch, expected " << DemuxListResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxListResponse Message version mismatch, expected " << DemuxListResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxList & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxList, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

DemuxListNML::DemuxListNML() : NMLmsg((NMLTYPE)DemuxList::ID,sizeof(DemuxListNML)), nmlVersion(DemuxList::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxList()*/)
{
};

DemuxListNML::~DemuxListNML()
{
};

DemuxListNML & DemuxListNML::operator=(const DemuxListNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxListNML & DemuxListNML::operator=(const DemuxList & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxList);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxListNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxList&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxListNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxList> temp(new DemuxList());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxList::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxList Message version mismatch, expected " << DemuxList::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxList Message version mismatch, expected " << DemuxList::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxSelectRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxSelectRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topic);

    }  
 }

DemuxSelectRequestNML::DemuxSelectRequestNML() : NMLmsg((NMLTYPE)DemuxSelectRequest::ID,sizeof(DemuxSelectRequestNML)), nmlVersion(DemuxSelectRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxSelectRequest()*/)
{
};

DemuxSelectRequestNML::~DemuxSelectRequestNML()
{
};

DemuxSelectRequestNML & DemuxSelectRequestNML::operator=(const DemuxSelectRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxSelectRequestNML & DemuxSelectRequestNML::operator=(const DemuxSelectRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxSelectRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxSelectRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxSelectRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxSelectRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxSelectRequest> temp(new DemuxSelectRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxSelectRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxSelectRequest Message version mismatch, expected " << DemuxSelectRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxSelectRequest Message version mismatch, expected " << DemuxSelectRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxSelectResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxSelectResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.prev_topic);

    }  
 }

DemuxSelectResponseNML::DemuxSelectResponseNML() : NMLmsg((NMLTYPE)DemuxSelectResponse::ID,sizeof(DemuxSelectResponseNML)), nmlVersion(DemuxSelectResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxSelectResponse()*/)
{
};

DemuxSelectResponseNML::~DemuxSelectResponseNML()
{
};

DemuxSelectResponseNML & DemuxSelectResponseNML::operator=(const DemuxSelectResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxSelectResponseNML & DemuxSelectResponseNML::operator=(const DemuxSelectResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxSelectResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxSelectResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxSelectResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxSelectResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxSelectResponse> temp(new DemuxSelectResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxSelectResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxSelectResponse Message version mismatch, expected " << DemuxSelectResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxSelectResponse Message version mismatch, expected " << DemuxSelectResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, DemuxSelect & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DemuxSelect, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

DemuxSelectNML::DemuxSelectNML() : NMLmsg((NMLTYPE)DemuxSelect::ID,sizeof(DemuxSelectNML)), nmlVersion(DemuxSelect::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DemuxSelect()*/)
{
};

DemuxSelectNML::~DemuxSelectNML()
{
};

DemuxSelectNML & DemuxSelectNML::operator=(const DemuxSelectNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DemuxSelectNML & DemuxSelectNML::operator=(const DemuxSelect & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DemuxSelect);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DemuxSelectNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DemuxSelect&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DemuxSelectNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DemuxSelect> temp(new DemuxSelect());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DemuxSelect::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DemuxSelect Message version mismatch, expected " << DemuxSelect::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DemuxSelect Message version mismatch, expected " << DemuxSelect::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxAddRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxAddRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topic);

    }  
 }

MuxAddRequestNML::MuxAddRequestNML() : NMLmsg((NMLTYPE)MuxAddRequest::ID,sizeof(MuxAddRequestNML)), nmlVersion(MuxAddRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxAddRequest()*/)
{
};

MuxAddRequestNML::~MuxAddRequestNML()
{
};

MuxAddRequestNML & MuxAddRequestNML::operator=(const MuxAddRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxAddRequestNML & MuxAddRequestNML::operator=(const MuxAddRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxAddRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxAddRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxAddRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxAddRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxAddRequest> temp(new MuxAddRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxAddRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxAddRequest Message version mismatch, expected " << MuxAddRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxAddRequest Message version mismatch, expected " << MuxAddRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxAddResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxAddResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

MuxAddResponseNML::MuxAddResponseNML() : NMLmsg((NMLTYPE)MuxAddResponse::ID,sizeof(MuxAddResponseNML)), nmlVersion(MuxAddResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxAddResponse()*/)
{
};

MuxAddResponseNML::~MuxAddResponseNML()
{
};

MuxAddResponseNML & MuxAddResponseNML::operator=(const MuxAddResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxAddResponseNML & MuxAddResponseNML::operator=(const MuxAddResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxAddResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxAddResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxAddResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxAddResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxAddResponse> temp(new MuxAddResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxAddResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxAddResponse Message version mismatch, expected " << MuxAddResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxAddResponse Message version mismatch, expected " << MuxAddResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxAdd & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxAdd, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

MuxAddNML::MuxAddNML() : NMLmsg((NMLTYPE)MuxAdd::ID,sizeof(MuxAddNML)), nmlVersion(MuxAdd::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxAdd()*/)
{
};

MuxAddNML::~MuxAddNML()
{
};

MuxAddNML & MuxAddNML::operator=(const MuxAddNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxAddNML & MuxAddNML::operator=(const MuxAdd & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxAdd);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxAddNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxAdd&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxAddNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxAdd> temp(new MuxAdd());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxAdd::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxAdd Message version mismatch, expected " << MuxAdd::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxAdd Message version mismatch, expected " << MuxAdd::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxDeleteRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxDeleteRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topic);

    }  
 }

MuxDeleteRequestNML::MuxDeleteRequestNML() : NMLmsg((NMLTYPE)MuxDeleteRequest::ID,sizeof(MuxDeleteRequestNML)), nmlVersion(MuxDeleteRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxDeleteRequest()*/)
{
};

MuxDeleteRequestNML::~MuxDeleteRequestNML()
{
};

MuxDeleteRequestNML & MuxDeleteRequestNML::operator=(const MuxDeleteRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxDeleteRequestNML & MuxDeleteRequestNML::operator=(const MuxDeleteRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxDeleteRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxDeleteRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxDeleteRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxDeleteRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxDeleteRequest> temp(new MuxDeleteRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxDeleteRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxDeleteRequest Message version mismatch, expected " << MuxDeleteRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxDeleteRequest Message version mismatch, expected " << MuxDeleteRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxDeleteResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxDeleteResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

MuxDeleteResponseNML::MuxDeleteResponseNML() : NMLmsg((NMLTYPE)MuxDeleteResponse::ID,sizeof(MuxDeleteResponseNML)), nmlVersion(MuxDeleteResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxDeleteResponse()*/)
{
};

MuxDeleteResponseNML::~MuxDeleteResponseNML()
{
};

MuxDeleteResponseNML & MuxDeleteResponseNML::operator=(const MuxDeleteResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxDeleteResponseNML & MuxDeleteResponseNML::operator=(const MuxDeleteResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxDeleteResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxDeleteResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxDeleteResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxDeleteResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxDeleteResponse> temp(new MuxDeleteResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxDeleteResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxDeleteResponse Message version mismatch, expected " << MuxDeleteResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxDeleteResponse Message version mismatch, expected " << MuxDeleteResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxDelete & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxDelete, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

MuxDeleteNML::MuxDeleteNML() : NMLmsg((NMLTYPE)MuxDelete::ID,sizeof(MuxDeleteNML)), nmlVersion(MuxDelete::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxDelete()*/)
{
};

MuxDeleteNML::~MuxDeleteNML()
{
};

MuxDeleteNML & MuxDeleteNML::operator=(const MuxDeleteNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxDeleteNML & MuxDeleteNML::operator=(const MuxDelete & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxDelete);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxDeleteNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxDelete&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxDeleteNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxDelete> temp(new MuxDelete());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxDelete::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxDelete Message version mismatch, expected " << MuxDelete::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxDelete Message version mismatch, expected " << MuxDelete::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxListRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxListRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

MuxListRequestNML::MuxListRequestNML() : NMLmsg((NMLTYPE)MuxListRequest::ID,sizeof(MuxListRequestNML)), nmlVersion(MuxListRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxListRequest()*/)
{
};

MuxListRequestNML::~MuxListRequestNML()
{
};

MuxListRequestNML & MuxListRequestNML::operator=(const MuxListRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxListRequestNML & MuxListRequestNML::operator=(const MuxListRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxListRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxListRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxListRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxListRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxListRequest> temp(new MuxListRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxListRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxListRequest Message version mismatch, expected " << MuxListRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxListRequest Message version mismatch, expected " << MuxListRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxListResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxListResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topics);

    }  
 }

MuxListResponseNML::MuxListResponseNML() : NMLmsg((NMLTYPE)MuxListResponse::ID,sizeof(MuxListResponseNML)), nmlVersion(MuxListResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxListResponse()*/)
{
};

MuxListResponseNML::~MuxListResponseNML()
{
};

MuxListResponseNML & MuxListResponseNML::operator=(const MuxListResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxListResponseNML & MuxListResponseNML::operator=(const MuxListResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxListResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxListResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxListResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxListResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxListResponse> temp(new MuxListResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxListResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxListResponse Message version mismatch, expected " << MuxListResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxListResponse Message version mismatch, expected " << MuxListResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxList & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxList, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

MuxListNML::MuxListNML() : NMLmsg((NMLTYPE)MuxList::ID,sizeof(MuxListNML)), nmlVersion(MuxList::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxList()*/)
{
};

MuxListNML::~MuxListNML()
{
};

MuxListNML & MuxListNML::operator=(const MuxListNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxListNML & MuxListNML::operator=(const MuxList & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxList);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxListNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxList&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxListNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxList> temp(new MuxList());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxList::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxList Message version mismatch, expected " << MuxList::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxList Message version mismatch, expected " << MuxList::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxSelectRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxSelectRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.topic);

    }  
 }

MuxSelectRequestNML::MuxSelectRequestNML() : NMLmsg((NMLTYPE)MuxSelectRequest::ID,sizeof(MuxSelectRequestNML)), nmlVersion(MuxSelectRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxSelectRequest()*/)
{
};

MuxSelectRequestNML::~MuxSelectRequestNML()
{
};

MuxSelectRequestNML & MuxSelectRequestNML::operator=(const MuxSelectRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxSelectRequestNML & MuxSelectRequestNML::operator=(const MuxSelectRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxSelectRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxSelectRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxSelectRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxSelectRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxSelectRequest> temp(new MuxSelectRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxSelectRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxSelectRequest Message version mismatch, expected " << MuxSelectRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxSelectRequest Message version mismatch, expected " << MuxSelectRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxSelectResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxSelectResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.prev_topic);

    }  
 }

MuxSelectResponseNML::MuxSelectResponseNML() : NMLmsg((NMLTYPE)MuxSelectResponse::ID,sizeof(MuxSelectResponseNML)), nmlVersion(MuxSelectResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxSelectResponse()*/)
{
};

MuxSelectResponseNML::~MuxSelectResponseNML()
{
};

MuxSelectResponseNML & MuxSelectResponseNML::operator=(const MuxSelectResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxSelectResponseNML & MuxSelectResponseNML::operator=(const MuxSelectResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxSelectResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxSelectResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxSelectResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxSelectResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxSelectResponse> temp(new MuxSelectResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxSelectResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxSelectResponse Message version mismatch, expected " << MuxSelectResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxSelectResponse Message version mismatch, expected " << MuxSelectResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void topic_tools::nmlupdate(CMS * cms, MuxSelect & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MuxSelect, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

MuxSelectNML::MuxSelectNML() : NMLmsg((NMLTYPE)MuxSelect::ID,sizeof(MuxSelectNML)), nmlVersion(MuxSelect::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MuxSelect()*/)
{
};

MuxSelectNML::~MuxSelectNML()
{
};

MuxSelectNML & MuxSelectNML::operator=(const MuxSelectNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MuxSelectNML & MuxSelectNML::operator=(const MuxSelect & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MuxSelect);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MuxSelectNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MuxSelect&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MuxSelectNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MuxSelect> temp(new MuxSelect());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: topic_tools_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MuxSelect::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MuxSelect Message version mismatch, expected " << MuxSelect::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MuxSelect Message version mismatch, expected " << MuxSelect::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int topic_tools::topic_tools_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("topic_tools_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case DemuxAddRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxAddRequest, id " << DemuxAddRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxAddRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxAddResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxAddResponse, id " << DemuxAddResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxAddResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxAdd::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxAdd, id " << DemuxAdd::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxAddNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxDeleteRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxDeleteRequest, id " << DemuxDeleteRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxDeleteRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxDeleteResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxDeleteResponse, id " << DemuxDeleteResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxDeleteResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxDelete::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxDelete, id " << DemuxDelete::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxDeleteNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxListRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxListRequest, id " << DemuxListRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxListRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxListResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxListResponse, id " << DemuxListResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxListResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxList::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxList, id " << DemuxList::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxListNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxSelectRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxSelectRequest, id " << DemuxSelectRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxSelectRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxSelectResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxSelectResponse, id " << DemuxSelectResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxSelectResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DemuxSelect::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DemuxSelect, id " << DemuxSelect::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DemuxSelectNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxAddRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxAddRequest, id " << MuxAddRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxAddRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxAddResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxAddResponse, id " << MuxAddResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxAddResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxAdd::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxAdd, id " << MuxAdd::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxAddNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxDeleteRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxDeleteRequest, id " << MuxDeleteRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxDeleteRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxDeleteResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxDeleteResponse, id " << MuxDeleteResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxDeleteResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxDelete::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxDelete, id " << MuxDelete::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxDeleteNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxListRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxListRequest, id " << MuxListRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxListRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxListResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxListResponse, id " << MuxListResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxListResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxList::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxList, id " << MuxList::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxListNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxSelectRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxSelectRequest, id " << MuxSelectRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxSelectRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxSelectResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxSelectResponse, id " << MuxSelectResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxSelectResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MuxSelect::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MuxSelect, id " << MuxSelect::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_topic_tools_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"topic_tools_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MuxSelectNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

