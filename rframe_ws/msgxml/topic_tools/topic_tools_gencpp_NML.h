// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:59 -0500
//  From Template/Script: data_templates/NMLHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_TOPIC_TOOLS_GENCPPNML_H_
#define _CODEGEN_TOPIC_TOOLS_GENCPPNML_H_

#include <messaging/nml/NMLMessageFactory.h>
//#include <DataTypeInfo.h>
#include <messaging/Message.h>

#include "topic_tools_gencpp_NMLSupport.h"

namespace rframe { class DataTypeInfo; };

#include "DemuxAddRequest.h"
#include "DemuxAddResponse.h"
#include "DemuxAdd.h"
#include "DemuxDeleteRequest.h"
#include "DemuxDeleteResponse.h"
#include "DemuxDelete.h"
#include "DemuxListRequest.h"
#include "DemuxListResponse.h"
#include "DemuxList.h"
#include "DemuxSelectRequest.h"
#include "DemuxSelectResponse.h"
#include "DemuxSelect.h"
#include "MuxAddRequest.h"
#include "MuxAddResponse.h"
#include "MuxAdd.h"
#include "MuxDeleteRequest.h"
#include "MuxDeleteResponse.h"
#include "MuxDelete.h"
#include "MuxListRequest.h"
#include "MuxListResponse.h"
#include "MuxList.h"
#include "MuxSelectRequest.h"
#include "MuxSelectResponse.h"
#include "MuxSelect.h"

namespace topic_tools {

    /** definition of message factory for topic_tools_gencpp */
    class topic_tools_gencppNMLMessageFactory : public NMLMessageFactory
    {
    public:
        /** constructor */
        topic_tools_gencppNMLMessageFactory();
        /** destructor */
        virtual ~topic_tools_gencppNMLMessageFactory();

        /** see  rframe::MessageFactoryInterface */
        virtual void dataTypes(std::vector<DataTypeInfo> & ids);
        /** see  rframe::MessageFactoryInterface */
        virtual int dataType(NMLmsg & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateTransport(NMLmsg * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateMessage(MessageBase * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int toTransport( MessageBase & src, NMLmsg & dst);
        /** see  rframe::MessageFactoryInterface */
        virtual int fromTransport( NMLmsg & src, MessageBase & dst);

        /** \return poitner to nml format function */
        virtual NML_FORMAT_PTR FormatPointer();
        /** run constructor for class of type id in the provided buffer */
        virtual int constructBuffer(rframe::ID_TYPE id, void * buffer);
        /** run destructor for class of type id in the buffer */
        virtual int destructBuffer(rframe::ID_TYPE id, void * buffer);
    };

    /** factory allocation function for use when not dynamically loading the factory library  */
    NMLMessageFactory * allocate_topic_tools_gencpp();

    /** NML interface for DemuxAddRequest 

    */
    class DemuxAddRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxAddRequestNML();
        /** destructor */
        ~DemuxAddRequestNML();

        /** assignment operator */
        DemuxAddRequestNML & operator=(const DemuxAddRequestNML &inobj);
        /** assignment operator for base data class */
        DemuxAddRequestNML & operator=(const DemuxAddRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxAddRequest nmlPayload;

        /** set payload */
        void payload(const DemuxAddRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxAddRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxAddRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxAddRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxAddResponse 

    */
    class DemuxAddResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxAddResponseNML();
        /** destructor */
        ~DemuxAddResponseNML();

        /** assignment operator */
        DemuxAddResponseNML & operator=(const DemuxAddResponseNML &inobj);
        /** assignment operator for base data class */
        DemuxAddResponseNML & operator=(const DemuxAddResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxAddResponse nmlPayload;

        /** set payload */
        void payload(const DemuxAddResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxAddResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxAddResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxAddResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxAdd 

    */
    class DemuxAddNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxAddNML();
        /** destructor */
        ~DemuxAddNML();

        /** assignment operator */
        DemuxAddNML & operator=(const DemuxAddNML &inobj);
        /** assignment operator for base data class */
        DemuxAddNML & operator=(const DemuxAdd &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxAdd nmlPayload;

        /** set payload */
        void payload(const DemuxAdd &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxAdd> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxAdd * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxAdd> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxDeleteRequest 

    */
    class DemuxDeleteRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxDeleteRequestNML();
        /** destructor */
        ~DemuxDeleteRequestNML();

        /** assignment operator */
        DemuxDeleteRequestNML & operator=(const DemuxDeleteRequestNML &inobj);
        /** assignment operator for base data class */
        DemuxDeleteRequestNML & operator=(const DemuxDeleteRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxDeleteRequest nmlPayload;

        /** set payload */
        void payload(const DemuxDeleteRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxDeleteRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxDeleteRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxDeleteRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxDeleteResponse 

    */
    class DemuxDeleteResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxDeleteResponseNML();
        /** destructor */
        ~DemuxDeleteResponseNML();

        /** assignment operator */
        DemuxDeleteResponseNML & operator=(const DemuxDeleteResponseNML &inobj);
        /** assignment operator for base data class */
        DemuxDeleteResponseNML & operator=(const DemuxDeleteResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxDeleteResponse nmlPayload;

        /** set payload */
        void payload(const DemuxDeleteResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxDeleteResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxDeleteResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxDeleteResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxDelete 

    */
    class DemuxDeleteNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxDeleteNML();
        /** destructor */
        ~DemuxDeleteNML();

        /** assignment operator */
        DemuxDeleteNML & operator=(const DemuxDeleteNML &inobj);
        /** assignment operator for base data class */
        DemuxDeleteNML & operator=(const DemuxDelete &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxDelete nmlPayload;

        /** set payload */
        void payload(const DemuxDelete &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxDelete> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxDelete * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxDelete> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxListRequest 

    */
    class DemuxListRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxListRequestNML();
        /** destructor */
        ~DemuxListRequestNML();

        /** assignment operator */
        DemuxListRequestNML & operator=(const DemuxListRequestNML &inobj);
        /** assignment operator for base data class */
        DemuxListRequestNML & operator=(const DemuxListRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxListRequest nmlPayload;

        /** set payload */
        void payload(const DemuxListRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxListRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxListRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxListRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxListResponse 

    */
    class DemuxListResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxListResponseNML();
        /** destructor */
        ~DemuxListResponseNML();

        /** assignment operator */
        DemuxListResponseNML & operator=(const DemuxListResponseNML &inobj);
        /** assignment operator for base data class */
        DemuxListResponseNML & operator=(const DemuxListResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxListResponse nmlPayload;

        /** set payload */
        void payload(const DemuxListResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxListResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxListResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxListResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxList 

    */
    class DemuxListNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxListNML();
        /** destructor */
        ~DemuxListNML();

        /** assignment operator */
        DemuxListNML & operator=(const DemuxListNML &inobj);
        /** assignment operator for base data class */
        DemuxListNML & operator=(const DemuxList &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxList nmlPayload;

        /** set payload */
        void payload(const DemuxList &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxList> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxList * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxList> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxSelectRequest 

    */
    class DemuxSelectRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxSelectRequestNML();
        /** destructor */
        ~DemuxSelectRequestNML();

        /** assignment operator */
        DemuxSelectRequestNML & operator=(const DemuxSelectRequestNML &inobj);
        /** assignment operator for base data class */
        DemuxSelectRequestNML & operator=(const DemuxSelectRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxSelectRequest nmlPayload;

        /** set payload */
        void payload(const DemuxSelectRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxSelectRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxSelectRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxSelectRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxSelectResponse 

    */
    class DemuxSelectResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxSelectResponseNML();
        /** destructor */
        ~DemuxSelectResponseNML();

        /** assignment operator */
        DemuxSelectResponseNML & operator=(const DemuxSelectResponseNML &inobj);
        /** assignment operator for base data class */
        DemuxSelectResponseNML & operator=(const DemuxSelectResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxSelectResponse nmlPayload;

        /** set payload */
        void payload(const DemuxSelectResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxSelectResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxSelectResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxSelectResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DemuxSelect 

    */
    class DemuxSelectNML : public NMLmsg
    {
    public:

        /** constructor */
        DemuxSelectNML();
        /** destructor */
        ~DemuxSelectNML();

        /** assignment operator */
        DemuxSelectNML & operator=(const DemuxSelectNML &inobj);
        /** assignment operator for base data class */
        DemuxSelectNML & operator=(const DemuxSelect &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DemuxSelect nmlPayload;

        /** set payload */
        void payload(const DemuxSelect &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DemuxSelect> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DemuxSelect * payload() { return & nmlPayload; };

    //     std::shared_ptr<DemuxSelect> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxAddRequest 

    */
    class MuxAddRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxAddRequestNML();
        /** destructor */
        ~MuxAddRequestNML();

        /** assignment operator */
        MuxAddRequestNML & operator=(const MuxAddRequestNML &inobj);
        /** assignment operator for base data class */
        MuxAddRequestNML & operator=(const MuxAddRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxAddRequest nmlPayload;

        /** set payload */
        void payload(const MuxAddRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxAddRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxAddRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxAddRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxAddResponse 

    */
    class MuxAddResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxAddResponseNML();
        /** destructor */
        ~MuxAddResponseNML();

        /** assignment operator */
        MuxAddResponseNML & operator=(const MuxAddResponseNML &inobj);
        /** assignment operator for base data class */
        MuxAddResponseNML & operator=(const MuxAddResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxAddResponse nmlPayload;

        /** set payload */
        void payload(const MuxAddResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxAddResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxAddResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxAddResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxAdd 

    */
    class MuxAddNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxAddNML();
        /** destructor */
        ~MuxAddNML();

        /** assignment operator */
        MuxAddNML & operator=(const MuxAddNML &inobj);
        /** assignment operator for base data class */
        MuxAddNML & operator=(const MuxAdd &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxAdd nmlPayload;

        /** set payload */
        void payload(const MuxAdd &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxAdd> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxAdd * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxAdd> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxDeleteRequest 

    */
    class MuxDeleteRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxDeleteRequestNML();
        /** destructor */
        ~MuxDeleteRequestNML();

        /** assignment operator */
        MuxDeleteRequestNML & operator=(const MuxDeleteRequestNML &inobj);
        /** assignment operator for base data class */
        MuxDeleteRequestNML & operator=(const MuxDeleteRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxDeleteRequest nmlPayload;

        /** set payload */
        void payload(const MuxDeleteRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxDeleteRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxDeleteRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxDeleteRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxDeleteResponse 

    */
    class MuxDeleteResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxDeleteResponseNML();
        /** destructor */
        ~MuxDeleteResponseNML();

        /** assignment operator */
        MuxDeleteResponseNML & operator=(const MuxDeleteResponseNML &inobj);
        /** assignment operator for base data class */
        MuxDeleteResponseNML & operator=(const MuxDeleteResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxDeleteResponse nmlPayload;

        /** set payload */
        void payload(const MuxDeleteResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxDeleteResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxDeleteResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxDeleteResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxDelete 

    */
    class MuxDeleteNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxDeleteNML();
        /** destructor */
        ~MuxDeleteNML();

        /** assignment operator */
        MuxDeleteNML & operator=(const MuxDeleteNML &inobj);
        /** assignment operator for base data class */
        MuxDeleteNML & operator=(const MuxDelete &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxDelete nmlPayload;

        /** set payload */
        void payload(const MuxDelete &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxDelete> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxDelete * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxDelete> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxListRequest 

    */
    class MuxListRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxListRequestNML();
        /** destructor */
        ~MuxListRequestNML();

        /** assignment operator */
        MuxListRequestNML & operator=(const MuxListRequestNML &inobj);
        /** assignment operator for base data class */
        MuxListRequestNML & operator=(const MuxListRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxListRequest nmlPayload;

        /** set payload */
        void payload(const MuxListRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxListRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxListRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxListRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxListResponse 

    */
    class MuxListResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxListResponseNML();
        /** destructor */
        ~MuxListResponseNML();

        /** assignment operator */
        MuxListResponseNML & operator=(const MuxListResponseNML &inobj);
        /** assignment operator for base data class */
        MuxListResponseNML & operator=(const MuxListResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxListResponse nmlPayload;

        /** set payload */
        void payload(const MuxListResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxListResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxListResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxListResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxList 

    */
    class MuxListNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxListNML();
        /** destructor */
        ~MuxListNML();

        /** assignment operator */
        MuxListNML & operator=(const MuxListNML &inobj);
        /** assignment operator for base data class */
        MuxListNML & operator=(const MuxList &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxList nmlPayload;

        /** set payload */
        void payload(const MuxList &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxList> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxList * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxList> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxSelectRequest 

    */
    class MuxSelectRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxSelectRequestNML();
        /** destructor */
        ~MuxSelectRequestNML();

        /** assignment operator */
        MuxSelectRequestNML & operator=(const MuxSelectRequestNML &inobj);
        /** assignment operator for base data class */
        MuxSelectRequestNML & operator=(const MuxSelectRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxSelectRequest nmlPayload;

        /** set payload */
        void payload(const MuxSelectRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxSelectRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxSelectRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxSelectRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxSelectResponse 

    */
    class MuxSelectResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxSelectResponseNML();
        /** destructor */
        ~MuxSelectResponseNML();

        /** assignment operator */
        MuxSelectResponseNML & operator=(const MuxSelectResponseNML &inobj);
        /** assignment operator for base data class */
        MuxSelectResponseNML & operator=(const MuxSelectResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxSelectResponse nmlPayload;

        /** set payload */
        void payload(const MuxSelectResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxSelectResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxSelectResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxSelectResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MuxSelect 

    */
    class MuxSelectNML : public NMLmsg
    {
    public:

        /** constructor */
        MuxSelectNML();
        /** destructor */
        ~MuxSelectNML();

        /** assignment operator */
        MuxSelectNML & operator=(const MuxSelectNML &inobj);
        /** assignment operator for base data class */
        MuxSelectNML & operator=(const MuxSelect &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MuxSelect nmlPayload;

        /** set payload */
        void payload(const MuxSelect &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MuxSelect> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MuxSelect * payload() { return & nmlPayload; };

    //     std::shared_ptr<MuxSelect> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    // predeclaration of nmlupdate functions (necessary due to namespaces )

    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxAddRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxAddResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxAdd & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxDeleteRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxDeleteResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxDelete & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxListRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxListResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxList & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxSelectRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxSelectResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::DemuxSelect & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxAddRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxAddResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxAdd & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxDeleteRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxDeleteResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxDelete & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxListRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxListResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxList & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxSelectRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxSelectResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, topic_tools::MuxSelect & inobj);

    /** nml format function */
    int topic_tools_gencpp_format(NMLTYPE type, void * buffer, CMS* cms);

}; // end namespace topic_tools

#endif // _TOPIC_TOOLS_GENCPPNML_H_
