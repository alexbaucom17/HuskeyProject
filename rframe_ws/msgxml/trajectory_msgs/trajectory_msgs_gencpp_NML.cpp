// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:09 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "trajectory_msgs_gencpp_NML.h"
#include "trajectory_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <JointTrajectory.h>
#include <JointTrajectoryPoint.h>
#include <MultiDOFJointTrajectory.h>
#include <MultiDOFJointTrajectoryPoint.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace trajectory_msgs;

rframe::NMLMessageFactory * NML_trajectory_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_trajectory_msgs_gencppfactory = new trajectory_msgs_gencppNMLMessageFactory();
        return NML_trajectory_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * trajectory_msgs::allocate_trajectory_msgs_gencpp()
{
    NML_trajectory_msgs_gencppfactory = new trajectory_msgs_gencppNMLMessageFactory();
    return NML_trajectory_msgs_gencppfactory;
};

trajectory_msgs_gencppNMLMessageFactory::trajectory_msgs_gencppNMLMessageFactory()
{
    name("trajectory_msgs_gencpp");
    // use constructor to register data types
    trajectory_msgs::registerLibrary();
}

trajectory_msgs_gencppNMLMessageFactory::~trajectory_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR trajectory_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return trajectory_msgs_gencpp_format;
}

int trajectory_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void trajectory_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(JointTrajectory::ID);
    info.name(JointTrajectory::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectory::DATA_VERSION);
    info.md5Key(JointTrajectory::VERSION_MD5);
    info.xmlSource(JointTrajectory::XML_SOURCE);
    info.flat(JointTrajectory::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryPoint::ID);
    info.name(JointTrajectoryPoint::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryPoint::DATA_VERSION);
    info.md5Key(JointTrajectoryPoint::VERSION_MD5);
    info.xmlSource(JointTrajectoryPoint::XML_SOURCE);
    info.flat(JointTrajectoryPoint::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiDOFJointTrajectory::ID);
    info.name(MultiDOFJointTrajectory::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiDOFJointTrajectory::DATA_VERSION);
    info.md5Key(MultiDOFJointTrajectory::VERSION_MD5);
    info.xmlSource(MultiDOFJointTrajectory::XML_SOURCE);
    info.flat(MultiDOFJointTrajectory::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiDOFJointTrajectoryPoint::ID);
    info.name(MultiDOFJointTrajectoryPoint::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiDOFJointTrajectoryPoint::DATA_VERSION);
    info.md5Key(MultiDOFJointTrajectoryPoint::VERSION_MD5);
    info.xmlSource(MultiDOFJointTrajectoryPoint::XML_SOURCE);
    info.flat(MultiDOFJointTrajectoryPoint::dataTypeFlat());
    ids.push_back(info);

}

int trajectory_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case JointTrajectory::ID:
        {
            //JointTrajectoryNML * newmsg = new JointTrajectoryNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryNML(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryPoint::ID:
        {
            //JointTrajectoryPointNML * newmsg = new JointTrajectoryPointNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryPointNML(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MultiDOFJointTrajectory::ID:
        {
            //MultiDOFJointTrajectoryNML * newmsg = new MultiDOFJointTrajectoryNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MultiDOFJointTrajectoryNML(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MultiDOFJointTrajectoryPoint::ID:
        {
            //MultiDOFJointTrajectoryPointNML * newmsg = new MultiDOFJointTrajectoryPointNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MultiDOFJointTrajectoryPointNML(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case JointTrajectory::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectory>(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryPoint::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryPoint>(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiDOFJointTrajectory::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiDOFJointTrajectory>(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiDOFJointTrajectoryPoint::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiDOFJointTrajectoryPoint>(),std::bind(&trajectory_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case JointTrajectory::ID:
            {
                JointTrajectoryNML * tempmsg = static_cast<JointTrajectoryNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryPoint::ID:
            {
                JointTrajectoryPointNML * tempmsg = static_cast<JointTrajectoryPointNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MultiDOFJointTrajectory::ID:
            {
                MultiDOFJointTrajectoryNML * tempmsg = static_cast<MultiDOFJointTrajectoryNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MultiDOFJointTrajectoryPoint::ID:
            {
                MultiDOFJointTrajectoryPointNML * tempmsg = static_cast<MultiDOFJointTrajectoryPointNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case JointTrajectory::ID:
            {
                JointTrajectoryNML & tempDst = static_cast<JointTrajectoryNML&>(dst);
                Message<JointTrajectory > & tempSrc = static_cast<Message<JointTrajectory>&>(src);

                if (tempSrc.version() != JointTrajectory::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectory: " << __FILE__ << " expected: " 
                             << JointTrajectory::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectory: " << __FILE__ << " expected: " 
                         << JointTrajectory::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryPoint::ID:
            {
                JointTrajectoryPointNML & tempDst = static_cast<JointTrajectoryPointNML&>(dst);
                Message<JointTrajectoryPoint > & tempSrc = static_cast<Message<JointTrajectoryPoint>&>(src);

                if (tempSrc.version() != JointTrajectoryPoint::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryPoint: " << __FILE__ << " expected: " 
                             << JointTrajectoryPoint::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryPoint: " << __FILE__ << " expected: " 
                         << JointTrajectoryPoint::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MultiDOFJointTrajectory::ID:
            {
                MultiDOFJointTrajectoryNML & tempDst = static_cast<MultiDOFJointTrajectoryNML&>(dst);
                Message<MultiDOFJointTrajectory > & tempSrc = static_cast<Message<MultiDOFJointTrajectory>&>(src);

                if (tempSrc.version() != MultiDOFJointTrajectory::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MultiDOFJointTrajectory: " << __FILE__ << " expected: " 
                             << MultiDOFJointTrajectory::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MultiDOFJointTrajectory: " << __FILE__ << " expected: " 
                         << MultiDOFJointTrajectory::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MultiDOFJointTrajectoryPoint::ID:
            {
                MultiDOFJointTrajectoryPointNML & tempDst = static_cast<MultiDOFJointTrajectoryPointNML&>(dst);
                Message<MultiDOFJointTrajectoryPoint > & tempSrc = static_cast<Message<MultiDOFJointTrajectoryPoint>&>(src);

                if (tempSrc.version() != MultiDOFJointTrajectoryPoint::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MultiDOFJointTrajectoryPoint: " << __FILE__ << " expected: " 
                             << MultiDOFJointTrajectoryPoint::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MultiDOFJointTrajectoryPoint: " << __FILE__ << " expected: " 
                         << MultiDOFJointTrajectoryPoint::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case JointTrajectory::ID:
            {
                JointTrajectoryNML & tempSrc = static_cast<JointTrajectoryNML&>(src);
                Message<JointTrajectory > & tempDst = static_cast<Message<JointTrajectory>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectory::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryPoint::ID:
            {
                JointTrajectoryPointNML & tempSrc = static_cast<JointTrajectoryPointNML&>(src);
                Message<JointTrajectoryPoint > & tempDst = static_cast<Message<JointTrajectoryPoint>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryPoint::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MultiDOFJointTrajectory::ID:
            {
                MultiDOFJointTrajectoryNML & tempSrc = static_cast<MultiDOFJointTrajectoryNML&>(src);
                Message<MultiDOFJointTrajectory > & tempDst = static_cast<Message<MultiDOFJointTrajectory>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MultiDOFJointTrajectory::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MultiDOFJointTrajectoryPoint::ID:
            {
                MultiDOFJointTrajectoryPointNML & tempSrc = static_cast<MultiDOFJointTrajectoryPointNML&>(src);
                Message<MultiDOFJointTrajectoryPoint > & tempDst = static_cast<Message<MultiDOFJointTrajectoryPoint>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MultiDOFJointTrajectoryPoint::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case JointTrajectory::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectory::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectory at %p\n",buffer);
                JointTrajectoryNML * p = static_cast<JointTrajectoryNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectory at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryPoint::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryPoint::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryPoint at %p\n",buffer);
                JointTrajectoryPointNML * p = static_cast<JointTrajectoryPointNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryPointNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryPoint at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MultiDOFJointTrajectory::ID:
        {
            // only need to construct if data type is not flat
            if (MultiDOFJointTrajectory::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MultiDOFJointTrajectory at %p\n",buffer);
                MultiDOFJointTrajectoryNML * p = static_cast<MultiDOFJointTrajectoryNML*>(buffer);
                // construct the type at pointer p
                new (p) MultiDOFJointTrajectoryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MultiDOFJointTrajectory at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MultiDOFJointTrajectoryPoint::ID:
        {
            // only need to construct if data type is not flat
            if (MultiDOFJointTrajectoryPoint::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MultiDOFJointTrajectoryPoint at %p\n",buffer);
                MultiDOFJointTrajectoryPointNML * p = static_cast<MultiDOFJointTrajectoryPointNML*>(buffer);
                // construct the type at pointer p
                new (p) MultiDOFJointTrajectoryPointNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MultiDOFJointTrajectoryPoint at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int trajectory_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case JointTrajectory::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectory::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectory at %p\n",buffer);
                JointTrajectoryNML * p = static_cast<JointTrajectoryNML*>(buffer);
                p->~JointTrajectoryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectory at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryPoint::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryPoint::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryPoint at %p\n",buffer);
                JointTrajectoryPointNML * p = static_cast<JointTrajectoryPointNML*>(buffer);
                p->~JointTrajectoryPointNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryPoint at %p, is flat\n",buffer);
            }
            break;
        } 
        case MultiDOFJointTrajectory::ID:
        {
            // only need to destruct if data type is not flat
            if (MultiDOFJointTrajectory::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MultiDOFJointTrajectory at %p\n",buffer);
                MultiDOFJointTrajectoryNML * p = static_cast<MultiDOFJointTrajectoryNML*>(buffer);
                p->~MultiDOFJointTrajectoryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MultiDOFJointTrajectory at %p, is flat\n",buffer);
            }
            break;
        } 
        case MultiDOFJointTrajectoryPoint::ID:
        {
            // only need to destruct if data type is not flat
            if (MultiDOFJointTrajectoryPoint::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MultiDOFJointTrajectoryPoint at %p\n",buffer);
                MultiDOFJointTrajectoryPointNML * p = static_cast<MultiDOFJointTrajectoryPointNML*>(buffer);
                p->~MultiDOFJointTrajectoryPointNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MultiDOFJointTrajectoryPoint at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void trajectory_msgs::nmlupdate(CMS * cms, JointTrajectory & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectory, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.points);

    }  
 }

JointTrajectoryNML::JointTrajectoryNML() : NMLmsg((NMLTYPE)JointTrajectory::ID,sizeof(JointTrajectoryNML)), nmlVersion(JointTrajectory::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectory()*/)
{
};

JointTrajectoryNML::~JointTrajectoryNML()
{
};

JointTrajectoryNML & JointTrajectoryNML::operator=(const JointTrajectoryNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryNML & JointTrajectoryNML::operator=(const JointTrajectory & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectory);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectory&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectory> temp(new JointTrajectory());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: trajectory_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectory::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectory Message version mismatch, expected " << JointTrajectory::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectory Message version mismatch, expected " << JointTrajectory::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void trajectory_msgs::nmlupdate(CMS * cms, JointTrajectoryPoint & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryPoint, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.positions);
        nmlupdate(cms,inobj.velocities);
        nmlupdate(cms,inobj.accelerations);
        nmlupdate(cms,inobj.effort);
        nmlupdate(cms,inobj.time_from_start);

    }  
 }

JointTrajectoryPointNML::JointTrajectoryPointNML() : NMLmsg((NMLTYPE)JointTrajectoryPoint::ID,sizeof(JointTrajectoryPointNML)), nmlVersion(JointTrajectoryPoint::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryPoint()*/)
{
};

JointTrajectoryPointNML::~JointTrajectoryPointNML()
{
};

JointTrajectoryPointNML & JointTrajectoryPointNML::operator=(const JointTrajectoryPointNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryPointNML & JointTrajectoryPointNML::operator=(const JointTrajectoryPoint & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryPoint);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryPointNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryPoint&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryPointNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryPoint> temp(new JointTrajectoryPoint());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: trajectory_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryPoint::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryPoint Message version mismatch, expected " << JointTrajectoryPoint::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryPoint Message version mismatch, expected " << JointTrajectoryPoint::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void trajectory_msgs::nmlupdate(CMS * cms, MultiDOFJointTrajectory & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MultiDOFJointTrajectory, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.points);

    }  
 }

MultiDOFJointTrajectoryNML::MultiDOFJointTrajectoryNML() : NMLmsg((NMLTYPE)MultiDOFJointTrajectory::ID,sizeof(MultiDOFJointTrajectoryNML)), nmlVersion(MultiDOFJointTrajectory::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MultiDOFJointTrajectory()*/)
{
};

MultiDOFJointTrajectoryNML::~MultiDOFJointTrajectoryNML()
{
};

MultiDOFJointTrajectoryNML & MultiDOFJointTrajectoryNML::operator=(const MultiDOFJointTrajectoryNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MultiDOFJointTrajectoryNML & MultiDOFJointTrajectoryNML::operator=(const MultiDOFJointTrajectory & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MultiDOFJointTrajectory);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MultiDOFJointTrajectoryNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MultiDOFJointTrajectory&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MultiDOFJointTrajectoryNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MultiDOFJointTrajectory> temp(new MultiDOFJointTrajectory());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: trajectory_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MultiDOFJointTrajectory::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MultiDOFJointTrajectory Message version mismatch, expected " << MultiDOFJointTrajectory::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MultiDOFJointTrajectory Message version mismatch, expected " << MultiDOFJointTrajectory::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void trajectory_msgs::nmlupdate(CMS * cms, MultiDOFJointTrajectoryPoint & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MultiDOFJointTrajectoryPoint, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.transforms);
        nmlupdate(cms,inobj.velocities);
        nmlupdate(cms,inobj.accelerations);
        nmlupdate(cms,inobj.time_from_start);

    }  
 }

MultiDOFJointTrajectoryPointNML::MultiDOFJointTrajectoryPointNML() : NMLmsg((NMLTYPE)MultiDOFJointTrajectoryPoint::ID,sizeof(MultiDOFJointTrajectoryPointNML)), nmlVersion(MultiDOFJointTrajectoryPoint::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MultiDOFJointTrajectoryPoint()*/)
{
};

MultiDOFJointTrajectoryPointNML::~MultiDOFJointTrajectoryPointNML()
{
};

MultiDOFJointTrajectoryPointNML & MultiDOFJointTrajectoryPointNML::operator=(const MultiDOFJointTrajectoryPointNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MultiDOFJointTrajectoryPointNML & MultiDOFJointTrajectoryPointNML::operator=(const MultiDOFJointTrajectoryPoint & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MultiDOFJointTrajectoryPoint);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MultiDOFJointTrajectoryPointNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MultiDOFJointTrajectoryPoint&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MultiDOFJointTrajectoryPointNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MultiDOFJointTrajectoryPoint> temp(new MultiDOFJointTrajectoryPoint());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: trajectory_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MultiDOFJointTrajectoryPoint::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MultiDOFJointTrajectoryPoint Message version mismatch, expected " << MultiDOFJointTrajectoryPoint::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MultiDOFJointTrajectoryPoint Message version mismatch, expected " << MultiDOFJointTrajectoryPoint::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int trajectory_msgs::trajectory_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("trajectory_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case JointTrajectory::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectory, id " << JointTrajectory::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_trajectory_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"trajectory_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryPoint::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryPoint, id " << JointTrajectoryPoint::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_trajectory_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"trajectory_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryPointNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MultiDOFJointTrajectory::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MultiDOFJointTrajectory, id " << MultiDOFJointTrajectory::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_trajectory_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"trajectory_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MultiDOFJointTrajectoryNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MultiDOFJointTrajectoryPoint::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MultiDOFJointTrajectoryPoint, id " << MultiDOFJointTrajectoryPoint::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_trajectory_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"trajectory_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MultiDOFJointTrajectoryPointNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

