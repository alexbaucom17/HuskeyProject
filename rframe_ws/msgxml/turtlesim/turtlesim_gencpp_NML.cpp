// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:45:00 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "turtlesim_gencpp_NML.h"
#include "turtlesim_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <Color.h>
#include <Pose.h>
#include <KillRequest.h>
#include <KillResponse.h>
#include <Kill.h>
#include <SetPenRequest.h>
#include <SetPenResponse.h>
#include <SetPen.h>
#include <SpawnRequest.h>
#include <SpawnResponse.h>
#include <Spawn.h>
#include <TeleportAbsoluteRequest.h>
#include <TeleportAbsoluteResponse.h>
#include <TeleportAbsolute.h>
#include <TeleportRelativeRequest.h>
#include <TeleportRelativeResponse.h>
#include <TeleportRelative.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace turtlesim;

rframe::NMLMessageFactory * NML_turtlesim_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_turtlesim_gencppfactory = new turtlesim_gencppNMLMessageFactory();
        return NML_turtlesim_gencppfactory;
    };
}

rframe::NMLMessageFactory * turtlesim::allocate_turtlesim_gencpp()
{
    NML_turtlesim_gencppfactory = new turtlesim_gencppNMLMessageFactory();
    return NML_turtlesim_gencppfactory;
};

turtlesim_gencppNMLMessageFactory::turtlesim_gencppNMLMessageFactory()
{
    name("turtlesim_gencpp");
    // use constructor to register data types
    turtlesim::registerLibrary();
}

turtlesim_gencppNMLMessageFactory::~turtlesim_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR turtlesim_gencppNMLMessageFactory::FormatPointer()
{
    return turtlesim_gencpp_format;
}

int turtlesim_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void turtlesim_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(Color::ID);
    info.name(Color::DATA_TYPE_FULL_NAME);
    info.hashKey(Color::DATA_VERSION);
    info.md5Key(Color::VERSION_MD5);
    info.xmlSource(Color::XML_SOURCE);
    info.flat(Color::dataTypeFlat());
    ids.push_back(info);

    info.id(Pose::ID);
    info.name(Pose::DATA_TYPE_FULL_NAME);
    info.hashKey(Pose::DATA_VERSION);
    info.md5Key(Pose::VERSION_MD5);
    info.xmlSource(Pose::XML_SOURCE);
    info.flat(Pose::dataTypeFlat());
    ids.push_back(info);

    info.id(KillRequest::ID);
    info.name(KillRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(KillRequest::DATA_VERSION);
    info.md5Key(KillRequest::VERSION_MD5);
    info.xmlSource(KillRequest::XML_SOURCE);
    info.flat(KillRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(KillResponse::ID);
    info.name(KillResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(KillResponse::DATA_VERSION);
    info.md5Key(KillResponse::VERSION_MD5);
    info.xmlSource(KillResponse::XML_SOURCE);
    info.flat(KillResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(Kill::ID);
    info.name(Kill::DATA_TYPE_FULL_NAME);
    info.hashKey(Kill::DATA_VERSION);
    info.md5Key(Kill::VERSION_MD5);
    info.xmlSource(Kill::XML_SOURCE);
    info.flat(Kill::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPenRequest::ID);
    info.name(SetPenRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPenRequest::DATA_VERSION);
    info.md5Key(SetPenRequest::VERSION_MD5);
    info.xmlSource(SetPenRequest::XML_SOURCE);
    info.flat(SetPenRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPenResponse::ID);
    info.name(SetPenResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPenResponse::DATA_VERSION);
    info.md5Key(SetPenResponse::VERSION_MD5);
    info.xmlSource(SetPenResponse::XML_SOURCE);
    info.flat(SetPenResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPen::ID);
    info.name(SetPen::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPen::DATA_VERSION);
    info.md5Key(SetPen::VERSION_MD5);
    info.xmlSource(SetPen::XML_SOURCE);
    info.flat(SetPen::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnRequest::ID);
    info.name(SpawnRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnRequest::DATA_VERSION);
    info.md5Key(SpawnRequest::VERSION_MD5);
    info.xmlSource(SpawnRequest::XML_SOURCE);
    info.flat(SpawnRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnResponse::ID);
    info.name(SpawnResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnResponse::DATA_VERSION);
    info.md5Key(SpawnResponse::VERSION_MD5);
    info.xmlSource(SpawnResponse::XML_SOURCE);
    info.flat(SpawnResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(Spawn::ID);
    info.name(Spawn::DATA_TYPE_FULL_NAME);
    info.hashKey(Spawn::DATA_VERSION);
    info.md5Key(Spawn::VERSION_MD5);
    info.xmlSource(Spawn::XML_SOURCE);
    info.flat(Spawn::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportAbsoluteRequest::ID);
    info.name(TeleportAbsoluteRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportAbsoluteRequest::DATA_VERSION);
    info.md5Key(TeleportAbsoluteRequest::VERSION_MD5);
    info.xmlSource(TeleportAbsoluteRequest::XML_SOURCE);
    info.flat(TeleportAbsoluteRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportAbsoluteResponse::ID);
    info.name(TeleportAbsoluteResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportAbsoluteResponse::DATA_VERSION);
    info.md5Key(TeleportAbsoluteResponse::VERSION_MD5);
    info.xmlSource(TeleportAbsoluteResponse::XML_SOURCE);
    info.flat(TeleportAbsoluteResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportAbsolute::ID);
    info.name(TeleportAbsolute::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportAbsolute::DATA_VERSION);
    info.md5Key(TeleportAbsolute::VERSION_MD5);
    info.xmlSource(TeleportAbsolute::XML_SOURCE);
    info.flat(TeleportAbsolute::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportRelativeRequest::ID);
    info.name(TeleportRelativeRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportRelativeRequest::DATA_VERSION);
    info.md5Key(TeleportRelativeRequest::VERSION_MD5);
    info.xmlSource(TeleportRelativeRequest::XML_SOURCE);
    info.flat(TeleportRelativeRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportRelativeResponse::ID);
    info.name(TeleportRelativeResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportRelativeResponse::DATA_VERSION);
    info.md5Key(TeleportRelativeResponse::VERSION_MD5);
    info.xmlSource(TeleportRelativeResponse::XML_SOURCE);
    info.flat(TeleportRelativeResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportRelative::ID);
    info.name(TeleportRelative::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportRelative::DATA_VERSION);
    info.md5Key(TeleportRelative::VERSION_MD5);
    info.xmlSource(TeleportRelative::XML_SOURCE);
    info.flat(TeleportRelative::dataTypeFlat());
    ids.push_back(info);

}

int turtlesim_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case Color::ID:
        {
            //ColorNML * newmsg = new ColorNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ColorNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Pose::ID:
        {
            //PoseNML * newmsg = new PoseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PoseNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case KillRequest::ID:
        {
            //KillRequestNML * newmsg = new KillRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new KillRequestNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case KillResponse::ID:
        {
            //KillResponseNML * newmsg = new KillResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new KillResponseNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Kill::ID:
        {
            //KillNML * newmsg = new KillNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new KillNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetPenRequest::ID:
        {
            //SetPenRequestNML * newmsg = new SetPenRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetPenRequestNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetPenResponse::ID:
        {
            //SetPenResponseNML * newmsg = new SetPenResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetPenResponseNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetPen::ID:
        {
            //SetPenNML * newmsg = new SetPenNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetPenNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SpawnRequest::ID:
        {
            //SpawnRequestNML * newmsg = new SpawnRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SpawnRequestNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SpawnResponse::ID:
        {
            //SpawnResponseNML * newmsg = new SpawnResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SpawnResponseNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Spawn::ID:
        {
            //SpawnNML * newmsg = new SpawnNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SpawnNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TeleportAbsoluteRequest::ID:
        {
            //TeleportAbsoluteRequestNML * newmsg = new TeleportAbsoluteRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TeleportAbsoluteRequestNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TeleportAbsoluteResponse::ID:
        {
            //TeleportAbsoluteResponseNML * newmsg = new TeleportAbsoluteResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TeleportAbsoluteResponseNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TeleportAbsolute::ID:
        {
            //TeleportAbsoluteNML * newmsg = new TeleportAbsoluteNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TeleportAbsoluteNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TeleportRelativeRequest::ID:
        {
            //TeleportRelativeRequestNML * newmsg = new TeleportRelativeRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TeleportRelativeRequestNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TeleportRelativeResponse::ID:
        {
            //TeleportRelativeResponseNML * newmsg = new TeleportRelativeResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TeleportRelativeResponseNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TeleportRelative::ID:
        {
            //TeleportRelativeNML * newmsg = new TeleportRelativeNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TeleportRelativeNML(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int turtlesim_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case Color::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Color>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Pose::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Pose>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case KillRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<KillRequest>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case KillResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<KillResponse>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Kill::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Kill>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPenRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPenRequest>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPenResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPenResponse>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPen::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPen>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnRequest>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnResponse>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Spawn::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Spawn>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportAbsoluteRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportAbsoluteRequest>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportAbsoluteResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportAbsoluteResponse>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportAbsolute::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportAbsolute>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportRelativeRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportRelativeRequest>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportRelativeResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportRelativeResponse>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportRelative::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportRelative>(),std::bind(&turtlesim_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int turtlesim_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int turtlesim_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case Color::ID:
            {
                ColorNML * tempmsg = static_cast<ColorNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Pose::ID:
            {
                PoseNML * tempmsg = static_cast<PoseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case KillRequest::ID:
            {
                KillRequestNML * tempmsg = static_cast<KillRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case KillResponse::ID:
            {
                KillResponseNML * tempmsg = static_cast<KillResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Kill::ID:
            {
                KillNML * tempmsg = static_cast<KillNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetPenRequest::ID:
            {
                SetPenRequestNML * tempmsg = static_cast<SetPenRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetPenResponse::ID:
            {
                SetPenResponseNML * tempmsg = static_cast<SetPenResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetPen::ID:
            {
                SetPenNML * tempmsg = static_cast<SetPenNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SpawnRequest::ID:
            {
                SpawnRequestNML * tempmsg = static_cast<SpawnRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SpawnResponse::ID:
            {
                SpawnResponseNML * tempmsg = static_cast<SpawnResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Spawn::ID:
            {
                SpawnNML * tempmsg = static_cast<SpawnNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TeleportAbsoluteRequest::ID:
            {
                TeleportAbsoluteRequestNML * tempmsg = static_cast<TeleportAbsoluteRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TeleportAbsoluteResponse::ID:
            {
                TeleportAbsoluteResponseNML * tempmsg = static_cast<TeleportAbsoluteResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TeleportAbsolute::ID:
            {
                TeleportAbsoluteNML * tempmsg = static_cast<TeleportAbsoluteNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TeleportRelativeRequest::ID:
            {
                TeleportRelativeRequestNML * tempmsg = static_cast<TeleportRelativeRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TeleportRelativeResponse::ID:
            {
                TeleportRelativeResponseNML * tempmsg = static_cast<TeleportRelativeResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TeleportRelative::ID:
            {
                TeleportRelativeNML * tempmsg = static_cast<TeleportRelativeNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int turtlesim_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case Color::ID:
            {
                ColorNML & tempDst = static_cast<ColorNML&>(dst);
                Message<Color > & tempSrc = static_cast<Message<Color>&>(src);

                if (tempSrc.version() != Color::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Color: " << __FILE__ << " expected: " 
                             << Color::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Color: " << __FILE__ << " expected: " 
                         << Color::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Pose::ID:
            {
                PoseNML & tempDst = static_cast<PoseNML&>(dst);
                Message<Pose > & tempSrc = static_cast<Message<Pose>&>(src);

                if (tempSrc.version() != Pose::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Pose: " << __FILE__ << " expected: " 
                             << Pose::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Pose: " << __FILE__ << " expected: " 
                         << Pose::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case KillRequest::ID:
            {
                KillRequestNML & tempDst = static_cast<KillRequestNML&>(dst);
                Message<KillRequest > & tempSrc = static_cast<Message<KillRequest>&>(src);

                if (tempSrc.version() != KillRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of KillRequest: " << __FILE__ << " expected: " 
                             << KillRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of KillRequest: " << __FILE__ << " expected: " 
                         << KillRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case KillResponse::ID:
            {
                KillResponseNML & tempDst = static_cast<KillResponseNML&>(dst);
                Message<KillResponse > & tempSrc = static_cast<Message<KillResponse>&>(src);

                if (tempSrc.version() != KillResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of KillResponse: " << __FILE__ << " expected: " 
                             << KillResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of KillResponse: " << __FILE__ << " expected: " 
                         << KillResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Kill::ID:
            {
                KillNML & tempDst = static_cast<KillNML&>(dst);
                Message<Kill > & tempSrc = static_cast<Message<Kill>&>(src);

                if (tempSrc.version() != Kill::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Kill: " << __FILE__ << " expected: " 
                             << Kill::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Kill: " << __FILE__ << " expected: " 
                         << Kill::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetPenRequest::ID:
            {
                SetPenRequestNML & tempDst = static_cast<SetPenRequestNML&>(dst);
                Message<SetPenRequest > & tempSrc = static_cast<Message<SetPenRequest>&>(src);

                if (tempSrc.version() != SetPenRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetPenRequest: " << __FILE__ << " expected: " 
                             << SetPenRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetPenRequest: " << __FILE__ << " expected: " 
                         << SetPenRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetPenResponse::ID:
            {
                SetPenResponseNML & tempDst = static_cast<SetPenResponseNML&>(dst);
                Message<SetPenResponse > & tempSrc = static_cast<Message<SetPenResponse>&>(src);

                if (tempSrc.version() != SetPenResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetPenResponse: " << __FILE__ << " expected: " 
                             << SetPenResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetPenResponse: " << __FILE__ << " expected: " 
                         << SetPenResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetPen::ID:
            {
                SetPenNML & tempDst = static_cast<SetPenNML&>(dst);
                Message<SetPen > & tempSrc = static_cast<Message<SetPen>&>(src);

                if (tempSrc.version() != SetPen::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetPen: " << __FILE__ << " expected: " 
                             << SetPen::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetPen: " << __FILE__ << " expected: " 
                         << SetPen::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SpawnRequest::ID:
            {
                SpawnRequestNML & tempDst = static_cast<SpawnRequestNML&>(dst);
                Message<SpawnRequest > & tempSrc = static_cast<Message<SpawnRequest>&>(src);

                if (tempSrc.version() != SpawnRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SpawnRequest: " << __FILE__ << " expected: " 
                             << SpawnRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SpawnRequest: " << __FILE__ << " expected: " 
                         << SpawnRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SpawnResponse::ID:
            {
                SpawnResponseNML & tempDst = static_cast<SpawnResponseNML&>(dst);
                Message<SpawnResponse > & tempSrc = static_cast<Message<SpawnResponse>&>(src);

                if (tempSrc.version() != SpawnResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SpawnResponse: " << __FILE__ << " expected: " 
                             << SpawnResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SpawnResponse: " << __FILE__ << " expected: " 
                         << SpawnResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Spawn::ID:
            {
                SpawnNML & tempDst = static_cast<SpawnNML&>(dst);
                Message<Spawn > & tempSrc = static_cast<Message<Spawn>&>(src);

                if (tempSrc.version() != Spawn::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Spawn: " << __FILE__ << " expected: " 
                             << Spawn::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Spawn: " << __FILE__ << " expected: " 
                         << Spawn::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TeleportAbsoluteRequest::ID:
            {
                TeleportAbsoluteRequestNML & tempDst = static_cast<TeleportAbsoluteRequestNML&>(dst);
                Message<TeleportAbsoluteRequest > & tempSrc = static_cast<Message<TeleportAbsoluteRequest>&>(src);

                if (tempSrc.version() != TeleportAbsoluteRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TeleportAbsoluteRequest: " << __FILE__ << " expected: " 
                             << TeleportAbsoluteRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TeleportAbsoluteRequest: " << __FILE__ << " expected: " 
                         << TeleportAbsoluteRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TeleportAbsoluteResponse::ID:
            {
                TeleportAbsoluteResponseNML & tempDst = static_cast<TeleportAbsoluteResponseNML&>(dst);
                Message<TeleportAbsoluteResponse > & tempSrc = static_cast<Message<TeleportAbsoluteResponse>&>(src);

                if (tempSrc.version() != TeleportAbsoluteResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TeleportAbsoluteResponse: " << __FILE__ << " expected: " 
                             << TeleportAbsoluteResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TeleportAbsoluteResponse: " << __FILE__ << " expected: " 
                         << TeleportAbsoluteResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TeleportAbsolute::ID:
            {
                TeleportAbsoluteNML & tempDst = static_cast<TeleportAbsoluteNML&>(dst);
                Message<TeleportAbsolute > & tempSrc = static_cast<Message<TeleportAbsolute>&>(src);

                if (tempSrc.version() != TeleportAbsolute::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TeleportAbsolute: " << __FILE__ << " expected: " 
                             << TeleportAbsolute::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TeleportAbsolute: " << __FILE__ << " expected: " 
                         << TeleportAbsolute::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TeleportRelativeRequest::ID:
            {
                TeleportRelativeRequestNML & tempDst = static_cast<TeleportRelativeRequestNML&>(dst);
                Message<TeleportRelativeRequest > & tempSrc = static_cast<Message<TeleportRelativeRequest>&>(src);

                if (tempSrc.version() != TeleportRelativeRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TeleportRelativeRequest: " << __FILE__ << " expected: " 
                             << TeleportRelativeRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TeleportRelativeRequest: " << __FILE__ << " expected: " 
                         << TeleportRelativeRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TeleportRelativeResponse::ID:
            {
                TeleportRelativeResponseNML & tempDst = static_cast<TeleportRelativeResponseNML&>(dst);
                Message<TeleportRelativeResponse > & tempSrc = static_cast<Message<TeleportRelativeResponse>&>(src);

                if (tempSrc.version() != TeleportRelativeResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TeleportRelativeResponse: " << __FILE__ << " expected: " 
                             << TeleportRelativeResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TeleportRelativeResponse: " << __FILE__ << " expected: " 
                         << TeleportRelativeResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TeleportRelative::ID:
            {
                TeleportRelativeNML & tempDst = static_cast<TeleportRelativeNML&>(dst);
                Message<TeleportRelative > & tempSrc = static_cast<Message<TeleportRelative>&>(src);

                if (tempSrc.version() != TeleportRelative::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TeleportRelative: " << __FILE__ << " expected: " 
                             << TeleportRelative::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TeleportRelative: " << __FILE__ << " expected: " 
                         << TeleportRelative::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int turtlesim_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case Color::ID:
            {
                ColorNML & tempSrc = static_cast<ColorNML&>(src);
                Message<Color > & tempDst = static_cast<Message<Color>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Color::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Pose::ID:
            {
                PoseNML & tempSrc = static_cast<PoseNML&>(src);
                Message<Pose > & tempDst = static_cast<Message<Pose>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Pose::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case KillRequest::ID:
            {
                KillRequestNML & tempSrc = static_cast<KillRequestNML&>(src);
                Message<KillRequest > & tempDst = static_cast<Message<KillRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (KillRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case KillResponse::ID:
            {
                KillResponseNML & tempSrc = static_cast<KillResponseNML&>(src);
                Message<KillResponse > & tempDst = static_cast<Message<KillResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (KillResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Kill::ID:
            {
                KillNML & tempSrc = static_cast<KillNML&>(src);
                Message<Kill > & tempDst = static_cast<Message<Kill>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Kill::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetPenRequest::ID:
            {
                SetPenRequestNML & tempSrc = static_cast<SetPenRequestNML&>(src);
                Message<SetPenRequest > & tempDst = static_cast<Message<SetPenRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetPenRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetPenResponse::ID:
            {
                SetPenResponseNML & tempSrc = static_cast<SetPenResponseNML&>(src);
                Message<SetPenResponse > & tempDst = static_cast<Message<SetPenResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetPenResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetPen::ID:
            {
                SetPenNML & tempSrc = static_cast<SetPenNML&>(src);
                Message<SetPen > & tempDst = static_cast<Message<SetPen>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetPen::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SpawnRequest::ID:
            {
                SpawnRequestNML & tempSrc = static_cast<SpawnRequestNML&>(src);
                Message<SpawnRequest > & tempDst = static_cast<Message<SpawnRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SpawnRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SpawnResponse::ID:
            {
                SpawnResponseNML & tempSrc = static_cast<SpawnResponseNML&>(src);
                Message<SpawnResponse > & tempDst = static_cast<Message<SpawnResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SpawnResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Spawn::ID:
            {
                SpawnNML & tempSrc = static_cast<SpawnNML&>(src);
                Message<Spawn > & tempDst = static_cast<Message<Spawn>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Spawn::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TeleportAbsoluteRequest::ID:
            {
                TeleportAbsoluteRequestNML & tempSrc = static_cast<TeleportAbsoluteRequestNML&>(src);
                Message<TeleportAbsoluteRequest > & tempDst = static_cast<Message<TeleportAbsoluteRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TeleportAbsoluteRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TeleportAbsoluteResponse::ID:
            {
                TeleportAbsoluteResponseNML & tempSrc = static_cast<TeleportAbsoluteResponseNML&>(src);
                Message<TeleportAbsoluteResponse > & tempDst = static_cast<Message<TeleportAbsoluteResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TeleportAbsoluteResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TeleportAbsolute::ID:
            {
                TeleportAbsoluteNML & tempSrc = static_cast<TeleportAbsoluteNML&>(src);
                Message<TeleportAbsolute > & tempDst = static_cast<Message<TeleportAbsolute>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TeleportAbsolute::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TeleportRelativeRequest::ID:
            {
                TeleportRelativeRequestNML & tempSrc = static_cast<TeleportRelativeRequestNML&>(src);
                Message<TeleportRelativeRequest > & tempDst = static_cast<Message<TeleportRelativeRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TeleportRelativeRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TeleportRelativeResponse::ID:
            {
                TeleportRelativeResponseNML & tempSrc = static_cast<TeleportRelativeResponseNML&>(src);
                Message<TeleportRelativeResponse > & tempDst = static_cast<Message<TeleportRelativeResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TeleportRelativeResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TeleportRelative::ID:
            {
                TeleportRelativeNML & tempSrc = static_cast<TeleportRelativeNML&>(src);
                Message<TeleportRelative > & tempDst = static_cast<Message<TeleportRelative>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TeleportRelative::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int turtlesim_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case Color::ID:
        {
            // only need to construct if data type is not flat
            if (Color::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Color at %p\n",buffer);
                ColorNML * p = static_cast<ColorNML*>(buffer);
                // construct the type at pointer p
                new (p) ColorNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Color at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Pose::ID:
        {
            // only need to construct if data type is not flat
            if (Pose::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Pose at %p\n",buffer);
                PoseNML * p = static_cast<PoseNML*>(buffer);
                // construct the type at pointer p
                new (p) PoseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Pose at %p,, is flat\n",buffer);
            }
            break;
        } 
        case KillRequest::ID:
        {
            // only need to construct if data type is not flat
            if (KillRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing KillRequest at %p\n",buffer);
                KillRequestNML * p = static_cast<KillRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) KillRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing KillRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case KillResponse::ID:
        {
            // only need to construct if data type is not flat
            if (KillResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing KillResponse at %p\n",buffer);
                KillResponseNML * p = static_cast<KillResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) KillResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing KillResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Kill::ID:
        {
            // only need to construct if data type is not flat
            if (Kill::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Kill at %p\n",buffer);
                KillNML * p = static_cast<KillNML*>(buffer);
                // construct the type at pointer p
                new (p) KillNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Kill at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetPenRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetPenRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetPenRequest at %p\n",buffer);
                SetPenRequestNML * p = static_cast<SetPenRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetPenRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetPenRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetPenResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetPenResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetPenResponse at %p\n",buffer);
                SetPenResponseNML * p = static_cast<SetPenResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetPenResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetPenResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetPen::ID:
        {
            // only need to construct if data type is not flat
            if (SetPen::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetPen at %p\n",buffer);
                SetPenNML * p = static_cast<SetPenNML*>(buffer);
                // construct the type at pointer p
                new (p) SetPenNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetPen at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SpawnRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SpawnRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SpawnRequest at %p\n",buffer);
                SpawnRequestNML * p = static_cast<SpawnRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SpawnRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SpawnRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SpawnResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SpawnResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SpawnResponse at %p\n",buffer);
                SpawnResponseNML * p = static_cast<SpawnResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SpawnResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SpawnResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Spawn::ID:
        {
            // only need to construct if data type is not flat
            if (Spawn::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Spawn at %p\n",buffer);
                SpawnNML * p = static_cast<SpawnNML*>(buffer);
                // construct the type at pointer p
                new (p) SpawnNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Spawn at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TeleportAbsoluteRequest::ID:
        {
            // only need to construct if data type is not flat
            if (TeleportAbsoluteRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TeleportAbsoluteRequest at %p\n",buffer);
                TeleportAbsoluteRequestNML * p = static_cast<TeleportAbsoluteRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) TeleportAbsoluteRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TeleportAbsoluteRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TeleportAbsoluteResponse::ID:
        {
            // only need to construct if data type is not flat
            if (TeleportAbsoluteResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TeleportAbsoluteResponse at %p\n",buffer);
                TeleportAbsoluteResponseNML * p = static_cast<TeleportAbsoluteResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) TeleportAbsoluteResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TeleportAbsoluteResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TeleportAbsolute::ID:
        {
            // only need to construct if data type is not flat
            if (TeleportAbsolute::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TeleportAbsolute at %p\n",buffer);
                TeleportAbsoluteNML * p = static_cast<TeleportAbsoluteNML*>(buffer);
                // construct the type at pointer p
                new (p) TeleportAbsoluteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TeleportAbsolute at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TeleportRelativeRequest::ID:
        {
            // only need to construct if data type is not flat
            if (TeleportRelativeRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TeleportRelativeRequest at %p\n",buffer);
                TeleportRelativeRequestNML * p = static_cast<TeleportRelativeRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) TeleportRelativeRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TeleportRelativeRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TeleportRelativeResponse::ID:
        {
            // only need to construct if data type is not flat
            if (TeleportRelativeResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TeleportRelativeResponse at %p\n",buffer);
                TeleportRelativeResponseNML * p = static_cast<TeleportRelativeResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) TeleportRelativeResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TeleportRelativeResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TeleportRelative::ID:
        {
            // only need to construct if data type is not flat
            if (TeleportRelative::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TeleportRelative at %p\n",buffer);
                TeleportRelativeNML * p = static_cast<TeleportRelativeNML*>(buffer);
                // construct the type at pointer p
                new (p) TeleportRelativeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TeleportRelative at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int turtlesim_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case Color::ID:
        {
            // only need to destruct if data type is not flat
            if (Color::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Color at %p\n",buffer);
                ColorNML * p = static_cast<ColorNML*>(buffer);
                p->~ColorNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Color at %p, is flat\n",buffer);
            }
            break;
        } 
        case Pose::ID:
        {
            // only need to destruct if data type is not flat
            if (Pose::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Pose at %p\n",buffer);
                PoseNML * p = static_cast<PoseNML*>(buffer);
                p->~PoseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Pose at %p, is flat\n",buffer);
            }
            break;
        } 
        case KillRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (KillRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing KillRequest at %p\n",buffer);
                KillRequestNML * p = static_cast<KillRequestNML*>(buffer);
                p->~KillRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction KillRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case KillResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (KillResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing KillResponse at %p\n",buffer);
                KillResponseNML * p = static_cast<KillResponseNML*>(buffer);
                p->~KillResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction KillResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case Kill::ID:
        {
            // only need to destruct if data type is not flat
            if (Kill::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Kill at %p\n",buffer);
                KillNML * p = static_cast<KillNML*>(buffer);
                p->~KillNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Kill at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetPenRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetPenRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetPenRequest at %p\n",buffer);
                SetPenRequestNML * p = static_cast<SetPenRequestNML*>(buffer);
                p->~SetPenRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetPenRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetPenResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetPenResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetPenResponse at %p\n",buffer);
                SetPenResponseNML * p = static_cast<SetPenResponseNML*>(buffer);
                p->~SetPenResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetPenResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetPen::ID:
        {
            // only need to destruct if data type is not flat
            if (SetPen::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetPen at %p\n",buffer);
                SetPenNML * p = static_cast<SetPenNML*>(buffer);
                p->~SetPenNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetPen at %p, is flat\n",buffer);
            }
            break;
        } 
        case SpawnRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SpawnRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SpawnRequest at %p\n",buffer);
                SpawnRequestNML * p = static_cast<SpawnRequestNML*>(buffer);
                p->~SpawnRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SpawnRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SpawnResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SpawnResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SpawnResponse at %p\n",buffer);
                SpawnResponseNML * p = static_cast<SpawnResponseNML*>(buffer);
                p->~SpawnResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SpawnResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case Spawn::ID:
        {
            // only need to destruct if data type is not flat
            if (Spawn::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Spawn at %p\n",buffer);
                SpawnNML * p = static_cast<SpawnNML*>(buffer);
                p->~SpawnNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Spawn at %p, is flat\n",buffer);
            }
            break;
        } 
        case TeleportAbsoluteRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (TeleportAbsoluteRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TeleportAbsoluteRequest at %p\n",buffer);
                TeleportAbsoluteRequestNML * p = static_cast<TeleportAbsoluteRequestNML*>(buffer);
                p->~TeleportAbsoluteRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TeleportAbsoluteRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case TeleportAbsoluteResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (TeleportAbsoluteResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TeleportAbsoluteResponse at %p\n",buffer);
                TeleportAbsoluteResponseNML * p = static_cast<TeleportAbsoluteResponseNML*>(buffer);
                p->~TeleportAbsoluteResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TeleportAbsoluteResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case TeleportAbsolute::ID:
        {
            // only need to destruct if data type is not flat
            if (TeleportAbsolute::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TeleportAbsolute at %p\n",buffer);
                TeleportAbsoluteNML * p = static_cast<TeleportAbsoluteNML*>(buffer);
                p->~TeleportAbsoluteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TeleportAbsolute at %p, is flat\n",buffer);
            }
            break;
        } 
        case TeleportRelativeRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (TeleportRelativeRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TeleportRelativeRequest at %p\n",buffer);
                TeleportRelativeRequestNML * p = static_cast<TeleportRelativeRequestNML*>(buffer);
                p->~TeleportRelativeRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TeleportRelativeRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case TeleportRelativeResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (TeleportRelativeResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TeleportRelativeResponse at %p\n",buffer);
                TeleportRelativeResponseNML * p = static_cast<TeleportRelativeResponseNML*>(buffer);
                p->~TeleportRelativeResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TeleportRelativeResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case TeleportRelative::ID:
        {
            // only need to destruct if data type is not flat
            if (TeleportRelative::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TeleportRelative at %p\n",buffer);
                TeleportRelativeNML * p = static_cast<TeleportRelativeNML*>(buffer);
                p->~TeleportRelativeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TeleportRelative at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void turtlesim::nmlupdate(CMS * cms, Color & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Color, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.r);
        cms->update(inobj.g);
        cms->update(inobj.b);

    }  
 }

ColorNML::ColorNML() : NMLmsg((NMLTYPE)Color::ID,sizeof(ColorNML)), nmlVersion(Color::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Color()*/)
{
};

ColorNML::~ColorNML()
{
};

ColorNML & ColorNML::operator=(const ColorNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ColorNML & ColorNML::operator=(const Color & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Color);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ColorNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Color&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ColorNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Color> temp(new Color());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Color::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Color Message version mismatch, expected " << Color::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Color Message version mismatch, expected " << Color::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, Pose & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Pose, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.theta);
        cms->update(inobj.linear_velocity);
        cms->update(inobj.angular_velocity);

    }  
 }

PoseNML::PoseNML() : NMLmsg((NMLTYPE)Pose::ID,sizeof(PoseNML)), nmlVersion(Pose::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Pose()*/)
{
};

PoseNML::~PoseNML()
{
};

PoseNML & PoseNML::operator=(const PoseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PoseNML & PoseNML::operator=(const Pose & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Pose);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PoseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Pose&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PoseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Pose> temp(new Pose());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Pose::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Pose Message version mismatch, expected " << Pose::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Pose Message version mismatch, expected " << Pose::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, KillRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate KillRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);

    }  
 }

KillRequestNML::KillRequestNML() : NMLmsg((NMLTYPE)KillRequest::ID,sizeof(KillRequestNML)), nmlVersion(KillRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new KillRequest()*/)
{
};

KillRequestNML::~KillRequestNML()
{
};

KillRequestNML & KillRequestNML::operator=(const KillRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

KillRequestNML & KillRequestNML::operator=(const KillRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(KillRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void KillRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<KillRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: KillRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<KillRequest> temp(new KillRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (KillRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: KillRequest Message version mismatch, expected " << KillRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: KillRequest Message version mismatch, expected " << KillRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, KillResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate KillResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

KillResponseNML::KillResponseNML() : NMLmsg((NMLTYPE)KillResponse::ID,sizeof(KillResponseNML)), nmlVersion(KillResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new KillResponse()*/)
{
};

KillResponseNML::~KillResponseNML()
{
};

KillResponseNML & KillResponseNML::operator=(const KillResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

KillResponseNML & KillResponseNML::operator=(const KillResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(KillResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void KillResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<KillResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: KillResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<KillResponse> temp(new KillResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (KillResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: KillResponse Message version mismatch, expected " << KillResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: KillResponse Message version mismatch, expected " << KillResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, Kill & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Kill, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

KillNML::KillNML() : NMLmsg((NMLTYPE)Kill::ID,sizeof(KillNML)), nmlVersion(Kill::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Kill()*/)
{
};

KillNML::~KillNML()
{
};

KillNML & KillNML::operator=(const KillNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

KillNML & KillNML::operator=(const Kill & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Kill);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void KillNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Kill&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: KillNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Kill> temp(new Kill());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Kill::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Kill Message version mismatch, expected " << Kill::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Kill Message version mismatch, expected " << Kill::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, SetPenRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetPenRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.r);
        cms->update(inobj.g);
        cms->update(inobj.b);
        cms->update(inobj.width);
        cms->update(inobj.off);

    }  
 }

SetPenRequestNML::SetPenRequestNML() : NMLmsg((NMLTYPE)SetPenRequest::ID,sizeof(SetPenRequestNML)), nmlVersion(SetPenRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetPenRequest()*/)
{
};

SetPenRequestNML::~SetPenRequestNML()
{
};

SetPenRequestNML & SetPenRequestNML::operator=(const SetPenRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetPenRequestNML & SetPenRequestNML::operator=(const SetPenRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetPenRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetPenRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetPenRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetPenRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetPenRequest> temp(new SetPenRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetPenRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetPenRequest Message version mismatch, expected " << SetPenRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetPenRequest Message version mismatch, expected " << SetPenRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, SetPenResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetPenResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

SetPenResponseNML::SetPenResponseNML() : NMLmsg((NMLTYPE)SetPenResponse::ID,sizeof(SetPenResponseNML)), nmlVersion(SetPenResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetPenResponse()*/)
{
};

SetPenResponseNML::~SetPenResponseNML()
{
};

SetPenResponseNML & SetPenResponseNML::operator=(const SetPenResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetPenResponseNML & SetPenResponseNML::operator=(const SetPenResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetPenResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetPenResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetPenResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetPenResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetPenResponse> temp(new SetPenResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetPenResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetPenResponse Message version mismatch, expected " << SetPenResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetPenResponse Message version mismatch, expected " << SetPenResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, SetPen & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetPen, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetPenNML::SetPenNML() : NMLmsg((NMLTYPE)SetPen::ID,sizeof(SetPenNML)), nmlVersion(SetPen::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetPen()*/)
{
};

SetPenNML::~SetPenNML()
{
};

SetPenNML & SetPenNML::operator=(const SetPenNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetPenNML & SetPenNML::operator=(const SetPen & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetPen);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetPenNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetPen&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetPenNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetPen> temp(new SetPen());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetPen::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetPen Message version mismatch, expected " << SetPen::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetPen Message version mismatch, expected " << SetPen::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, SpawnRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SpawnRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.theta);
        nmlupdate(cms,inobj.name);

    }  
 }

SpawnRequestNML::SpawnRequestNML() : NMLmsg((NMLTYPE)SpawnRequest::ID,sizeof(SpawnRequestNML)), nmlVersion(SpawnRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SpawnRequest()*/)
{
};

SpawnRequestNML::~SpawnRequestNML()
{
};

SpawnRequestNML & SpawnRequestNML::operator=(const SpawnRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SpawnRequestNML & SpawnRequestNML::operator=(const SpawnRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SpawnRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SpawnRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SpawnRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SpawnRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SpawnRequest> temp(new SpawnRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SpawnRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SpawnRequest Message version mismatch, expected " << SpawnRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SpawnRequest Message version mismatch, expected " << SpawnRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, SpawnResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SpawnResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);

    }  
 }

SpawnResponseNML::SpawnResponseNML() : NMLmsg((NMLTYPE)SpawnResponse::ID,sizeof(SpawnResponseNML)), nmlVersion(SpawnResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SpawnResponse()*/)
{
};

SpawnResponseNML::~SpawnResponseNML()
{
};

SpawnResponseNML & SpawnResponseNML::operator=(const SpawnResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SpawnResponseNML & SpawnResponseNML::operator=(const SpawnResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SpawnResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SpawnResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SpawnResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SpawnResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SpawnResponse> temp(new SpawnResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SpawnResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SpawnResponse Message version mismatch, expected " << SpawnResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SpawnResponse Message version mismatch, expected " << SpawnResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, Spawn & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Spawn, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SpawnNML::SpawnNML() : NMLmsg((NMLTYPE)Spawn::ID,sizeof(SpawnNML)), nmlVersion(Spawn::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Spawn()*/)
{
};

SpawnNML::~SpawnNML()
{
};

SpawnNML & SpawnNML::operator=(const SpawnNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SpawnNML & SpawnNML::operator=(const Spawn & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Spawn);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SpawnNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Spawn&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SpawnNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Spawn> temp(new Spawn());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Spawn::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Spawn Message version mismatch, expected " << Spawn::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Spawn Message version mismatch, expected " << Spawn::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, TeleportAbsoluteRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TeleportAbsoluteRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.theta);

    }  
 }

TeleportAbsoluteRequestNML::TeleportAbsoluteRequestNML() : NMLmsg((NMLTYPE)TeleportAbsoluteRequest::ID,sizeof(TeleportAbsoluteRequestNML)), nmlVersion(TeleportAbsoluteRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TeleportAbsoluteRequest()*/)
{
};

TeleportAbsoluteRequestNML::~TeleportAbsoluteRequestNML()
{
};

TeleportAbsoluteRequestNML & TeleportAbsoluteRequestNML::operator=(const TeleportAbsoluteRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TeleportAbsoluteRequestNML & TeleportAbsoluteRequestNML::operator=(const TeleportAbsoluteRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TeleportAbsoluteRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TeleportAbsoluteRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TeleportAbsoluteRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TeleportAbsoluteRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TeleportAbsoluteRequest> temp(new TeleportAbsoluteRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TeleportAbsoluteRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TeleportAbsoluteRequest Message version mismatch, expected " << TeleportAbsoluteRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TeleportAbsoluteRequest Message version mismatch, expected " << TeleportAbsoluteRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, TeleportAbsoluteResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TeleportAbsoluteResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

TeleportAbsoluteResponseNML::TeleportAbsoluteResponseNML() : NMLmsg((NMLTYPE)TeleportAbsoluteResponse::ID,sizeof(TeleportAbsoluteResponseNML)), nmlVersion(TeleportAbsoluteResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TeleportAbsoluteResponse()*/)
{
};

TeleportAbsoluteResponseNML::~TeleportAbsoluteResponseNML()
{
};

TeleportAbsoluteResponseNML & TeleportAbsoluteResponseNML::operator=(const TeleportAbsoluteResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TeleportAbsoluteResponseNML & TeleportAbsoluteResponseNML::operator=(const TeleportAbsoluteResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TeleportAbsoluteResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TeleportAbsoluteResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TeleportAbsoluteResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TeleportAbsoluteResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TeleportAbsoluteResponse> temp(new TeleportAbsoluteResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TeleportAbsoluteResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TeleportAbsoluteResponse Message version mismatch, expected " << TeleportAbsoluteResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TeleportAbsoluteResponse Message version mismatch, expected " << TeleportAbsoluteResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, TeleportAbsolute & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TeleportAbsolute, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

TeleportAbsoluteNML::TeleportAbsoluteNML() : NMLmsg((NMLTYPE)TeleportAbsolute::ID,sizeof(TeleportAbsoluteNML)), nmlVersion(TeleportAbsolute::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TeleportAbsolute()*/)
{
};

TeleportAbsoluteNML::~TeleportAbsoluteNML()
{
};

TeleportAbsoluteNML & TeleportAbsoluteNML::operator=(const TeleportAbsoluteNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TeleportAbsoluteNML & TeleportAbsoluteNML::operator=(const TeleportAbsolute & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TeleportAbsolute);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TeleportAbsoluteNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TeleportAbsolute&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TeleportAbsoluteNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TeleportAbsolute> temp(new TeleportAbsolute());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TeleportAbsolute::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TeleportAbsolute Message version mismatch, expected " << TeleportAbsolute::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TeleportAbsolute Message version mismatch, expected " << TeleportAbsolute::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, TeleportRelativeRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TeleportRelativeRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.linear);
        cms->update(inobj.angular);

    }  
 }

TeleportRelativeRequestNML::TeleportRelativeRequestNML() : NMLmsg((NMLTYPE)TeleportRelativeRequest::ID,sizeof(TeleportRelativeRequestNML)), nmlVersion(TeleportRelativeRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TeleportRelativeRequest()*/)
{
};

TeleportRelativeRequestNML::~TeleportRelativeRequestNML()
{
};

TeleportRelativeRequestNML & TeleportRelativeRequestNML::operator=(const TeleportRelativeRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TeleportRelativeRequestNML & TeleportRelativeRequestNML::operator=(const TeleportRelativeRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TeleportRelativeRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TeleportRelativeRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TeleportRelativeRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TeleportRelativeRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TeleportRelativeRequest> temp(new TeleportRelativeRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TeleportRelativeRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TeleportRelativeRequest Message version mismatch, expected " << TeleportRelativeRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TeleportRelativeRequest Message version mismatch, expected " << TeleportRelativeRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, TeleportRelativeResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TeleportRelativeResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

TeleportRelativeResponseNML::TeleportRelativeResponseNML() : NMLmsg((NMLTYPE)TeleportRelativeResponse::ID,sizeof(TeleportRelativeResponseNML)), nmlVersion(TeleportRelativeResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TeleportRelativeResponse()*/)
{
};

TeleportRelativeResponseNML::~TeleportRelativeResponseNML()
{
};

TeleportRelativeResponseNML & TeleportRelativeResponseNML::operator=(const TeleportRelativeResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TeleportRelativeResponseNML & TeleportRelativeResponseNML::operator=(const TeleportRelativeResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TeleportRelativeResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TeleportRelativeResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TeleportRelativeResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TeleportRelativeResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TeleportRelativeResponse> temp(new TeleportRelativeResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TeleportRelativeResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TeleportRelativeResponse Message version mismatch, expected " << TeleportRelativeResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TeleportRelativeResponse Message version mismatch, expected " << TeleportRelativeResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtlesim::nmlupdate(CMS * cms, TeleportRelative & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TeleportRelative, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

TeleportRelativeNML::TeleportRelativeNML() : NMLmsg((NMLTYPE)TeleportRelative::ID,sizeof(TeleportRelativeNML)), nmlVersion(TeleportRelative::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TeleportRelative()*/)
{
};

TeleportRelativeNML::~TeleportRelativeNML()
{
};

TeleportRelativeNML & TeleportRelativeNML::operator=(const TeleportRelativeNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TeleportRelativeNML & TeleportRelativeNML::operator=(const TeleportRelative & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TeleportRelative);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TeleportRelativeNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TeleportRelative&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TeleportRelativeNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TeleportRelative> temp(new TeleportRelative());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtlesim_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TeleportRelative::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TeleportRelative Message version mismatch, expected " << TeleportRelative::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TeleportRelative Message version mismatch, expected " << TeleportRelative::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int turtlesim::turtlesim_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("turtlesim_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case Color::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Color, id " << Color::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ColorNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Pose::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Pose, id " << Pose::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PoseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case KillRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for KillRequest, id " << KillRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((KillRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case KillResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for KillResponse, id " << KillResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((KillResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Kill::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Kill, id " << Kill::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((KillNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetPenRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetPenRequest, id " << SetPenRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetPenRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetPenResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetPenResponse, id " << SetPenResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetPenResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetPen::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetPen, id " << SetPen::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetPenNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SpawnRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SpawnRequest, id " << SpawnRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SpawnRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SpawnResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SpawnResponse, id " << SpawnResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SpawnResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Spawn::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Spawn, id " << Spawn::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SpawnNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TeleportAbsoluteRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TeleportAbsoluteRequest, id " << TeleportAbsoluteRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TeleportAbsoluteRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TeleportAbsoluteResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TeleportAbsoluteResponse, id " << TeleportAbsoluteResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TeleportAbsoluteResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TeleportAbsolute::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TeleportAbsolute, id " << TeleportAbsolute::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TeleportAbsoluteNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TeleportRelativeRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TeleportRelativeRequest, id " << TeleportRelativeRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TeleportRelativeRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TeleportRelativeResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TeleportRelativeResponse, id " << TeleportRelativeResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TeleportRelativeResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TeleportRelative::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TeleportRelative, id " << TeleportRelative::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtlesim_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtlesim_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TeleportRelativeNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

