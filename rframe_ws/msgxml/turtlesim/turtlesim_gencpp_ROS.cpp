// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:09 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "turtlesim_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace turtlesim;

rframe::ROSMessageFactory * ROS_turtlesim_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_turtlesim_gencppfactory = new turtlesim_gencppROSMessageFactory();

        return ROS_turtlesim_gencppfactory;
    };
}

rframe::ROSMessageFactory * turtlesim::allocate_turtlesim_gencpp()
{
    ROS_turtlesim_gencppfactory = new turtlesim_gencppROSMessageFactory();
    return ROS_turtlesim_gencppfactory;
};

turtlesim_gencppROSMessageFactory::turtlesim_gencppROSMessageFactory()
{
    name("turtlesim_gencpp");
    // use constructor to register data types
    turtlesim::registerLibrary();
}

turtlesim_gencppROSMessageFactory::~turtlesim_gencppROSMessageFactory()
{
}

int turtlesim_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void turtlesim_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(Color::ID);
    info.name(Color::DATA_TYPE_FULL_NAME);
    info.hashKey(Color::DATA_VERSION);
    info.md5Key(Color::VERSION_MD5);
    info.xmlSource(Color::XML_SOURCE);
    info.flat(Color::dataTypeFlat());
    ids.push_back(info);

    info.id(Pose::ID);
    info.name(Pose::DATA_TYPE_FULL_NAME);
    info.hashKey(Pose::DATA_VERSION);
    info.md5Key(Pose::VERSION_MD5);
    info.xmlSource(Pose::XML_SOURCE);
    info.flat(Pose::dataTypeFlat());
    ids.push_back(info);

    info.id(KillRequest::ID);
    info.name(KillRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(KillRequest::DATA_VERSION);
    info.md5Key(KillRequest::VERSION_MD5);
    info.xmlSource(KillRequest::XML_SOURCE);
    info.flat(KillRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(KillResponse::ID);
    info.name(KillResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(KillResponse::DATA_VERSION);
    info.md5Key(KillResponse::VERSION_MD5);
    info.xmlSource(KillResponse::XML_SOURCE);
    info.flat(KillResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(Kill::ID);
    info.name(Kill::DATA_TYPE_FULL_NAME);
    info.hashKey(Kill::DATA_VERSION);
    info.md5Key(Kill::VERSION_MD5);
    info.xmlSource(Kill::XML_SOURCE);
    info.flat(Kill::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPenRequest::ID);
    info.name(SetPenRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPenRequest::DATA_VERSION);
    info.md5Key(SetPenRequest::VERSION_MD5);
    info.xmlSource(SetPenRequest::XML_SOURCE);
    info.flat(SetPenRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPenResponse::ID);
    info.name(SetPenResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPenResponse::DATA_VERSION);
    info.md5Key(SetPenResponse::VERSION_MD5);
    info.xmlSource(SetPenResponse::XML_SOURCE);
    info.flat(SetPenResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPen::ID);
    info.name(SetPen::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPen::DATA_VERSION);
    info.md5Key(SetPen::VERSION_MD5);
    info.xmlSource(SetPen::XML_SOURCE);
    info.flat(SetPen::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnRequest::ID);
    info.name(SpawnRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnRequest::DATA_VERSION);
    info.md5Key(SpawnRequest::VERSION_MD5);
    info.xmlSource(SpawnRequest::XML_SOURCE);
    info.flat(SpawnRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnResponse::ID);
    info.name(SpawnResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnResponse::DATA_VERSION);
    info.md5Key(SpawnResponse::VERSION_MD5);
    info.xmlSource(SpawnResponse::XML_SOURCE);
    info.flat(SpawnResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(Spawn::ID);
    info.name(Spawn::DATA_TYPE_FULL_NAME);
    info.hashKey(Spawn::DATA_VERSION);
    info.md5Key(Spawn::VERSION_MD5);
    info.xmlSource(Spawn::XML_SOURCE);
    info.flat(Spawn::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportAbsoluteRequest::ID);
    info.name(TeleportAbsoluteRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportAbsoluteRequest::DATA_VERSION);
    info.md5Key(TeleportAbsoluteRequest::VERSION_MD5);
    info.xmlSource(TeleportAbsoluteRequest::XML_SOURCE);
    info.flat(TeleportAbsoluteRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportAbsoluteResponse::ID);
    info.name(TeleportAbsoluteResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportAbsoluteResponse::DATA_VERSION);
    info.md5Key(TeleportAbsoluteResponse::VERSION_MD5);
    info.xmlSource(TeleportAbsoluteResponse::XML_SOURCE);
    info.flat(TeleportAbsoluteResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportAbsolute::ID);
    info.name(TeleportAbsolute::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportAbsolute::DATA_VERSION);
    info.md5Key(TeleportAbsolute::VERSION_MD5);
    info.xmlSource(TeleportAbsolute::XML_SOURCE);
    info.flat(TeleportAbsolute::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportRelativeRequest::ID);
    info.name(TeleportRelativeRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportRelativeRequest::DATA_VERSION);
    info.md5Key(TeleportRelativeRequest::VERSION_MD5);
    info.xmlSource(TeleportRelativeRequest::XML_SOURCE);
    info.flat(TeleportRelativeRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportRelativeResponse::ID);
    info.name(TeleportRelativeResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportRelativeResponse::DATA_VERSION);
    info.md5Key(TeleportRelativeResponse::VERSION_MD5);
    info.xmlSource(TeleportRelativeResponse::XML_SOURCE);
    info.flat(TeleportRelativeResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(TeleportRelative::ID);
    info.name(TeleportRelative::DATA_TYPE_FULL_NAME);
    info.hashKey(TeleportRelative::DATA_VERSION);
    info.md5Key(TeleportRelative::VERSION_MD5);
    info.xmlSource(TeleportRelative::XML_SOURCE);
    info.flat(TeleportRelative::dataTypeFlat());
    ids.push_back(info);

}

int turtlesim_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Color::ID:
        {
            str = "turtlesim/Color";
            break;
        }
        case Pose::ID:
        {
            str = "turtlesim/Pose";
            break;
        }
        case KillRequest::ID:
        {
            str = "turtlesim/KillRequest";
            break;
        }
        case KillResponse::ID:
        {
            str = "turtlesim/KillResponse";
            break;
        }
        case Kill::ID:
        {
            str = "turtlesim/Kill";
            break;
        }
        case SetPenRequest::ID:
        {
            str = "turtlesim/SetPenRequest";
            break;
        }
        case SetPenResponse::ID:
        {
            str = "turtlesim/SetPenResponse";
            break;
        }
        case SetPen::ID:
        {
            str = "turtlesim/SetPen";
            break;
        }
        case SpawnRequest::ID:
        {
            str = "turtlesim/SpawnRequest";
            break;
        }
        case SpawnResponse::ID:
        {
            str = "turtlesim/SpawnResponse";
            break;
        }
        case Spawn::ID:
        {
            str = "turtlesim/Spawn";
            break;
        }
        case TeleportAbsoluteRequest::ID:
        {
            str = "turtlesim/TeleportAbsoluteRequest";
            break;
        }
        case TeleportAbsoluteResponse::ID:
        {
            str = "turtlesim/TeleportAbsoluteResponse";
            break;
        }
        case TeleportAbsolute::ID:
        {
            str = "turtlesim/TeleportAbsolute";
            break;
        }
        case TeleportRelativeRequest::ID:
        {
            str = "turtlesim/TeleportRelativeRequest";
            break;
        }
        case TeleportRelativeResponse::ID:
        {
            str = "turtlesim/TeleportRelativeResponse";
            break;
        }
        case TeleportRelative::ID:
        {
            str = "turtlesim/TeleportRelative";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Color::ID:
        {
            str = "uint8 r\nuint8 g\nuint8 b\n";
            break;
        }
        case Pose::ID:
        {
            str = "float32 x\nfloat32 y\nfloat32 theta\n\nfloat32 linear_velocity\n";
            break;
        }
        case KillRequest::ID:
        {
            str = KillRequest::XML_SOURCE;
            break;
        }
        case KillResponse::ID:
        {
            str = KillResponse::XML_SOURCE;
            break;
        }
        case Kill::ID:
        {
            str = Kill::XML_SOURCE;
            break;
        }
        case SetPenRequest::ID:
        {
            str = SetPenRequest::XML_SOURCE;
            break;
        }
        case SetPenResponse::ID:
        {
            str = SetPenResponse::XML_SOURCE;
            break;
        }
        case SetPen::ID:
        {
            str = SetPen::XML_SOURCE;
            break;
        }
        case SpawnRequest::ID:
        {
            str = SpawnRequest::XML_SOURCE;
            break;
        }
        case SpawnResponse::ID:
        {
            str = SpawnResponse::XML_SOURCE;
            break;
        }
        case Spawn::ID:
        {
            str = Spawn::XML_SOURCE;
            break;
        }
        case TeleportAbsoluteRequest::ID:
        {
            str = TeleportAbsoluteRequest::XML_SOURCE;
            break;
        }
        case TeleportAbsoluteResponse::ID:
        {
            str = TeleportAbsoluteResponse::XML_SOURCE;
            break;
        }
        case TeleportAbsolute::ID:
        {
            str = TeleportAbsolute::XML_SOURCE;
            break;
        }
        case TeleportRelativeRequest::ID:
        {
            str = TeleportRelativeRequest::XML_SOURCE;
            break;
        }
        case TeleportRelativeResponse::ID:
        {
            str = TeleportRelativeResponse::XML_SOURCE;
            break;
        }
        case TeleportRelative::ID:
        {
            str = TeleportRelative::XML_SOURCE;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Color::ID:
        {
            str = "353891e354491c51aabe32df673fb446";
            break;
        }
        case Pose::ID:
        {
            str = "863b248d5016ca62ea2e895ae5265cf9";
            break;
        }
        case KillRequest::ID:
        {
            str = "c1f3d28f1b044c871e6eff2e9fc3c667";
            break;
        }
        case KillResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case Kill::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetPenRequest::ID:
        {
            str = "9f452acce566bf0c0954594f69a8e41b";
            break;
        }
        case SetPenResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetPen::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SpawnRequest::ID:
        {
            str = "57f001c49ab7b11d699f8606c1f4f7ff";
            break;
        }
        case SpawnResponse::ID:
        {
            str = "c1f3d28f1b044c871e6eff2e9fc3c667";
            break;
        }
        case Spawn::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case TeleportAbsoluteRequest::ID:
        {
            str = "a130bc60ee6513855dc62ea83fcc5b20";
            break;
        }
        case TeleportAbsoluteResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case TeleportAbsolute::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case TeleportRelativeRequest::ID:
        {
            str = "9d5c2dcd348ac8f76ce2a4307bd63a13";
            break;
        }
        case TeleportRelativeResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case TeleportRelative::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Color::ID:
        {   
		    highOrder = 0x353891e354491c51ULL;
            lowOrder = 0xaabe32df673fb446ULL;
            break;
        }
        case Pose::ID:
        {   
		    highOrder = 0x863b248d5016ca62ULL;
            lowOrder = 0xea2e895ae5265cf9ULL;
            break;
        }
        case KillRequest::ID:
        {   
		    highOrder = 0xc1f3d28f1b044c87ULL;
            lowOrder = 0x1e6eff2e9fc3c667ULL;
            break;
        }
        case KillResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case Kill::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetPenRequest::ID:
        {   
		    highOrder = 0x9f452acce566bf0cULL;
            lowOrder = 0x0954594f69a8e41bULL;
            break;
        }
        case SetPenResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetPen::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SpawnRequest::ID:
        {   
		    highOrder = 0x57f001c49ab7b11dULL;
            lowOrder = 0x699f8606c1f4f7ffULL;
            break;
        }
        case SpawnResponse::ID:
        {   
		    highOrder = 0xc1f3d28f1b044c87ULL;
            lowOrder = 0x1e6eff2e9fc3c667ULL;
            break;
        }
        case Spawn::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case TeleportAbsoluteRequest::ID:
        {   
		    highOrder = 0xa130bc60ee651385ULL;
            lowOrder = 0x5dc62ea83fcc5b20ULL;
            break;
        }
        case TeleportAbsoluteResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case TeleportAbsolute::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case TeleportRelativeRequest::ID:
        {   
		    highOrder = 0x9d5c2dcd348ac8f7ULL;
            lowOrder = 0x6ce2a4307bd63a13ULL;
            break;
        }
        case TeleportRelativeResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case TeleportRelative::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case Color::ID:
        case Pose::ID:
        case KillRequest::ID:
        case KillResponse::ID:
        case Kill::ID:
        case SetPenRequest::ID:
        case SetPenResponse::ID:
        case SetPen::ID:
        case SpawnRequest::ID:
        case SpawnResponse::ID:
        case Spawn::ID:
        case TeleportAbsoluteRequest::ID:
        case TeleportAbsoluteResponse::ID:
        case TeleportAbsolute::ID:
        case TeleportRelativeRequest::ID:
        case TeleportRelativeResponse::ID:
        case TeleportRelative::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case Color::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Color>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Pose::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Pose>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case KillRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<KillRequest>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case KillResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<KillResponse>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Kill::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Kill>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPenRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPenRequest>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPenResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPenResponse>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPen::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPen>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnRequest>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnResponse>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Spawn::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Spawn>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportAbsoluteRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportAbsoluteRequest>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportAbsoluteResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportAbsoluteResponse>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportAbsolute::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportAbsolute>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportRelativeRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportRelativeRequest>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportRelativeResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportRelativeResponse>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TeleportRelative::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TeleportRelative>(),std::bind(&turtlesim_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case Color::ID:
            {
                Message<Color > & tempSrc = static_cast<Message<Color>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::Color buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Pose::ID:
            {
                Message<Pose > & tempSrc = static_cast<Message<Pose>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::Pose buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case KillRequest::ID:
            {
                Message<KillRequest > & tempSrc = static_cast<Message<KillRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::KillRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case KillResponse::ID:
            {
                Message<KillResponse > & tempSrc = static_cast<Message<KillResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::KillResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Kill::ID:
            {
                Message<Kill > & tempSrc = static_cast<Message<Kill>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::Kill buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetPenRequest::ID:
            {
                Message<SetPenRequest > & tempSrc = static_cast<Message<SetPenRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::SetPenRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetPenResponse::ID:
            {
                Message<SetPenResponse > & tempSrc = static_cast<Message<SetPenResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::SetPenResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetPen::ID:
            {
                Message<SetPen > & tempSrc = static_cast<Message<SetPen>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::SetPen buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SpawnRequest::ID:
            {
                Message<SpawnRequest > & tempSrc = static_cast<Message<SpawnRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::SpawnRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SpawnResponse::ID:
            {
                Message<SpawnResponse > & tempSrc = static_cast<Message<SpawnResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::SpawnResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Spawn::ID:
            {
                Message<Spawn > & tempSrc = static_cast<Message<Spawn>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::Spawn buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TeleportAbsoluteRequest::ID:
            {
                Message<TeleportAbsoluteRequest > & tempSrc = static_cast<Message<TeleportAbsoluteRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::TeleportAbsoluteRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TeleportAbsoluteResponse::ID:
            {
                Message<TeleportAbsoluteResponse > & tempSrc = static_cast<Message<TeleportAbsoluteResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::TeleportAbsoluteResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TeleportAbsolute::ID:
            {
                Message<TeleportAbsolute > & tempSrc = static_cast<Message<TeleportAbsolute>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::TeleportAbsolute buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TeleportRelativeRequest::ID:
            {
                Message<TeleportRelativeRequest > & tempSrc = static_cast<Message<TeleportRelativeRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::TeleportRelativeRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TeleportRelativeResponse::ID:
            {
                Message<TeleportRelativeResponse > & tempSrc = static_cast<Message<TeleportRelativeResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::TeleportRelativeResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TeleportRelative::ID:
            {
                Message<TeleportRelative > & tempSrc = static_cast<Message<TeleportRelative>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: turtlesim_gencpp::TeleportRelative buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case Color::ID:
            {
                Message<Color > & tempDst = static_cast<Message<Color>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Pose::ID:
            {
                Message<Pose > & tempDst = static_cast<Message<Pose>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case KillRequest::ID:
            {
                Message<KillRequest > & tempDst = static_cast<Message<KillRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case KillResponse::ID:
            {
                Message<KillResponse > & tempDst = static_cast<Message<KillResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Kill::ID:
            {
                Message<Kill > & tempDst = static_cast<Message<Kill>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetPenRequest::ID:
            {
                Message<SetPenRequest > & tempDst = static_cast<Message<SetPenRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetPenResponse::ID:
            {
                Message<SetPenResponse > & tempDst = static_cast<Message<SetPenResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetPen::ID:
            {
                Message<SetPen > & tempDst = static_cast<Message<SetPen>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SpawnRequest::ID:
            {
                Message<SpawnRequest > & tempDst = static_cast<Message<SpawnRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SpawnResponse::ID:
            {
                Message<SpawnResponse > & tempDst = static_cast<Message<SpawnResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Spawn::ID:
            {
                Message<Spawn > & tempDst = static_cast<Message<Spawn>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TeleportAbsoluteRequest::ID:
            {
                Message<TeleportAbsoluteRequest > & tempDst = static_cast<Message<TeleportAbsoluteRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TeleportAbsoluteResponse::ID:
            {
                Message<TeleportAbsoluteResponse > & tempDst = static_cast<Message<TeleportAbsoluteResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TeleportAbsolute::ID:
            {
                Message<TeleportAbsolute > & tempDst = static_cast<Message<TeleportAbsolute>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TeleportRelativeRequest::ID:
            {
                Message<TeleportRelativeRequest > & tempDst = static_cast<Message<TeleportRelativeRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TeleportRelativeResponse::ID:
            {
                Message<TeleportRelativeResponse > & tempDst = static_cast<Message<TeleportRelativeResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TeleportRelative::ID:
            {
                Message<TeleportRelative > & tempDst = static_cast<Message<TeleportRelative>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int turtlesim_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // Color does not have a Header as its first member 
        // Pose does not have a Header as its first member 
        // KillRequest does not have a Header as its first member 
        // Kill does not have a Header as its first member 
        // SetPenRequest does not have a Header as its first member 
        // SetPen does not have a Header as its first member 
        // SpawnRequest does not have a Header as its first member 
        // SpawnResponse does not have a Header as its first member 
        // Spawn does not have a Header as its first member 
        // TeleportAbsoluteRequest does not have a Header as its first member 
        // TeleportAbsolute does not have a Header as its first member 
        // TeleportRelativeRequest does not have a Header as its first member 
        // TeleportRelative does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
