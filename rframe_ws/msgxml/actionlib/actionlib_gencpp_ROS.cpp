// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:03 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "actionlib_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace actionlib;

rframe::ROSMessageFactory * ROS_actionlib_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_actionlib_gencppfactory = new actionlib_gencppROSMessageFactory();

        return ROS_actionlib_gencppfactory;
    };
}

rframe::ROSMessageFactory * actionlib::allocate_actionlib_gencpp()
{
    ROS_actionlib_gencppfactory = new actionlib_gencppROSMessageFactory();
    return ROS_actionlib_gencppfactory;
};

actionlib_gencppROSMessageFactory::actionlib_gencppROSMessageFactory()
{
    name("actionlib_gencpp");
    // use constructor to register data types
    actionlib::registerLibrary();
}

actionlib_gencppROSMessageFactory::~actionlib_gencppROSMessageFactory()
{
}

int actionlib_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void actionlib_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(TestAction::ID);
    info.name(TestAction::DATA_TYPE_FULL_NAME);
    info.hashKey(TestAction::DATA_VERSION);
    info.md5Key(TestAction::VERSION_MD5);
    info.xmlSource(TestAction::XML_SOURCE);
    info.flat(TestAction::dataTypeFlat());
    ids.push_back(info);

    info.id(TestActionFeedback::ID);
    info.name(TestActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestActionFeedback::DATA_VERSION);
    info.md5Key(TestActionFeedback::VERSION_MD5);
    info.xmlSource(TestActionFeedback::XML_SOURCE);
    info.flat(TestActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestActionGoal::ID);
    info.name(TestActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestActionGoal::DATA_VERSION);
    info.md5Key(TestActionGoal::VERSION_MD5);
    info.xmlSource(TestActionGoal::XML_SOURCE);
    info.flat(TestActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestActionResult::ID);
    info.name(TestActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestActionResult::DATA_VERSION);
    info.md5Key(TestActionResult::VERSION_MD5);
    info.xmlSource(TestActionResult::XML_SOURCE);
    info.flat(TestActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TestFeedback::ID);
    info.name(TestFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestFeedback::DATA_VERSION);
    info.md5Key(TestFeedback::VERSION_MD5);
    info.xmlSource(TestFeedback::XML_SOURCE);
    info.flat(TestFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestGoal::ID);
    info.name(TestGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestGoal::DATA_VERSION);
    info.md5Key(TestGoal::VERSION_MD5);
    info.xmlSource(TestGoal::XML_SOURCE);
    info.flat(TestGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestAction::ID);
    info.name(TestRequestAction::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestAction::DATA_VERSION);
    info.md5Key(TestRequestAction::VERSION_MD5);
    info.xmlSource(TestRequestAction::XML_SOURCE);
    info.flat(TestRequestAction::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestActionFeedback::ID);
    info.name(TestRequestActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestActionFeedback::DATA_VERSION);
    info.md5Key(TestRequestActionFeedback::VERSION_MD5);
    info.xmlSource(TestRequestActionFeedback::XML_SOURCE);
    info.flat(TestRequestActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestActionGoal::ID);
    info.name(TestRequestActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestActionGoal::DATA_VERSION);
    info.md5Key(TestRequestActionGoal::VERSION_MD5);
    info.xmlSource(TestRequestActionGoal::XML_SOURCE);
    info.flat(TestRequestActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestActionResult::ID);
    info.name(TestRequestActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestActionResult::DATA_VERSION);
    info.md5Key(TestRequestActionResult::VERSION_MD5);
    info.xmlSource(TestRequestActionResult::XML_SOURCE);
    info.flat(TestRequestActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestFeedback::ID);
    info.name(TestRequestFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestFeedback::DATA_VERSION);
    info.md5Key(TestRequestFeedback::VERSION_MD5);
    info.xmlSource(TestRequestFeedback::XML_SOURCE);
    info.flat(TestRequestFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestGoal::ID);
    info.name(TestRequestGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestGoal::DATA_VERSION);
    info.md5Key(TestRequestGoal::VERSION_MD5);
    info.xmlSource(TestRequestGoal::XML_SOURCE);
    info.flat(TestRequestGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestResult::ID);
    info.name(TestRequestResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestResult::DATA_VERSION);
    info.md5Key(TestRequestResult::VERSION_MD5);
    info.xmlSource(TestRequestResult::XML_SOURCE);
    info.flat(TestRequestResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TestResult::ID);
    info.name(TestResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestResult::DATA_VERSION);
    info.md5Key(TestResult::VERSION_MD5);
    info.xmlSource(TestResult::XML_SOURCE);
    info.flat(TestResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsAction::ID);
    info.name(TwoIntsAction::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsAction::DATA_VERSION);
    info.md5Key(TwoIntsAction::VERSION_MD5);
    info.xmlSource(TwoIntsAction::XML_SOURCE);
    info.flat(TwoIntsAction::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsActionFeedback::ID);
    info.name(TwoIntsActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsActionFeedback::DATA_VERSION);
    info.md5Key(TwoIntsActionFeedback::VERSION_MD5);
    info.xmlSource(TwoIntsActionFeedback::XML_SOURCE);
    info.flat(TwoIntsActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsActionGoal::ID);
    info.name(TwoIntsActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsActionGoal::DATA_VERSION);
    info.md5Key(TwoIntsActionGoal::VERSION_MD5);
    info.xmlSource(TwoIntsActionGoal::XML_SOURCE);
    info.flat(TwoIntsActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsActionResult::ID);
    info.name(TwoIntsActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsActionResult::DATA_VERSION);
    info.md5Key(TwoIntsActionResult::VERSION_MD5);
    info.xmlSource(TwoIntsActionResult::XML_SOURCE);
    info.flat(TwoIntsActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsFeedback::ID);
    info.name(TwoIntsFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsFeedback::DATA_VERSION);
    info.md5Key(TwoIntsFeedback::VERSION_MD5);
    info.xmlSource(TwoIntsFeedback::XML_SOURCE);
    info.flat(TwoIntsFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsGoal::ID);
    info.name(TwoIntsGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsGoal::DATA_VERSION);
    info.md5Key(TwoIntsGoal::VERSION_MD5);
    info.xmlSource(TwoIntsGoal::XML_SOURCE);
    info.flat(TwoIntsGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsResult::ID);
    info.name(TwoIntsResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsResult::DATA_VERSION);
    info.md5Key(TwoIntsResult::VERSION_MD5);
    info.xmlSource(TwoIntsResult::XML_SOURCE);
    info.flat(TwoIntsResult::dataTypeFlat());
    ids.push_back(info);

}

int actionlib_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case TestAction::ID:
        {
            str = "actionlib/TestAction";
            break;
        }
        case TestActionFeedback::ID:
        {
            str = "actionlib/TestActionFeedback";
            break;
        }
        case TestActionGoal::ID:
        {
            str = "actionlib/TestActionGoal";
            break;
        }
        case TestActionResult::ID:
        {
            str = "actionlib/TestActionResult";
            break;
        }
        case TestFeedback::ID:
        {
            str = "actionlib/TestFeedback";
            break;
        }
        case TestGoal::ID:
        {
            str = "actionlib/TestGoal";
            break;
        }
        case TestRequestAction::ID:
        {
            str = "actionlib/TestRequestAction";
            break;
        }
        case TestRequestActionFeedback::ID:
        {
            str = "actionlib/TestRequestActionFeedback";
            break;
        }
        case TestRequestActionGoal::ID:
        {
            str = "actionlib/TestRequestActionGoal";
            break;
        }
        case TestRequestActionResult::ID:
        {
            str = "actionlib/TestRequestActionResult";
            break;
        }
        case TestRequestFeedback::ID:
        {
            str = "actionlib/TestRequestFeedback";
            break;
        }
        case TestRequestGoal::ID:
        {
            str = "actionlib/TestRequestGoal";
            break;
        }
        case TestRequestResult::ID:
        {
            str = "actionlib/TestRequestResult";
            break;
        }
        case TestResult::ID:
        {
            str = "actionlib/TestResult";
            break;
        }
        case TwoIntsAction::ID:
        {
            str = "actionlib/TwoIntsAction";
            break;
        }
        case TwoIntsActionFeedback::ID:
        {
            str = "actionlib/TwoIntsActionFeedback";
            break;
        }
        case TwoIntsActionGoal::ID:
        {
            str = "actionlib/TwoIntsActionGoal";
            break;
        }
        case TwoIntsActionResult::ID:
        {
            str = "actionlib/TwoIntsActionResult";
            break;
        }
        case TwoIntsFeedback::ID:
        {
            str = "actionlib/TwoIntsFeedback";
            break;
        }
        case TwoIntsGoal::ID:
        {
            str = "actionlib/TwoIntsGoal";
            break;
        }
        case TwoIntsResult::ID:
        {
            str = "actionlib/TwoIntsResult";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case TestAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nTestActionGoal action_goal\nTestActionResult action_result\nTestActionFeedback action_feedback\n\n================================================================================\nMSG: actionlib/TestActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nTestGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 goal\n\n================================================================================\nMSG: actionlib/TestActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib/TestResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 result\n\n================================================================================\nMSG: actionlib/TestActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestFeedback feedback\n\n================================================================================\nMSG: actionlib/TestFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 feedback\n\n";
            break;
        }
        case TestActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 feedback\n\n";
            break;
        }
        case TestActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nTestGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 goal\n";
            break;
        }
        case TestActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 result\n";
            break;
        }
        case TestFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 feedback\n\n";
            break;
        }
        case TestGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 goal\n";
            break;
        }
        case TestRequestAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nTestRequestActionGoal action_goal\nTestRequestActionResult action_result\nTestRequestActionFeedback action_feedback\n\n================================================================================\nMSG: actionlib/TestRequestActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nTestRequestGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestRequestGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 TERMINATE_SUCCESS = 0\nint32 TERMINATE_ABORTED = 1\nint32 TERMINATE_REJECTED = 2\nint32 TERMINATE_LOSE = 3\nint32 TERMINATE_DROP = 4\nint32 TERMINATE_EXCEPTION = 5\nint32 terminate_status\nbool ignore_cancel  # If true, ignores requests to cancel\nstring result_text\nint32 the_result    # Desired value for the_result in the Result\nbool is_simple_client\nduration delay_accept  # Delays accepting the goal by this amount of time\nduration delay_terminate  # Delays terminating for this amount of time\nduration pause_status  # Pauses the status messages for this amount of time\n\n================================================================================\nMSG: actionlib/TestRequestActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestRequestResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib/TestRequestResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 the_result\nbool is_simple_server\n\n================================================================================\nMSG: actionlib/TestRequestActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestRequestFeedback feedback\n\n================================================================================\nMSG: actionlib/TestRequestFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case TestRequestActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestRequestFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestRequestFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case TestRequestActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nTestRequestGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestRequestGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 TERMINATE_SUCCESS = 0\nint32 TERMINATE_ABORTED = 1\nint32 TERMINATE_REJECTED = 2\nint32 TERMINATE_LOSE = 3\nint32 TERMINATE_DROP = 4\nint32 TERMINATE_EXCEPTION = 5\nint32 terminate_status\nbool ignore_cancel  # If true, ignores requests to cancel\nstring result_text\nint32 the_result    # Desired value for the_result in the Result\nbool is_simple_client\nduration delay_accept  # Delays accepting the goal by this amount of time\nduration delay_terminate  # Delays terminating for this amount of time\nduration pause_status  # Pauses the status messages for this amount of time\n";
            break;
        }
        case TestRequestActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTestRequestResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TestRequestResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 the_result\nbool is_simple_server\n";
            break;
        }
        case TestRequestFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case TestRequestGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 TERMINATE_SUCCESS = 0\nint32 TERMINATE_ABORTED = 1\nint32 TERMINATE_REJECTED = 2\nint32 TERMINATE_LOSE = 3\nint32 TERMINATE_DROP = 4\nint32 TERMINATE_EXCEPTION = 5\nint32 terminate_status\nbool ignore_cancel  # If true, ignores requests to cancel\nstring result_text\nint32 the_result    # Desired value for the_result in the Result\nbool is_simple_client\nduration delay_accept  # Delays accepting the goal by this amount of time\nduration delay_terminate  # Delays terminating for this amount of time\nduration pause_status  # Pauses the status messages for this amount of time\n";
            break;
        }
        case TestRequestResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 the_result\nbool is_simple_server\n";
            break;
        }
        case TestResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 result\n";
            break;
        }
        case TwoIntsAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nTwoIntsActionGoal action_goal\nTwoIntsActionResult action_result\nTwoIntsActionFeedback action_feedback\n\n================================================================================\nMSG: actionlib/TwoIntsActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nTwoIntsGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TwoIntsGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint64 a\nint64 b\n\n================================================================================\nMSG: actionlib/TwoIntsActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTwoIntsResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib/TwoIntsResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint64 sum\n\n================================================================================\nMSG: actionlib/TwoIntsActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTwoIntsFeedback feedback\n\n================================================================================\nMSG: actionlib/TwoIntsFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case TwoIntsActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTwoIntsFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TwoIntsFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case TwoIntsActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nTwoIntsGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TwoIntsGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint64 a\nint64 b\n";
            break;
        }
        case TwoIntsActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nTwoIntsResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: actionlib/TwoIntsResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint64 sum\n";
            break;
        }
        case TwoIntsFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case TwoIntsGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint64 a\nint64 b\n";
            break;
        }
        case TwoIntsResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint64 sum\n";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case TestAction::ID:
        {
            str = "991e87a72802262dfbe5d1b3cf6efc9a";
            break;
        }
        case TestActionFeedback::ID:
        {
            str = "6d3d0bf7fb3dda24779c010a9f3eb7cb";
            break;
        }
        case TestActionGoal::ID:
        {
            str = "348369c5b403676156094e8c159720bf";
            break;
        }
        case TestActionResult::ID:
        {
            str = "3d669e3a63aa986c667ea7b0f46ce85e";
            break;
        }
        case TestFeedback::ID:
        {
            str = "49ceb5b32ea3af22073ede4a0328249e";
            break;
        }
        case TestGoal::ID:
        {
            str = "18df0149936b7aa95588e3862476ebde";
            break;
        }
        case TestRequestAction::ID:
        {
            str = "dc44b1f4045dbf0d1db54423b3b86b30";
            break;
        }
        case TestRequestActionFeedback::ID:
        {
            str = "aae20e09065c3809e8a8e87c4c8953fd";
            break;
        }
        case TestRequestActionGoal::ID:
        {
            str = "1889556d3fef88f821c7cb004e4251f3";
            break;
        }
        case TestRequestActionResult::ID:
        {
            str = "0476d1fdf437a3a6e7d6d0e9f5561298";
            break;
        }
        case TestRequestFeedback::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case TestRequestGoal::ID:
        {
            str = "db5d00ba98302d6c6dd3737e9a03ceea";
            break;
        }
        case TestRequestResult::ID:
        {
            str = "61c2364524499c7c5017e2f3fce7ba06";
            break;
        }
        case TestResult::ID:
        {
            str = "034a8e20d6a306665e3a5b340fab3f09";
            break;
        }
        case TwoIntsAction::ID:
        {
            str = "6d1aa538c4bd6183a2dfb7fcac41ee50";
            break;
        }
        case TwoIntsActionFeedback::ID:
        {
            str = "aae20e09065c3809e8a8e87c4c8953fd";
            break;
        }
        case TwoIntsActionGoal::ID:
        {
            str = "684a2db55d6ffb8046fb9d6764ce0860";
            break;
        }
        case TwoIntsActionResult::ID:
        {
            str = "3ba7dea8b8cddcae4528ade4ef74b6e7";
            break;
        }
        case TwoIntsFeedback::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case TwoIntsGoal::ID:
        {
            str = "36d09b846be0b371c5f190354dd3153e";
            break;
        }
        case TwoIntsResult::ID:
        {
            str = "b88405221c77b1878a3cbbfff53428d7";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case TestAction::ID:
        {   
		    highOrder = 0x991e87a72802262dULL;
            lowOrder = 0xfbe5d1b3cf6efc9aULL;
            break;
        }
        case TestActionFeedback::ID:
        {   
		    highOrder = 0x6d3d0bf7fb3dda24ULL;
            lowOrder = 0x779c010a9f3eb7cbULL;
            break;
        }
        case TestActionGoal::ID:
        {   
		    highOrder = 0x348369c5b4036761ULL;
            lowOrder = 0x56094e8c159720bfULL;
            break;
        }
        case TestActionResult::ID:
        {   
		    highOrder = 0x3d669e3a63aa986cULL;
            lowOrder = 0x667ea7b0f46ce85eULL;
            break;
        }
        case TestFeedback::ID:
        {   
		    highOrder = 0x49ceb5b32ea3af22ULL;
            lowOrder = 0x073ede4a0328249eULL;
            break;
        }
        case TestGoal::ID:
        {   
		    highOrder = 0x18df0149936b7aa9ULL;
            lowOrder = 0x5588e3862476ebdeULL;
            break;
        }
        case TestRequestAction::ID:
        {   
		    highOrder = 0xdc44b1f4045dbf0dULL;
            lowOrder = 0x1db54423b3b86b30ULL;
            break;
        }
        case TestRequestActionFeedback::ID:
        {   
		    highOrder = 0xaae20e09065c3809ULL;
            lowOrder = 0xe8a8e87c4c8953fdULL;
            break;
        }
        case TestRequestActionGoal::ID:
        {   
		    highOrder = 0x1889556d3fef88f8ULL;
            lowOrder = 0x21c7cb004e4251f3ULL;
            break;
        }
        case TestRequestActionResult::ID:
        {   
		    highOrder = 0x0476d1fdf437a3a6ULL;
            lowOrder = 0xe7d6d0e9f5561298ULL;
            break;
        }
        case TestRequestFeedback::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case TestRequestGoal::ID:
        {   
		    highOrder = 0xdb5d00ba98302d6cULL;
            lowOrder = 0x6dd3737e9a03ceeaULL;
            break;
        }
        case TestRequestResult::ID:
        {   
		    highOrder = 0x61c2364524499c7cULL;
            lowOrder = 0x5017e2f3fce7ba06ULL;
            break;
        }
        case TestResult::ID:
        {   
		    highOrder = 0x034a8e20d6a30666ULL;
            lowOrder = 0x5e3a5b340fab3f09ULL;
            break;
        }
        case TwoIntsAction::ID:
        {   
		    highOrder = 0x6d1aa538c4bd6183ULL;
            lowOrder = 0xa2dfb7fcac41ee50ULL;
            break;
        }
        case TwoIntsActionFeedback::ID:
        {   
		    highOrder = 0xaae20e09065c3809ULL;
            lowOrder = 0xe8a8e87c4c8953fdULL;
            break;
        }
        case TwoIntsActionGoal::ID:
        {   
		    highOrder = 0x684a2db55d6ffb80ULL;
            lowOrder = 0x46fb9d6764ce0860ULL;
            break;
        }
        case TwoIntsActionResult::ID:
        {   
		    highOrder = 0x3ba7dea8b8cddcaeULL;
            lowOrder = 0x4528ade4ef74b6e7ULL;
            break;
        }
        case TwoIntsFeedback::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case TwoIntsGoal::ID:
        {   
		    highOrder = 0x36d09b846be0b371ULL;
            lowOrder = 0xc5f190354dd3153eULL;
            break;
        }
        case TwoIntsResult::ID:
        {   
		    highOrder = 0xb88405221c77b187ULL;
            lowOrder = 0x8a3cbbfff53428d7ULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case TestAction::ID:
        case TestActionFeedback::ID:
        case TestActionGoal::ID:
        case TestActionResult::ID:
        case TestFeedback::ID:
        case TestGoal::ID:
        case TestRequestAction::ID:
        case TestRequestActionFeedback::ID:
        case TestRequestActionGoal::ID:
        case TestRequestActionResult::ID:
        case TestRequestFeedback::ID:
        case TestRequestGoal::ID:
        case TestRequestResult::ID:
        case TestResult::ID:
        case TwoIntsAction::ID:
        case TwoIntsActionFeedback::ID:
        case TwoIntsActionGoal::ID:
        case TwoIntsActionResult::ID:
        case TwoIntsFeedback::ID:
        case TwoIntsGoal::ID:
        case TwoIntsResult::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case TestAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestAction>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestActionFeedback>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestActionGoal>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestActionResult>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestFeedback>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestGoal>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestAction>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestActionFeedback>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestActionGoal>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestActionResult>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestFeedback>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestGoal>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestResult>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestResult>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsAction>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsActionFeedback>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsActionGoal>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsActionResult>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsFeedback>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsGoal>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsResult>(),std::bind(&actionlib_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case TestAction::ID:
            {
                Message<TestAction > & tempSrc = static_cast<Message<TestAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestActionFeedback::ID:
            {
                Message<TestActionFeedback > & tempSrc = static_cast<Message<TestActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestActionGoal::ID:
            {
                Message<TestActionGoal > & tempSrc = static_cast<Message<TestActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestActionResult::ID:
            {
                Message<TestActionResult > & tempSrc = static_cast<Message<TestActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestFeedback::ID:
            {
                Message<TestFeedback > & tempSrc = static_cast<Message<TestFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestGoal::ID:
            {
                Message<TestGoal > & tempSrc = static_cast<Message<TestGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestAction::ID:
            {
                Message<TestRequestAction > & tempSrc = static_cast<Message<TestRequestAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestActionFeedback::ID:
            {
                Message<TestRequestActionFeedback > & tempSrc = static_cast<Message<TestRequestActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestActionGoal::ID:
            {
                Message<TestRequestActionGoal > & tempSrc = static_cast<Message<TestRequestActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestActionResult::ID:
            {
                Message<TestRequestActionResult > & tempSrc = static_cast<Message<TestRequestActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestFeedback::ID:
            {
                Message<TestRequestFeedback > & tempSrc = static_cast<Message<TestRequestFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestGoal::ID:
            {
                Message<TestRequestGoal > & tempSrc = static_cast<Message<TestRequestGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestRequestResult::ID:
            {
                Message<TestRequestResult > & tempSrc = static_cast<Message<TestRequestResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestRequestResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TestResult::ID:
            {
                Message<TestResult > & tempSrc = static_cast<Message<TestResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TestResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsAction::ID:
            {
                Message<TwoIntsAction > & tempSrc = static_cast<Message<TwoIntsAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsActionFeedback::ID:
            {
                Message<TwoIntsActionFeedback > & tempSrc = static_cast<Message<TwoIntsActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsActionGoal::ID:
            {
                Message<TwoIntsActionGoal > & tempSrc = static_cast<Message<TwoIntsActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsActionResult::ID:
            {
                Message<TwoIntsActionResult > & tempSrc = static_cast<Message<TwoIntsActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsFeedback::ID:
            {
                Message<TwoIntsFeedback > & tempSrc = static_cast<Message<TwoIntsFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsGoal::ID:
            {
                Message<TwoIntsGoal > & tempSrc = static_cast<Message<TwoIntsGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwoIntsResult::ID:
            {
                Message<TwoIntsResult > & tempSrc = static_cast<Message<TwoIntsResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: actionlib_gencpp::TwoIntsResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case TestAction::ID:
            {
                Message<TestAction > & tempDst = static_cast<Message<TestAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestActionFeedback::ID:
            {
                Message<TestActionFeedback > & tempDst = static_cast<Message<TestActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TestActionGoal::ID:
            {
                Message<TestActionGoal > & tempDst = static_cast<Message<TestActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TestActionResult::ID:
            {
                Message<TestActionResult > & tempDst = static_cast<Message<TestActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TestFeedback::ID:
            {
                Message<TestFeedback > & tempDst = static_cast<Message<TestFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestGoal::ID:
            {
                Message<TestGoal > & tempDst = static_cast<Message<TestGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestRequestAction::ID:
            {
                Message<TestRequestAction > & tempDst = static_cast<Message<TestRequestAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestRequestActionFeedback::ID:
            {
                Message<TestRequestActionFeedback > & tempDst = static_cast<Message<TestRequestActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TestRequestActionGoal::ID:
            {
                Message<TestRequestActionGoal > & tempDst = static_cast<Message<TestRequestActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TestRequestActionResult::ID:
            {
                Message<TestRequestActionResult > & tempDst = static_cast<Message<TestRequestActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TestRequestFeedback::ID:
            {
                Message<TestRequestFeedback > & tempDst = static_cast<Message<TestRequestFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestRequestGoal::ID:
            {
                Message<TestRequestGoal > & tempDst = static_cast<Message<TestRequestGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestRequestResult::ID:
            {
                Message<TestRequestResult > & tempDst = static_cast<Message<TestRequestResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TestResult::ID:
            {
                Message<TestResult > & tempDst = static_cast<Message<TestResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TwoIntsAction::ID:
            {
                Message<TwoIntsAction > & tempDst = static_cast<Message<TwoIntsAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TwoIntsActionFeedback::ID:
            {
                Message<TwoIntsActionFeedback > & tempDst = static_cast<Message<TwoIntsActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TwoIntsActionGoal::ID:
            {
                Message<TwoIntsActionGoal > & tempDst = static_cast<Message<TwoIntsActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TwoIntsActionResult::ID:
            {
                Message<TwoIntsActionResult > & tempDst = static_cast<Message<TwoIntsActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TwoIntsFeedback::ID:
            {
                Message<TwoIntsFeedback > & tempDst = static_cast<Message<TwoIntsFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TwoIntsGoal::ID:
            {
                Message<TwoIntsGoal > & tempDst = static_cast<Message<TwoIntsGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TwoIntsResult::ID:
            {
                Message<TwoIntsResult > & tempDst = static_cast<Message<TwoIntsResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int actionlib_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // TestAction does not have a Header as its first member 
        case TestActionFeedback::ID:
        {
            Message<TestActionFeedback > & tempMsg = static_cast<Message<TestActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case TestActionGoal::ID:
        {
            Message<TestActionGoal > & tempMsg = static_cast<Message<TestActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case TestActionResult::ID:
        {
            Message<TestActionResult > & tempMsg = static_cast<Message<TestActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // TestFeedback does not have a Header as its first member 
        // TestGoal does not have a Header as its first member 
        // TestRequestAction does not have a Header as its first member 
        case TestRequestActionFeedback::ID:
        {
            Message<TestRequestActionFeedback > & tempMsg = static_cast<Message<TestRequestActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case TestRequestActionGoal::ID:
        {
            Message<TestRequestActionGoal > & tempMsg = static_cast<Message<TestRequestActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case TestRequestActionResult::ID:
        {
            Message<TestRequestActionResult > & tempMsg = static_cast<Message<TestRequestActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // TestRequestGoal does not have a Header as its first member 
        // TestRequestResult does not have a Header as its first member 
        // TestResult does not have a Header as its first member 
        // TwoIntsAction does not have a Header as its first member 
        case TwoIntsActionFeedback::ID:
        {
            Message<TwoIntsActionFeedback > & tempMsg = static_cast<Message<TwoIntsActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            Message<TwoIntsActionGoal > & tempMsg = static_cast<Message<TwoIntsActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case TwoIntsActionResult::ID:
        {
            Message<TwoIntsActionResult > & tempMsg = static_cast<Message<TwoIntsActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // TwoIntsGoal does not have a Header as its first member 
        // TwoIntsResult does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
