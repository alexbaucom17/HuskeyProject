// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:03 -0500
//  From Template/Script: data_templates/NMLHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_ACTIONLIB_GENCPPNML_H_
#define _CODEGEN_ACTIONLIB_GENCPPNML_H_

#include <messaging/nml/NMLMessageFactory.h>
//#include <DataTypeInfo.h>
#include <messaging/Message.h>

#include "actionlib_gencpp_NMLSupport.h"

namespace rframe { class DataTypeInfo; };

#include "TestAction.h"
#include "TestActionFeedback.h"
#include "TestActionGoal.h"
#include "TestActionResult.h"
#include "TestFeedback.h"
#include "TestGoal.h"
#include "TestRequestAction.h"
#include "TestRequestActionFeedback.h"
#include "TestRequestActionGoal.h"
#include "TestRequestActionResult.h"
#include "TestRequestFeedback.h"
#include "TestRequestGoal.h"
#include "TestRequestResult.h"
#include "TestResult.h"
#include "TwoIntsAction.h"
#include "TwoIntsActionFeedback.h"
#include "TwoIntsActionGoal.h"
#include "TwoIntsActionResult.h"
#include "TwoIntsFeedback.h"
#include "TwoIntsGoal.h"
#include "TwoIntsResult.h"

namespace actionlib {

    /** definition of message factory for actionlib_gencpp */
    class actionlib_gencppNMLMessageFactory : public NMLMessageFactory
    {
    public:
        /** constructor */
        actionlib_gencppNMLMessageFactory();
        /** destructor */
        virtual ~actionlib_gencppNMLMessageFactory();

        /** see  rframe::MessageFactoryInterface */
        virtual void dataTypes(std::vector<DataTypeInfo> & ids);
        /** see  rframe::MessageFactoryInterface */
        virtual int dataType(NMLmsg & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateTransport(NMLmsg * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateMessage(MessageBase * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int toTransport( MessageBase & src, NMLmsg & dst);
        /** see  rframe::MessageFactoryInterface */
        virtual int fromTransport( NMLmsg & src, MessageBase & dst);

        /** \return poitner to nml format function */
        virtual NML_FORMAT_PTR FormatPointer();
        /** run constructor for class of type id in the provided buffer */
        virtual int constructBuffer(rframe::ID_TYPE id, void * buffer);
        /** run destructor for class of type id in the buffer */
        virtual int destructBuffer(rframe::ID_TYPE id, void * buffer);
    };

    /** factory allocation function for use when not dynamically loading the factory library  */
    NMLMessageFactory * allocate_actionlib_gencpp();

    /** NML interface for TestAction 

    */
    class TestActionNML : public NMLmsg
    {
    public:

        /** constructor */
        TestActionNML();
        /** destructor */
        ~TestActionNML();

        /** assignment operator */
        TestActionNML & operator=(const TestActionNML &inobj);
        /** assignment operator for base data class */
        TestActionNML & operator=(const TestAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestAction nmlPayload;

        /** set payload */
        void payload(const TestAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestActionFeedback 

    */
    class TestActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        TestActionFeedbackNML();
        /** destructor */
        ~TestActionFeedbackNML();

        /** assignment operator */
        TestActionFeedbackNML & operator=(const TestActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        TestActionFeedbackNML & operator=(const TestActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestActionFeedback nmlPayload;

        /** set payload */
        void payload(const TestActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestActionGoal 

    */
    class TestActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        TestActionGoalNML();
        /** destructor */
        ~TestActionGoalNML();

        /** assignment operator */
        TestActionGoalNML & operator=(const TestActionGoalNML &inobj);
        /** assignment operator for base data class */
        TestActionGoalNML & operator=(const TestActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestActionGoal nmlPayload;

        /** set payload */
        void payload(const TestActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestActionResult 

    */
    class TestActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        TestActionResultNML();
        /** destructor */
        ~TestActionResultNML();

        /** assignment operator */
        TestActionResultNML & operator=(const TestActionResultNML &inobj);
        /** assignment operator for base data class */
        TestActionResultNML & operator=(const TestActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestActionResult nmlPayload;

        /** set payload */
        void payload(const TestActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestFeedback 

    */
    class TestFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        TestFeedbackNML();
        /** destructor */
        ~TestFeedbackNML();

        /** assignment operator */
        TestFeedbackNML & operator=(const TestFeedbackNML &inobj);
        /** assignment operator for base data class */
        TestFeedbackNML & operator=(const TestFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestFeedback nmlPayload;

        /** set payload */
        void payload(const TestFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestGoal 

    */
    class TestGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        TestGoalNML();
        /** destructor */
        ~TestGoalNML();

        /** assignment operator */
        TestGoalNML & operator=(const TestGoalNML &inobj);
        /** assignment operator for base data class */
        TestGoalNML & operator=(const TestGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestGoal nmlPayload;

        /** set payload */
        void payload(const TestGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestAction 

    */
    class TestRequestActionNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestActionNML();
        /** destructor */
        ~TestRequestActionNML();

        /** assignment operator */
        TestRequestActionNML & operator=(const TestRequestActionNML &inobj);
        /** assignment operator for base data class */
        TestRequestActionNML & operator=(const TestRequestAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestAction nmlPayload;

        /** set payload */
        void payload(const TestRequestAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestActionFeedback 

    */
    class TestRequestActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestActionFeedbackNML();
        /** destructor */
        ~TestRequestActionFeedbackNML();

        /** assignment operator */
        TestRequestActionFeedbackNML & operator=(const TestRequestActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        TestRequestActionFeedbackNML & operator=(const TestRequestActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestActionFeedback nmlPayload;

        /** set payload */
        void payload(const TestRequestActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestActionGoal 

    */
    class TestRequestActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestActionGoalNML();
        /** destructor */
        ~TestRequestActionGoalNML();

        /** assignment operator */
        TestRequestActionGoalNML & operator=(const TestRequestActionGoalNML &inobj);
        /** assignment operator for base data class */
        TestRequestActionGoalNML & operator=(const TestRequestActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestActionGoal nmlPayload;

        /** set payload */
        void payload(const TestRequestActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestActionResult 

    */
    class TestRequestActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestActionResultNML();
        /** destructor */
        ~TestRequestActionResultNML();

        /** assignment operator */
        TestRequestActionResultNML & operator=(const TestRequestActionResultNML &inobj);
        /** assignment operator for base data class */
        TestRequestActionResultNML & operator=(const TestRequestActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestActionResult nmlPayload;

        /** set payload */
        void payload(const TestRequestActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestFeedback 

    */
    class TestRequestFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestFeedbackNML();
        /** destructor */
        ~TestRequestFeedbackNML();

        /** assignment operator */
        TestRequestFeedbackNML & operator=(const TestRequestFeedbackNML &inobj);
        /** assignment operator for base data class */
        TestRequestFeedbackNML & operator=(const TestRequestFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestFeedback nmlPayload;

        /** set payload */
        void payload(const TestRequestFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestGoal 

    */
    class TestRequestGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestGoalNML();
        /** destructor */
        ~TestRequestGoalNML();

        /** assignment operator */
        TestRequestGoalNML & operator=(const TestRequestGoalNML &inobj);
        /** assignment operator for base data class */
        TestRequestGoalNML & operator=(const TestRequestGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestGoal nmlPayload;

        /** set payload */
        void payload(const TestRequestGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestRequestResult 

    */
    class TestRequestResultNML : public NMLmsg
    {
    public:

        /** constructor */
        TestRequestResultNML();
        /** destructor */
        ~TestRequestResultNML();

        /** assignment operator */
        TestRequestResultNML & operator=(const TestRequestResultNML &inobj);
        /** assignment operator for base data class */
        TestRequestResultNML & operator=(const TestRequestResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestRequestResult nmlPayload;

        /** set payload */
        void payload(const TestRequestResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestRequestResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestRequestResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestRequestResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TestResult 

    */
    class TestResultNML : public NMLmsg
    {
    public:

        /** constructor */
        TestResultNML();
        /** destructor */
        ~TestResultNML();

        /** assignment operator */
        TestResultNML & operator=(const TestResultNML &inobj);
        /** assignment operator for base data class */
        TestResultNML & operator=(const TestResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TestResult nmlPayload;

        /** set payload */
        void payload(const TestResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TestResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TestResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<TestResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsAction 

    */
    class TwoIntsActionNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsActionNML();
        /** destructor */
        ~TwoIntsActionNML();

        /** assignment operator */
        TwoIntsActionNML & operator=(const TwoIntsActionNML &inobj);
        /** assignment operator for base data class */
        TwoIntsActionNML & operator=(const TwoIntsAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsAction nmlPayload;

        /** set payload */
        void payload(const TwoIntsAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsActionFeedback 

    */
    class TwoIntsActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsActionFeedbackNML();
        /** destructor */
        ~TwoIntsActionFeedbackNML();

        /** assignment operator */
        TwoIntsActionFeedbackNML & operator=(const TwoIntsActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        TwoIntsActionFeedbackNML & operator=(const TwoIntsActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsActionFeedback nmlPayload;

        /** set payload */
        void payload(const TwoIntsActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsActionGoal 

    */
    class TwoIntsActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsActionGoalNML();
        /** destructor */
        ~TwoIntsActionGoalNML();

        /** assignment operator */
        TwoIntsActionGoalNML & operator=(const TwoIntsActionGoalNML &inobj);
        /** assignment operator for base data class */
        TwoIntsActionGoalNML & operator=(const TwoIntsActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsActionGoal nmlPayload;

        /** set payload */
        void payload(const TwoIntsActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsActionResult 

    */
    class TwoIntsActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsActionResultNML();
        /** destructor */
        ~TwoIntsActionResultNML();

        /** assignment operator */
        TwoIntsActionResultNML & operator=(const TwoIntsActionResultNML &inobj);
        /** assignment operator for base data class */
        TwoIntsActionResultNML & operator=(const TwoIntsActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsActionResult nmlPayload;

        /** set payload */
        void payload(const TwoIntsActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsFeedback 

    */
    class TwoIntsFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsFeedbackNML();
        /** destructor */
        ~TwoIntsFeedbackNML();

        /** assignment operator */
        TwoIntsFeedbackNML & operator=(const TwoIntsFeedbackNML &inobj);
        /** assignment operator for base data class */
        TwoIntsFeedbackNML & operator=(const TwoIntsFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsFeedback nmlPayload;

        /** set payload */
        void payload(const TwoIntsFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsGoal 

    */
    class TwoIntsGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsGoalNML();
        /** destructor */
        ~TwoIntsGoalNML();

        /** assignment operator */
        TwoIntsGoalNML & operator=(const TwoIntsGoalNML &inobj);
        /** assignment operator for base data class */
        TwoIntsGoalNML & operator=(const TwoIntsGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsGoal nmlPayload;

        /** set payload */
        void payload(const TwoIntsGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TwoIntsResult 

    */
    class TwoIntsResultNML : public NMLmsg
    {
    public:

        /** constructor */
        TwoIntsResultNML();
        /** destructor */
        ~TwoIntsResultNML();

        /** assignment operator */
        TwoIntsResultNML & operator=(const TwoIntsResultNML &inobj);
        /** assignment operator for base data class */
        TwoIntsResultNML & operator=(const TwoIntsResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TwoIntsResult nmlPayload;

        /** set payload */
        void payload(const TwoIntsResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TwoIntsResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TwoIntsResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<TwoIntsResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    // predeclaration of nmlupdate functions (necessary due to namespaces )

    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestRequestResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TestResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib::TwoIntsResult & inobj);

    /** nml format function */
    int actionlib_gencpp_format(NMLTYPE type, void * buffer, CMS* cms);

}; // end namespace actionlib

#endif // _ACTIONLIB_GENCPPNML_H_
