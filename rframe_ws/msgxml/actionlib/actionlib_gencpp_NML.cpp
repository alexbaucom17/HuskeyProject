// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:03 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "actionlib_gencpp_NML.h"
#include "actionlib_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <TestAction.h>
#include <TestActionFeedback.h>
#include <TestActionGoal.h>
#include <TestActionResult.h>
#include <TestFeedback.h>
#include <TestGoal.h>
#include <TestRequestAction.h>
#include <TestRequestActionFeedback.h>
#include <TestRequestActionGoal.h>
#include <TestRequestActionResult.h>
#include <TestRequestFeedback.h>
#include <TestRequestGoal.h>
#include <TestRequestResult.h>
#include <TestResult.h>
#include <TwoIntsAction.h>
#include <TwoIntsActionFeedback.h>
#include <TwoIntsActionGoal.h>
#include <TwoIntsActionResult.h>
#include <TwoIntsFeedback.h>
#include <TwoIntsGoal.h>
#include <TwoIntsResult.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace actionlib;

rframe::NMLMessageFactory * NML_actionlib_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_actionlib_gencppfactory = new actionlib_gencppNMLMessageFactory();
        return NML_actionlib_gencppfactory;
    };
}

rframe::NMLMessageFactory * actionlib::allocate_actionlib_gencpp()
{
    NML_actionlib_gencppfactory = new actionlib_gencppNMLMessageFactory();
    return NML_actionlib_gencppfactory;
};

actionlib_gencppNMLMessageFactory::actionlib_gencppNMLMessageFactory()
{
    name("actionlib_gencpp");
    // use constructor to register data types
    actionlib::registerLibrary();
}

actionlib_gencppNMLMessageFactory::~actionlib_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR actionlib_gencppNMLMessageFactory::FormatPointer()
{
    return actionlib_gencpp_format;
}

int actionlib_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void actionlib_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(TestAction::ID);
    info.name(TestAction::DATA_TYPE_FULL_NAME);
    info.hashKey(TestAction::DATA_VERSION);
    info.md5Key(TestAction::VERSION_MD5);
    info.xmlSource(TestAction::XML_SOURCE);
    info.flat(TestAction::dataTypeFlat());
    ids.push_back(info);

    info.id(TestActionFeedback::ID);
    info.name(TestActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestActionFeedback::DATA_VERSION);
    info.md5Key(TestActionFeedback::VERSION_MD5);
    info.xmlSource(TestActionFeedback::XML_SOURCE);
    info.flat(TestActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestActionGoal::ID);
    info.name(TestActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestActionGoal::DATA_VERSION);
    info.md5Key(TestActionGoal::VERSION_MD5);
    info.xmlSource(TestActionGoal::XML_SOURCE);
    info.flat(TestActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestActionResult::ID);
    info.name(TestActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestActionResult::DATA_VERSION);
    info.md5Key(TestActionResult::VERSION_MD5);
    info.xmlSource(TestActionResult::XML_SOURCE);
    info.flat(TestActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TestFeedback::ID);
    info.name(TestFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestFeedback::DATA_VERSION);
    info.md5Key(TestFeedback::VERSION_MD5);
    info.xmlSource(TestFeedback::XML_SOURCE);
    info.flat(TestFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestGoal::ID);
    info.name(TestGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestGoal::DATA_VERSION);
    info.md5Key(TestGoal::VERSION_MD5);
    info.xmlSource(TestGoal::XML_SOURCE);
    info.flat(TestGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestAction::ID);
    info.name(TestRequestAction::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestAction::DATA_VERSION);
    info.md5Key(TestRequestAction::VERSION_MD5);
    info.xmlSource(TestRequestAction::XML_SOURCE);
    info.flat(TestRequestAction::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestActionFeedback::ID);
    info.name(TestRequestActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestActionFeedback::DATA_VERSION);
    info.md5Key(TestRequestActionFeedback::VERSION_MD5);
    info.xmlSource(TestRequestActionFeedback::XML_SOURCE);
    info.flat(TestRequestActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestActionGoal::ID);
    info.name(TestRequestActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestActionGoal::DATA_VERSION);
    info.md5Key(TestRequestActionGoal::VERSION_MD5);
    info.xmlSource(TestRequestActionGoal::XML_SOURCE);
    info.flat(TestRequestActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestActionResult::ID);
    info.name(TestRequestActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestActionResult::DATA_VERSION);
    info.md5Key(TestRequestActionResult::VERSION_MD5);
    info.xmlSource(TestRequestActionResult::XML_SOURCE);
    info.flat(TestRequestActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestFeedback::ID);
    info.name(TestRequestFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestFeedback::DATA_VERSION);
    info.md5Key(TestRequestFeedback::VERSION_MD5);
    info.xmlSource(TestRequestFeedback::XML_SOURCE);
    info.flat(TestRequestFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestGoal::ID);
    info.name(TestRequestGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestGoal::DATA_VERSION);
    info.md5Key(TestRequestGoal::VERSION_MD5);
    info.xmlSource(TestRequestGoal::XML_SOURCE);
    info.flat(TestRequestGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TestRequestResult::ID);
    info.name(TestRequestResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestRequestResult::DATA_VERSION);
    info.md5Key(TestRequestResult::VERSION_MD5);
    info.xmlSource(TestRequestResult::XML_SOURCE);
    info.flat(TestRequestResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TestResult::ID);
    info.name(TestResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TestResult::DATA_VERSION);
    info.md5Key(TestResult::VERSION_MD5);
    info.xmlSource(TestResult::XML_SOURCE);
    info.flat(TestResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsAction::ID);
    info.name(TwoIntsAction::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsAction::DATA_VERSION);
    info.md5Key(TwoIntsAction::VERSION_MD5);
    info.xmlSource(TwoIntsAction::XML_SOURCE);
    info.flat(TwoIntsAction::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsActionFeedback::ID);
    info.name(TwoIntsActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsActionFeedback::DATA_VERSION);
    info.md5Key(TwoIntsActionFeedback::VERSION_MD5);
    info.xmlSource(TwoIntsActionFeedback::XML_SOURCE);
    info.flat(TwoIntsActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsActionGoal::ID);
    info.name(TwoIntsActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsActionGoal::DATA_VERSION);
    info.md5Key(TwoIntsActionGoal::VERSION_MD5);
    info.xmlSource(TwoIntsActionGoal::XML_SOURCE);
    info.flat(TwoIntsActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsActionResult::ID);
    info.name(TwoIntsActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsActionResult::DATA_VERSION);
    info.md5Key(TwoIntsActionResult::VERSION_MD5);
    info.xmlSource(TwoIntsActionResult::XML_SOURCE);
    info.flat(TwoIntsActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsFeedback::ID);
    info.name(TwoIntsFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsFeedback::DATA_VERSION);
    info.md5Key(TwoIntsFeedback::VERSION_MD5);
    info.xmlSource(TwoIntsFeedback::XML_SOURCE);
    info.flat(TwoIntsFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsGoal::ID);
    info.name(TwoIntsGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsGoal::DATA_VERSION);
    info.md5Key(TwoIntsGoal::VERSION_MD5);
    info.xmlSource(TwoIntsGoal::XML_SOURCE);
    info.flat(TwoIntsGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(TwoIntsResult::ID);
    info.name(TwoIntsResult::DATA_TYPE_FULL_NAME);
    info.hashKey(TwoIntsResult::DATA_VERSION);
    info.md5Key(TwoIntsResult::VERSION_MD5);
    info.xmlSource(TwoIntsResult::XML_SOURCE);
    info.flat(TwoIntsResult::dataTypeFlat());
    ids.push_back(info);

}

int actionlib_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case TestAction::ID:
        {
            //TestActionNML * newmsg = new TestActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestActionNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestActionFeedback::ID:
        {
            //TestActionFeedbackNML * newmsg = new TestActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestActionFeedbackNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestActionGoal::ID:
        {
            //TestActionGoalNML * newmsg = new TestActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestActionGoalNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestActionResult::ID:
        {
            //TestActionResultNML * newmsg = new TestActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestActionResultNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestFeedback::ID:
        {
            //TestFeedbackNML * newmsg = new TestFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestFeedbackNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestGoal::ID:
        {
            //TestGoalNML * newmsg = new TestGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestGoalNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestAction::ID:
        {
            //TestRequestActionNML * newmsg = new TestRequestActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestActionNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestActionFeedback::ID:
        {
            //TestRequestActionFeedbackNML * newmsg = new TestRequestActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestActionFeedbackNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestActionGoal::ID:
        {
            //TestRequestActionGoalNML * newmsg = new TestRequestActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestActionGoalNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestActionResult::ID:
        {
            //TestRequestActionResultNML * newmsg = new TestRequestActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestActionResultNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestFeedback::ID:
        {
            //TestRequestFeedbackNML * newmsg = new TestRequestFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestFeedbackNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestGoal::ID:
        {
            //TestRequestGoalNML * newmsg = new TestRequestGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestGoalNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestRequestResult::ID:
        {
            //TestRequestResultNML * newmsg = new TestRequestResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestRequestResultNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TestResult::ID:
        {
            //TestResultNML * newmsg = new TestResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TestResultNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsAction::ID:
        {
            //TwoIntsActionNML * newmsg = new TwoIntsActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsActionNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsActionFeedback::ID:
        {
            //TwoIntsActionFeedbackNML * newmsg = new TwoIntsActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsActionFeedbackNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            //TwoIntsActionGoalNML * newmsg = new TwoIntsActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsActionGoalNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsActionResult::ID:
        {
            //TwoIntsActionResultNML * newmsg = new TwoIntsActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsActionResultNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsFeedback::ID:
        {
            //TwoIntsFeedbackNML * newmsg = new TwoIntsFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsFeedbackNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsGoal::ID:
        {
            //TwoIntsGoalNML * newmsg = new TwoIntsGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsGoalNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwoIntsResult::ID:
        {
            //TwoIntsResultNML * newmsg = new TwoIntsResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwoIntsResultNML(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int actionlib_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case TestAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestAction>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestActionFeedback>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestActionGoal>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestActionResult>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestFeedback>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestGoal>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestAction>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestActionFeedback>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestActionGoal>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestActionResult>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestFeedback>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestGoal>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestRequestResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestRequestResult>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TestResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TestResult>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsAction>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsActionFeedback>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsActionGoal>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsActionResult>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsFeedback>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsGoal>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwoIntsResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwoIntsResult>(),std::bind(&actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int actionlib_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int actionlib_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case TestAction::ID:
            {
                TestActionNML * tempmsg = static_cast<TestActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestActionFeedback::ID:
            {
                TestActionFeedbackNML * tempmsg = static_cast<TestActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestActionGoal::ID:
            {
                TestActionGoalNML * tempmsg = static_cast<TestActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestActionResult::ID:
            {
                TestActionResultNML * tempmsg = static_cast<TestActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestFeedback::ID:
            {
                TestFeedbackNML * tempmsg = static_cast<TestFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestGoal::ID:
            {
                TestGoalNML * tempmsg = static_cast<TestGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestAction::ID:
            {
                TestRequestActionNML * tempmsg = static_cast<TestRequestActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestActionFeedback::ID:
            {
                TestRequestActionFeedbackNML * tempmsg = static_cast<TestRequestActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestActionGoal::ID:
            {
                TestRequestActionGoalNML * tempmsg = static_cast<TestRequestActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestActionResult::ID:
            {
                TestRequestActionResultNML * tempmsg = static_cast<TestRequestActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestFeedback::ID:
            {
                TestRequestFeedbackNML * tempmsg = static_cast<TestRequestFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestGoal::ID:
            {
                TestRequestGoalNML * tempmsg = static_cast<TestRequestGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestRequestResult::ID:
            {
                TestRequestResultNML * tempmsg = static_cast<TestRequestResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TestResult::ID:
            {
                TestResultNML * tempmsg = static_cast<TestResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsAction::ID:
            {
                TwoIntsActionNML * tempmsg = static_cast<TwoIntsActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsActionFeedback::ID:
            {
                TwoIntsActionFeedbackNML * tempmsg = static_cast<TwoIntsActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsActionGoal::ID:
            {
                TwoIntsActionGoalNML * tempmsg = static_cast<TwoIntsActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsActionResult::ID:
            {
                TwoIntsActionResultNML * tempmsg = static_cast<TwoIntsActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsFeedback::ID:
            {
                TwoIntsFeedbackNML * tempmsg = static_cast<TwoIntsFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsGoal::ID:
            {
                TwoIntsGoalNML * tempmsg = static_cast<TwoIntsGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwoIntsResult::ID:
            {
                TwoIntsResultNML * tempmsg = static_cast<TwoIntsResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int actionlib_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case TestAction::ID:
            {
                TestActionNML & tempDst = static_cast<TestActionNML&>(dst);
                Message<TestAction > & tempSrc = static_cast<Message<TestAction>&>(src);

                if (tempSrc.version() != TestAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestAction: " << __FILE__ << " expected: " 
                             << TestAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestAction: " << __FILE__ << " expected: " 
                         << TestAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestActionFeedback::ID:
            {
                TestActionFeedbackNML & tempDst = static_cast<TestActionFeedbackNML&>(dst);
                Message<TestActionFeedback > & tempSrc = static_cast<Message<TestActionFeedback>&>(src);

                if (tempSrc.version() != TestActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestActionFeedback: " << __FILE__ << " expected: " 
                             << TestActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestActionFeedback: " << __FILE__ << " expected: " 
                         << TestActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestActionGoal::ID:
            {
                TestActionGoalNML & tempDst = static_cast<TestActionGoalNML&>(dst);
                Message<TestActionGoal > & tempSrc = static_cast<Message<TestActionGoal>&>(src);

                if (tempSrc.version() != TestActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestActionGoal: " << __FILE__ << " expected: " 
                             << TestActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestActionGoal: " << __FILE__ << " expected: " 
                         << TestActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestActionResult::ID:
            {
                TestActionResultNML & tempDst = static_cast<TestActionResultNML&>(dst);
                Message<TestActionResult > & tempSrc = static_cast<Message<TestActionResult>&>(src);

                if (tempSrc.version() != TestActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestActionResult: " << __FILE__ << " expected: " 
                             << TestActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestActionResult: " << __FILE__ << " expected: " 
                         << TestActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestFeedback::ID:
            {
                TestFeedbackNML & tempDst = static_cast<TestFeedbackNML&>(dst);
                Message<TestFeedback > & tempSrc = static_cast<Message<TestFeedback>&>(src);

                if (tempSrc.version() != TestFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestFeedback: " << __FILE__ << " expected: " 
                             << TestFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestFeedback: " << __FILE__ << " expected: " 
                         << TestFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestGoal::ID:
            {
                TestGoalNML & tempDst = static_cast<TestGoalNML&>(dst);
                Message<TestGoal > & tempSrc = static_cast<Message<TestGoal>&>(src);

                if (tempSrc.version() != TestGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestGoal: " << __FILE__ << " expected: " 
                             << TestGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestGoal: " << __FILE__ << " expected: " 
                         << TestGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestAction::ID:
            {
                TestRequestActionNML & tempDst = static_cast<TestRequestActionNML&>(dst);
                Message<TestRequestAction > & tempSrc = static_cast<Message<TestRequestAction>&>(src);

                if (tempSrc.version() != TestRequestAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestAction: " << __FILE__ << " expected: " 
                             << TestRequestAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestAction: " << __FILE__ << " expected: " 
                         << TestRequestAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestActionFeedback::ID:
            {
                TestRequestActionFeedbackNML & tempDst = static_cast<TestRequestActionFeedbackNML&>(dst);
                Message<TestRequestActionFeedback > & tempSrc = static_cast<Message<TestRequestActionFeedback>&>(src);

                if (tempSrc.version() != TestRequestActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestActionFeedback: " << __FILE__ << " expected: " 
                             << TestRequestActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestActionFeedback: " << __FILE__ << " expected: " 
                         << TestRequestActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestActionGoal::ID:
            {
                TestRequestActionGoalNML & tempDst = static_cast<TestRequestActionGoalNML&>(dst);
                Message<TestRequestActionGoal > & tempSrc = static_cast<Message<TestRequestActionGoal>&>(src);

                if (tempSrc.version() != TestRequestActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestActionGoal: " << __FILE__ << " expected: " 
                             << TestRequestActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestActionGoal: " << __FILE__ << " expected: " 
                         << TestRequestActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestActionResult::ID:
            {
                TestRequestActionResultNML & tempDst = static_cast<TestRequestActionResultNML&>(dst);
                Message<TestRequestActionResult > & tempSrc = static_cast<Message<TestRequestActionResult>&>(src);

                if (tempSrc.version() != TestRequestActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestActionResult: " << __FILE__ << " expected: " 
                             << TestRequestActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestActionResult: " << __FILE__ << " expected: " 
                         << TestRequestActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestFeedback::ID:
            {
                TestRequestFeedbackNML & tempDst = static_cast<TestRequestFeedbackNML&>(dst);
                Message<TestRequestFeedback > & tempSrc = static_cast<Message<TestRequestFeedback>&>(src);

                if (tempSrc.version() != TestRequestFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestFeedback: " << __FILE__ << " expected: " 
                             << TestRequestFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestFeedback: " << __FILE__ << " expected: " 
                         << TestRequestFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestGoal::ID:
            {
                TestRequestGoalNML & tempDst = static_cast<TestRequestGoalNML&>(dst);
                Message<TestRequestGoal > & tempSrc = static_cast<Message<TestRequestGoal>&>(src);

                if (tempSrc.version() != TestRequestGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestGoal: " << __FILE__ << " expected: " 
                             << TestRequestGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestGoal: " << __FILE__ << " expected: " 
                         << TestRequestGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestRequestResult::ID:
            {
                TestRequestResultNML & tempDst = static_cast<TestRequestResultNML&>(dst);
                Message<TestRequestResult > & tempSrc = static_cast<Message<TestRequestResult>&>(src);

                if (tempSrc.version() != TestRequestResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestRequestResult: " << __FILE__ << " expected: " 
                             << TestRequestResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestRequestResult: " << __FILE__ << " expected: " 
                         << TestRequestResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TestResult::ID:
            {
                TestResultNML & tempDst = static_cast<TestResultNML&>(dst);
                Message<TestResult > & tempSrc = static_cast<Message<TestResult>&>(src);

                if (tempSrc.version() != TestResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TestResult: " << __FILE__ << " expected: " 
                             << TestResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TestResult: " << __FILE__ << " expected: " 
                         << TestResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsAction::ID:
            {
                TwoIntsActionNML & tempDst = static_cast<TwoIntsActionNML&>(dst);
                Message<TwoIntsAction > & tempSrc = static_cast<Message<TwoIntsAction>&>(src);

                if (tempSrc.version() != TwoIntsAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsAction: " << __FILE__ << " expected: " 
                             << TwoIntsAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsAction: " << __FILE__ << " expected: " 
                         << TwoIntsAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsActionFeedback::ID:
            {
                TwoIntsActionFeedbackNML & tempDst = static_cast<TwoIntsActionFeedbackNML&>(dst);
                Message<TwoIntsActionFeedback > & tempSrc = static_cast<Message<TwoIntsActionFeedback>&>(src);

                if (tempSrc.version() != TwoIntsActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsActionFeedback: " << __FILE__ << " expected: " 
                             << TwoIntsActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsActionFeedback: " << __FILE__ << " expected: " 
                         << TwoIntsActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsActionGoal::ID:
            {
                TwoIntsActionGoalNML & tempDst = static_cast<TwoIntsActionGoalNML&>(dst);
                Message<TwoIntsActionGoal > & tempSrc = static_cast<Message<TwoIntsActionGoal>&>(src);

                if (tempSrc.version() != TwoIntsActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsActionGoal: " << __FILE__ << " expected: " 
                             << TwoIntsActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsActionGoal: " << __FILE__ << " expected: " 
                         << TwoIntsActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsActionResult::ID:
            {
                TwoIntsActionResultNML & tempDst = static_cast<TwoIntsActionResultNML&>(dst);
                Message<TwoIntsActionResult > & tempSrc = static_cast<Message<TwoIntsActionResult>&>(src);

                if (tempSrc.version() != TwoIntsActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsActionResult: " << __FILE__ << " expected: " 
                             << TwoIntsActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsActionResult: " << __FILE__ << " expected: " 
                         << TwoIntsActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsFeedback::ID:
            {
                TwoIntsFeedbackNML & tempDst = static_cast<TwoIntsFeedbackNML&>(dst);
                Message<TwoIntsFeedback > & tempSrc = static_cast<Message<TwoIntsFeedback>&>(src);

                if (tempSrc.version() != TwoIntsFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsFeedback: " << __FILE__ << " expected: " 
                             << TwoIntsFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsFeedback: " << __FILE__ << " expected: " 
                         << TwoIntsFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsGoal::ID:
            {
                TwoIntsGoalNML & tempDst = static_cast<TwoIntsGoalNML&>(dst);
                Message<TwoIntsGoal > & tempSrc = static_cast<Message<TwoIntsGoal>&>(src);

                if (tempSrc.version() != TwoIntsGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsGoal: " << __FILE__ << " expected: " 
                             << TwoIntsGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsGoal: " << __FILE__ << " expected: " 
                         << TwoIntsGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwoIntsResult::ID:
            {
                TwoIntsResultNML & tempDst = static_cast<TwoIntsResultNML&>(dst);
                Message<TwoIntsResult > & tempSrc = static_cast<Message<TwoIntsResult>&>(src);

                if (tempSrc.version() != TwoIntsResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwoIntsResult: " << __FILE__ << " expected: " 
                             << TwoIntsResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwoIntsResult: " << __FILE__ << " expected: " 
                         << TwoIntsResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int actionlib_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case TestAction::ID:
            {
                TestActionNML & tempSrc = static_cast<TestActionNML&>(src);
                Message<TestAction > & tempDst = static_cast<Message<TestAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestActionFeedback::ID:
            {
                TestActionFeedbackNML & tempSrc = static_cast<TestActionFeedbackNML&>(src);
                Message<TestActionFeedback > & tempDst = static_cast<Message<TestActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestActionGoal::ID:
            {
                TestActionGoalNML & tempSrc = static_cast<TestActionGoalNML&>(src);
                Message<TestActionGoal > & tempDst = static_cast<Message<TestActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestActionResult::ID:
            {
                TestActionResultNML & tempSrc = static_cast<TestActionResultNML&>(src);
                Message<TestActionResult > & tempDst = static_cast<Message<TestActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestFeedback::ID:
            {
                TestFeedbackNML & tempSrc = static_cast<TestFeedbackNML&>(src);
                Message<TestFeedback > & tempDst = static_cast<Message<TestFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestGoal::ID:
            {
                TestGoalNML & tempSrc = static_cast<TestGoalNML&>(src);
                Message<TestGoal > & tempDst = static_cast<Message<TestGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestAction::ID:
            {
                TestRequestActionNML & tempSrc = static_cast<TestRequestActionNML&>(src);
                Message<TestRequestAction > & tempDst = static_cast<Message<TestRequestAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestActionFeedback::ID:
            {
                TestRequestActionFeedbackNML & tempSrc = static_cast<TestRequestActionFeedbackNML&>(src);
                Message<TestRequestActionFeedback > & tempDst = static_cast<Message<TestRequestActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestActionGoal::ID:
            {
                TestRequestActionGoalNML & tempSrc = static_cast<TestRequestActionGoalNML&>(src);
                Message<TestRequestActionGoal > & tempDst = static_cast<Message<TestRequestActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestActionResult::ID:
            {
                TestRequestActionResultNML & tempSrc = static_cast<TestRequestActionResultNML&>(src);
                Message<TestRequestActionResult > & tempDst = static_cast<Message<TestRequestActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestFeedback::ID:
            {
                TestRequestFeedbackNML & tempSrc = static_cast<TestRequestFeedbackNML&>(src);
                Message<TestRequestFeedback > & tempDst = static_cast<Message<TestRequestFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestGoal::ID:
            {
                TestRequestGoalNML & tempSrc = static_cast<TestRequestGoalNML&>(src);
                Message<TestRequestGoal > & tempDst = static_cast<Message<TestRequestGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestRequestResult::ID:
            {
                TestRequestResultNML & tempSrc = static_cast<TestRequestResultNML&>(src);
                Message<TestRequestResult > & tempDst = static_cast<Message<TestRequestResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestRequestResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TestResult::ID:
            {
                TestResultNML & tempSrc = static_cast<TestResultNML&>(src);
                Message<TestResult > & tempDst = static_cast<Message<TestResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TestResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsAction::ID:
            {
                TwoIntsActionNML & tempSrc = static_cast<TwoIntsActionNML&>(src);
                Message<TwoIntsAction > & tempDst = static_cast<Message<TwoIntsAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsActionFeedback::ID:
            {
                TwoIntsActionFeedbackNML & tempSrc = static_cast<TwoIntsActionFeedbackNML&>(src);
                Message<TwoIntsActionFeedback > & tempDst = static_cast<Message<TwoIntsActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsActionGoal::ID:
            {
                TwoIntsActionGoalNML & tempSrc = static_cast<TwoIntsActionGoalNML&>(src);
                Message<TwoIntsActionGoal > & tempDst = static_cast<Message<TwoIntsActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsActionResult::ID:
            {
                TwoIntsActionResultNML & tempSrc = static_cast<TwoIntsActionResultNML&>(src);
                Message<TwoIntsActionResult > & tempDst = static_cast<Message<TwoIntsActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsFeedback::ID:
            {
                TwoIntsFeedbackNML & tempSrc = static_cast<TwoIntsFeedbackNML&>(src);
                Message<TwoIntsFeedback > & tempDst = static_cast<Message<TwoIntsFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsGoal::ID:
            {
                TwoIntsGoalNML & tempSrc = static_cast<TwoIntsGoalNML&>(src);
                Message<TwoIntsGoal > & tempDst = static_cast<Message<TwoIntsGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwoIntsResult::ID:
            {
                TwoIntsResultNML & tempSrc = static_cast<TwoIntsResultNML&>(src);
                Message<TwoIntsResult > & tempDst = static_cast<Message<TwoIntsResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwoIntsResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int actionlib_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case TestAction::ID:
        {
            // only need to construct if data type is not flat
            if (TestAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestAction at %p\n",buffer);
                TestActionNML * p = static_cast<TestActionNML*>(buffer);
                // construct the type at pointer p
                new (p) TestActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (TestActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestActionFeedback at %p\n",buffer);
                TestActionFeedbackNML * p = static_cast<TestActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) TestActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (TestActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestActionGoal at %p\n",buffer);
                TestActionGoalNML * p = static_cast<TestActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) TestActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (TestActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestActionResult at %p\n",buffer);
                TestActionResultNML * p = static_cast<TestActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) TestActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (TestFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestFeedback at %p\n",buffer);
                TestFeedbackNML * p = static_cast<TestFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) TestFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestGoal::ID:
        {
            // only need to construct if data type is not flat
            if (TestGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestGoal at %p\n",buffer);
                TestGoalNML * p = static_cast<TestGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) TestGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestAction::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestAction at %p\n",buffer);
                TestRequestActionNML * p = static_cast<TestRequestActionNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestActionFeedback at %p\n",buffer);
                TestRequestActionFeedbackNML * p = static_cast<TestRequestActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestActionGoal at %p\n",buffer);
                TestRequestActionGoalNML * p = static_cast<TestRequestActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestActionResult at %p\n",buffer);
                TestRequestActionResultNML * p = static_cast<TestRequestActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestFeedback at %p\n",buffer);
                TestRequestFeedbackNML * p = static_cast<TestRequestFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestGoal::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestGoal at %p\n",buffer);
                TestRequestGoalNML * p = static_cast<TestRequestGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestResult::ID:
        {
            // only need to construct if data type is not flat
            if (TestRequestResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestRequestResult at %p\n",buffer);
                TestRequestResultNML * p = static_cast<TestRequestResultNML*>(buffer);
                // construct the type at pointer p
                new (p) TestRequestResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestRequestResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TestResult::ID:
        {
            // only need to construct if data type is not flat
            if (TestResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TestResult at %p\n",buffer);
                TestResultNML * p = static_cast<TestResultNML*>(buffer);
                // construct the type at pointer p
                new (p) TestResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TestResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsAction::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsAction at %p\n",buffer);
                TwoIntsActionNML * p = static_cast<TwoIntsActionNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsActionFeedback at %p\n",buffer);
                TwoIntsActionFeedbackNML * p = static_cast<TwoIntsActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsActionGoal at %p\n",buffer);
                TwoIntsActionGoalNML * p = static_cast<TwoIntsActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsActionResult at %p\n",buffer);
                TwoIntsActionResultNML * p = static_cast<TwoIntsActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsFeedback at %p\n",buffer);
                TwoIntsFeedbackNML * p = static_cast<TwoIntsFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsGoal::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsGoal at %p\n",buffer);
                TwoIntsGoalNML * p = static_cast<TwoIntsGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsResult::ID:
        {
            // only need to construct if data type is not flat
            if (TwoIntsResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwoIntsResult at %p\n",buffer);
                TwoIntsResultNML * p = static_cast<TwoIntsResultNML*>(buffer);
                // construct the type at pointer p
                new (p) TwoIntsResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwoIntsResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int actionlib_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case TestAction::ID:
        {
            // only need to destruct if data type is not flat
            if (TestAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestAction at %p\n",buffer);
                TestActionNML * p = static_cast<TestActionNML*>(buffer);
                p->~TestActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (TestActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestActionFeedback at %p\n",buffer);
                TestActionFeedbackNML * p = static_cast<TestActionFeedbackNML*>(buffer);
                p->~TestActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (TestActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestActionGoal at %p\n",buffer);
                TestActionGoalNML * p = static_cast<TestActionGoalNML*>(buffer);
                p->~TestActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (TestActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestActionResult at %p\n",buffer);
                TestActionResultNML * p = static_cast<TestActionResultNML*>(buffer);
                p->~TestActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (TestFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestFeedback at %p\n",buffer);
                TestFeedbackNML * p = static_cast<TestFeedbackNML*>(buffer);
                p->~TestFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (TestGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestGoal at %p\n",buffer);
                TestGoalNML * p = static_cast<TestGoalNML*>(buffer);
                p->~TestGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestAction::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestAction at %p\n",buffer);
                TestRequestActionNML * p = static_cast<TestRequestActionNML*>(buffer);
                p->~TestRequestActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestActionFeedback at %p\n",buffer);
                TestRequestActionFeedbackNML * p = static_cast<TestRequestActionFeedbackNML*>(buffer);
                p->~TestRequestActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestActionGoal at %p\n",buffer);
                TestRequestActionGoalNML * p = static_cast<TestRequestActionGoalNML*>(buffer);
                p->~TestRequestActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestActionResult at %p\n",buffer);
                TestRequestActionResultNML * p = static_cast<TestRequestActionResultNML*>(buffer);
                p->~TestRequestActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestFeedback at %p\n",buffer);
                TestRequestFeedbackNML * p = static_cast<TestRequestFeedbackNML*>(buffer);
                p->~TestRequestFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestGoal at %p\n",buffer);
                TestRequestGoalNML * p = static_cast<TestRequestGoalNML*>(buffer);
                p->~TestRequestGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestRequestResult::ID:
        {
            // only need to destruct if data type is not flat
            if (TestRequestResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestRequestResult at %p\n",buffer);
                TestRequestResultNML * p = static_cast<TestRequestResultNML*>(buffer);
                p->~TestRequestResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestRequestResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case TestResult::ID:
        {
            // only need to destruct if data type is not flat
            if (TestResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TestResult at %p\n",buffer);
                TestResultNML * p = static_cast<TestResultNML*>(buffer);
                p->~TestResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TestResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsAction::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsAction at %p\n",buffer);
                TwoIntsActionNML * p = static_cast<TwoIntsActionNML*>(buffer);
                p->~TwoIntsActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsActionFeedback at %p\n",buffer);
                TwoIntsActionFeedbackNML * p = static_cast<TwoIntsActionFeedbackNML*>(buffer);
                p->~TwoIntsActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsActionGoal at %p\n",buffer);
                TwoIntsActionGoalNML * p = static_cast<TwoIntsActionGoalNML*>(buffer);
                p->~TwoIntsActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsActionResult at %p\n",buffer);
                TwoIntsActionResultNML * p = static_cast<TwoIntsActionResultNML*>(buffer);
                p->~TwoIntsActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsFeedback at %p\n",buffer);
                TwoIntsFeedbackNML * p = static_cast<TwoIntsFeedbackNML*>(buffer);
                p->~TwoIntsFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsGoal at %p\n",buffer);
                TwoIntsGoalNML * p = static_cast<TwoIntsGoalNML*>(buffer);
                p->~TwoIntsGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwoIntsResult::ID:
        {
            // only need to destruct if data type is not flat
            if (TwoIntsResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwoIntsResult at %p\n",buffer);
                TwoIntsResultNML * p = static_cast<TwoIntsResultNML*>(buffer);
                p->~TwoIntsResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwoIntsResult at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void actionlib::nmlupdate(CMS * cms, TestAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

TestActionNML::TestActionNML() : NMLmsg((NMLTYPE)TestAction::ID,sizeof(TestActionNML)), nmlVersion(TestAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestAction()*/)
{
};

TestActionNML::~TestActionNML()
{
};

TestActionNML & TestActionNML::operator=(const TestActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestActionNML & TestActionNML::operator=(const TestAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestAction> temp(new TestAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestAction Message version mismatch, expected " << TestAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestAction Message version mismatch, expected " << TestAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

TestActionFeedbackNML::TestActionFeedbackNML() : NMLmsg((NMLTYPE)TestActionFeedback::ID,sizeof(TestActionFeedbackNML)), nmlVersion(TestActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestActionFeedback()*/)
{
};

TestActionFeedbackNML::~TestActionFeedbackNML()
{
};

TestActionFeedbackNML & TestActionFeedbackNML::operator=(const TestActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestActionFeedbackNML & TestActionFeedbackNML::operator=(const TestActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestActionFeedback> temp(new TestActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestActionFeedback Message version mismatch, expected " << TestActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestActionFeedback Message version mismatch, expected " << TestActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

TestActionGoalNML::TestActionGoalNML() : NMLmsg((NMLTYPE)TestActionGoal::ID,sizeof(TestActionGoalNML)), nmlVersion(TestActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestActionGoal()*/)
{
};

TestActionGoalNML::~TestActionGoalNML()
{
};

TestActionGoalNML & TestActionGoalNML::operator=(const TestActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestActionGoalNML & TestActionGoalNML::operator=(const TestActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestActionGoal> temp(new TestActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestActionGoal Message version mismatch, expected " << TestActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestActionGoal Message version mismatch, expected " << TestActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

TestActionResultNML::TestActionResultNML() : NMLmsg((NMLTYPE)TestActionResult::ID,sizeof(TestActionResultNML)), nmlVersion(TestActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestActionResult()*/)
{
};

TestActionResultNML::~TestActionResultNML()
{
};

TestActionResultNML & TestActionResultNML::operator=(const TestActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestActionResultNML & TestActionResultNML::operator=(const TestActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestActionResult> temp(new TestActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestActionResult Message version mismatch, expected " << TestActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestActionResult Message version mismatch, expected " << TestActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.feedback);

    }  
 }

TestFeedbackNML::TestFeedbackNML() : NMLmsg((NMLTYPE)TestFeedback::ID,sizeof(TestFeedbackNML)), nmlVersion(TestFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestFeedback()*/)
{
};

TestFeedbackNML::~TestFeedbackNML()
{
};

TestFeedbackNML & TestFeedbackNML::operator=(const TestFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestFeedbackNML & TestFeedbackNML::operator=(const TestFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestFeedback> temp(new TestFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestFeedback Message version mismatch, expected " << TestFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestFeedback Message version mismatch, expected " << TestFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.goal);

    }  
 }

TestGoalNML::TestGoalNML() : NMLmsg((NMLTYPE)TestGoal::ID,sizeof(TestGoalNML)), nmlVersion(TestGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestGoal()*/)
{
};

TestGoalNML::~TestGoalNML()
{
};

TestGoalNML & TestGoalNML::operator=(const TestGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestGoalNML & TestGoalNML::operator=(const TestGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestGoal> temp(new TestGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestGoal Message version mismatch, expected " << TestGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestGoal Message version mismatch, expected " << TestGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

TestRequestActionNML::TestRequestActionNML() : NMLmsg((NMLTYPE)TestRequestAction::ID,sizeof(TestRequestActionNML)), nmlVersion(TestRequestAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestAction()*/)
{
};

TestRequestActionNML::~TestRequestActionNML()
{
};

TestRequestActionNML & TestRequestActionNML::operator=(const TestRequestActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestActionNML & TestRequestActionNML::operator=(const TestRequestAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestAction> temp(new TestRequestAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestAction Message version mismatch, expected " << TestRequestAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestAction Message version mismatch, expected " << TestRequestAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

TestRequestActionFeedbackNML::TestRequestActionFeedbackNML() : NMLmsg((NMLTYPE)TestRequestActionFeedback::ID,sizeof(TestRequestActionFeedbackNML)), nmlVersion(TestRequestActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestActionFeedback()*/)
{
};

TestRequestActionFeedbackNML::~TestRequestActionFeedbackNML()
{
};

TestRequestActionFeedbackNML & TestRequestActionFeedbackNML::operator=(const TestRequestActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestActionFeedbackNML & TestRequestActionFeedbackNML::operator=(const TestRequestActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestActionFeedback> temp(new TestRequestActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestActionFeedback Message version mismatch, expected " << TestRequestActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestActionFeedback Message version mismatch, expected " << TestRequestActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

TestRequestActionGoalNML::TestRequestActionGoalNML() : NMLmsg((NMLTYPE)TestRequestActionGoal::ID,sizeof(TestRequestActionGoalNML)), nmlVersion(TestRequestActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestActionGoal()*/)
{
};

TestRequestActionGoalNML::~TestRequestActionGoalNML()
{
};

TestRequestActionGoalNML & TestRequestActionGoalNML::operator=(const TestRequestActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestActionGoalNML & TestRequestActionGoalNML::operator=(const TestRequestActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestActionGoal> temp(new TestRequestActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestActionGoal Message version mismatch, expected " << TestRequestActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestActionGoal Message version mismatch, expected " << TestRequestActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

TestRequestActionResultNML::TestRequestActionResultNML() : NMLmsg((NMLTYPE)TestRequestActionResult::ID,sizeof(TestRequestActionResultNML)), nmlVersion(TestRequestActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestActionResult()*/)
{
};

TestRequestActionResultNML::~TestRequestActionResultNML()
{
};

TestRequestActionResultNML & TestRequestActionResultNML::operator=(const TestRequestActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestActionResultNML & TestRequestActionResultNML::operator=(const TestRequestActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestActionResult> temp(new TestRequestActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestActionResult Message version mismatch, expected " << TestRequestActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestActionResult Message version mismatch, expected " << TestRequestActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

TestRequestFeedbackNML::TestRequestFeedbackNML() : NMLmsg((NMLTYPE)TestRequestFeedback::ID,sizeof(TestRequestFeedbackNML)), nmlVersion(TestRequestFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestFeedback()*/)
{
};

TestRequestFeedbackNML::~TestRequestFeedbackNML()
{
};

TestRequestFeedbackNML & TestRequestFeedbackNML::operator=(const TestRequestFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestFeedbackNML & TestRequestFeedbackNML::operator=(const TestRequestFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestFeedback> temp(new TestRequestFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestFeedback Message version mismatch, expected " << TestRequestFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestFeedback Message version mismatch, expected " << TestRequestFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.terminate_status);
        cms->update(inobj.ignore_cancel);
        nmlupdate(cms,inobj.result_text);
        cms->update(inobj.the_result);
        cms->update(inobj.is_simple_client);
        nmlupdate(cms,inobj.delay_accept);
        nmlupdate(cms,inobj.delay_terminate);
        nmlupdate(cms,inobj.pause_status);

    }  
 }

TestRequestGoalNML::TestRequestGoalNML() : NMLmsg((NMLTYPE)TestRequestGoal::ID,sizeof(TestRequestGoalNML)), nmlVersion(TestRequestGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestGoal()*/)
{
};

TestRequestGoalNML::~TestRequestGoalNML()
{
};

TestRequestGoalNML & TestRequestGoalNML::operator=(const TestRequestGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestGoalNML & TestRequestGoalNML::operator=(const TestRequestGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestGoal> temp(new TestRequestGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestGoal Message version mismatch, expected " << TestRequestGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestGoal Message version mismatch, expected " << TestRequestGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestRequestResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestRequestResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.the_result);
        cms->update(inobj.is_simple_server);

    }  
 }

TestRequestResultNML::TestRequestResultNML() : NMLmsg((NMLTYPE)TestRequestResult::ID,sizeof(TestRequestResultNML)), nmlVersion(TestRequestResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestRequestResult()*/)
{
};

TestRequestResultNML::~TestRequestResultNML()
{
};

TestRequestResultNML & TestRequestResultNML::operator=(const TestRequestResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestRequestResultNML & TestRequestResultNML::operator=(const TestRequestResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestRequestResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestRequestResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestRequestResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestRequestResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestRequestResult> temp(new TestRequestResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestRequestResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestRequestResult Message version mismatch, expected " << TestRequestResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestRequestResult Message version mismatch, expected " << TestRequestResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TestResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TestResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.result);

    }  
 }

TestResultNML::TestResultNML() : NMLmsg((NMLTYPE)TestResult::ID,sizeof(TestResultNML)), nmlVersion(TestResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TestResult()*/)
{
};

TestResultNML::~TestResultNML()
{
};

TestResultNML & TestResultNML::operator=(const TestResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TestResultNML & TestResultNML::operator=(const TestResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TestResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TestResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TestResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TestResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TestResult> temp(new TestResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TestResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TestResult Message version mismatch, expected " << TestResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TestResult Message version mismatch, expected " << TestResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

TwoIntsActionNML::TwoIntsActionNML() : NMLmsg((NMLTYPE)TwoIntsAction::ID,sizeof(TwoIntsActionNML)), nmlVersion(TwoIntsAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsAction()*/)
{
};

TwoIntsActionNML::~TwoIntsActionNML()
{
};

TwoIntsActionNML & TwoIntsActionNML::operator=(const TwoIntsActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsActionNML & TwoIntsActionNML::operator=(const TwoIntsAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsAction> temp(new TwoIntsAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsAction Message version mismatch, expected " << TwoIntsAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsAction Message version mismatch, expected " << TwoIntsAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

TwoIntsActionFeedbackNML::TwoIntsActionFeedbackNML() : NMLmsg((NMLTYPE)TwoIntsActionFeedback::ID,sizeof(TwoIntsActionFeedbackNML)), nmlVersion(TwoIntsActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsActionFeedback()*/)
{
};

TwoIntsActionFeedbackNML::~TwoIntsActionFeedbackNML()
{
};

TwoIntsActionFeedbackNML & TwoIntsActionFeedbackNML::operator=(const TwoIntsActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsActionFeedbackNML & TwoIntsActionFeedbackNML::operator=(const TwoIntsActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsActionFeedback> temp(new TwoIntsActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsActionFeedback Message version mismatch, expected " << TwoIntsActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsActionFeedback Message version mismatch, expected " << TwoIntsActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

TwoIntsActionGoalNML::TwoIntsActionGoalNML() : NMLmsg((NMLTYPE)TwoIntsActionGoal::ID,sizeof(TwoIntsActionGoalNML)), nmlVersion(TwoIntsActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsActionGoal()*/)
{
};

TwoIntsActionGoalNML::~TwoIntsActionGoalNML()
{
};

TwoIntsActionGoalNML & TwoIntsActionGoalNML::operator=(const TwoIntsActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsActionGoalNML & TwoIntsActionGoalNML::operator=(const TwoIntsActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsActionGoal> temp(new TwoIntsActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsActionGoal Message version mismatch, expected " << TwoIntsActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsActionGoal Message version mismatch, expected " << TwoIntsActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

TwoIntsActionResultNML::TwoIntsActionResultNML() : NMLmsg((NMLTYPE)TwoIntsActionResult::ID,sizeof(TwoIntsActionResultNML)), nmlVersion(TwoIntsActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsActionResult()*/)
{
};

TwoIntsActionResultNML::~TwoIntsActionResultNML()
{
};

TwoIntsActionResultNML & TwoIntsActionResultNML::operator=(const TwoIntsActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsActionResultNML & TwoIntsActionResultNML::operator=(const TwoIntsActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsActionResult> temp(new TwoIntsActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsActionResult Message version mismatch, expected " << TwoIntsActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsActionResult Message version mismatch, expected " << TwoIntsActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

TwoIntsFeedbackNML::TwoIntsFeedbackNML() : NMLmsg((NMLTYPE)TwoIntsFeedback::ID,sizeof(TwoIntsFeedbackNML)), nmlVersion(TwoIntsFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsFeedback()*/)
{
};

TwoIntsFeedbackNML::~TwoIntsFeedbackNML()
{
};

TwoIntsFeedbackNML & TwoIntsFeedbackNML::operator=(const TwoIntsFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsFeedbackNML & TwoIntsFeedbackNML::operator=(const TwoIntsFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsFeedback> temp(new TwoIntsFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsFeedback Message version mismatch, expected " << TwoIntsFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsFeedback Message version mismatch, expected " << TwoIntsFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.a);
        cms->update(inobj.b);

    }  
 }

TwoIntsGoalNML::TwoIntsGoalNML() : NMLmsg((NMLTYPE)TwoIntsGoal::ID,sizeof(TwoIntsGoalNML)), nmlVersion(TwoIntsGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsGoal()*/)
{
};

TwoIntsGoalNML::~TwoIntsGoalNML()
{
};

TwoIntsGoalNML & TwoIntsGoalNML::operator=(const TwoIntsGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsGoalNML & TwoIntsGoalNML::operator=(const TwoIntsGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsGoal> temp(new TwoIntsGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsGoal Message version mismatch, expected " << TwoIntsGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsGoal Message version mismatch, expected " << TwoIntsGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib::nmlupdate(CMS * cms, TwoIntsResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwoIntsResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.sum);

    }  
 }

TwoIntsResultNML::TwoIntsResultNML() : NMLmsg((NMLTYPE)TwoIntsResult::ID,sizeof(TwoIntsResultNML)), nmlVersion(TwoIntsResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwoIntsResult()*/)
{
};

TwoIntsResultNML::~TwoIntsResultNML()
{
};

TwoIntsResultNML & TwoIntsResultNML::operator=(const TwoIntsResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwoIntsResultNML & TwoIntsResultNML::operator=(const TwoIntsResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwoIntsResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwoIntsResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwoIntsResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwoIntsResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwoIntsResult> temp(new TwoIntsResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwoIntsResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwoIntsResult Message version mismatch, expected " << TwoIntsResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwoIntsResult Message version mismatch, expected " << TwoIntsResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int actionlib::actionlib_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("actionlib_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case TestAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestAction, id " << TestAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestActionFeedback, id " << TestActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestActionGoal, id " << TestActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestActionResult, id " << TestActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestFeedback, id " << TestFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestGoal, id " << TestGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestAction, id " << TestRequestAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestActionFeedback, id " << TestRequestActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestActionGoal, id " << TestRequestActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestActionResult, id " << TestRequestActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestFeedback, id " << TestRequestFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestGoal, id " << TestRequestGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestRequestResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestRequestResult, id " << TestRequestResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestRequestResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TestResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TestResult, id " << TestResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TestResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsAction, id " << TwoIntsAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsActionFeedback, id " << TwoIntsActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsActionGoal, id " << TwoIntsActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsActionResult, id " << TwoIntsActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsFeedback, id " << TwoIntsFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsGoal, id " << TwoIntsGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwoIntsResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwoIntsResult, id " << TwoIntsResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwoIntsResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

