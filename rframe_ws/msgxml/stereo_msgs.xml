<!--
 
  AUTOGENERATED FILE:   do not edit

  Generated by:         alex on alex-laptop, 2016-12-05 12:07:35 -0500
  From Template/Script: rosToXML.rb
 

-->
<classes library_name="stereo_msgs_gencpp" namespace="stereo_msgs" >

<class name="DisparityImage" publicDataMembers="true" sourceIDL="ROS" ros="true" rosMD5="04a177815f75271039fa21f16acad8c9" rosDesc="# Separate header for compatibility with current TimeSynchronizer.\n# Likely to be removed in a later release, use image.header instead.\nHeader header\n\n# Floating point disparity image. The disparities are pre-adjusted for any\n# x-offset between the principal points of the two cameras (in the case\n# that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)\nsensor_msgs/Image image\n\n# Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.\nfloat32 f # Focal length, pixels\nfloat32 T # Baseline, world units\n\n# Subwindow of (potentially) valid disparity values.\nsensor_msgs/RegionOfInterest valid_window\n\n# The range of disparities searched.\n# In the disparity image, any disparity less than min_disparity is invalid.\n# The disparity search range defines the horopter, or 3D volume that the\n# stereo algorithm can \&quot;see\&quot;. Points with Z outside of:\n#     Z_min = fT / max_disparity\n#     Z_max = fT / min_disparity\n# could not be found.\nfloat32 min_disparity\nfloat32 max_disparity\n\n# Smallest allowed disparity increment. The smallest achievable depth range\n# resolution is delta_Z = (Z^2/fT)*delta_d.\nfloat32 delta_d\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called &apos;secs&apos;)\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called &apos;nsecs&apos;)\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: sensor_msgs/Image\n# This message contains an uncompressed image\n# (0, 0) is at top-left corner of image\n#\n\nHeader header        # Header timestamp should be acquisition time of image\n                     # Header frame_id should be optical frame of camera\n                     # origin of frame should be optical center of cameara\n                     # +x should point to the right in the image\n                     # +y should point down in the image\n                     # +z should point into to plane of the image\n                     # If the frame_id here and the frame_id of the CameraInfo\n                     # message associated with the image conflict\n                     # the behavior is undefined\n\nuint32 height         # image height, that is, number of rows\nuint32 width          # image width, that is, number of columns\n\n# The legal values for encoding are in file src/image_encodings.cpp\n# If you want to standardize a new string format, join\n# ros-users@lists.sourceforge.net and send an email proposing a new encoding.\n\nstring encoding       # Encoding of pixels -- channel meaning, ordering, size\n                      # taken from the list of strings in include/sensor_msgs/image_encodings.h\n\nuint8 is_bigendian    # is this data bigendian?\nuint32 step           # Full row length in bytes\nuint8[] data          # actual matrix data, size is (step * rows)\n\n================================================================================\nMSG: sensor_msgs/RegionOfInterest\n# This message is used to specify a region of interest within an image.\n#\n# When used to specify the ROI setting of the camera when the image was\n# taken, the height and width fields should either match the height and\n# width fields for the associated image; or height = width = 0\n# indicates that the full resolution image was captured.\n\nuint32 x_offset  # Leftmost pixel of the ROI\n                 # (0 if the ROI includes the left edge of the image)\nuint32 y_offset  # Topmost pixel of the ROI\n                 # (0 if the ROI includes the top edge of the image)\nuint32 height    # Height of ROI\nuint32 width     # Width of ROI\n\n# True if a distinct rectified ROI should be calculated from the \&quot;raw\&quot;\n# ROI in this message. Typically this should be False if the full image\n# is captured (ROI not used), and True if a subwindow is captured (ROI\n# used).\nbool do_rectify\n" comment="Separate header for compatibility with current TimeSynchronizer.
 Likely to be removed in a later release, use image.header instead." >
  <field name="header" type="std_msgs::Header"  sourceType="Header" comment="Floating point disparity image. The disparities are pre-adjusted for any
 x-offset between the principal points of the two cameras (in the case
 that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)" />
  <field name="image" type="sensor_msgs::Image"  sourceType="sensor_msgs::Image" comment="Stereo geometry. For disparity d, the depth from the camera is Z = fT/d." />
  <field name="f" type="float"  sourceType="float32" comment="Focal length, pixels" />
  <field name="T" type="float"  sourceType="float32" comment="Baseline, world units
 Subwindow of (potentially) valid disparity values." />
  <field name="valid_window" type="sensor_msgs::RegionOfInterest"  sourceType="sensor_msgs::RegionOfInterest" comment="The range of disparities searched.
 In the disparity image, any disparity less than min_disparity is invalid.
 The disparity search range defines the horopter, or 3D volume that the
 stereo algorithm can &quot;see&quot;. Points with Z outside of:
     Z_min = fT / max_disparity
     Z_max = fT / min_disparity
 could not be found." />
  <field name="min_disparity" type="float"  sourceType="float32" comment="" />
  <field name="max_disparity" type="float"  sourceType="float32" comment="Smallest allowed disparity increment. The smallest achievable depth range
 resolution is delta_Z = (Z^2/fT)*delta_d." />
  <field name="delta_d" type="float"  sourceType="float32" comment="" />
</class>

<dependency name="sensor_msgs_gencpp"/>
<dependency name="std_msgs_gencpp"/>
<dependency name="std_srvs_gencpp"/>

</classes>
