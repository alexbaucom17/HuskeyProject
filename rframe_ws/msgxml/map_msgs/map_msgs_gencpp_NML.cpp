// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:50 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "map_msgs_gencpp_NML.h"
#include "map_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <OccupancyGridUpdate.h>
#include <PointCloud2Update.h>
#include <ProjectedMap.h>
#include <ProjectedMapInfo.h>
#include <GetMapROIRequest.h>
#include <GetMapROIResponse.h>
#include <GetMapROI.h>
#include <GetPointMapRequest.h>
#include <GetPointMapResponse.h>
#include <GetPointMap.h>
#include <GetPointMapROIRequest.h>
#include <GetPointMapROIResponse.h>
#include <GetPointMapROI.h>
#include <ProjectedMapsInfo.h>
#include <SaveMap.h>
#include <SetMapProjectionsRequest.h>
#include <SetMapProjectionsResponse.h>
#include <SetMapProjections.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace map_msgs;

rframe::NMLMessageFactory * NML_map_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_map_msgs_gencppfactory = new map_msgs_gencppNMLMessageFactory();
        return NML_map_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * map_msgs::allocate_map_msgs_gencpp()
{
    NML_map_msgs_gencppfactory = new map_msgs_gencppNMLMessageFactory();
    return NML_map_msgs_gencppfactory;
};

map_msgs_gencppNMLMessageFactory::map_msgs_gencppNMLMessageFactory()
{
    name("map_msgs_gencpp");
    // use constructor to register data types
    map_msgs::registerLibrary();
}

map_msgs_gencppNMLMessageFactory::~map_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR map_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return map_msgs_gencpp_format;
}

int map_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void map_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(OccupancyGridUpdate::ID);
    info.name(OccupancyGridUpdate::DATA_TYPE_FULL_NAME);
    info.hashKey(OccupancyGridUpdate::DATA_VERSION);
    info.md5Key(OccupancyGridUpdate::VERSION_MD5);
    info.xmlSource(OccupancyGridUpdate::XML_SOURCE);
    info.flat(OccupancyGridUpdate::dataTypeFlat());
    ids.push_back(info);

    info.id(PointCloud2Update::ID);
    info.name(PointCloud2Update::DATA_TYPE_FULL_NAME);
    info.hashKey(PointCloud2Update::DATA_VERSION);
    info.md5Key(PointCloud2Update::VERSION_MD5);
    info.xmlSource(PointCloud2Update::XML_SOURCE);
    info.flat(PointCloud2Update::dataTypeFlat());
    ids.push_back(info);

    info.id(ProjectedMap::ID);
    info.name(ProjectedMap::DATA_TYPE_FULL_NAME);
    info.hashKey(ProjectedMap::DATA_VERSION);
    info.md5Key(ProjectedMap::VERSION_MD5);
    info.xmlSource(ProjectedMap::XML_SOURCE);
    info.flat(ProjectedMap::dataTypeFlat());
    ids.push_back(info);

    info.id(ProjectedMapInfo::ID);
    info.name(ProjectedMapInfo::DATA_TYPE_FULL_NAME);
    info.hashKey(ProjectedMapInfo::DATA_VERSION);
    info.md5Key(ProjectedMapInfo::VERSION_MD5);
    info.xmlSource(ProjectedMapInfo::XML_SOURCE);
    info.flat(ProjectedMapInfo::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapROIRequest::ID);
    info.name(GetMapROIRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapROIRequest::DATA_VERSION);
    info.md5Key(GetMapROIRequest::VERSION_MD5);
    info.xmlSource(GetMapROIRequest::XML_SOURCE);
    info.flat(GetMapROIRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapROIResponse::ID);
    info.name(GetMapROIResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapROIResponse::DATA_VERSION);
    info.md5Key(GetMapROIResponse::VERSION_MD5);
    info.xmlSource(GetMapROIResponse::XML_SOURCE);
    info.flat(GetMapROIResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapROI::ID);
    info.name(GetMapROI::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapROI::DATA_VERSION);
    info.md5Key(GetMapROI::VERSION_MD5);
    info.xmlSource(GetMapROI::XML_SOURCE);
    info.flat(GetMapROI::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPointMapRequest::ID);
    info.name(GetPointMapRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPointMapRequest::DATA_VERSION);
    info.md5Key(GetPointMapRequest::VERSION_MD5);
    info.xmlSource(GetPointMapRequest::XML_SOURCE);
    info.flat(GetPointMapRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPointMapResponse::ID);
    info.name(GetPointMapResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPointMapResponse::DATA_VERSION);
    info.md5Key(GetPointMapResponse::VERSION_MD5);
    info.xmlSource(GetPointMapResponse::XML_SOURCE);
    info.flat(GetPointMapResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPointMap::ID);
    info.name(GetPointMap::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPointMap::DATA_VERSION);
    info.md5Key(GetPointMap::VERSION_MD5);
    info.xmlSource(GetPointMap::XML_SOURCE);
    info.flat(GetPointMap::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPointMapROIRequest::ID);
    info.name(GetPointMapROIRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPointMapROIRequest::DATA_VERSION);
    info.md5Key(GetPointMapROIRequest::VERSION_MD5);
    info.xmlSource(GetPointMapROIRequest::XML_SOURCE);
    info.flat(GetPointMapROIRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPointMapROIResponse::ID);
    info.name(GetPointMapROIResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPointMapROIResponse::DATA_VERSION);
    info.md5Key(GetPointMapROIResponse::VERSION_MD5);
    info.xmlSource(GetPointMapROIResponse::XML_SOURCE);
    info.flat(GetPointMapROIResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPointMapROI::ID);
    info.name(GetPointMapROI::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPointMapROI::DATA_VERSION);
    info.md5Key(GetPointMapROI::VERSION_MD5);
    info.xmlSource(GetPointMapROI::XML_SOURCE);
    info.flat(GetPointMapROI::dataTypeFlat());
    ids.push_back(info);

    info.id(ProjectedMapsInfo::ID);
    info.name(ProjectedMapsInfo::DATA_TYPE_FULL_NAME);
    info.hashKey(ProjectedMapsInfo::DATA_VERSION);
    info.md5Key(ProjectedMapsInfo::VERSION_MD5);
    info.xmlSource(ProjectedMapsInfo::XML_SOURCE);
    info.flat(ProjectedMapsInfo::dataTypeFlat());
    ids.push_back(info);

    info.id(SaveMap::ID);
    info.name(SaveMap::DATA_TYPE_FULL_NAME);
    info.hashKey(SaveMap::DATA_VERSION);
    info.md5Key(SaveMap::VERSION_MD5);
    info.xmlSource(SaveMap::XML_SOURCE);
    info.flat(SaveMap::dataTypeFlat());
    ids.push_back(info);

    info.id(SetMapProjectionsRequest::ID);
    info.name(SetMapProjectionsRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetMapProjectionsRequest::DATA_VERSION);
    info.md5Key(SetMapProjectionsRequest::VERSION_MD5);
    info.xmlSource(SetMapProjectionsRequest::XML_SOURCE);
    info.flat(SetMapProjectionsRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetMapProjectionsResponse::ID);
    info.name(SetMapProjectionsResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetMapProjectionsResponse::DATA_VERSION);
    info.md5Key(SetMapProjectionsResponse::VERSION_MD5);
    info.xmlSource(SetMapProjectionsResponse::XML_SOURCE);
    info.flat(SetMapProjectionsResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetMapProjections::ID);
    info.name(SetMapProjections::DATA_TYPE_FULL_NAME);
    info.hashKey(SetMapProjections::DATA_VERSION);
    info.md5Key(SetMapProjections::VERSION_MD5);
    info.xmlSource(SetMapProjections::XML_SOURCE);
    info.flat(SetMapProjections::dataTypeFlat());
    ids.push_back(info);

}

int map_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case OccupancyGridUpdate::ID:
        {
            //OccupancyGridUpdateNML * newmsg = new OccupancyGridUpdateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new OccupancyGridUpdateNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointCloud2Update::ID:
        {
            //PointCloud2UpdateNML * newmsg = new PointCloud2UpdateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointCloud2UpdateNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ProjectedMap::ID:
        {
            //ProjectedMapNML * newmsg = new ProjectedMapNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ProjectedMapNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ProjectedMapInfo::ID:
        {
            //ProjectedMapInfoNML * newmsg = new ProjectedMapInfoNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ProjectedMapInfoNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapROIRequest::ID:
        {
            //GetMapROIRequestNML * newmsg = new GetMapROIRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapROIRequestNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapROIResponse::ID:
        {
            //GetMapROIResponseNML * newmsg = new GetMapROIResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapROIResponseNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapROI::ID:
        {
            //GetMapROINML * newmsg = new GetMapROINML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapROINML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPointMapRequest::ID:
        {
            //GetPointMapRequestNML * newmsg = new GetPointMapRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPointMapRequestNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPointMapResponse::ID:
        {
            //GetPointMapResponseNML * newmsg = new GetPointMapResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPointMapResponseNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPointMap::ID:
        {
            //GetPointMapNML * newmsg = new GetPointMapNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPointMapNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPointMapROIRequest::ID:
        {
            //GetPointMapROIRequestNML * newmsg = new GetPointMapROIRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPointMapROIRequestNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPointMapROIResponse::ID:
        {
            //GetPointMapROIResponseNML * newmsg = new GetPointMapROIResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPointMapROIResponseNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPointMapROI::ID:
        {
            //GetPointMapROINML * newmsg = new GetPointMapROINML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPointMapROINML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ProjectedMapsInfo::ID:
        {
            //ProjectedMapsInfoNML * newmsg = new ProjectedMapsInfoNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ProjectedMapsInfoNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SaveMap::ID:
        {
            //SaveMapNML * newmsg = new SaveMapNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SaveMapNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetMapProjectionsRequest::ID:
        {
            //SetMapProjectionsRequestNML * newmsg = new SetMapProjectionsRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetMapProjectionsRequestNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetMapProjectionsResponse::ID:
        {
            //SetMapProjectionsResponseNML * newmsg = new SetMapProjectionsResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetMapProjectionsResponseNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetMapProjections::ID:
        {
            //SetMapProjectionsNML * newmsg = new SetMapProjectionsNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetMapProjectionsNML(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int map_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case OccupancyGridUpdate::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<OccupancyGridUpdate>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointCloud2Update::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointCloud2Update>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ProjectedMap::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ProjectedMap>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ProjectedMapInfo::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ProjectedMapInfo>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapROIRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapROIRequest>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapROIResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapROIResponse>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapROI::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapROI>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPointMapRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPointMapRequest>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPointMapResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPointMapResponse>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPointMap::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPointMap>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPointMapROIRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPointMapROIRequest>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPointMapROIResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPointMapROIResponse>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPointMapROI::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPointMapROI>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ProjectedMapsInfo::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ProjectedMapsInfo>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SaveMap::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SaveMap>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetMapProjectionsRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetMapProjectionsRequest>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetMapProjectionsResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetMapProjectionsResponse>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetMapProjections::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetMapProjections>(),std::bind(&map_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int map_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int map_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case OccupancyGridUpdate::ID:
            {
                OccupancyGridUpdateNML * tempmsg = static_cast<OccupancyGridUpdateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointCloud2Update::ID:
            {
                PointCloud2UpdateNML * tempmsg = static_cast<PointCloud2UpdateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ProjectedMap::ID:
            {
                ProjectedMapNML * tempmsg = static_cast<ProjectedMapNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ProjectedMapInfo::ID:
            {
                ProjectedMapInfoNML * tempmsg = static_cast<ProjectedMapInfoNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapROIRequest::ID:
            {
                GetMapROIRequestNML * tempmsg = static_cast<GetMapROIRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapROIResponse::ID:
            {
                GetMapROIResponseNML * tempmsg = static_cast<GetMapROIResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapROI::ID:
            {
                GetMapROINML * tempmsg = static_cast<GetMapROINML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPointMapRequest::ID:
            {
                GetPointMapRequestNML * tempmsg = static_cast<GetPointMapRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPointMapResponse::ID:
            {
                GetPointMapResponseNML * tempmsg = static_cast<GetPointMapResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPointMap::ID:
            {
                GetPointMapNML * tempmsg = static_cast<GetPointMapNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPointMapROIRequest::ID:
            {
                GetPointMapROIRequestNML * tempmsg = static_cast<GetPointMapROIRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPointMapROIResponse::ID:
            {
                GetPointMapROIResponseNML * tempmsg = static_cast<GetPointMapROIResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPointMapROI::ID:
            {
                GetPointMapROINML * tempmsg = static_cast<GetPointMapROINML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ProjectedMapsInfo::ID:
            {
                ProjectedMapsInfoNML * tempmsg = static_cast<ProjectedMapsInfoNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SaveMap::ID:
            {
                SaveMapNML * tempmsg = static_cast<SaveMapNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetMapProjectionsRequest::ID:
            {
                SetMapProjectionsRequestNML * tempmsg = static_cast<SetMapProjectionsRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetMapProjectionsResponse::ID:
            {
                SetMapProjectionsResponseNML * tempmsg = static_cast<SetMapProjectionsResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetMapProjections::ID:
            {
                SetMapProjectionsNML * tempmsg = static_cast<SetMapProjectionsNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int map_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case OccupancyGridUpdate::ID:
            {
                OccupancyGridUpdateNML & tempDst = static_cast<OccupancyGridUpdateNML&>(dst);
                Message<OccupancyGridUpdate > & tempSrc = static_cast<Message<OccupancyGridUpdate>&>(src);

                if (tempSrc.version() != OccupancyGridUpdate::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of OccupancyGridUpdate: " << __FILE__ << " expected: " 
                             << OccupancyGridUpdate::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of OccupancyGridUpdate: " << __FILE__ << " expected: " 
                         << OccupancyGridUpdate::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointCloud2Update::ID:
            {
                PointCloud2UpdateNML & tempDst = static_cast<PointCloud2UpdateNML&>(dst);
                Message<PointCloud2Update > & tempSrc = static_cast<Message<PointCloud2Update>&>(src);

                if (tempSrc.version() != PointCloud2Update::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointCloud2Update: " << __FILE__ << " expected: " 
                             << PointCloud2Update::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointCloud2Update: " << __FILE__ << " expected: " 
                         << PointCloud2Update::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ProjectedMap::ID:
            {
                ProjectedMapNML & tempDst = static_cast<ProjectedMapNML&>(dst);
                Message<ProjectedMap > & tempSrc = static_cast<Message<ProjectedMap>&>(src);

                if (tempSrc.version() != ProjectedMap::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ProjectedMap: " << __FILE__ << " expected: " 
                             << ProjectedMap::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ProjectedMap: " << __FILE__ << " expected: " 
                         << ProjectedMap::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ProjectedMapInfo::ID:
            {
                ProjectedMapInfoNML & tempDst = static_cast<ProjectedMapInfoNML&>(dst);
                Message<ProjectedMapInfo > & tempSrc = static_cast<Message<ProjectedMapInfo>&>(src);

                if (tempSrc.version() != ProjectedMapInfo::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ProjectedMapInfo: " << __FILE__ << " expected: " 
                             << ProjectedMapInfo::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ProjectedMapInfo: " << __FILE__ << " expected: " 
                         << ProjectedMapInfo::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapROIRequest::ID:
            {
                GetMapROIRequestNML & tempDst = static_cast<GetMapROIRequestNML&>(dst);
                Message<GetMapROIRequest > & tempSrc = static_cast<Message<GetMapROIRequest>&>(src);

                if (tempSrc.version() != GetMapROIRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapROIRequest: " << __FILE__ << " expected: " 
                             << GetMapROIRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapROIRequest: " << __FILE__ << " expected: " 
                         << GetMapROIRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapROIResponse::ID:
            {
                GetMapROIResponseNML & tempDst = static_cast<GetMapROIResponseNML&>(dst);
                Message<GetMapROIResponse > & tempSrc = static_cast<Message<GetMapROIResponse>&>(src);

                if (tempSrc.version() != GetMapROIResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapROIResponse: " << __FILE__ << " expected: " 
                             << GetMapROIResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapROIResponse: " << __FILE__ << " expected: " 
                         << GetMapROIResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapROI::ID:
            {
                GetMapROINML & tempDst = static_cast<GetMapROINML&>(dst);
                Message<GetMapROI > & tempSrc = static_cast<Message<GetMapROI>&>(src);

                if (tempSrc.version() != GetMapROI::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapROI: " << __FILE__ << " expected: " 
                             << GetMapROI::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapROI: " << __FILE__ << " expected: " 
                         << GetMapROI::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPointMapRequest::ID:
            {
                GetPointMapRequestNML & tempDst = static_cast<GetPointMapRequestNML&>(dst);
                Message<GetPointMapRequest > & tempSrc = static_cast<Message<GetPointMapRequest>&>(src);

                if (tempSrc.version() != GetPointMapRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPointMapRequest: " << __FILE__ << " expected: " 
                             << GetPointMapRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPointMapRequest: " << __FILE__ << " expected: " 
                         << GetPointMapRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPointMapResponse::ID:
            {
                GetPointMapResponseNML & tempDst = static_cast<GetPointMapResponseNML&>(dst);
                Message<GetPointMapResponse > & tempSrc = static_cast<Message<GetPointMapResponse>&>(src);

                if (tempSrc.version() != GetPointMapResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPointMapResponse: " << __FILE__ << " expected: " 
                             << GetPointMapResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPointMapResponse: " << __FILE__ << " expected: " 
                         << GetPointMapResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPointMap::ID:
            {
                GetPointMapNML & tempDst = static_cast<GetPointMapNML&>(dst);
                Message<GetPointMap > & tempSrc = static_cast<Message<GetPointMap>&>(src);

                if (tempSrc.version() != GetPointMap::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPointMap: " << __FILE__ << " expected: " 
                             << GetPointMap::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPointMap: " << __FILE__ << " expected: " 
                         << GetPointMap::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPointMapROIRequest::ID:
            {
                GetPointMapROIRequestNML & tempDst = static_cast<GetPointMapROIRequestNML&>(dst);
                Message<GetPointMapROIRequest > & tempSrc = static_cast<Message<GetPointMapROIRequest>&>(src);

                if (tempSrc.version() != GetPointMapROIRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPointMapROIRequest: " << __FILE__ << " expected: " 
                             << GetPointMapROIRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPointMapROIRequest: " << __FILE__ << " expected: " 
                         << GetPointMapROIRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPointMapROIResponse::ID:
            {
                GetPointMapROIResponseNML & tempDst = static_cast<GetPointMapROIResponseNML&>(dst);
                Message<GetPointMapROIResponse > & tempSrc = static_cast<Message<GetPointMapROIResponse>&>(src);

                if (tempSrc.version() != GetPointMapROIResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPointMapROIResponse: " << __FILE__ << " expected: " 
                             << GetPointMapROIResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPointMapROIResponse: " << __FILE__ << " expected: " 
                         << GetPointMapROIResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPointMapROI::ID:
            {
                GetPointMapROINML & tempDst = static_cast<GetPointMapROINML&>(dst);
                Message<GetPointMapROI > & tempSrc = static_cast<Message<GetPointMapROI>&>(src);

                if (tempSrc.version() != GetPointMapROI::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPointMapROI: " << __FILE__ << " expected: " 
                             << GetPointMapROI::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPointMapROI: " << __FILE__ << " expected: " 
                         << GetPointMapROI::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ProjectedMapsInfo::ID:
            {
                ProjectedMapsInfoNML & tempDst = static_cast<ProjectedMapsInfoNML&>(dst);
                Message<ProjectedMapsInfo > & tempSrc = static_cast<Message<ProjectedMapsInfo>&>(src);

                if (tempSrc.version() != ProjectedMapsInfo::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ProjectedMapsInfo: " << __FILE__ << " expected: " 
                             << ProjectedMapsInfo::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ProjectedMapsInfo: " << __FILE__ << " expected: " 
                         << ProjectedMapsInfo::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SaveMap::ID:
            {
                SaveMapNML & tempDst = static_cast<SaveMapNML&>(dst);
                Message<SaveMap > & tempSrc = static_cast<Message<SaveMap>&>(src);

                if (tempSrc.version() != SaveMap::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SaveMap: " << __FILE__ << " expected: " 
                             << SaveMap::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SaveMap: " << __FILE__ << " expected: " 
                         << SaveMap::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetMapProjectionsRequest::ID:
            {
                SetMapProjectionsRequestNML & tempDst = static_cast<SetMapProjectionsRequestNML&>(dst);
                Message<SetMapProjectionsRequest > & tempSrc = static_cast<Message<SetMapProjectionsRequest>&>(src);

                if (tempSrc.version() != SetMapProjectionsRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetMapProjectionsRequest: " << __FILE__ << " expected: " 
                             << SetMapProjectionsRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetMapProjectionsRequest: " << __FILE__ << " expected: " 
                         << SetMapProjectionsRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetMapProjectionsResponse::ID:
            {
                SetMapProjectionsResponseNML & tempDst = static_cast<SetMapProjectionsResponseNML&>(dst);
                Message<SetMapProjectionsResponse > & tempSrc = static_cast<Message<SetMapProjectionsResponse>&>(src);

                if (tempSrc.version() != SetMapProjectionsResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetMapProjectionsResponse: " << __FILE__ << " expected: " 
                             << SetMapProjectionsResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetMapProjectionsResponse: " << __FILE__ << " expected: " 
                         << SetMapProjectionsResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetMapProjections::ID:
            {
                SetMapProjectionsNML & tempDst = static_cast<SetMapProjectionsNML&>(dst);
                Message<SetMapProjections > & tempSrc = static_cast<Message<SetMapProjections>&>(src);

                if (tempSrc.version() != SetMapProjections::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetMapProjections: " << __FILE__ << " expected: " 
                             << SetMapProjections::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetMapProjections: " << __FILE__ << " expected: " 
                         << SetMapProjections::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int map_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case OccupancyGridUpdate::ID:
            {
                OccupancyGridUpdateNML & tempSrc = static_cast<OccupancyGridUpdateNML&>(src);
                Message<OccupancyGridUpdate > & tempDst = static_cast<Message<OccupancyGridUpdate>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (OccupancyGridUpdate::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointCloud2Update::ID:
            {
                PointCloud2UpdateNML & tempSrc = static_cast<PointCloud2UpdateNML&>(src);
                Message<PointCloud2Update > & tempDst = static_cast<Message<PointCloud2Update>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointCloud2Update::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ProjectedMap::ID:
            {
                ProjectedMapNML & tempSrc = static_cast<ProjectedMapNML&>(src);
                Message<ProjectedMap > & tempDst = static_cast<Message<ProjectedMap>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ProjectedMap::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ProjectedMapInfo::ID:
            {
                ProjectedMapInfoNML & tempSrc = static_cast<ProjectedMapInfoNML&>(src);
                Message<ProjectedMapInfo > & tempDst = static_cast<Message<ProjectedMapInfo>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ProjectedMapInfo::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapROIRequest::ID:
            {
                GetMapROIRequestNML & tempSrc = static_cast<GetMapROIRequestNML&>(src);
                Message<GetMapROIRequest > & tempDst = static_cast<Message<GetMapROIRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapROIRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapROIResponse::ID:
            {
                GetMapROIResponseNML & tempSrc = static_cast<GetMapROIResponseNML&>(src);
                Message<GetMapROIResponse > & tempDst = static_cast<Message<GetMapROIResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapROIResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapROI::ID:
            {
                GetMapROINML & tempSrc = static_cast<GetMapROINML&>(src);
                Message<GetMapROI > & tempDst = static_cast<Message<GetMapROI>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapROI::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPointMapRequest::ID:
            {
                GetPointMapRequestNML & tempSrc = static_cast<GetPointMapRequestNML&>(src);
                Message<GetPointMapRequest > & tempDst = static_cast<Message<GetPointMapRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPointMapRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPointMapResponse::ID:
            {
                GetPointMapResponseNML & tempSrc = static_cast<GetPointMapResponseNML&>(src);
                Message<GetPointMapResponse > & tempDst = static_cast<Message<GetPointMapResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPointMapResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPointMap::ID:
            {
                GetPointMapNML & tempSrc = static_cast<GetPointMapNML&>(src);
                Message<GetPointMap > & tempDst = static_cast<Message<GetPointMap>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPointMap::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPointMapROIRequest::ID:
            {
                GetPointMapROIRequestNML & tempSrc = static_cast<GetPointMapROIRequestNML&>(src);
                Message<GetPointMapROIRequest > & tempDst = static_cast<Message<GetPointMapROIRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPointMapROIRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPointMapROIResponse::ID:
            {
                GetPointMapROIResponseNML & tempSrc = static_cast<GetPointMapROIResponseNML&>(src);
                Message<GetPointMapROIResponse > & tempDst = static_cast<Message<GetPointMapROIResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPointMapROIResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPointMapROI::ID:
            {
                GetPointMapROINML & tempSrc = static_cast<GetPointMapROINML&>(src);
                Message<GetPointMapROI > & tempDst = static_cast<Message<GetPointMapROI>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPointMapROI::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ProjectedMapsInfo::ID:
            {
                ProjectedMapsInfoNML & tempSrc = static_cast<ProjectedMapsInfoNML&>(src);
                Message<ProjectedMapsInfo > & tempDst = static_cast<Message<ProjectedMapsInfo>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ProjectedMapsInfo::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SaveMap::ID:
            {
                SaveMapNML & tempSrc = static_cast<SaveMapNML&>(src);
                Message<SaveMap > & tempDst = static_cast<Message<SaveMap>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SaveMap::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetMapProjectionsRequest::ID:
            {
                SetMapProjectionsRequestNML & tempSrc = static_cast<SetMapProjectionsRequestNML&>(src);
                Message<SetMapProjectionsRequest > & tempDst = static_cast<Message<SetMapProjectionsRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetMapProjectionsRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetMapProjectionsResponse::ID:
            {
                SetMapProjectionsResponseNML & tempSrc = static_cast<SetMapProjectionsResponseNML&>(src);
                Message<SetMapProjectionsResponse > & tempDst = static_cast<Message<SetMapProjectionsResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetMapProjectionsResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetMapProjections::ID:
            {
                SetMapProjectionsNML & tempSrc = static_cast<SetMapProjectionsNML&>(src);
                Message<SetMapProjections > & tempDst = static_cast<Message<SetMapProjections>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetMapProjections::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int map_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case OccupancyGridUpdate::ID:
        {
            // only need to construct if data type is not flat
            if (OccupancyGridUpdate::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing OccupancyGridUpdate at %p\n",buffer);
                OccupancyGridUpdateNML * p = static_cast<OccupancyGridUpdateNML*>(buffer);
                // construct the type at pointer p
                new (p) OccupancyGridUpdateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing OccupancyGridUpdate at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointCloud2Update::ID:
        {
            // only need to construct if data type is not flat
            if (PointCloud2Update::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointCloud2Update at %p\n",buffer);
                PointCloud2UpdateNML * p = static_cast<PointCloud2UpdateNML*>(buffer);
                // construct the type at pointer p
                new (p) PointCloud2UpdateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointCloud2Update at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ProjectedMap::ID:
        {
            // only need to construct if data type is not flat
            if (ProjectedMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ProjectedMap at %p\n",buffer);
                ProjectedMapNML * p = static_cast<ProjectedMapNML*>(buffer);
                // construct the type at pointer p
                new (p) ProjectedMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ProjectedMap at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ProjectedMapInfo::ID:
        {
            // only need to construct if data type is not flat
            if (ProjectedMapInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ProjectedMapInfo at %p\n",buffer);
                ProjectedMapInfoNML * p = static_cast<ProjectedMapInfoNML*>(buffer);
                // construct the type at pointer p
                new (p) ProjectedMapInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ProjectedMapInfo at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapROIRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapROIRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapROIRequest at %p\n",buffer);
                GetMapROIRequestNML * p = static_cast<GetMapROIRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapROIRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapROIRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapROIResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapROIResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapROIResponse at %p\n",buffer);
                GetMapROIResponseNML * p = static_cast<GetMapROIResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapROIResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapROIResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapROI::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapROI::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapROI at %p\n",buffer);
                GetMapROINML * p = static_cast<GetMapROINML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapROINML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapROI at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetPointMapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPointMapRequest at %p\n",buffer);
                GetPointMapRequestNML * p = static_cast<GetPointMapRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPointMapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPointMapRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetPointMapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPointMapResponse at %p\n",buffer);
                GetPointMapResponseNML * p = static_cast<GetPointMapResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPointMapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPointMapResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMap::ID:
        {
            // only need to construct if data type is not flat
            if (GetPointMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPointMap at %p\n",buffer);
                GetPointMapNML * p = static_cast<GetPointMapNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPointMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPointMap at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapROIRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetPointMapROIRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPointMapROIRequest at %p\n",buffer);
                GetPointMapROIRequestNML * p = static_cast<GetPointMapROIRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPointMapROIRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPointMapROIRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapROIResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetPointMapROIResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPointMapROIResponse at %p\n",buffer);
                GetPointMapROIResponseNML * p = static_cast<GetPointMapROIResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPointMapROIResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPointMapROIResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapROI::ID:
        {
            // only need to construct if data type is not flat
            if (GetPointMapROI::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPointMapROI at %p\n",buffer);
                GetPointMapROINML * p = static_cast<GetPointMapROINML*>(buffer);
                // construct the type at pointer p
                new (p) GetPointMapROINML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPointMapROI at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ProjectedMapsInfo::ID:
        {
            // only need to construct if data type is not flat
            if (ProjectedMapsInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ProjectedMapsInfo at %p\n",buffer);
                ProjectedMapsInfoNML * p = static_cast<ProjectedMapsInfoNML*>(buffer);
                // construct the type at pointer p
                new (p) ProjectedMapsInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ProjectedMapsInfo at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SaveMap::ID:
        {
            // only need to construct if data type is not flat
            if (SaveMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SaveMap at %p\n",buffer);
                SaveMapNML * p = static_cast<SaveMapNML*>(buffer);
                // construct the type at pointer p
                new (p) SaveMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SaveMap at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetMapProjectionsRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetMapProjectionsRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetMapProjectionsRequest at %p\n",buffer);
                SetMapProjectionsRequestNML * p = static_cast<SetMapProjectionsRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetMapProjectionsRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetMapProjectionsRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetMapProjectionsResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetMapProjectionsResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetMapProjectionsResponse at %p\n",buffer);
                SetMapProjectionsResponseNML * p = static_cast<SetMapProjectionsResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetMapProjectionsResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetMapProjectionsResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetMapProjections::ID:
        {
            // only need to construct if data type is not flat
            if (SetMapProjections::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetMapProjections at %p\n",buffer);
                SetMapProjectionsNML * p = static_cast<SetMapProjectionsNML*>(buffer);
                // construct the type at pointer p
                new (p) SetMapProjectionsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetMapProjections at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int map_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case OccupancyGridUpdate::ID:
        {
            // only need to destruct if data type is not flat
            if (OccupancyGridUpdate::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing OccupancyGridUpdate at %p\n",buffer);
                OccupancyGridUpdateNML * p = static_cast<OccupancyGridUpdateNML*>(buffer);
                p->~OccupancyGridUpdateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction OccupancyGridUpdate at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointCloud2Update::ID:
        {
            // only need to destruct if data type is not flat
            if (PointCloud2Update::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointCloud2Update at %p\n",buffer);
                PointCloud2UpdateNML * p = static_cast<PointCloud2UpdateNML*>(buffer);
                p->~PointCloud2UpdateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointCloud2Update at %p, is flat\n",buffer);
            }
            break;
        } 
        case ProjectedMap::ID:
        {
            // only need to destruct if data type is not flat
            if (ProjectedMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ProjectedMap at %p\n",buffer);
                ProjectedMapNML * p = static_cast<ProjectedMapNML*>(buffer);
                p->~ProjectedMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ProjectedMap at %p, is flat\n",buffer);
            }
            break;
        } 
        case ProjectedMapInfo::ID:
        {
            // only need to destruct if data type is not flat
            if (ProjectedMapInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ProjectedMapInfo at %p\n",buffer);
                ProjectedMapInfoNML * p = static_cast<ProjectedMapInfoNML*>(buffer);
                p->~ProjectedMapInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ProjectedMapInfo at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapROIRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapROIRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapROIRequest at %p\n",buffer);
                GetMapROIRequestNML * p = static_cast<GetMapROIRequestNML*>(buffer);
                p->~GetMapROIRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapROIRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapROIResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapROIResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapROIResponse at %p\n",buffer);
                GetMapROIResponseNML * p = static_cast<GetMapROIResponseNML*>(buffer);
                p->~GetMapROIResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapROIResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapROI::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapROI::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapROI at %p\n",buffer);
                GetMapROINML * p = static_cast<GetMapROINML*>(buffer);
                p->~GetMapROINML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapROI at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPointMapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPointMapRequest at %p\n",buffer);
                GetPointMapRequestNML * p = static_cast<GetPointMapRequestNML*>(buffer);
                p->~GetPointMapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPointMapRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPointMapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPointMapResponse at %p\n",buffer);
                GetPointMapResponseNML * p = static_cast<GetPointMapResponseNML*>(buffer);
                p->~GetPointMapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPointMapResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMap::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPointMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPointMap at %p\n",buffer);
                GetPointMapNML * p = static_cast<GetPointMapNML*>(buffer);
                p->~GetPointMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPointMap at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapROIRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPointMapROIRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPointMapROIRequest at %p\n",buffer);
                GetPointMapROIRequestNML * p = static_cast<GetPointMapROIRequestNML*>(buffer);
                p->~GetPointMapROIRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPointMapROIRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapROIResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPointMapROIResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPointMapROIResponse at %p\n",buffer);
                GetPointMapROIResponseNML * p = static_cast<GetPointMapROIResponseNML*>(buffer);
                p->~GetPointMapROIResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPointMapROIResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPointMapROI::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPointMapROI::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPointMapROI at %p\n",buffer);
                GetPointMapROINML * p = static_cast<GetPointMapROINML*>(buffer);
                p->~GetPointMapROINML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPointMapROI at %p, is flat\n",buffer);
            }
            break;
        } 
        case ProjectedMapsInfo::ID:
        {
            // only need to destruct if data type is not flat
            if (ProjectedMapsInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ProjectedMapsInfo at %p\n",buffer);
                ProjectedMapsInfoNML * p = static_cast<ProjectedMapsInfoNML*>(buffer);
                p->~ProjectedMapsInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ProjectedMapsInfo at %p, is flat\n",buffer);
            }
            break;
        } 
        case SaveMap::ID:
        {
            // only need to destruct if data type is not flat
            if (SaveMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SaveMap at %p\n",buffer);
                SaveMapNML * p = static_cast<SaveMapNML*>(buffer);
                p->~SaveMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SaveMap at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetMapProjectionsRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetMapProjectionsRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetMapProjectionsRequest at %p\n",buffer);
                SetMapProjectionsRequestNML * p = static_cast<SetMapProjectionsRequestNML*>(buffer);
                p->~SetMapProjectionsRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetMapProjectionsRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetMapProjectionsResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetMapProjectionsResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetMapProjectionsResponse at %p\n",buffer);
                SetMapProjectionsResponseNML * p = static_cast<SetMapProjectionsResponseNML*>(buffer);
                p->~SetMapProjectionsResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetMapProjectionsResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetMapProjections::ID:
        {
            // only need to destruct if data type is not flat
            if (SetMapProjections::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetMapProjections at %p\n",buffer);
                SetMapProjectionsNML * p = static_cast<SetMapProjectionsNML*>(buffer);
                p->~SetMapProjectionsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetMapProjections at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void map_msgs::nmlupdate(CMS * cms, OccupancyGridUpdate & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate OccupancyGridUpdate, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.width);
        cms->update(inobj.height);
        nmlupdate(cms,inobj.data);

    }  
 }

OccupancyGridUpdateNML::OccupancyGridUpdateNML() : NMLmsg((NMLTYPE)OccupancyGridUpdate::ID,sizeof(OccupancyGridUpdateNML)), nmlVersion(OccupancyGridUpdate::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new OccupancyGridUpdate()*/)
{
};

OccupancyGridUpdateNML::~OccupancyGridUpdateNML()
{
};

OccupancyGridUpdateNML & OccupancyGridUpdateNML::operator=(const OccupancyGridUpdateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

OccupancyGridUpdateNML & OccupancyGridUpdateNML::operator=(const OccupancyGridUpdate & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(OccupancyGridUpdate);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void OccupancyGridUpdateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<OccupancyGridUpdate&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: OccupancyGridUpdateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<OccupancyGridUpdate> temp(new OccupancyGridUpdate());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (OccupancyGridUpdate::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: OccupancyGridUpdate Message version mismatch, expected " << OccupancyGridUpdate::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: OccupancyGridUpdate Message version mismatch, expected " << OccupancyGridUpdate::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, PointCloud2Update & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointCloud2Update, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.type);
        nmlupdate(cms,inobj.points);

    }  
 }

PointCloud2UpdateNML::PointCloud2UpdateNML() : NMLmsg((NMLTYPE)PointCloud2Update::ID,sizeof(PointCloud2UpdateNML)), nmlVersion(PointCloud2Update::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointCloud2Update()*/)
{
};

PointCloud2UpdateNML::~PointCloud2UpdateNML()
{
};

PointCloud2UpdateNML & PointCloud2UpdateNML::operator=(const PointCloud2UpdateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointCloud2UpdateNML & PointCloud2UpdateNML::operator=(const PointCloud2Update & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointCloud2Update);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointCloud2UpdateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointCloud2Update&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointCloud2UpdateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointCloud2Update> temp(new PointCloud2Update());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointCloud2Update::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointCloud2Update Message version mismatch, expected " << PointCloud2Update::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointCloud2Update Message version mismatch, expected " << PointCloud2Update::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, ProjectedMap & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ProjectedMap, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.map);
        cms->update(inobj.min_z);
        cms->update(inobj.max_z);

    }  
 }

ProjectedMapNML::ProjectedMapNML() : NMLmsg((NMLTYPE)ProjectedMap::ID,sizeof(ProjectedMapNML)), nmlVersion(ProjectedMap::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ProjectedMap()*/)
{
};

ProjectedMapNML::~ProjectedMapNML()
{
};

ProjectedMapNML & ProjectedMapNML::operator=(const ProjectedMapNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ProjectedMapNML & ProjectedMapNML::operator=(const ProjectedMap & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ProjectedMap);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ProjectedMapNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ProjectedMap&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ProjectedMapNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ProjectedMap> temp(new ProjectedMap());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ProjectedMap::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ProjectedMap Message version mismatch, expected " << ProjectedMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ProjectedMap Message version mismatch, expected " << ProjectedMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, ProjectedMapInfo & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ProjectedMapInfo, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.frame_id);
        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.width);
        cms->update(inobj.height);
        cms->update(inobj.min_z);
        cms->update(inobj.max_z);

    }  
 }

ProjectedMapInfoNML::ProjectedMapInfoNML() : NMLmsg((NMLTYPE)ProjectedMapInfo::ID,sizeof(ProjectedMapInfoNML)), nmlVersion(ProjectedMapInfo::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ProjectedMapInfo()*/)
{
};

ProjectedMapInfoNML::~ProjectedMapInfoNML()
{
};

ProjectedMapInfoNML & ProjectedMapInfoNML::operator=(const ProjectedMapInfoNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ProjectedMapInfoNML & ProjectedMapInfoNML::operator=(const ProjectedMapInfo & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ProjectedMapInfo);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ProjectedMapInfoNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ProjectedMapInfo&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ProjectedMapInfoNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ProjectedMapInfo> temp(new ProjectedMapInfo());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ProjectedMapInfo::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ProjectedMapInfo Message version mismatch, expected " << ProjectedMapInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ProjectedMapInfo Message version mismatch, expected " << ProjectedMapInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetMapROIRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapROIRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.l_x);
        cms->update(inobj.l_y);

    }  
 }

GetMapROIRequestNML::GetMapROIRequestNML() : NMLmsg((NMLTYPE)GetMapROIRequest::ID,sizeof(GetMapROIRequestNML)), nmlVersion(GetMapROIRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapROIRequest()*/)
{
};

GetMapROIRequestNML::~GetMapROIRequestNML()
{
};

GetMapROIRequestNML & GetMapROIRequestNML::operator=(const GetMapROIRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapROIRequestNML & GetMapROIRequestNML::operator=(const GetMapROIRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapROIRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapROIRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapROIRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapROIRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapROIRequest> temp(new GetMapROIRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapROIRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapROIRequest Message version mismatch, expected " << GetMapROIRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapROIRequest Message version mismatch, expected " << GetMapROIRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetMapROIResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapROIResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.sub_map);

    }  
 }

GetMapROIResponseNML::GetMapROIResponseNML() : NMLmsg((NMLTYPE)GetMapROIResponse::ID,sizeof(GetMapROIResponseNML)), nmlVersion(GetMapROIResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapROIResponse()*/)
{
};

GetMapROIResponseNML::~GetMapROIResponseNML()
{
};

GetMapROIResponseNML & GetMapROIResponseNML::operator=(const GetMapROIResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapROIResponseNML & GetMapROIResponseNML::operator=(const GetMapROIResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapROIResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapROIResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapROIResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapROIResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapROIResponse> temp(new GetMapROIResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapROIResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapROIResponse Message version mismatch, expected " << GetMapROIResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapROIResponse Message version mismatch, expected " << GetMapROIResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetMapROI & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapROI, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetMapROINML::GetMapROINML() : NMLmsg((NMLTYPE)GetMapROI::ID,sizeof(GetMapROINML)), nmlVersion(GetMapROI::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapROI()*/)
{
};

GetMapROINML::~GetMapROINML()
{
};

GetMapROINML & GetMapROINML::operator=(const GetMapROINML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapROINML & GetMapROINML::operator=(const GetMapROI & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapROI);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapROINML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapROI&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapROINML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapROI> temp(new GetMapROI());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapROI::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapROI Message version mismatch, expected " << GetMapROI::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapROI Message version mismatch, expected " << GetMapROI::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetPointMapRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPointMapRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

GetPointMapRequestNML::GetPointMapRequestNML() : NMLmsg((NMLTYPE)GetPointMapRequest::ID,sizeof(GetPointMapRequestNML)), nmlVersion(GetPointMapRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPointMapRequest()*/)
{
};

GetPointMapRequestNML::~GetPointMapRequestNML()
{
};

GetPointMapRequestNML & GetPointMapRequestNML::operator=(const GetPointMapRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPointMapRequestNML & GetPointMapRequestNML::operator=(const GetPointMapRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPointMapRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPointMapRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPointMapRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPointMapRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPointMapRequest> temp(new GetPointMapRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPointMapRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPointMapRequest Message version mismatch, expected " << GetPointMapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPointMapRequest Message version mismatch, expected " << GetPointMapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetPointMapResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPointMapResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.map);

    }  
 }

GetPointMapResponseNML::GetPointMapResponseNML() : NMLmsg((NMLTYPE)GetPointMapResponse::ID,sizeof(GetPointMapResponseNML)), nmlVersion(GetPointMapResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPointMapResponse()*/)
{
};

GetPointMapResponseNML::~GetPointMapResponseNML()
{
};

GetPointMapResponseNML & GetPointMapResponseNML::operator=(const GetPointMapResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPointMapResponseNML & GetPointMapResponseNML::operator=(const GetPointMapResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPointMapResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPointMapResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPointMapResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPointMapResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPointMapResponse> temp(new GetPointMapResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPointMapResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPointMapResponse Message version mismatch, expected " << GetPointMapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPointMapResponse Message version mismatch, expected " << GetPointMapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetPointMap & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPointMap, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetPointMapNML::GetPointMapNML() : NMLmsg((NMLTYPE)GetPointMap::ID,sizeof(GetPointMapNML)), nmlVersion(GetPointMap::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPointMap()*/)
{
};

GetPointMapNML::~GetPointMapNML()
{
};

GetPointMapNML & GetPointMapNML::operator=(const GetPointMapNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPointMapNML & GetPointMapNML::operator=(const GetPointMap & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPointMap);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPointMapNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPointMap&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPointMapNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPointMap> temp(new GetPointMap());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPointMap::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPointMap Message version mismatch, expected " << GetPointMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPointMap Message version mismatch, expected " << GetPointMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetPointMapROIRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPointMapROIRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.z);
        cms->update(inobj.r);
        cms->update(inobj.l_x);
        cms->update(inobj.l_y);
        cms->update(inobj.l_z);

    }  
 }

GetPointMapROIRequestNML::GetPointMapROIRequestNML() : NMLmsg((NMLTYPE)GetPointMapROIRequest::ID,sizeof(GetPointMapROIRequestNML)), nmlVersion(GetPointMapROIRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPointMapROIRequest()*/)
{
};

GetPointMapROIRequestNML::~GetPointMapROIRequestNML()
{
};

GetPointMapROIRequestNML & GetPointMapROIRequestNML::operator=(const GetPointMapROIRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPointMapROIRequestNML & GetPointMapROIRequestNML::operator=(const GetPointMapROIRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPointMapROIRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPointMapROIRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPointMapROIRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPointMapROIRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPointMapROIRequest> temp(new GetPointMapROIRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPointMapROIRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPointMapROIRequest Message version mismatch, expected " << GetPointMapROIRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPointMapROIRequest Message version mismatch, expected " << GetPointMapROIRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetPointMapROIResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPointMapROIResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.sub_map);

    }  
 }

GetPointMapROIResponseNML::GetPointMapROIResponseNML() : NMLmsg((NMLTYPE)GetPointMapROIResponse::ID,sizeof(GetPointMapROIResponseNML)), nmlVersion(GetPointMapROIResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPointMapROIResponse()*/)
{
};

GetPointMapROIResponseNML::~GetPointMapROIResponseNML()
{
};

GetPointMapROIResponseNML & GetPointMapROIResponseNML::operator=(const GetPointMapROIResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPointMapROIResponseNML & GetPointMapROIResponseNML::operator=(const GetPointMapROIResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPointMapROIResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPointMapROIResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPointMapROIResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPointMapROIResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPointMapROIResponse> temp(new GetPointMapROIResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPointMapROIResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPointMapROIResponse Message version mismatch, expected " << GetPointMapROIResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPointMapROIResponse Message version mismatch, expected " << GetPointMapROIResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, GetPointMapROI & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPointMapROI, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetPointMapROINML::GetPointMapROINML() : NMLmsg((NMLTYPE)GetPointMapROI::ID,sizeof(GetPointMapROINML)), nmlVersion(GetPointMapROI::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPointMapROI()*/)
{
};

GetPointMapROINML::~GetPointMapROINML()
{
};

GetPointMapROINML & GetPointMapROINML::operator=(const GetPointMapROINML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPointMapROINML & GetPointMapROINML::operator=(const GetPointMapROI & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPointMapROI);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPointMapROINML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPointMapROI&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPointMapROINML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPointMapROI> temp(new GetPointMapROI());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPointMapROI::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPointMapROI Message version mismatch, expected " << GetPointMapROI::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPointMapROI Message version mismatch, expected " << GetPointMapROI::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, ProjectedMapsInfo & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ProjectedMapsInfo, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.projected_maps_info);

    }  
 }

ProjectedMapsInfoNML::ProjectedMapsInfoNML() : NMLmsg((NMLTYPE)ProjectedMapsInfo::ID,sizeof(ProjectedMapsInfoNML)), nmlVersion(ProjectedMapsInfo::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ProjectedMapsInfo()*/)
{
};

ProjectedMapsInfoNML::~ProjectedMapsInfoNML()
{
};

ProjectedMapsInfoNML & ProjectedMapsInfoNML::operator=(const ProjectedMapsInfoNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ProjectedMapsInfoNML & ProjectedMapsInfoNML::operator=(const ProjectedMapsInfo & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ProjectedMapsInfo);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ProjectedMapsInfoNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ProjectedMapsInfo&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ProjectedMapsInfoNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ProjectedMapsInfo> temp(new ProjectedMapsInfo());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ProjectedMapsInfo::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ProjectedMapsInfo Message version mismatch, expected " << ProjectedMapsInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ProjectedMapsInfo Message version mismatch, expected " << ProjectedMapsInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, SaveMap & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SaveMap, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.filename);

    }  
 }

SaveMapNML::SaveMapNML() : NMLmsg((NMLTYPE)SaveMap::ID,sizeof(SaveMapNML)), nmlVersion(SaveMap::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SaveMap()*/)
{
};

SaveMapNML::~SaveMapNML()
{
};

SaveMapNML & SaveMapNML::operator=(const SaveMapNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SaveMapNML & SaveMapNML::operator=(const SaveMap & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SaveMap);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SaveMapNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SaveMap&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SaveMapNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SaveMap> temp(new SaveMap());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SaveMap::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SaveMap Message version mismatch, expected " << SaveMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SaveMap Message version mismatch, expected " << SaveMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, SetMapProjectionsRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetMapProjectionsRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

SetMapProjectionsRequestNML::SetMapProjectionsRequestNML() : NMLmsg((NMLTYPE)SetMapProjectionsRequest::ID,sizeof(SetMapProjectionsRequestNML)), nmlVersion(SetMapProjectionsRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetMapProjectionsRequest()*/)
{
};

SetMapProjectionsRequestNML::~SetMapProjectionsRequestNML()
{
};

SetMapProjectionsRequestNML & SetMapProjectionsRequestNML::operator=(const SetMapProjectionsRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetMapProjectionsRequestNML & SetMapProjectionsRequestNML::operator=(const SetMapProjectionsRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetMapProjectionsRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetMapProjectionsRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetMapProjectionsRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetMapProjectionsRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetMapProjectionsRequest> temp(new SetMapProjectionsRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetMapProjectionsRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetMapProjectionsRequest Message version mismatch, expected " << SetMapProjectionsRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetMapProjectionsRequest Message version mismatch, expected " << SetMapProjectionsRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, SetMapProjectionsResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetMapProjectionsResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.projected_maps_info);

    }  
 }

SetMapProjectionsResponseNML::SetMapProjectionsResponseNML() : NMLmsg((NMLTYPE)SetMapProjectionsResponse::ID,sizeof(SetMapProjectionsResponseNML)), nmlVersion(SetMapProjectionsResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetMapProjectionsResponse()*/)
{
};

SetMapProjectionsResponseNML::~SetMapProjectionsResponseNML()
{
};

SetMapProjectionsResponseNML & SetMapProjectionsResponseNML::operator=(const SetMapProjectionsResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetMapProjectionsResponseNML & SetMapProjectionsResponseNML::operator=(const SetMapProjectionsResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetMapProjectionsResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetMapProjectionsResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetMapProjectionsResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetMapProjectionsResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetMapProjectionsResponse> temp(new SetMapProjectionsResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetMapProjectionsResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetMapProjectionsResponse Message version mismatch, expected " << SetMapProjectionsResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetMapProjectionsResponse Message version mismatch, expected " << SetMapProjectionsResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void map_msgs::nmlupdate(CMS * cms, SetMapProjections & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetMapProjections, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetMapProjectionsNML::SetMapProjectionsNML() : NMLmsg((NMLTYPE)SetMapProjections::ID,sizeof(SetMapProjectionsNML)), nmlVersion(SetMapProjections::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetMapProjections()*/)
{
};

SetMapProjectionsNML::~SetMapProjectionsNML()
{
};

SetMapProjectionsNML & SetMapProjectionsNML::operator=(const SetMapProjectionsNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetMapProjectionsNML & SetMapProjectionsNML::operator=(const SetMapProjections & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetMapProjections);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetMapProjectionsNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetMapProjections&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetMapProjectionsNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetMapProjections> temp(new SetMapProjections());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: map_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetMapProjections::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetMapProjections Message version mismatch, expected " << SetMapProjections::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetMapProjections Message version mismatch, expected " << SetMapProjections::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int map_msgs::map_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("map_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case OccupancyGridUpdate::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for OccupancyGridUpdate, id " << OccupancyGridUpdate::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((OccupancyGridUpdateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointCloud2Update::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointCloud2Update, id " << PointCloud2Update::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointCloud2UpdateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ProjectedMap::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ProjectedMap, id " << ProjectedMap::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ProjectedMapNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ProjectedMapInfo::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ProjectedMapInfo, id " << ProjectedMapInfo::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ProjectedMapInfoNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapROIRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapROIRequest, id " << GetMapROIRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapROIRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapROIResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapROIResponse, id " << GetMapROIResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapROIResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapROI::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapROI, id " << GetMapROI::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapROINML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPointMapRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPointMapRequest, id " << GetPointMapRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPointMapRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPointMapResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPointMapResponse, id " << GetPointMapResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPointMapResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPointMap::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPointMap, id " << GetPointMap::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPointMapNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPointMapROIRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPointMapROIRequest, id " << GetPointMapROIRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPointMapROIRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPointMapROIResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPointMapROIResponse, id " << GetPointMapROIResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPointMapROIResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPointMapROI::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPointMapROI, id " << GetPointMapROI::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPointMapROINML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ProjectedMapsInfo::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ProjectedMapsInfo, id " << ProjectedMapsInfo::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ProjectedMapsInfoNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SaveMap::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SaveMap, id " << SaveMap::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SaveMapNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetMapProjectionsRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetMapProjectionsRequest, id " << SetMapProjectionsRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetMapProjectionsRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetMapProjectionsResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetMapProjectionsResponse, id " << SetMapProjectionsResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetMapProjectionsResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetMapProjections::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetMapProjections, id " << SetMapProjections::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_map_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"map_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetMapProjectionsNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

