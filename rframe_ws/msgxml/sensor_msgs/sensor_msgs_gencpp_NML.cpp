// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:07 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "sensor_msgs_gencpp_NML.h"
#include "sensor_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <BatteryState.h>
#include <CameraInfo.h>
#include <ChannelFloat32.h>
#include <CompressedImage.h>
#include <FluidPressure.h>
#include <Illuminance.h>
#include <Image.h>
#include <Imu.h>
#include <JointState.h>
#include <Joy.h>
#include <JoyFeedback.h>
#include <JoyFeedbackArray.h>
#include <LaserEcho.h>
#include <LaserScan.h>
#include <MagneticField.h>
#include <MultiDOFJointState.h>
#include <MultiEchoLaserScan.h>
#include <NavSatFix.h>
#include <NavSatStatus.h>
#include <PointCloud.h>
#include <PointCloud2.h>
#include <PointField.h>
#include <Range.h>
#include <RegionOfInterest.h>
#include <RelativeHumidity.h>
#include <Temperature.h>
#include <TimeReference.h>
#include <SetCameraInfoRequest.h>
#include <SetCameraInfoResponse.h>
#include <SetCameraInfo.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace sensor_msgs;

rframe::NMLMessageFactory * NML_sensor_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_sensor_msgs_gencppfactory = new sensor_msgs_gencppNMLMessageFactory();
        return NML_sensor_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * sensor_msgs::allocate_sensor_msgs_gencpp()
{
    NML_sensor_msgs_gencppfactory = new sensor_msgs_gencppNMLMessageFactory();
    return NML_sensor_msgs_gencppfactory;
};

sensor_msgs_gencppNMLMessageFactory::sensor_msgs_gencppNMLMessageFactory()
{
    name("sensor_msgs_gencpp");
    // use constructor to register data types
    sensor_msgs::registerLibrary();
}

sensor_msgs_gencppNMLMessageFactory::~sensor_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR sensor_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return sensor_msgs_gencpp_format;
}

int sensor_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void sensor_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(BatteryState::ID);
    info.name(BatteryState::DATA_TYPE_FULL_NAME);
    info.hashKey(BatteryState::DATA_VERSION);
    info.md5Key(BatteryState::VERSION_MD5);
    info.xmlSource(BatteryState::XML_SOURCE);
    info.flat(BatteryState::dataTypeFlat());
    ids.push_back(info);

    info.id(CameraInfo::ID);
    info.name(CameraInfo::DATA_TYPE_FULL_NAME);
    info.hashKey(CameraInfo::DATA_VERSION);
    info.md5Key(CameraInfo::VERSION_MD5);
    info.xmlSource(CameraInfo::XML_SOURCE);
    info.flat(CameraInfo::dataTypeFlat());
    ids.push_back(info);

    info.id(ChannelFloat32::ID);
    info.name(ChannelFloat32::DATA_TYPE_FULL_NAME);
    info.hashKey(ChannelFloat32::DATA_VERSION);
    info.md5Key(ChannelFloat32::VERSION_MD5);
    info.xmlSource(ChannelFloat32::XML_SOURCE);
    info.flat(ChannelFloat32::dataTypeFlat());
    ids.push_back(info);

    info.id(CompressedImage::ID);
    info.name(CompressedImage::DATA_TYPE_FULL_NAME);
    info.hashKey(CompressedImage::DATA_VERSION);
    info.md5Key(CompressedImage::VERSION_MD5);
    info.xmlSource(CompressedImage::XML_SOURCE);
    info.flat(CompressedImage::dataTypeFlat());
    ids.push_back(info);

    info.id(FluidPressure::ID);
    info.name(FluidPressure::DATA_TYPE_FULL_NAME);
    info.hashKey(FluidPressure::DATA_VERSION);
    info.md5Key(FluidPressure::VERSION_MD5);
    info.xmlSource(FluidPressure::XML_SOURCE);
    info.flat(FluidPressure::dataTypeFlat());
    ids.push_back(info);

    info.id(Illuminance::ID);
    info.name(Illuminance::DATA_TYPE_FULL_NAME);
    info.hashKey(Illuminance::DATA_VERSION);
    info.md5Key(Illuminance::VERSION_MD5);
    info.xmlSource(Illuminance::XML_SOURCE);
    info.flat(Illuminance::dataTypeFlat());
    ids.push_back(info);

    info.id(Image::ID);
    info.name(Image::DATA_TYPE_FULL_NAME);
    info.hashKey(Image::DATA_VERSION);
    info.md5Key(Image::VERSION_MD5);
    info.xmlSource(Image::XML_SOURCE);
    info.flat(Image::dataTypeFlat());
    ids.push_back(info);

    info.id(Imu::ID);
    info.name(Imu::DATA_TYPE_FULL_NAME);
    info.hashKey(Imu::DATA_VERSION);
    info.md5Key(Imu::VERSION_MD5);
    info.xmlSource(Imu::XML_SOURCE);
    info.flat(Imu::dataTypeFlat());
    ids.push_back(info);

    info.id(JointState::ID);
    info.name(JointState::DATA_TYPE_FULL_NAME);
    info.hashKey(JointState::DATA_VERSION);
    info.md5Key(JointState::VERSION_MD5);
    info.xmlSource(JointState::XML_SOURCE);
    info.flat(JointState::dataTypeFlat());
    ids.push_back(info);

    info.id(Joy::ID);
    info.name(Joy::DATA_TYPE_FULL_NAME);
    info.hashKey(Joy::DATA_VERSION);
    info.md5Key(Joy::VERSION_MD5);
    info.xmlSource(Joy::XML_SOURCE);
    info.flat(Joy::dataTypeFlat());
    ids.push_back(info);

    info.id(JoyFeedback::ID);
    info.name(JoyFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(JoyFeedback::DATA_VERSION);
    info.md5Key(JoyFeedback::VERSION_MD5);
    info.xmlSource(JoyFeedback::XML_SOURCE);
    info.flat(JoyFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(JoyFeedbackArray::ID);
    info.name(JoyFeedbackArray::DATA_TYPE_FULL_NAME);
    info.hashKey(JoyFeedbackArray::DATA_VERSION);
    info.md5Key(JoyFeedbackArray::VERSION_MD5);
    info.xmlSource(JoyFeedbackArray::XML_SOURCE);
    info.flat(JoyFeedbackArray::dataTypeFlat());
    ids.push_back(info);

    info.id(LaserEcho::ID);
    info.name(LaserEcho::DATA_TYPE_FULL_NAME);
    info.hashKey(LaserEcho::DATA_VERSION);
    info.md5Key(LaserEcho::VERSION_MD5);
    info.xmlSource(LaserEcho::XML_SOURCE);
    info.flat(LaserEcho::dataTypeFlat());
    ids.push_back(info);

    info.id(LaserScan::ID);
    info.name(LaserScan::DATA_TYPE_FULL_NAME);
    info.hashKey(LaserScan::DATA_VERSION);
    info.md5Key(LaserScan::VERSION_MD5);
    info.xmlSource(LaserScan::XML_SOURCE);
    info.flat(LaserScan::dataTypeFlat());
    ids.push_back(info);

    info.id(MagneticField::ID);
    info.name(MagneticField::DATA_TYPE_FULL_NAME);
    info.hashKey(MagneticField::DATA_VERSION);
    info.md5Key(MagneticField::VERSION_MD5);
    info.xmlSource(MagneticField::XML_SOURCE);
    info.flat(MagneticField::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiDOFJointState::ID);
    info.name(MultiDOFJointState::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiDOFJointState::DATA_VERSION);
    info.md5Key(MultiDOFJointState::VERSION_MD5);
    info.xmlSource(MultiDOFJointState::XML_SOURCE);
    info.flat(MultiDOFJointState::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiEchoLaserScan::ID);
    info.name(MultiEchoLaserScan::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiEchoLaserScan::DATA_VERSION);
    info.md5Key(MultiEchoLaserScan::VERSION_MD5);
    info.xmlSource(MultiEchoLaserScan::XML_SOURCE);
    info.flat(MultiEchoLaserScan::dataTypeFlat());
    ids.push_back(info);

    info.id(NavSatFix::ID);
    info.name(NavSatFix::DATA_TYPE_FULL_NAME);
    info.hashKey(NavSatFix::DATA_VERSION);
    info.md5Key(NavSatFix::VERSION_MD5);
    info.xmlSource(NavSatFix::XML_SOURCE);
    info.flat(NavSatFix::dataTypeFlat());
    ids.push_back(info);

    info.id(NavSatStatus::ID);
    info.name(NavSatStatus::DATA_TYPE_FULL_NAME);
    info.hashKey(NavSatStatus::DATA_VERSION);
    info.md5Key(NavSatStatus::VERSION_MD5);
    info.xmlSource(NavSatStatus::XML_SOURCE);
    info.flat(NavSatStatus::dataTypeFlat());
    ids.push_back(info);

    info.id(PointCloud::ID);
    info.name(PointCloud::DATA_TYPE_FULL_NAME);
    info.hashKey(PointCloud::DATA_VERSION);
    info.md5Key(PointCloud::VERSION_MD5);
    info.xmlSource(PointCloud::XML_SOURCE);
    info.flat(PointCloud::dataTypeFlat());
    ids.push_back(info);

    info.id(PointCloud2::ID);
    info.name(PointCloud2::DATA_TYPE_FULL_NAME);
    info.hashKey(PointCloud2::DATA_VERSION);
    info.md5Key(PointCloud2::VERSION_MD5);
    info.xmlSource(PointCloud2::XML_SOURCE);
    info.flat(PointCloud2::dataTypeFlat());
    ids.push_back(info);

    info.id(PointField::ID);
    info.name(PointField::DATA_TYPE_FULL_NAME);
    info.hashKey(PointField::DATA_VERSION);
    info.md5Key(PointField::VERSION_MD5);
    info.xmlSource(PointField::XML_SOURCE);
    info.flat(PointField::dataTypeFlat());
    ids.push_back(info);

    info.id(Range::ID);
    info.name(Range::DATA_TYPE_FULL_NAME);
    info.hashKey(Range::DATA_VERSION);
    info.md5Key(Range::VERSION_MD5);
    info.xmlSource(Range::XML_SOURCE);
    info.flat(Range::dataTypeFlat());
    ids.push_back(info);

    info.id(RegionOfInterest::ID);
    info.name(RegionOfInterest::DATA_TYPE_FULL_NAME);
    info.hashKey(RegionOfInterest::DATA_VERSION);
    info.md5Key(RegionOfInterest::VERSION_MD5);
    info.xmlSource(RegionOfInterest::XML_SOURCE);
    info.flat(RegionOfInterest::dataTypeFlat());
    ids.push_back(info);

    info.id(RelativeHumidity::ID);
    info.name(RelativeHumidity::DATA_TYPE_FULL_NAME);
    info.hashKey(RelativeHumidity::DATA_VERSION);
    info.md5Key(RelativeHumidity::VERSION_MD5);
    info.xmlSource(RelativeHumidity::XML_SOURCE);
    info.flat(RelativeHumidity::dataTypeFlat());
    ids.push_back(info);

    info.id(Temperature::ID);
    info.name(Temperature::DATA_TYPE_FULL_NAME);
    info.hashKey(Temperature::DATA_VERSION);
    info.md5Key(Temperature::VERSION_MD5);
    info.xmlSource(Temperature::XML_SOURCE);
    info.flat(Temperature::dataTypeFlat());
    ids.push_back(info);

    info.id(TimeReference::ID);
    info.name(TimeReference::DATA_TYPE_FULL_NAME);
    info.hashKey(TimeReference::DATA_VERSION);
    info.md5Key(TimeReference::VERSION_MD5);
    info.xmlSource(TimeReference::XML_SOURCE);
    info.flat(TimeReference::dataTypeFlat());
    ids.push_back(info);

    info.id(SetCameraInfoRequest::ID);
    info.name(SetCameraInfoRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetCameraInfoRequest::DATA_VERSION);
    info.md5Key(SetCameraInfoRequest::VERSION_MD5);
    info.xmlSource(SetCameraInfoRequest::XML_SOURCE);
    info.flat(SetCameraInfoRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetCameraInfoResponse::ID);
    info.name(SetCameraInfoResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetCameraInfoResponse::DATA_VERSION);
    info.md5Key(SetCameraInfoResponse::VERSION_MD5);
    info.xmlSource(SetCameraInfoResponse::XML_SOURCE);
    info.flat(SetCameraInfoResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetCameraInfo::ID);
    info.name(SetCameraInfo::DATA_TYPE_FULL_NAME);
    info.hashKey(SetCameraInfo::DATA_VERSION);
    info.md5Key(SetCameraInfo::VERSION_MD5);
    info.xmlSource(SetCameraInfo::XML_SOURCE);
    info.flat(SetCameraInfo::dataTypeFlat());
    ids.push_back(info);

}

int sensor_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case BatteryState::ID:
        {
            //BatteryStateNML * newmsg = new BatteryStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new BatteryStateNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case CameraInfo::ID:
        {
            //CameraInfoNML * newmsg = new CameraInfoNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new CameraInfoNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ChannelFloat32::ID:
        {
            //ChannelFloat32NML * newmsg = new ChannelFloat32NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ChannelFloat32NML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case CompressedImage::ID:
        {
            //CompressedImageNML * newmsg = new CompressedImageNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new CompressedImageNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FluidPressure::ID:
        {
            //FluidPressureNML * newmsg = new FluidPressureNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FluidPressureNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Illuminance::ID:
        {
            //IlluminanceNML * newmsg = new IlluminanceNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new IlluminanceNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Image::ID:
        {
            //ImageNML * newmsg = new ImageNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ImageNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Imu::ID:
        {
            //ImuNML * newmsg = new ImuNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ImuNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointState::ID:
        {
            //JointStateNML * newmsg = new JointStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointStateNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Joy::ID:
        {
            //JoyNML * newmsg = new JoyNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JoyNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JoyFeedback::ID:
        {
            //JoyFeedbackNML * newmsg = new JoyFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JoyFeedbackNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JoyFeedbackArray::ID:
        {
            //JoyFeedbackArrayNML * newmsg = new JoyFeedbackArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JoyFeedbackArrayNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LaserEcho::ID:
        {
            //LaserEchoNML * newmsg = new LaserEchoNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LaserEchoNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LaserScan::ID:
        {
            //LaserScanNML * newmsg = new LaserScanNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LaserScanNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MagneticField::ID:
        {
            //MagneticFieldNML * newmsg = new MagneticFieldNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MagneticFieldNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MultiDOFJointState::ID:
        {
            //MultiDOFJointStateNML * newmsg = new MultiDOFJointStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MultiDOFJointStateNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MultiEchoLaserScan::ID:
        {
            //MultiEchoLaserScanNML * newmsg = new MultiEchoLaserScanNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MultiEchoLaserScanNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NavSatFix::ID:
        {
            //NavSatFixNML * newmsg = new NavSatFixNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NavSatFixNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NavSatStatus::ID:
        {
            //NavSatStatusNML * newmsg = new NavSatStatusNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NavSatStatusNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointCloud::ID:
        {
            //PointCloudNML * newmsg = new PointCloudNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointCloudNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointCloud2::ID:
        {
            //PointCloud2NML * newmsg = new PointCloud2NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointCloud2NML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointField::ID:
        {
            //PointFieldNML * newmsg = new PointFieldNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointFieldNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Range::ID:
        {
            //RangeNML * newmsg = new RangeNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new RangeNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case RegionOfInterest::ID:
        {
            //RegionOfInterestNML * newmsg = new RegionOfInterestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new RegionOfInterestNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case RelativeHumidity::ID:
        {
            //RelativeHumidityNML * newmsg = new RelativeHumidityNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new RelativeHumidityNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Temperature::ID:
        {
            //TemperatureNML * newmsg = new TemperatureNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TemperatureNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TimeReference::ID:
        {
            //TimeReferenceNML * newmsg = new TimeReferenceNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TimeReferenceNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetCameraInfoRequest::ID:
        {
            //SetCameraInfoRequestNML * newmsg = new SetCameraInfoRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetCameraInfoRequestNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetCameraInfoResponse::ID:
        {
            //SetCameraInfoResponseNML * newmsg = new SetCameraInfoResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetCameraInfoResponseNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetCameraInfo::ID:
        {
            //SetCameraInfoNML * newmsg = new SetCameraInfoNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetCameraInfoNML(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case BatteryState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BatteryState>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case CameraInfo::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<CameraInfo>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ChannelFloat32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ChannelFloat32>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case CompressedImage::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<CompressedImage>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FluidPressure::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FluidPressure>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Illuminance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Illuminance>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Image::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Image>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Imu::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Imu>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointState>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Joy::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Joy>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JoyFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JoyFeedback>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JoyFeedbackArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JoyFeedbackArray>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LaserEcho::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LaserEcho>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LaserScan::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LaserScan>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MagneticField::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MagneticField>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiDOFJointState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiDOFJointState>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiEchoLaserScan::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiEchoLaserScan>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NavSatFix::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NavSatFix>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NavSatStatus::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NavSatStatus>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointCloud::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointCloud>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointCloud2::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointCloud2>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointField::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointField>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Range::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Range>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case RegionOfInterest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<RegionOfInterest>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case RelativeHumidity::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<RelativeHumidity>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Temperature::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Temperature>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TimeReference::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TimeReference>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetCameraInfoRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetCameraInfoRequest>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetCameraInfoResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetCameraInfoResponse>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetCameraInfo::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetCameraInfo>(),std::bind(&sensor_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case BatteryState::ID:
            {
                BatteryStateNML * tempmsg = static_cast<BatteryStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case CameraInfo::ID:
            {
                CameraInfoNML * tempmsg = static_cast<CameraInfoNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ChannelFloat32::ID:
            {
                ChannelFloat32NML * tempmsg = static_cast<ChannelFloat32NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case CompressedImage::ID:
            {
                CompressedImageNML * tempmsg = static_cast<CompressedImageNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FluidPressure::ID:
            {
                FluidPressureNML * tempmsg = static_cast<FluidPressureNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Illuminance::ID:
            {
                IlluminanceNML * tempmsg = static_cast<IlluminanceNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Image::ID:
            {
                ImageNML * tempmsg = static_cast<ImageNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Imu::ID:
            {
                ImuNML * tempmsg = static_cast<ImuNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointState::ID:
            {
                JointStateNML * tempmsg = static_cast<JointStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Joy::ID:
            {
                JoyNML * tempmsg = static_cast<JoyNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JoyFeedback::ID:
            {
                JoyFeedbackNML * tempmsg = static_cast<JoyFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JoyFeedbackArray::ID:
            {
                JoyFeedbackArrayNML * tempmsg = static_cast<JoyFeedbackArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LaserEcho::ID:
            {
                LaserEchoNML * tempmsg = static_cast<LaserEchoNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LaserScan::ID:
            {
                LaserScanNML * tempmsg = static_cast<LaserScanNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MagneticField::ID:
            {
                MagneticFieldNML * tempmsg = static_cast<MagneticFieldNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MultiDOFJointState::ID:
            {
                MultiDOFJointStateNML * tempmsg = static_cast<MultiDOFJointStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MultiEchoLaserScan::ID:
            {
                MultiEchoLaserScanNML * tempmsg = static_cast<MultiEchoLaserScanNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NavSatFix::ID:
            {
                NavSatFixNML * tempmsg = static_cast<NavSatFixNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NavSatStatus::ID:
            {
                NavSatStatusNML * tempmsg = static_cast<NavSatStatusNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointCloud::ID:
            {
                PointCloudNML * tempmsg = static_cast<PointCloudNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointCloud2::ID:
            {
                PointCloud2NML * tempmsg = static_cast<PointCloud2NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointField::ID:
            {
                PointFieldNML * tempmsg = static_cast<PointFieldNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Range::ID:
            {
                RangeNML * tempmsg = static_cast<RangeNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case RegionOfInterest::ID:
            {
                RegionOfInterestNML * tempmsg = static_cast<RegionOfInterestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case RelativeHumidity::ID:
            {
                RelativeHumidityNML * tempmsg = static_cast<RelativeHumidityNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Temperature::ID:
            {
                TemperatureNML * tempmsg = static_cast<TemperatureNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TimeReference::ID:
            {
                TimeReferenceNML * tempmsg = static_cast<TimeReferenceNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetCameraInfoRequest::ID:
            {
                SetCameraInfoRequestNML * tempmsg = static_cast<SetCameraInfoRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetCameraInfoResponse::ID:
            {
                SetCameraInfoResponseNML * tempmsg = static_cast<SetCameraInfoResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetCameraInfo::ID:
            {
                SetCameraInfoNML * tempmsg = static_cast<SetCameraInfoNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case BatteryState::ID:
            {
                BatteryStateNML & tempDst = static_cast<BatteryStateNML&>(dst);
                Message<BatteryState > & tempSrc = static_cast<Message<BatteryState>&>(src);

                if (tempSrc.version() != BatteryState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of BatteryState: " << __FILE__ << " expected: " 
                             << BatteryState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of BatteryState: " << __FILE__ << " expected: " 
                         << BatteryState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case CameraInfo::ID:
            {
                CameraInfoNML & tempDst = static_cast<CameraInfoNML&>(dst);
                Message<CameraInfo > & tempSrc = static_cast<Message<CameraInfo>&>(src);

                if (tempSrc.version() != CameraInfo::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of CameraInfo: " << __FILE__ << " expected: " 
                             << CameraInfo::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of CameraInfo: " << __FILE__ << " expected: " 
                         << CameraInfo::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ChannelFloat32::ID:
            {
                ChannelFloat32NML & tempDst = static_cast<ChannelFloat32NML&>(dst);
                Message<ChannelFloat32 > & tempSrc = static_cast<Message<ChannelFloat32>&>(src);

                if (tempSrc.version() != ChannelFloat32::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ChannelFloat32: " << __FILE__ << " expected: " 
                             << ChannelFloat32::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ChannelFloat32: " << __FILE__ << " expected: " 
                         << ChannelFloat32::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case CompressedImage::ID:
            {
                CompressedImageNML & tempDst = static_cast<CompressedImageNML&>(dst);
                Message<CompressedImage > & tempSrc = static_cast<Message<CompressedImage>&>(src);

                if (tempSrc.version() != CompressedImage::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of CompressedImage: " << __FILE__ << " expected: " 
                             << CompressedImage::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of CompressedImage: " << __FILE__ << " expected: " 
                         << CompressedImage::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FluidPressure::ID:
            {
                FluidPressureNML & tempDst = static_cast<FluidPressureNML&>(dst);
                Message<FluidPressure > & tempSrc = static_cast<Message<FluidPressure>&>(src);

                if (tempSrc.version() != FluidPressure::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FluidPressure: " << __FILE__ << " expected: " 
                             << FluidPressure::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FluidPressure: " << __FILE__ << " expected: " 
                         << FluidPressure::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Illuminance::ID:
            {
                IlluminanceNML & tempDst = static_cast<IlluminanceNML&>(dst);
                Message<Illuminance > & tempSrc = static_cast<Message<Illuminance>&>(src);

                if (tempSrc.version() != Illuminance::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Illuminance: " << __FILE__ << " expected: " 
                             << Illuminance::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Illuminance: " << __FILE__ << " expected: " 
                         << Illuminance::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Image::ID:
            {
                ImageNML & tempDst = static_cast<ImageNML&>(dst);
                Message<Image > & tempSrc = static_cast<Message<Image>&>(src);

                if (tempSrc.version() != Image::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Image: " << __FILE__ << " expected: " 
                             << Image::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Image: " << __FILE__ << " expected: " 
                         << Image::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Imu::ID:
            {
                ImuNML & tempDst = static_cast<ImuNML&>(dst);
                Message<Imu > & tempSrc = static_cast<Message<Imu>&>(src);

                if (tempSrc.version() != Imu::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Imu: " << __FILE__ << " expected: " 
                             << Imu::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Imu: " << __FILE__ << " expected: " 
                         << Imu::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointState::ID:
            {
                JointStateNML & tempDst = static_cast<JointStateNML&>(dst);
                Message<JointState > & tempSrc = static_cast<Message<JointState>&>(src);

                if (tempSrc.version() != JointState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointState: " << __FILE__ << " expected: " 
                             << JointState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointState: " << __FILE__ << " expected: " 
                         << JointState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Joy::ID:
            {
                JoyNML & tempDst = static_cast<JoyNML&>(dst);
                Message<Joy > & tempSrc = static_cast<Message<Joy>&>(src);

                if (tempSrc.version() != Joy::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Joy: " << __FILE__ << " expected: " 
                             << Joy::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Joy: " << __FILE__ << " expected: " 
                         << Joy::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JoyFeedback::ID:
            {
                JoyFeedbackNML & tempDst = static_cast<JoyFeedbackNML&>(dst);
                Message<JoyFeedback > & tempSrc = static_cast<Message<JoyFeedback>&>(src);

                if (tempSrc.version() != JoyFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JoyFeedback: " << __FILE__ << " expected: " 
                             << JoyFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JoyFeedback: " << __FILE__ << " expected: " 
                         << JoyFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JoyFeedbackArray::ID:
            {
                JoyFeedbackArrayNML & tempDst = static_cast<JoyFeedbackArrayNML&>(dst);
                Message<JoyFeedbackArray > & tempSrc = static_cast<Message<JoyFeedbackArray>&>(src);

                if (tempSrc.version() != JoyFeedbackArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JoyFeedbackArray: " << __FILE__ << " expected: " 
                             << JoyFeedbackArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JoyFeedbackArray: " << __FILE__ << " expected: " 
                         << JoyFeedbackArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LaserEcho::ID:
            {
                LaserEchoNML & tempDst = static_cast<LaserEchoNML&>(dst);
                Message<LaserEcho > & tempSrc = static_cast<Message<LaserEcho>&>(src);

                if (tempSrc.version() != LaserEcho::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LaserEcho: " << __FILE__ << " expected: " 
                             << LaserEcho::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LaserEcho: " << __FILE__ << " expected: " 
                         << LaserEcho::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LaserScan::ID:
            {
                LaserScanNML & tempDst = static_cast<LaserScanNML&>(dst);
                Message<LaserScan > & tempSrc = static_cast<Message<LaserScan>&>(src);

                if (tempSrc.version() != LaserScan::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LaserScan: " << __FILE__ << " expected: " 
                             << LaserScan::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LaserScan: " << __FILE__ << " expected: " 
                         << LaserScan::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MagneticField::ID:
            {
                MagneticFieldNML & tempDst = static_cast<MagneticFieldNML&>(dst);
                Message<MagneticField > & tempSrc = static_cast<Message<MagneticField>&>(src);

                if (tempSrc.version() != MagneticField::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MagneticField: " << __FILE__ << " expected: " 
                             << MagneticField::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MagneticField: " << __FILE__ << " expected: " 
                         << MagneticField::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MultiDOFJointState::ID:
            {
                MultiDOFJointStateNML & tempDst = static_cast<MultiDOFJointStateNML&>(dst);
                Message<MultiDOFJointState > & tempSrc = static_cast<Message<MultiDOFJointState>&>(src);

                if (tempSrc.version() != MultiDOFJointState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MultiDOFJointState: " << __FILE__ << " expected: " 
                             << MultiDOFJointState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MultiDOFJointState: " << __FILE__ << " expected: " 
                         << MultiDOFJointState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MultiEchoLaserScan::ID:
            {
                MultiEchoLaserScanNML & tempDst = static_cast<MultiEchoLaserScanNML&>(dst);
                Message<MultiEchoLaserScan > & tempSrc = static_cast<Message<MultiEchoLaserScan>&>(src);

                if (tempSrc.version() != MultiEchoLaserScan::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MultiEchoLaserScan: " << __FILE__ << " expected: " 
                             << MultiEchoLaserScan::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MultiEchoLaserScan: " << __FILE__ << " expected: " 
                         << MultiEchoLaserScan::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NavSatFix::ID:
            {
                NavSatFixNML & tempDst = static_cast<NavSatFixNML&>(dst);
                Message<NavSatFix > & tempSrc = static_cast<Message<NavSatFix>&>(src);

                if (tempSrc.version() != NavSatFix::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NavSatFix: " << __FILE__ << " expected: " 
                             << NavSatFix::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NavSatFix: " << __FILE__ << " expected: " 
                         << NavSatFix::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NavSatStatus::ID:
            {
                NavSatStatusNML & tempDst = static_cast<NavSatStatusNML&>(dst);
                Message<NavSatStatus > & tempSrc = static_cast<Message<NavSatStatus>&>(src);

                if (tempSrc.version() != NavSatStatus::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NavSatStatus: " << __FILE__ << " expected: " 
                             << NavSatStatus::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NavSatStatus: " << __FILE__ << " expected: " 
                         << NavSatStatus::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointCloud::ID:
            {
                PointCloudNML & tempDst = static_cast<PointCloudNML&>(dst);
                Message<PointCloud > & tempSrc = static_cast<Message<PointCloud>&>(src);

                if (tempSrc.version() != PointCloud::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointCloud: " << __FILE__ << " expected: " 
                             << PointCloud::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointCloud: " << __FILE__ << " expected: " 
                         << PointCloud::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointCloud2::ID:
            {
                PointCloud2NML & tempDst = static_cast<PointCloud2NML&>(dst);
                Message<PointCloud2 > & tempSrc = static_cast<Message<PointCloud2>&>(src);

                if (tempSrc.version() != PointCloud2::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointCloud2: " << __FILE__ << " expected: " 
                             << PointCloud2::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointCloud2: " << __FILE__ << " expected: " 
                         << PointCloud2::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointField::ID:
            {
                PointFieldNML & tempDst = static_cast<PointFieldNML&>(dst);
                Message<PointField > & tempSrc = static_cast<Message<PointField>&>(src);

                if (tempSrc.version() != PointField::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointField: " << __FILE__ << " expected: " 
                             << PointField::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointField: " << __FILE__ << " expected: " 
                         << PointField::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Range::ID:
            {
                RangeNML & tempDst = static_cast<RangeNML&>(dst);
                Message<Range > & tempSrc = static_cast<Message<Range>&>(src);

                if (tempSrc.version() != Range::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Range: " << __FILE__ << " expected: " 
                             << Range::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Range: " << __FILE__ << " expected: " 
                         << Range::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case RegionOfInterest::ID:
            {
                RegionOfInterestNML & tempDst = static_cast<RegionOfInterestNML&>(dst);
                Message<RegionOfInterest > & tempSrc = static_cast<Message<RegionOfInterest>&>(src);

                if (tempSrc.version() != RegionOfInterest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of RegionOfInterest: " << __FILE__ << " expected: " 
                             << RegionOfInterest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of RegionOfInterest: " << __FILE__ << " expected: " 
                         << RegionOfInterest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case RelativeHumidity::ID:
            {
                RelativeHumidityNML & tempDst = static_cast<RelativeHumidityNML&>(dst);
                Message<RelativeHumidity > & tempSrc = static_cast<Message<RelativeHumidity>&>(src);

                if (tempSrc.version() != RelativeHumidity::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of RelativeHumidity: " << __FILE__ << " expected: " 
                             << RelativeHumidity::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of RelativeHumidity: " << __FILE__ << " expected: " 
                         << RelativeHumidity::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Temperature::ID:
            {
                TemperatureNML & tempDst = static_cast<TemperatureNML&>(dst);
                Message<Temperature > & tempSrc = static_cast<Message<Temperature>&>(src);

                if (tempSrc.version() != Temperature::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Temperature: " << __FILE__ << " expected: " 
                             << Temperature::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Temperature: " << __FILE__ << " expected: " 
                         << Temperature::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TimeReference::ID:
            {
                TimeReferenceNML & tempDst = static_cast<TimeReferenceNML&>(dst);
                Message<TimeReference > & tempSrc = static_cast<Message<TimeReference>&>(src);

                if (tempSrc.version() != TimeReference::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TimeReference: " << __FILE__ << " expected: " 
                             << TimeReference::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TimeReference: " << __FILE__ << " expected: " 
                         << TimeReference::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetCameraInfoRequest::ID:
            {
                SetCameraInfoRequestNML & tempDst = static_cast<SetCameraInfoRequestNML&>(dst);
                Message<SetCameraInfoRequest > & tempSrc = static_cast<Message<SetCameraInfoRequest>&>(src);

                if (tempSrc.version() != SetCameraInfoRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetCameraInfoRequest: " << __FILE__ << " expected: " 
                             << SetCameraInfoRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetCameraInfoRequest: " << __FILE__ << " expected: " 
                         << SetCameraInfoRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetCameraInfoResponse::ID:
            {
                SetCameraInfoResponseNML & tempDst = static_cast<SetCameraInfoResponseNML&>(dst);
                Message<SetCameraInfoResponse > & tempSrc = static_cast<Message<SetCameraInfoResponse>&>(src);

                if (tempSrc.version() != SetCameraInfoResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetCameraInfoResponse: " << __FILE__ << " expected: " 
                             << SetCameraInfoResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetCameraInfoResponse: " << __FILE__ << " expected: " 
                         << SetCameraInfoResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetCameraInfo::ID:
            {
                SetCameraInfoNML & tempDst = static_cast<SetCameraInfoNML&>(dst);
                Message<SetCameraInfo > & tempSrc = static_cast<Message<SetCameraInfo>&>(src);

                if (tempSrc.version() != SetCameraInfo::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetCameraInfo: " << __FILE__ << " expected: " 
                             << SetCameraInfo::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetCameraInfo: " << __FILE__ << " expected: " 
                         << SetCameraInfo::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case BatteryState::ID:
            {
                BatteryStateNML & tempSrc = static_cast<BatteryStateNML&>(src);
                Message<BatteryState > & tempDst = static_cast<Message<BatteryState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (BatteryState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case CameraInfo::ID:
            {
                CameraInfoNML & tempSrc = static_cast<CameraInfoNML&>(src);
                Message<CameraInfo > & tempDst = static_cast<Message<CameraInfo>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (CameraInfo::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ChannelFloat32::ID:
            {
                ChannelFloat32NML & tempSrc = static_cast<ChannelFloat32NML&>(src);
                Message<ChannelFloat32 > & tempDst = static_cast<Message<ChannelFloat32>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ChannelFloat32::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case CompressedImage::ID:
            {
                CompressedImageNML & tempSrc = static_cast<CompressedImageNML&>(src);
                Message<CompressedImage > & tempDst = static_cast<Message<CompressedImage>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (CompressedImage::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FluidPressure::ID:
            {
                FluidPressureNML & tempSrc = static_cast<FluidPressureNML&>(src);
                Message<FluidPressure > & tempDst = static_cast<Message<FluidPressure>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FluidPressure::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Illuminance::ID:
            {
                IlluminanceNML & tempSrc = static_cast<IlluminanceNML&>(src);
                Message<Illuminance > & tempDst = static_cast<Message<Illuminance>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Illuminance::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Image::ID:
            {
                ImageNML & tempSrc = static_cast<ImageNML&>(src);
                Message<Image > & tempDst = static_cast<Message<Image>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Image::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Imu::ID:
            {
                ImuNML & tempSrc = static_cast<ImuNML&>(src);
                Message<Imu > & tempDst = static_cast<Message<Imu>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Imu::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointState::ID:
            {
                JointStateNML & tempSrc = static_cast<JointStateNML&>(src);
                Message<JointState > & tempDst = static_cast<Message<JointState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Joy::ID:
            {
                JoyNML & tempSrc = static_cast<JoyNML&>(src);
                Message<Joy > & tempDst = static_cast<Message<Joy>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Joy::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JoyFeedback::ID:
            {
                JoyFeedbackNML & tempSrc = static_cast<JoyFeedbackNML&>(src);
                Message<JoyFeedback > & tempDst = static_cast<Message<JoyFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JoyFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JoyFeedbackArray::ID:
            {
                JoyFeedbackArrayNML & tempSrc = static_cast<JoyFeedbackArrayNML&>(src);
                Message<JoyFeedbackArray > & tempDst = static_cast<Message<JoyFeedbackArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JoyFeedbackArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LaserEcho::ID:
            {
                LaserEchoNML & tempSrc = static_cast<LaserEchoNML&>(src);
                Message<LaserEcho > & tempDst = static_cast<Message<LaserEcho>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LaserEcho::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LaserScan::ID:
            {
                LaserScanNML & tempSrc = static_cast<LaserScanNML&>(src);
                Message<LaserScan > & tempDst = static_cast<Message<LaserScan>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LaserScan::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MagneticField::ID:
            {
                MagneticFieldNML & tempSrc = static_cast<MagneticFieldNML&>(src);
                Message<MagneticField > & tempDst = static_cast<Message<MagneticField>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MagneticField::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MultiDOFJointState::ID:
            {
                MultiDOFJointStateNML & tempSrc = static_cast<MultiDOFJointStateNML&>(src);
                Message<MultiDOFJointState > & tempDst = static_cast<Message<MultiDOFJointState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MultiDOFJointState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MultiEchoLaserScan::ID:
            {
                MultiEchoLaserScanNML & tempSrc = static_cast<MultiEchoLaserScanNML&>(src);
                Message<MultiEchoLaserScan > & tempDst = static_cast<Message<MultiEchoLaserScan>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MultiEchoLaserScan::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NavSatFix::ID:
            {
                NavSatFixNML & tempSrc = static_cast<NavSatFixNML&>(src);
                Message<NavSatFix > & tempDst = static_cast<Message<NavSatFix>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NavSatFix::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NavSatStatus::ID:
            {
                NavSatStatusNML & tempSrc = static_cast<NavSatStatusNML&>(src);
                Message<NavSatStatus > & tempDst = static_cast<Message<NavSatStatus>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NavSatStatus::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointCloud::ID:
            {
                PointCloudNML & tempSrc = static_cast<PointCloudNML&>(src);
                Message<PointCloud > & tempDst = static_cast<Message<PointCloud>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointCloud::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointCloud2::ID:
            {
                PointCloud2NML & tempSrc = static_cast<PointCloud2NML&>(src);
                Message<PointCloud2 > & tempDst = static_cast<Message<PointCloud2>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointCloud2::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointField::ID:
            {
                PointFieldNML & tempSrc = static_cast<PointFieldNML&>(src);
                Message<PointField > & tempDst = static_cast<Message<PointField>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointField::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Range::ID:
            {
                RangeNML & tempSrc = static_cast<RangeNML&>(src);
                Message<Range > & tempDst = static_cast<Message<Range>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Range::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case RegionOfInterest::ID:
            {
                RegionOfInterestNML & tempSrc = static_cast<RegionOfInterestNML&>(src);
                Message<RegionOfInterest > & tempDst = static_cast<Message<RegionOfInterest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (RegionOfInterest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case RelativeHumidity::ID:
            {
                RelativeHumidityNML & tempSrc = static_cast<RelativeHumidityNML&>(src);
                Message<RelativeHumidity > & tempDst = static_cast<Message<RelativeHumidity>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (RelativeHumidity::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Temperature::ID:
            {
                TemperatureNML & tempSrc = static_cast<TemperatureNML&>(src);
                Message<Temperature > & tempDst = static_cast<Message<Temperature>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Temperature::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TimeReference::ID:
            {
                TimeReferenceNML & tempSrc = static_cast<TimeReferenceNML&>(src);
                Message<TimeReference > & tempDst = static_cast<Message<TimeReference>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TimeReference::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetCameraInfoRequest::ID:
            {
                SetCameraInfoRequestNML & tempSrc = static_cast<SetCameraInfoRequestNML&>(src);
                Message<SetCameraInfoRequest > & tempDst = static_cast<Message<SetCameraInfoRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetCameraInfoRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetCameraInfoResponse::ID:
            {
                SetCameraInfoResponseNML & tempSrc = static_cast<SetCameraInfoResponseNML&>(src);
                Message<SetCameraInfoResponse > & tempDst = static_cast<Message<SetCameraInfoResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetCameraInfoResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetCameraInfo::ID:
            {
                SetCameraInfoNML & tempSrc = static_cast<SetCameraInfoNML&>(src);
                Message<SetCameraInfo > & tempDst = static_cast<Message<SetCameraInfo>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetCameraInfo::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case BatteryState::ID:
        {
            // only need to construct if data type is not flat
            if (BatteryState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing BatteryState at %p\n",buffer);
                BatteryStateNML * p = static_cast<BatteryStateNML*>(buffer);
                // construct the type at pointer p
                new (p) BatteryStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing BatteryState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case CameraInfo::ID:
        {
            // only need to construct if data type is not flat
            if (CameraInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing CameraInfo at %p\n",buffer);
                CameraInfoNML * p = static_cast<CameraInfoNML*>(buffer);
                // construct the type at pointer p
                new (p) CameraInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing CameraInfo at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ChannelFloat32::ID:
        {
            // only need to construct if data type is not flat
            if (ChannelFloat32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ChannelFloat32 at %p\n",buffer);
                ChannelFloat32NML * p = static_cast<ChannelFloat32NML*>(buffer);
                // construct the type at pointer p
                new (p) ChannelFloat32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ChannelFloat32 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case CompressedImage::ID:
        {
            // only need to construct if data type is not flat
            if (CompressedImage::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing CompressedImage at %p\n",buffer);
                CompressedImageNML * p = static_cast<CompressedImageNML*>(buffer);
                // construct the type at pointer p
                new (p) CompressedImageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing CompressedImage at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FluidPressure::ID:
        {
            // only need to construct if data type is not flat
            if (FluidPressure::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FluidPressure at %p\n",buffer);
                FluidPressureNML * p = static_cast<FluidPressureNML*>(buffer);
                // construct the type at pointer p
                new (p) FluidPressureNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FluidPressure at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Illuminance::ID:
        {
            // only need to construct if data type is not flat
            if (Illuminance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Illuminance at %p\n",buffer);
                IlluminanceNML * p = static_cast<IlluminanceNML*>(buffer);
                // construct the type at pointer p
                new (p) IlluminanceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Illuminance at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Image::ID:
        {
            // only need to construct if data type is not flat
            if (Image::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Image at %p\n",buffer);
                ImageNML * p = static_cast<ImageNML*>(buffer);
                // construct the type at pointer p
                new (p) ImageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Image at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Imu::ID:
        {
            // only need to construct if data type is not flat
            if (Imu::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Imu at %p\n",buffer);
                ImuNML * p = static_cast<ImuNML*>(buffer);
                // construct the type at pointer p
                new (p) ImuNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Imu at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointState::ID:
        {
            // only need to construct if data type is not flat
            if (JointState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointState at %p\n",buffer);
                JointStateNML * p = static_cast<JointStateNML*>(buffer);
                // construct the type at pointer p
                new (p) JointStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Joy::ID:
        {
            // only need to construct if data type is not flat
            if (Joy::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Joy at %p\n",buffer);
                JoyNML * p = static_cast<JoyNML*>(buffer);
                // construct the type at pointer p
                new (p) JoyNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Joy at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JoyFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (JoyFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JoyFeedback at %p\n",buffer);
                JoyFeedbackNML * p = static_cast<JoyFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) JoyFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JoyFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JoyFeedbackArray::ID:
        {
            // only need to construct if data type is not flat
            if (JoyFeedbackArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JoyFeedbackArray at %p\n",buffer);
                JoyFeedbackArrayNML * p = static_cast<JoyFeedbackArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) JoyFeedbackArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JoyFeedbackArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LaserEcho::ID:
        {
            // only need to construct if data type is not flat
            if (LaserEcho::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LaserEcho at %p\n",buffer);
                LaserEchoNML * p = static_cast<LaserEchoNML*>(buffer);
                // construct the type at pointer p
                new (p) LaserEchoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LaserEcho at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LaserScan::ID:
        {
            // only need to construct if data type is not flat
            if (LaserScan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LaserScan at %p\n",buffer);
                LaserScanNML * p = static_cast<LaserScanNML*>(buffer);
                // construct the type at pointer p
                new (p) LaserScanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LaserScan at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MagneticField::ID:
        {
            // only need to construct if data type is not flat
            if (MagneticField::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MagneticField at %p\n",buffer);
                MagneticFieldNML * p = static_cast<MagneticFieldNML*>(buffer);
                // construct the type at pointer p
                new (p) MagneticFieldNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MagneticField at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MultiDOFJointState::ID:
        {
            // only need to construct if data type is not flat
            if (MultiDOFJointState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MultiDOFJointState at %p\n",buffer);
                MultiDOFJointStateNML * p = static_cast<MultiDOFJointStateNML*>(buffer);
                // construct the type at pointer p
                new (p) MultiDOFJointStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MultiDOFJointState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MultiEchoLaserScan::ID:
        {
            // only need to construct if data type is not flat
            if (MultiEchoLaserScan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MultiEchoLaserScan at %p\n",buffer);
                MultiEchoLaserScanNML * p = static_cast<MultiEchoLaserScanNML*>(buffer);
                // construct the type at pointer p
                new (p) MultiEchoLaserScanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MultiEchoLaserScan at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NavSatFix::ID:
        {
            // only need to construct if data type is not flat
            if (NavSatFix::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NavSatFix at %p\n",buffer);
                NavSatFixNML * p = static_cast<NavSatFixNML*>(buffer);
                // construct the type at pointer p
                new (p) NavSatFixNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NavSatFix at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NavSatStatus::ID:
        {
            // only need to construct if data type is not flat
            if (NavSatStatus::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NavSatStatus at %p\n",buffer);
                NavSatStatusNML * p = static_cast<NavSatStatusNML*>(buffer);
                // construct the type at pointer p
                new (p) NavSatStatusNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NavSatStatus at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointCloud::ID:
        {
            // only need to construct if data type is not flat
            if (PointCloud::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointCloud at %p\n",buffer);
                PointCloudNML * p = static_cast<PointCloudNML*>(buffer);
                // construct the type at pointer p
                new (p) PointCloudNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointCloud at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointCloud2::ID:
        {
            // only need to construct if data type is not flat
            if (PointCloud2::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointCloud2 at %p\n",buffer);
                PointCloud2NML * p = static_cast<PointCloud2NML*>(buffer);
                // construct the type at pointer p
                new (p) PointCloud2NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointCloud2 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointField::ID:
        {
            // only need to construct if data type is not flat
            if (PointField::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointField at %p\n",buffer);
                PointFieldNML * p = static_cast<PointFieldNML*>(buffer);
                // construct the type at pointer p
                new (p) PointFieldNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointField at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Range::ID:
        {
            // only need to construct if data type is not flat
            if (Range::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Range at %p\n",buffer);
                RangeNML * p = static_cast<RangeNML*>(buffer);
                // construct the type at pointer p
                new (p) RangeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Range at %p,, is flat\n",buffer);
            }
            break;
        } 
        case RegionOfInterest::ID:
        {
            // only need to construct if data type is not flat
            if (RegionOfInterest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing RegionOfInterest at %p\n",buffer);
                RegionOfInterestNML * p = static_cast<RegionOfInterestNML*>(buffer);
                // construct the type at pointer p
                new (p) RegionOfInterestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing RegionOfInterest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case RelativeHumidity::ID:
        {
            // only need to construct if data type is not flat
            if (RelativeHumidity::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing RelativeHumidity at %p\n",buffer);
                RelativeHumidityNML * p = static_cast<RelativeHumidityNML*>(buffer);
                // construct the type at pointer p
                new (p) RelativeHumidityNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing RelativeHumidity at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Temperature::ID:
        {
            // only need to construct if data type is not flat
            if (Temperature::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Temperature at %p\n",buffer);
                TemperatureNML * p = static_cast<TemperatureNML*>(buffer);
                // construct the type at pointer p
                new (p) TemperatureNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Temperature at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TimeReference::ID:
        {
            // only need to construct if data type is not flat
            if (TimeReference::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TimeReference at %p\n",buffer);
                TimeReferenceNML * p = static_cast<TimeReferenceNML*>(buffer);
                // construct the type at pointer p
                new (p) TimeReferenceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TimeReference at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetCameraInfoRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetCameraInfoRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetCameraInfoRequest at %p\n",buffer);
                SetCameraInfoRequestNML * p = static_cast<SetCameraInfoRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetCameraInfoRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetCameraInfoRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetCameraInfoResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetCameraInfoResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetCameraInfoResponse at %p\n",buffer);
                SetCameraInfoResponseNML * p = static_cast<SetCameraInfoResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetCameraInfoResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetCameraInfoResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetCameraInfo::ID:
        {
            // only need to construct if data type is not flat
            if (SetCameraInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetCameraInfo at %p\n",buffer);
                SetCameraInfoNML * p = static_cast<SetCameraInfoNML*>(buffer);
                // construct the type at pointer p
                new (p) SetCameraInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetCameraInfo at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int sensor_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case BatteryState::ID:
        {
            // only need to destruct if data type is not flat
            if (BatteryState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing BatteryState at %p\n",buffer);
                BatteryStateNML * p = static_cast<BatteryStateNML*>(buffer);
                p->~BatteryStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction BatteryState at %p, is flat\n",buffer);
            }
            break;
        } 
        case CameraInfo::ID:
        {
            // only need to destruct if data type is not flat
            if (CameraInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing CameraInfo at %p\n",buffer);
                CameraInfoNML * p = static_cast<CameraInfoNML*>(buffer);
                p->~CameraInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction CameraInfo at %p, is flat\n",buffer);
            }
            break;
        } 
        case ChannelFloat32::ID:
        {
            // only need to destruct if data type is not flat
            if (ChannelFloat32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ChannelFloat32 at %p\n",buffer);
                ChannelFloat32NML * p = static_cast<ChannelFloat32NML*>(buffer);
                p->~ChannelFloat32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ChannelFloat32 at %p, is flat\n",buffer);
            }
            break;
        } 
        case CompressedImage::ID:
        {
            // only need to destruct if data type is not flat
            if (CompressedImage::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing CompressedImage at %p\n",buffer);
                CompressedImageNML * p = static_cast<CompressedImageNML*>(buffer);
                p->~CompressedImageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction CompressedImage at %p, is flat\n",buffer);
            }
            break;
        } 
        case FluidPressure::ID:
        {
            // only need to destruct if data type is not flat
            if (FluidPressure::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FluidPressure at %p\n",buffer);
                FluidPressureNML * p = static_cast<FluidPressureNML*>(buffer);
                p->~FluidPressureNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FluidPressure at %p, is flat\n",buffer);
            }
            break;
        } 
        case Illuminance::ID:
        {
            // only need to destruct if data type is not flat
            if (Illuminance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Illuminance at %p\n",buffer);
                IlluminanceNML * p = static_cast<IlluminanceNML*>(buffer);
                p->~IlluminanceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Illuminance at %p, is flat\n",buffer);
            }
            break;
        } 
        case Image::ID:
        {
            // only need to destruct if data type is not flat
            if (Image::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Image at %p\n",buffer);
                ImageNML * p = static_cast<ImageNML*>(buffer);
                p->~ImageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Image at %p, is flat\n",buffer);
            }
            break;
        } 
        case Imu::ID:
        {
            // only need to destruct if data type is not flat
            if (Imu::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Imu at %p\n",buffer);
                ImuNML * p = static_cast<ImuNML*>(buffer);
                p->~ImuNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Imu at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointState::ID:
        {
            // only need to destruct if data type is not flat
            if (JointState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointState at %p\n",buffer);
                JointStateNML * p = static_cast<JointStateNML*>(buffer);
                p->~JointStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointState at %p, is flat\n",buffer);
            }
            break;
        } 
        case Joy::ID:
        {
            // only need to destruct if data type is not flat
            if (Joy::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Joy at %p\n",buffer);
                JoyNML * p = static_cast<JoyNML*>(buffer);
                p->~JoyNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Joy at %p, is flat\n",buffer);
            }
            break;
        } 
        case JoyFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (JoyFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JoyFeedback at %p\n",buffer);
                JoyFeedbackNML * p = static_cast<JoyFeedbackNML*>(buffer);
                p->~JoyFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JoyFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case JoyFeedbackArray::ID:
        {
            // only need to destruct if data type is not flat
            if (JoyFeedbackArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JoyFeedbackArray at %p\n",buffer);
                JoyFeedbackArrayNML * p = static_cast<JoyFeedbackArrayNML*>(buffer);
                p->~JoyFeedbackArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JoyFeedbackArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case LaserEcho::ID:
        {
            // only need to destruct if data type is not flat
            if (LaserEcho::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LaserEcho at %p\n",buffer);
                LaserEchoNML * p = static_cast<LaserEchoNML*>(buffer);
                p->~LaserEchoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LaserEcho at %p, is flat\n",buffer);
            }
            break;
        } 
        case LaserScan::ID:
        {
            // only need to destruct if data type is not flat
            if (LaserScan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LaserScan at %p\n",buffer);
                LaserScanNML * p = static_cast<LaserScanNML*>(buffer);
                p->~LaserScanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LaserScan at %p, is flat\n",buffer);
            }
            break;
        } 
        case MagneticField::ID:
        {
            // only need to destruct if data type is not flat
            if (MagneticField::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MagneticField at %p\n",buffer);
                MagneticFieldNML * p = static_cast<MagneticFieldNML*>(buffer);
                p->~MagneticFieldNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MagneticField at %p, is flat\n",buffer);
            }
            break;
        } 
        case MultiDOFJointState::ID:
        {
            // only need to destruct if data type is not flat
            if (MultiDOFJointState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MultiDOFJointState at %p\n",buffer);
                MultiDOFJointStateNML * p = static_cast<MultiDOFJointStateNML*>(buffer);
                p->~MultiDOFJointStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MultiDOFJointState at %p, is flat\n",buffer);
            }
            break;
        } 
        case MultiEchoLaserScan::ID:
        {
            // only need to destruct if data type is not flat
            if (MultiEchoLaserScan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MultiEchoLaserScan at %p\n",buffer);
                MultiEchoLaserScanNML * p = static_cast<MultiEchoLaserScanNML*>(buffer);
                p->~MultiEchoLaserScanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MultiEchoLaserScan at %p, is flat\n",buffer);
            }
            break;
        } 
        case NavSatFix::ID:
        {
            // only need to destruct if data type is not flat
            if (NavSatFix::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NavSatFix at %p\n",buffer);
                NavSatFixNML * p = static_cast<NavSatFixNML*>(buffer);
                p->~NavSatFixNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NavSatFix at %p, is flat\n",buffer);
            }
            break;
        } 
        case NavSatStatus::ID:
        {
            // only need to destruct if data type is not flat
            if (NavSatStatus::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NavSatStatus at %p\n",buffer);
                NavSatStatusNML * p = static_cast<NavSatStatusNML*>(buffer);
                p->~NavSatStatusNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NavSatStatus at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointCloud::ID:
        {
            // only need to destruct if data type is not flat
            if (PointCloud::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointCloud at %p\n",buffer);
                PointCloudNML * p = static_cast<PointCloudNML*>(buffer);
                p->~PointCloudNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointCloud at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointCloud2::ID:
        {
            // only need to destruct if data type is not flat
            if (PointCloud2::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointCloud2 at %p\n",buffer);
                PointCloud2NML * p = static_cast<PointCloud2NML*>(buffer);
                p->~PointCloud2NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointCloud2 at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointField::ID:
        {
            // only need to destruct if data type is not flat
            if (PointField::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointField at %p\n",buffer);
                PointFieldNML * p = static_cast<PointFieldNML*>(buffer);
                p->~PointFieldNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointField at %p, is flat\n",buffer);
            }
            break;
        } 
        case Range::ID:
        {
            // only need to destruct if data type is not flat
            if (Range::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Range at %p\n",buffer);
                RangeNML * p = static_cast<RangeNML*>(buffer);
                p->~RangeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Range at %p, is flat\n",buffer);
            }
            break;
        } 
        case RegionOfInterest::ID:
        {
            // only need to destruct if data type is not flat
            if (RegionOfInterest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing RegionOfInterest at %p\n",buffer);
                RegionOfInterestNML * p = static_cast<RegionOfInterestNML*>(buffer);
                p->~RegionOfInterestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction RegionOfInterest at %p, is flat\n",buffer);
            }
            break;
        } 
        case RelativeHumidity::ID:
        {
            // only need to destruct if data type is not flat
            if (RelativeHumidity::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing RelativeHumidity at %p\n",buffer);
                RelativeHumidityNML * p = static_cast<RelativeHumidityNML*>(buffer);
                p->~RelativeHumidityNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction RelativeHumidity at %p, is flat\n",buffer);
            }
            break;
        } 
        case Temperature::ID:
        {
            // only need to destruct if data type is not flat
            if (Temperature::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Temperature at %p\n",buffer);
                TemperatureNML * p = static_cast<TemperatureNML*>(buffer);
                p->~TemperatureNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Temperature at %p, is flat\n",buffer);
            }
            break;
        } 
        case TimeReference::ID:
        {
            // only need to destruct if data type is not flat
            if (TimeReference::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TimeReference at %p\n",buffer);
                TimeReferenceNML * p = static_cast<TimeReferenceNML*>(buffer);
                p->~TimeReferenceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TimeReference at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetCameraInfoRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetCameraInfoRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetCameraInfoRequest at %p\n",buffer);
                SetCameraInfoRequestNML * p = static_cast<SetCameraInfoRequestNML*>(buffer);
                p->~SetCameraInfoRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetCameraInfoRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetCameraInfoResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetCameraInfoResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetCameraInfoResponse at %p\n",buffer);
                SetCameraInfoResponseNML * p = static_cast<SetCameraInfoResponseNML*>(buffer);
                p->~SetCameraInfoResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetCameraInfoResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetCameraInfo::ID:
        {
            // only need to destruct if data type is not flat
            if (SetCameraInfo::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetCameraInfo at %p\n",buffer);
                SetCameraInfoNML * p = static_cast<SetCameraInfoNML*>(buffer);
                p->~SetCameraInfoNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetCameraInfo at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void sensor_msgs::nmlupdate(CMS * cms, BatteryState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate BatteryState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.voltage);
        cms->update(inobj.current);
        cms->update(inobj.charge);
        cms->update(inobj.capacity);
        cms->update(inobj.design_capacity);
        cms->update(inobj.percentage);
        cms->update(inobj.power_supply_status);
        cms->update(inobj.power_supply_health);
        cms->update(inobj.power_supply_technology);
        cms->update(inobj.present);
        nmlupdate(cms,inobj.cell_voltage);
        nmlupdate(cms,inobj.location);
        nmlupdate(cms,inobj.serial_number);

    }  
 }

BatteryStateNML::BatteryStateNML() : NMLmsg((NMLTYPE)BatteryState::ID,sizeof(BatteryStateNML)), nmlVersion(BatteryState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new BatteryState()*/)
{
};

BatteryStateNML::~BatteryStateNML()
{
};

BatteryStateNML & BatteryStateNML::operator=(const BatteryStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

BatteryStateNML & BatteryStateNML::operator=(const BatteryState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(BatteryState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void BatteryStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<BatteryState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: BatteryStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<BatteryState> temp(new BatteryState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (BatteryState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: BatteryState Message version mismatch, expected " << BatteryState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: BatteryState Message version mismatch, expected " << BatteryState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, CameraInfo & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate CameraInfo, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.height);
        cms->update(inobj.width);
        nmlupdate(cms,inobj.distortion_model);
        nmlupdate(cms,inobj.D);
        cms->update(inobj.K.data(),9); 
        cms->update(inobj.R.data(),9); 
        cms->update(inobj.P.data(),12); 
        cms->update(inobj.binning_x);
        cms->update(inobj.binning_y);
        nmlupdate(cms,inobj.roi);

    }  
 }

CameraInfoNML::CameraInfoNML() : NMLmsg((NMLTYPE)CameraInfo::ID,sizeof(CameraInfoNML)), nmlVersion(CameraInfo::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new CameraInfo()*/)
{
};

CameraInfoNML::~CameraInfoNML()
{
};

CameraInfoNML & CameraInfoNML::operator=(const CameraInfoNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

CameraInfoNML & CameraInfoNML::operator=(const CameraInfo & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(CameraInfo);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void CameraInfoNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<CameraInfo&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: CameraInfoNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<CameraInfo> temp(new CameraInfo());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (CameraInfo::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: CameraInfo Message version mismatch, expected " << CameraInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: CameraInfo Message version mismatch, expected " << CameraInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, ChannelFloat32 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ChannelFloat32, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.values);

    }  
 }

ChannelFloat32NML::ChannelFloat32NML() : NMLmsg((NMLTYPE)ChannelFloat32::ID,sizeof(ChannelFloat32NML)), nmlVersion(ChannelFloat32::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ChannelFloat32()*/)
{
};

ChannelFloat32NML::~ChannelFloat32NML()
{
};

ChannelFloat32NML & ChannelFloat32NML::operator=(const ChannelFloat32NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ChannelFloat32NML & ChannelFloat32NML::operator=(const ChannelFloat32 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ChannelFloat32);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ChannelFloat32NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ChannelFloat32&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ChannelFloat32NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ChannelFloat32> temp(new ChannelFloat32());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ChannelFloat32::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ChannelFloat32 Message version mismatch, expected " << ChannelFloat32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ChannelFloat32 Message version mismatch, expected " << ChannelFloat32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, CompressedImage & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate CompressedImage, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.format);
        nmlupdate(cms,inobj.data);

    }  
 }

CompressedImageNML::CompressedImageNML() : NMLmsg((NMLTYPE)CompressedImage::ID,sizeof(CompressedImageNML)), nmlVersion(CompressedImage::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new CompressedImage()*/)
{
};

CompressedImageNML::~CompressedImageNML()
{
};

CompressedImageNML & CompressedImageNML::operator=(const CompressedImageNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

CompressedImageNML & CompressedImageNML::operator=(const CompressedImage & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(CompressedImage);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void CompressedImageNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<CompressedImage&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: CompressedImageNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<CompressedImage> temp(new CompressedImage());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (CompressedImage::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: CompressedImage Message version mismatch, expected " << CompressedImage::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: CompressedImage Message version mismatch, expected " << CompressedImage::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, FluidPressure & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FluidPressure, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.fluid_pressure);
        cms->update(inobj.variance);

    }  
 }

FluidPressureNML::FluidPressureNML() : NMLmsg((NMLTYPE)FluidPressure::ID,sizeof(FluidPressureNML)), nmlVersion(FluidPressure::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FluidPressure()*/)
{
};

FluidPressureNML::~FluidPressureNML()
{
};

FluidPressureNML & FluidPressureNML::operator=(const FluidPressureNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FluidPressureNML & FluidPressureNML::operator=(const FluidPressure & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FluidPressure);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FluidPressureNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FluidPressure&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FluidPressureNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FluidPressure> temp(new FluidPressure());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FluidPressure::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FluidPressure Message version mismatch, expected " << FluidPressure::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FluidPressure Message version mismatch, expected " << FluidPressure::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, Illuminance & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Illuminance, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.illuminance);
        cms->update(inobj.variance);

    }  
 }

IlluminanceNML::IlluminanceNML() : NMLmsg((NMLTYPE)Illuminance::ID,sizeof(IlluminanceNML)), nmlVersion(Illuminance::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Illuminance()*/)
{
};

IlluminanceNML::~IlluminanceNML()
{
};

IlluminanceNML & IlluminanceNML::operator=(const IlluminanceNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

IlluminanceNML & IlluminanceNML::operator=(const Illuminance & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Illuminance);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void IlluminanceNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Illuminance&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: IlluminanceNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Illuminance> temp(new Illuminance());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Illuminance::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Illuminance Message version mismatch, expected " << Illuminance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Illuminance Message version mismatch, expected " << Illuminance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, Image & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Image, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.height);
        cms->update(inobj.width);
        nmlupdate(cms,inobj.encoding);
        cms->update(inobj.is_bigendian);
        cms->update(inobj.step);
        nmlupdate(cms,inobj.data);

    }  
 }

ImageNML::ImageNML() : NMLmsg((NMLTYPE)Image::ID,sizeof(ImageNML)), nmlVersion(Image::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Image()*/)
{
};

ImageNML::~ImageNML()
{
};

ImageNML & ImageNML::operator=(const ImageNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ImageNML & ImageNML::operator=(const Image & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Image);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ImageNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Image&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ImageNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Image> temp(new Image());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Image::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Image Message version mismatch, expected " << Image::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Image Message version mismatch, expected " << Image::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, Imu & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Imu, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.orientation);
        cms->update(inobj.orientation_covariance.data(),9); 
        nmlupdate(cms,inobj.angular_velocity);
        cms->update(inobj.angular_velocity_covariance.data(),9); 
        nmlupdate(cms,inobj.linear_acceleration);
        cms->update(inobj.linear_acceleration_covariance.data(),9); 

    }  
 }

ImuNML::ImuNML() : NMLmsg((NMLTYPE)Imu::ID,sizeof(ImuNML)), nmlVersion(Imu::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Imu()*/)
{
};

ImuNML::~ImuNML()
{
};

ImuNML & ImuNML::operator=(const ImuNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ImuNML & ImuNML::operator=(const Imu & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Imu);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ImuNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Imu&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ImuNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Imu> temp(new Imu());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Imu::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Imu Message version mismatch, expected " << Imu::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Imu Message version mismatch, expected " << Imu::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, JointState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.position);
        nmlupdate(cms,inobj.velocity);
        nmlupdate(cms,inobj.effort);

    }  
 }

JointStateNML::JointStateNML() : NMLmsg((NMLTYPE)JointState::ID,sizeof(JointStateNML)), nmlVersion(JointState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointState()*/)
{
};

JointStateNML::~JointStateNML()
{
};

JointStateNML & JointStateNML::operator=(const JointStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointStateNML & JointStateNML::operator=(const JointState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointState> temp(new JointState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointState Message version mismatch, expected " << JointState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointState Message version mismatch, expected " << JointState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, Joy & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Joy, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.axes);
        nmlupdate(cms,inobj.buttons);

    }  
 }

JoyNML::JoyNML() : NMLmsg((NMLTYPE)Joy::ID,sizeof(JoyNML)), nmlVersion(Joy::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Joy()*/)
{
};

JoyNML::~JoyNML()
{
};

JoyNML & JoyNML::operator=(const JoyNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JoyNML & JoyNML::operator=(const Joy & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Joy);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JoyNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Joy&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JoyNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Joy> temp(new Joy());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Joy::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Joy Message version mismatch, expected " << Joy::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Joy Message version mismatch, expected " << Joy::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, JoyFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JoyFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.type);
        cms->update(inobj.id);
        cms->update(inobj.intensity);

    }  
 }

JoyFeedbackNML::JoyFeedbackNML() : NMLmsg((NMLTYPE)JoyFeedback::ID,sizeof(JoyFeedbackNML)), nmlVersion(JoyFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JoyFeedback()*/)
{
};

JoyFeedbackNML::~JoyFeedbackNML()
{
};

JoyFeedbackNML & JoyFeedbackNML::operator=(const JoyFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JoyFeedbackNML & JoyFeedbackNML::operator=(const JoyFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JoyFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JoyFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JoyFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JoyFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JoyFeedback> temp(new JoyFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JoyFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JoyFeedback Message version mismatch, expected " << JoyFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JoyFeedback Message version mismatch, expected " << JoyFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, JoyFeedbackArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JoyFeedbackArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.array);

    }  
 }

JoyFeedbackArrayNML::JoyFeedbackArrayNML() : NMLmsg((NMLTYPE)JoyFeedbackArray::ID,sizeof(JoyFeedbackArrayNML)), nmlVersion(JoyFeedbackArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JoyFeedbackArray()*/)
{
};

JoyFeedbackArrayNML::~JoyFeedbackArrayNML()
{
};

JoyFeedbackArrayNML & JoyFeedbackArrayNML::operator=(const JoyFeedbackArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JoyFeedbackArrayNML & JoyFeedbackArrayNML::operator=(const JoyFeedbackArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JoyFeedbackArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JoyFeedbackArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JoyFeedbackArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JoyFeedbackArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JoyFeedbackArray> temp(new JoyFeedbackArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JoyFeedbackArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JoyFeedbackArray Message version mismatch, expected " << JoyFeedbackArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JoyFeedbackArray Message version mismatch, expected " << JoyFeedbackArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, LaserEcho & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LaserEcho, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.echoes);

    }  
 }

LaserEchoNML::LaserEchoNML() : NMLmsg((NMLTYPE)LaserEcho::ID,sizeof(LaserEchoNML)), nmlVersion(LaserEcho::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LaserEcho()*/)
{
};

LaserEchoNML::~LaserEchoNML()
{
};

LaserEchoNML & LaserEchoNML::operator=(const LaserEchoNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LaserEchoNML & LaserEchoNML::operator=(const LaserEcho & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LaserEcho);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LaserEchoNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LaserEcho&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LaserEchoNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LaserEcho> temp(new LaserEcho());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LaserEcho::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LaserEcho Message version mismatch, expected " << LaserEcho::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LaserEcho Message version mismatch, expected " << LaserEcho::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, LaserScan & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LaserScan, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.angle_min);
        cms->update(inobj.angle_max);
        cms->update(inobj.angle_increment);
        cms->update(inobj.time_increment);
        cms->update(inobj.scan_time);
        cms->update(inobj.range_min);
        cms->update(inobj.range_max);
        nmlupdate(cms,inobj.ranges);
        nmlupdate(cms,inobj.intensities);

    }  
 }

LaserScanNML::LaserScanNML() : NMLmsg((NMLTYPE)LaserScan::ID,sizeof(LaserScanNML)), nmlVersion(LaserScan::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LaserScan()*/)
{
};

LaserScanNML::~LaserScanNML()
{
};

LaserScanNML & LaserScanNML::operator=(const LaserScanNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LaserScanNML & LaserScanNML::operator=(const LaserScan & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LaserScan);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LaserScanNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LaserScan&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LaserScanNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LaserScan> temp(new LaserScan());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LaserScan::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LaserScan Message version mismatch, expected " << LaserScan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LaserScan Message version mismatch, expected " << LaserScan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, MagneticField & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MagneticField, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.magnetic_field);
        cms->update(inobj.magnetic_field_covariance.data(),9); 

    }  
 }

MagneticFieldNML::MagneticFieldNML() : NMLmsg((NMLTYPE)MagneticField::ID,sizeof(MagneticFieldNML)), nmlVersion(MagneticField::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MagneticField()*/)
{
};

MagneticFieldNML::~MagneticFieldNML()
{
};

MagneticFieldNML & MagneticFieldNML::operator=(const MagneticFieldNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MagneticFieldNML & MagneticFieldNML::operator=(const MagneticField & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MagneticField);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MagneticFieldNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MagneticField&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MagneticFieldNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MagneticField> temp(new MagneticField());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MagneticField::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MagneticField Message version mismatch, expected " << MagneticField::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MagneticField Message version mismatch, expected " << MagneticField::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, MultiDOFJointState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MultiDOFJointState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.transforms);
        nmlupdate(cms,inobj.twist);
        nmlupdate(cms,inobj.wrench);

    }  
 }

MultiDOFJointStateNML::MultiDOFJointStateNML() : NMLmsg((NMLTYPE)MultiDOFJointState::ID,sizeof(MultiDOFJointStateNML)), nmlVersion(MultiDOFJointState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MultiDOFJointState()*/)
{
};

MultiDOFJointStateNML::~MultiDOFJointStateNML()
{
};

MultiDOFJointStateNML & MultiDOFJointStateNML::operator=(const MultiDOFJointStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MultiDOFJointStateNML & MultiDOFJointStateNML::operator=(const MultiDOFJointState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MultiDOFJointState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MultiDOFJointStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MultiDOFJointState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MultiDOFJointStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MultiDOFJointState> temp(new MultiDOFJointState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MultiDOFJointState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MultiDOFJointState Message version mismatch, expected " << MultiDOFJointState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MultiDOFJointState Message version mismatch, expected " << MultiDOFJointState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, MultiEchoLaserScan & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MultiEchoLaserScan, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.angle_min);
        cms->update(inobj.angle_max);
        cms->update(inobj.angle_increment);
        cms->update(inobj.time_increment);
        cms->update(inobj.scan_time);
        cms->update(inobj.range_min);
        cms->update(inobj.range_max);
        nmlupdate(cms,inobj.ranges);
        nmlupdate(cms,inobj.intensities);

    }  
 }

MultiEchoLaserScanNML::MultiEchoLaserScanNML() : NMLmsg((NMLTYPE)MultiEchoLaserScan::ID,sizeof(MultiEchoLaserScanNML)), nmlVersion(MultiEchoLaserScan::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MultiEchoLaserScan()*/)
{
};

MultiEchoLaserScanNML::~MultiEchoLaserScanNML()
{
};

MultiEchoLaserScanNML & MultiEchoLaserScanNML::operator=(const MultiEchoLaserScanNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MultiEchoLaserScanNML & MultiEchoLaserScanNML::operator=(const MultiEchoLaserScan & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MultiEchoLaserScan);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MultiEchoLaserScanNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MultiEchoLaserScan&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MultiEchoLaserScanNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MultiEchoLaserScan> temp(new MultiEchoLaserScan());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MultiEchoLaserScan::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MultiEchoLaserScan Message version mismatch, expected " << MultiEchoLaserScan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MultiEchoLaserScan Message version mismatch, expected " << MultiEchoLaserScan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, NavSatFix & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NavSatFix, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        cms->update(inobj.latitude);
        cms->update(inobj.longitude);
        cms->update(inobj.altitude);
        cms->update(inobj.position_covariance.data(),9); 
        cms->update(inobj.position_covariance_type);

    }  
 }

NavSatFixNML::NavSatFixNML() : NMLmsg((NMLTYPE)NavSatFix::ID,sizeof(NavSatFixNML)), nmlVersion(NavSatFix::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NavSatFix()*/)
{
};

NavSatFixNML::~NavSatFixNML()
{
};

NavSatFixNML & NavSatFixNML::operator=(const NavSatFixNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NavSatFixNML & NavSatFixNML::operator=(const NavSatFix & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NavSatFix);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NavSatFixNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NavSatFix&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NavSatFixNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NavSatFix> temp(new NavSatFix());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NavSatFix::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NavSatFix Message version mismatch, expected " << NavSatFix::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NavSatFix Message version mismatch, expected " << NavSatFix::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, NavSatStatus & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NavSatStatus, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.status);
        cms->update(inobj.service);

    }  
 }

NavSatStatusNML::NavSatStatusNML() : NMLmsg((NMLTYPE)NavSatStatus::ID,sizeof(NavSatStatusNML)), nmlVersion(NavSatStatus::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NavSatStatus()*/)
{
};

NavSatStatusNML::~NavSatStatusNML()
{
};

NavSatStatusNML & NavSatStatusNML::operator=(const NavSatStatusNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NavSatStatusNML & NavSatStatusNML::operator=(const NavSatStatus & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NavSatStatus);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NavSatStatusNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NavSatStatus&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NavSatStatusNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NavSatStatus> temp(new NavSatStatus());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NavSatStatus::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NavSatStatus Message version mismatch, expected " << NavSatStatus::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NavSatStatus Message version mismatch, expected " << NavSatStatus::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, PointCloud & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointCloud, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.points);
        nmlupdate(cms,inobj.channels);

    }  
 }

PointCloudNML::PointCloudNML() : NMLmsg((NMLTYPE)PointCloud::ID,sizeof(PointCloudNML)), nmlVersion(PointCloud::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointCloud()*/)
{
};

PointCloudNML::~PointCloudNML()
{
};

PointCloudNML & PointCloudNML::operator=(const PointCloudNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointCloudNML & PointCloudNML::operator=(const PointCloud & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointCloud);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointCloudNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointCloud&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointCloudNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointCloud> temp(new PointCloud());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointCloud::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointCloud Message version mismatch, expected " << PointCloud::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointCloud Message version mismatch, expected " << PointCloud::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, PointCloud2 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointCloud2, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.height);
        cms->update(inobj.width);
        nmlupdate(cms,inobj.fields);
        cms->update(inobj.is_bigendian);
        cms->update(inobj.point_step);
        cms->update(inobj.row_step);
        nmlupdate(cms,inobj.data);
        cms->update(inobj.is_dense);

    }  
 }

PointCloud2NML::PointCloud2NML() : NMLmsg((NMLTYPE)PointCloud2::ID,sizeof(PointCloud2NML)), nmlVersion(PointCloud2::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointCloud2()*/)
{
};

PointCloud2NML::~PointCloud2NML()
{
};

PointCloud2NML & PointCloud2NML::operator=(const PointCloud2NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointCloud2NML & PointCloud2NML::operator=(const PointCloud2 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointCloud2);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointCloud2NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointCloud2&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointCloud2NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointCloud2> temp(new PointCloud2());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointCloud2::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointCloud2 Message version mismatch, expected " << PointCloud2::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointCloud2 Message version mismatch, expected " << PointCloud2::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, PointField & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointField, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        cms->update(inobj.offset);
        cms->update(inobj.datatype);
        cms->update(inobj.count);

    }  
 }

PointFieldNML::PointFieldNML() : NMLmsg((NMLTYPE)PointField::ID,sizeof(PointFieldNML)), nmlVersion(PointField::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointField()*/)
{
};

PointFieldNML::~PointFieldNML()
{
};

PointFieldNML & PointFieldNML::operator=(const PointFieldNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointFieldNML & PointFieldNML::operator=(const PointField & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointField);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointFieldNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointField&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointFieldNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointField> temp(new PointField());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointField::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointField Message version mismatch, expected " << PointField::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointField Message version mismatch, expected " << PointField::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, Range & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Range, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.radiation_type);
        cms->update(inobj.field_of_view);
        cms->update(inobj.min_range);
        cms->update(inobj.max_range);
        cms->update(inobj.range);

    }  
 }

RangeNML::RangeNML() : NMLmsg((NMLTYPE)Range::ID,sizeof(RangeNML)), nmlVersion(Range::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Range()*/)
{
};

RangeNML::~RangeNML()
{
};

RangeNML & RangeNML::operator=(const RangeNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

RangeNML & RangeNML::operator=(const Range & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Range);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void RangeNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Range&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: RangeNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Range> temp(new Range());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Range::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Range Message version mismatch, expected " << Range::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Range Message version mismatch, expected " << Range::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, RegionOfInterest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate RegionOfInterest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x_offset);
        cms->update(inobj.y_offset);
        cms->update(inobj.height);
        cms->update(inobj.width);
        cms->update(inobj.do_rectify);

    }  
 }

RegionOfInterestNML::RegionOfInterestNML() : NMLmsg((NMLTYPE)RegionOfInterest::ID,sizeof(RegionOfInterestNML)), nmlVersion(RegionOfInterest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new RegionOfInterest()*/)
{
};

RegionOfInterestNML::~RegionOfInterestNML()
{
};

RegionOfInterestNML & RegionOfInterestNML::operator=(const RegionOfInterestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

RegionOfInterestNML & RegionOfInterestNML::operator=(const RegionOfInterest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(RegionOfInterest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void RegionOfInterestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<RegionOfInterest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: RegionOfInterestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<RegionOfInterest> temp(new RegionOfInterest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (RegionOfInterest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: RegionOfInterest Message version mismatch, expected " << RegionOfInterest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: RegionOfInterest Message version mismatch, expected " << RegionOfInterest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, RelativeHumidity & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate RelativeHumidity, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.relative_humidity);
        cms->update(inobj.variance);

    }  
 }

RelativeHumidityNML::RelativeHumidityNML() : NMLmsg((NMLTYPE)RelativeHumidity::ID,sizeof(RelativeHumidityNML)), nmlVersion(RelativeHumidity::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new RelativeHumidity()*/)
{
};

RelativeHumidityNML::~RelativeHumidityNML()
{
};

RelativeHumidityNML & RelativeHumidityNML::operator=(const RelativeHumidityNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

RelativeHumidityNML & RelativeHumidityNML::operator=(const RelativeHumidity & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(RelativeHumidity);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void RelativeHumidityNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<RelativeHumidity&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: RelativeHumidityNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<RelativeHumidity> temp(new RelativeHumidity());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (RelativeHumidity::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: RelativeHumidity Message version mismatch, expected " << RelativeHumidity::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: RelativeHumidity Message version mismatch, expected " << RelativeHumidity::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, Temperature & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Temperature, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.temperature);
        cms->update(inobj.variance);

    }  
 }

TemperatureNML::TemperatureNML() : NMLmsg((NMLTYPE)Temperature::ID,sizeof(TemperatureNML)), nmlVersion(Temperature::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Temperature()*/)
{
};

TemperatureNML::~TemperatureNML()
{
};

TemperatureNML & TemperatureNML::operator=(const TemperatureNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TemperatureNML & TemperatureNML::operator=(const Temperature & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Temperature);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TemperatureNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Temperature&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TemperatureNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Temperature> temp(new Temperature());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Temperature::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Temperature Message version mismatch, expected " << Temperature::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Temperature Message version mismatch, expected " << Temperature::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, TimeReference & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TimeReference, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.time_ref);
        nmlupdate(cms,inobj.source);

    }  
 }

TimeReferenceNML::TimeReferenceNML() : NMLmsg((NMLTYPE)TimeReference::ID,sizeof(TimeReferenceNML)), nmlVersion(TimeReference::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TimeReference()*/)
{
};

TimeReferenceNML::~TimeReferenceNML()
{
};

TimeReferenceNML & TimeReferenceNML::operator=(const TimeReferenceNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TimeReferenceNML & TimeReferenceNML::operator=(const TimeReference & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TimeReference);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TimeReferenceNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TimeReference&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TimeReferenceNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TimeReference> temp(new TimeReference());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TimeReference::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TimeReference Message version mismatch, expected " << TimeReference::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TimeReference Message version mismatch, expected " << TimeReference::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, SetCameraInfoRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetCameraInfoRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.camera_info);

    }  
 }

SetCameraInfoRequestNML::SetCameraInfoRequestNML() : NMLmsg((NMLTYPE)SetCameraInfoRequest::ID,sizeof(SetCameraInfoRequestNML)), nmlVersion(SetCameraInfoRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetCameraInfoRequest()*/)
{
};

SetCameraInfoRequestNML::~SetCameraInfoRequestNML()
{
};

SetCameraInfoRequestNML & SetCameraInfoRequestNML::operator=(const SetCameraInfoRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetCameraInfoRequestNML & SetCameraInfoRequestNML::operator=(const SetCameraInfoRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetCameraInfoRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetCameraInfoRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetCameraInfoRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetCameraInfoRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetCameraInfoRequest> temp(new SetCameraInfoRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetCameraInfoRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetCameraInfoRequest Message version mismatch, expected " << SetCameraInfoRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetCameraInfoRequest Message version mismatch, expected " << SetCameraInfoRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, SetCameraInfoResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetCameraInfoResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetCameraInfoResponseNML::SetCameraInfoResponseNML() : NMLmsg((NMLTYPE)SetCameraInfoResponse::ID,sizeof(SetCameraInfoResponseNML)), nmlVersion(SetCameraInfoResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetCameraInfoResponse()*/)
{
};

SetCameraInfoResponseNML::~SetCameraInfoResponseNML()
{
};

SetCameraInfoResponseNML & SetCameraInfoResponseNML::operator=(const SetCameraInfoResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetCameraInfoResponseNML & SetCameraInfoResponseNML::operator=(const SetCameraInfoResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetCameraInfoResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetCameraInfoResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetCameraInfoResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetCameraInfoResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetCameraInfoResponse> temp(new SetCameraInfoResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetCameraInfoResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetCameraInfoResponse Message version mismatch, expected " << SetCameraInfoResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetCameraInfoResponse Message version mismatch, expected " << SetCameraInfoResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void sensor_msgs::nmlupdate(CMS * cms, SetCameraInfo & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetCameraInfo, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetCameraInfoNML::SetCameraInfoNML() : NMLmsg((NMLTYPE)SetCameraInfo::ID,sizeof(SetCameraInfoNML)), nmlVersion(SetCameraInfo::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetCameraInfo()*/)
{
};

SetCameraInfoNML::~SetCameraInfoNML()
{
};

SetCameraInfoNML & SetCameraInfoNML::operator=(const SetCameraInfoNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetCameraInfoNML & SetCameraInfoNML::operator=(const SetCameraInfo & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetCameraInfo);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetCameraInfoNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetCameraInfo&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetCameraInfoNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetCameraInfo> temp(new SetCameraInfo());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: sensor_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetCameraInfo::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetCameraInfo Message version mismatch, expected " << SetCameraInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetCameraInfo Message version mismatch, expected " << SetCameraInfo::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int sensor_msgs::sensor_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("sensor_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case BatteryState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for BatteryState, id " << BatteryState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((BatteryStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case CameraInfo::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for CameraInfo, id " << CameraInfo::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((CameraInfoNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ChannelFloat32::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ChannelFloat32, id " << ChannelFloat32::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ChannelFloat32NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case CompressedImage::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for CompressedImage, id " << CompressedImage::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((CompressedImageNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FluidPressure::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FluidPressure, id " << FluidPressure::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FluidPressureNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Illuminance::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Illuminance, id " << Illuminance::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((IlluminanceNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Image::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Image, id " << Image::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ImageNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Imu::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Imu, id " << Imu::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ImuNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointState, id " << JointState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Joy::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Joy, id " << Joy::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JoyNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JoyFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JoyFeedback, id " << JoyFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JoyFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JoyFeedbackArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JoyFeedbackArray, id " << JoyFeedbackArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JoyFeedbackArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LaserEcho::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LaserEcho, id " << LaserEcho::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LaserEchoNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LaserScan::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LaserScan, id " << LaserScan::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LaserScanNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MagneticField::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MagneticField, id " << MagneticField::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MagneticFieldNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MultiDOFJointState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MultiDOFJointState, id " << MultiDOFJointState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MultiDOFJointStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MultiEchoLaserScan::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MultiEchoLaserScan, id " << MultiEchoLaserScan::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MultiEchoLaserScanNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NavSatFix::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NavSatFix, id " << NavSatFix::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NavSatFixNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NavSatStatus::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NavSatStatus, id " << NavSatStatus::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NavSatStatusNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointCloud::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointCloud, id " << PointCloud::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointCloudNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointCloud2::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointCloud2, id " << PointCloud2::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointCloud2NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointField::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointField, id " << PointField::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointFieldNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Range::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Range, id " << Range::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((RangeNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case RegionOfInterest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for RegionOfInterest, id " << RegionOfInterest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((RegionOfInterestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case RelativeHumidity::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for RelativeHumidity, id " << RelativeHumidity::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((RelativeHumidityNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Temperature::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Temperature, id " << Temperature::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TemperatureNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TimeReference::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TimeReference, id " << TimeReference::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TimeReferenceNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetCameraInfoRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetCameraInfoRequest, id " << SetCameraInfoRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetCameraInfoRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetCameraInfoResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetCameraInfoResponse, id " << SetCameraInfoResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetCameraInfoResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetCameraInfo::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetCameraInfo, id " << SetCameraInfo::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_sensor_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"sensor_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetCameraInfoNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

