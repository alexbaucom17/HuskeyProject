// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:07 -0500
//  From Template/Script: data_templates/DataLibraryTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "sensor_msgs_gencpp_Library.h"
#include <common/Log.h>
#include <common/TypeRegistry.h>
#include <messaging/Message.h>

#include <sensor_msgs/BatteryState.h>
#include <sensor_msgs/CameraInfo.h>
#include <sensor_msgs/ChannelFloat32.h>
#include <sensor_msgs/CompressedImage.h>
#include <sensor_msgs/FluidPressure.h>
#include <sensor_msgs/Illuminance.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/Imu.h>
#include <sensor_msgs/JointState.h>
#include <sensor_msgs/Joy.h>
#include <sensor_msgs/JoyFeedback.h>
#include <sensor_msgs/JoyFeedbackArray.h>
#include <sensor_msgs/LaserEcho.h>
#include <sensor_msgs/LaserScan.h>
#include <sensor_msgs/MagneticField.h>
#include <sensor_msgs/MultiDOFJointState.h>
#include <sensor_msgs/MultiEchoLaserScan.h>
#include <sensor_msgs/NavSatFix.h>
#include <sensor_msgs/NavSatStatus.h>
#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointField.h>
#include <sensor_msgs/Range.h>
#include <sensor_msgs/RegionOfInterest.h>
#include <sensor_msgs/RelativeHumidity.h>
#include <sensor_msgs/Temperature.h>
#include <sensor_msgs/TimeReference.h>
#include <sensor_msgs/SetCameraInfoRequest.h>
#include <sensor_msgs/SetCameraInfoResponse.h>
#include <sensor_msgs/SetCameraInfo.h>

extern "C"
{
    /** library access method */
    int rframeRegisterDataLibrary()
    {
        return sensor_msgs::registerLibrary();
    };
}

namespace sensor_msgs
{

    static void deallocateMessage(MessageBase * msg)
    {
        delete msg;
    }

    static int allocateMessage(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
    {
        int retval = rframe::Error::SUCCESS;
        bool found = true;
        switch (id)
        { 
            case BatteryState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<BatteryState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case CameraInfo::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<CameraInfo>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ChannelFloat32::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ChannelFloat32>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case CompressedImage::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<CompressedImage>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case FluidPressure::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<FluidPressure>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case Illuminance::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<Illuminance>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case Image::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<Image>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case Imu::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<Imu>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case JointState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<JointState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case Joy::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<Joy>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case JoyFeedback::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<JoyFeedback>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case JoyFeedbackArray::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<JoyFeedbackArray>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case LaserEcho::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<LaserEcho>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case LaserScan::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<LaserScan>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case MagneticField::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<MagneticField>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case MultiDOFJointState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<MultiDOFJointState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case MultiEchoLaserScan::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<MultiEchoLaserScan>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case NavSatFix::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<NavSatFix>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case NavSatStatus::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<NavSatStatus>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case PointCloud::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<PointCloud>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case PointCloud2::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<PointCloud2>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case PointField::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<PointField>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case Range::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<Range>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case RegionOfInterest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<RegionOfInterest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case RelativeHumidity::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<RelativeHumidity>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case Temperature::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<Temperature>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case TimeReference::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<TimeReference>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetCameraInfoRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetCameraInfoRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetCameraInfoResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetCameraInfoResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetCameraInfo::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetCameraInfo>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            default:
            {
                found = false;
            }
        }

        if (found == false)
        {
            retval = rframe::Error::PARAM_RANGE;
        }
        else if (msg.get() == NULL)
        {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else if (msg.get() != NULL)
        {
            retval = rframe::Error::SUCCESS;
        }

        return retval;
    }

    /** registry this data set with the system */
    //int register_sensor_msgs_gencpp()
    int registerLibrary()
    {
        int retval = rframe::Error::SUCCESS;
        static bool registered = false;
        rframe::TypeRegistry & reg = rframe::TypeRegistry::instance();

        LOG_INFO("registering data for library: sensor_msgs_gencpp");

        if (registered == false)
        {
            registered = true;

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::BatteryState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::BatteryState>(
                    // boost::lambda::new_ptr<sensor_msgs::BatteryState>(),
                    [](){ return new sensor_msgs::BatteryState(); },
                                std::bind(allocateMessage,sensor_msgs::BatteryState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: BatteryState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::BatteryState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::BatteryState::DATA_TYPE_NAME,sensor_msgs::BatteryState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: BatteryState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::CameraInfo::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::CameraInfo>(
                    // boost::lambda::new_ptr<sensor_msgs::CameraInfo>(),
                    [](){ return new sensor_msgs::CameraInfo(); },
                                std::bind(allocateMessage,sensor_msgs::CameraInfo::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: CameraInfo");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::CameraInfo::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::CameraInfo::DATA_TYPE_NAME,sensor_msgs::CameraInfo::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: CameraInfo");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::ChannelFloat32::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::ChannelFloat32>(
                    // boost::lambda::new_ptr<sensor_msgs::ChannelFloat32>(),
                    [](){ return new sensor_msgs::ChannelFloat32(); },
                                std::bind(allocateMessage,sensor_msgs::ChannelFloat32::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ChannelFloat32");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::ChannelFloat32::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::ChannelFloat32::DATA_TYPE_NAME,sensor_msgs::ChannelFloat32::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ChannelFloat32");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::CompressedImage::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::CompressedImage>(
                    // boost::lambda::new_ptr<sensor_msgs::CompressedImage>(),
                    [](){ return new sensor_msgs::CompressedImage(); },
                                std::bind(allocateMessage,sensor_msgs::CompressedImage::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: CompressedImage");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::CompressedImage::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::CompressedImage::DATA_TYPE_NAME,sensor_msgs::CompressedImage::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: CompressedImage");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::FluidPressure::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::FluidPressure>(
                    // boost::lambda::new_ptr<sensor_msgs::FluidPressure>(),
                    [](){ return new sensor_msgs::FluidPressure(); },
                                std::bind(allocateMessage,sensor_msgs::FluidPressure::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: FluidPressure");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::FluidPressure::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::FluidPressure::DATA_TYPE_NAME,sensor_msgs::FluidPressure::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: FluidPressure");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Illuminance::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::Illuminance>(
                    // boost::lambda::new_ptr<sensor_msgs::Illuminance>(),
                    [](){ return new sensor_msgs::Illuminance(); },
                                std::bind(allocateMessage,sensor_msgs::Illuminance::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: Illuminance");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Illuminance::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::Illuminance::DATA_TYPE_NAME,sensor_msgs::Illuminance::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: Illuminance");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Image::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::Image>(
                    // boost::lambda::new_ptr<sensor_msgs::Image>(),
                    [](){ return new sensor_msgs::Image(); },
                                std::bind(allocateMessage,sensor_msgs::Image::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: Image");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Image::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::Image::DATA_TYPE_NAME,sensor_msgs::Image::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: Image");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Imu::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::Imu>(
                    // boost::lambda::new_ptr<sensor_msgs::Imu>(),
                    [](){ return new sensor_msgs::Imu(); },
                                std::bind(allocateMessage,sensor_msgs::Imu::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: Imu");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Imu::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::Imu::DATA_TYPE_NAME,sensor_msgs::Imu::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: Imu");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::JointState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::JointState>(
                    // boost::lambda::new_ptr<sensor_msgs::JointState>(),
                    [](){ return new sensor_msgs::JointState(); },
                                std::bind(allocateMessage,sensor_msgs::JointState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: JointState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::JointState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::JointState::DATA_TYPE_NAME,sensor_msgs::JointState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: JointState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Joy::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::Joy>(
                    // boost::lambda::new_ptr<sensor_msgs::Joy>(),
                    [](){ return new sensor_msgs::Joy(); },
                                std::bind(allocateMessage,sensor_msgs::Joy::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: Joy");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Joy::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::Joy::DATA_TYPE_NAME,sensor_msgs::Joy::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: Joy");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::JoyFeedback::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::JoyFeedback>(
                    // boost::lambda::new_ptr<sensor_msgs::JoyFeedback>(),
                    [](){ return new sensor_msgs::JoyFeedback(); },
                                std::bind(allocateMessage,sensor_msgs::JoyFeedback::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: JoyFeedback");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::JoyFeedback::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::JoyFeedback::DATA_TYPE_NAME,sensor_msgs::JoyFeedback::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: JoyFeedback");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::JoyFeedbackArray::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::JoyFeedbackArray>(
                    // boost::lambda::new_ptr<sensor_msgs::JoyFeedbackArray>(),
                    [](){ return new sensor_msgs::JoyFeedbackArray(); },
                                std::bind(allocateMessage,sensor_msgs::JoyFeedbackArray::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: JoyFeedbackArray");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::JoyFeedbackArray::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::JoyFeedbackArray::DATA_TYPE_NAME,sensor_msgs::JoyFeedbackArray::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: JoyFeedbackArray");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::LaserEcho::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::LaserEcho>(
                    // boost::lambda::new_ptr<sensor_msgs::LaserEcho>(),
                    [](){ return new sensor_msgs::LaserEcho(); },
                                std::bind(allocateMessage,sensor_msgs::LaserEcho::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: LaserEcho");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::LaserEcho::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::LaserEcho::DATA_TYPE_NAME,sensor_msgs::LaserEcho::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: LaserEcho");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::LaserScan::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::LaserScan>(
                    // boost::lambda::new_ptr<sensor_msgs::LaserScan>(),
                    [](){ return new sensor_msgs::LaserScan(); },
                                std::bind(allocateMessage,sensor_msgs::LaserScan::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: LaserScan");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::LaserScan::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::LaserScan::DATA_TYPE_NAME,sensor_msgs::LaserScan::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: LaserScan");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::MagneticField::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::MagneticField>(
                    // boost::lambda::new_ptr<sensor_msgs::MagneticField>(),
                    [](){ return new sensor_msgs::MagneticField(); },
                                std::bind(allocateMessage,sensor_msgs::MagneticField::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: MagneticField");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::MagneticField::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::MagneticField::DATA_TYPE_NAME,sensor_msgs::MagneticField::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: MagneticField");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::MultiDOFJointState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::MultiDOFJointState>(
                    // boost::lambda::new_ptr<sensor_msgs::MultiDOFJointState>(),
                    [](){ return new sensor_msgs::MultiDOFJointState(); },
                                std::bind(allocateMessage,sensor_msgs::MultiDOFJointState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: MultiDOFJointState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::MultiDOFJointState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::MultiDOFJointState::DATA_TYPE_NAME,sensor_msgs::MultiDOFJointState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: MultiDOFJointState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::MultiEchoLaserScan::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::MultiEchoLaserScan>(
                    // boost::lambda::new_ptr<sensor_msgs::MultiEchoLaserScan>(),
                    [](){ return new sensor_msgs::MultiEchoLaserScan(); },
                                std::bind(allocateMessage,sensor_msgs::MultiEchoLaserScan::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: MultiEchoLaserScan");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::MultiEchoLaserScan::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::MultiEchoLaserScan::DATA_TYPE_NAME,sensor_msgs::MultiEchoLaserScan::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: MultiEchoLaserScan");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::NavSatFix::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::NavSatFix>(
                    // boost::lambda::new_ptr<sensor_msgs::NavSatFix>(),
                    [](){ return new sensor_msgs::NavSatFix(); },
                                std::bind(allocateMessage,sensor_msgs::NavSatFix::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: NavSatFix");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::NavSatFix::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::NavSatFix::DATA_TYPE_NAME,sensor_msgs::NavSatFix::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: NavSatFix");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::NavSatStatus::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::NavSatStatus>(
                    // boost::lambda::new_ptr<sensor_msgs::NavSatStatus>(),
                    [](){ return new sensor_msgs::NavSatStatus(); },
                                std::bind(allocateMessage,sensor_msgs::NavSatStatus::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: NavSatStatus");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::NavSatStatus::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::NavSatStatus::DATA_TYPE_NAME,sensor_msgs::NavSatStatus::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: NavSatStatus");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::PointCloud::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::PointCloud>(
                    // boost::lambda::new_ptr<sensor_msgs::PointCloud>(),
                    [](){ return new sensor_msgs::PointCloud(); },
                                std::bind(allocateMessage,sensor_msgs::PointCloud::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: PointCloud");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::PointCloud::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::PointCloud::DATA_TYPE_NAME,sensor_msgs::PointCloud::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: PointCloud");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::PointCloud2::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::PointCloud2>(
                    // boost::lambda::new_ptr<sensor_msgs::PointCloud2>(),
                    [](){ return new sensor_msgs::PointCloud2(); },
                                std::bind(allocateMessage,sensor_msgs::PointCloud2::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: PointCloud2");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::PointCloud2::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::PointCloud2::DATA_TYPE_NAME,sensor_msgs::PointCloud2::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: PointCloud2");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::PointField::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::PointField>(
                    // boost::lambda::new_ptr<sensor_msgs::PointField>(),
                    [](){ return new sensor_msgs::PointField(); },
                                std::bind(allocateMessage,sensor_msgs::PointField::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: PointField");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::PointField::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::PointField::DATA_TYPE_NAME,sensor_msgs::PointField::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: PointField");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Range::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::Range>(
                    // boost::lambda::new_ptr<sensor_msgs::Range>(),
                    [](){ return new sensor_msgs::Range(); },
                                std::bind(allocateMessage,sensor_msgs::Range::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: Range");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Range::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::Range::DATA_TYPE_NAME,sensor_msgs::Range::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: Range");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::RegionOfInterest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::RegionOfInterest>(
                    // boost::lambda::new_ptr<sensor_msgs::RegionOfInterest>(),
                    [](){ return new sensor_msgs::RegionOfInterest(); },
                                std::bind(allocateMessage,sensor_msgs::RegionOfInterest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: RegionOfInterest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::RegionOfInterest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::RegionOfInterest::DATA_TYPE_NAME,sensor_msgs::RegionOfInterest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: RegionOfInterest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::RelativeHumidity::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::RelativeHumidity>(
                    // boost::lambda::new_ptr<sensor_msgs::RelativeHumidity>(),
                    [](){ return new sensor_msgs::RelativeHumidity(); },
                                std::bind(allocateMessage,sensor_msgs::RelativeHumidity::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: RelativeHumidity");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::RelativeHumidity::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::RelativeHumidity::DATA_TYPE_NAME,sensor_msgs::RelativeHumidity::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: RelativeHumidity");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Temperature::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::Temperature>(
                    // boost::lambda::new_ptr<sensor_msgs::Temperature>(),
                    [](){ return new sensor_msgs::Temperature(); },
                                std::bind(allocateMessage,sensor_msgs::Temperature::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: Temperature");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::Temperature::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::Temperature::DATA_TYPE_NAME,sensor_msgs::Temperature::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: Temperature");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::TimeReference::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::TimeReference>(
                    // boost::lambda::new_ptr<sensor_msgs::TimeReference>(),
                    [](){ return new sensor_msgs::TimeReference(); },
                                std::bind(allocateMessage,sensor_msgs::TimeReference::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: TimeReference");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::TimeReference::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::TimeReference::DATA_TYPE_NAME,sensor_msgs::TimeReference::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: TimeReference");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::SetCameraInfoRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::SetCameraInfoRequest>(
                    // boost::lambda::new_ptr<sensor_msgs::SetCameraInfoRequest>(),
                    [](){ return new sensor_msgs::SetCameraInfoRequest(); },
                                std::bind(allocateMessage,sensor_msgs::SetCameraInfoRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetCameraInfoRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::SetCameraInfoRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::SetCameraInfoRequest::DATA_TYPE_NAME,sensor_msgs::SetCameraInfoRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetCameraInfoRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::SetCameraInfoResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::SetCameraInfoResponse>(
                    // boost::lambda::new_ptr<sensor_msgs::SetCameraInfoResponse>(),
                    [](){ return new sensor_msgs::SetCameraInfoResponse(); },
                                std::bind(allocateMessage,sensor_msgs::SetCameraInfoResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetCameraInfoResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::SetCameraInfoResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::SetCameraInfoResponse::DATA_TYPE_NAME,sensor_msgs::SetCameraInfoResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetCameraInfoResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::SetCameraInfo::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<sensor_msgs::SetCameraInfo>(
                    // boost::lambda::new_ptr<sensor_msgs::SetCameraInfo>(),
                    [](){ return new sensor_msgs::SetCameraInfo(); },
                                std::bind(allocateMessage,sensor_msgs::SetCameraInfo::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetCameraInfo");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = sensor_msgs::SetCameraInfo::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(sensor_msgs::SetCameraInfo::DATA_TYPE_NAME,sensor_msgs::SetCameraInfo::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetCameraInfo");
            }

        }

        return retval;
    };

    std::string xmlSource()
    {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\
<!--\
 \
  AUTOGENERATED FILE:   do not edit\
\
  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:56:59 -0500\
  From Template/Script: rosToXML.rb\
 \
\
-->\
<classes library_name=\"sensor_msgs_gencpp\" namespace=\"sensor_msgs\">\
\
<class name=\"BatteryState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"476f837fa6771f6e16e3bf4ef96f8770\" rosDesc=\"\\n# Constants are chosen to match the enums in the linux kernel\\n# defined in include/linux/power_supply.h as of version 3.7\\n# The one difference is for style reasons the constants are\\n# all uppercase not mixed case.\\n\\n# Power supply status constants\\nuint8 POWER_SUPPLY_STATUS_UNKNOWN = 0\\nuint8 POWER_SUPPLY_STATUS_CHARGING = 1\\nuint8 POWER_SUPPLY_STATUS_DISCHARGING = 2\\nuint8 POWER_SUPPLY_STATUS_NOT_CHARGING = 3\\nuint8 POWER_SUPPLY_STATUS_FULL = 4\\n\\n# Power supply health constants\\nuint8 POWER_SUPPLY_HEALTH_UNKNOWN = 0\\nuint8 POWER_SUPPLY_HEALTH_GOOD = 1\\nuint8 POWER_SUPPLY_HEALTH_OVERHEAT = 2\\nuint8 POWER_SUPPLY_HEALTH_DEAD = 3\\nuint8 POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4\\nuint8 POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5\\nuint8 POWER_SUPPLY_HEALTH_COLD = 6\\nuint8 POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7\\nuint8 POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8\\n\\n# Power supply technology (chemistry) constants\\nuint8 POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0\\nuint8 POWER_SUPPLY_TECHNOLOGY_NIMH = 1\\nuint8 POWER_SUPPLY_TECHNOLOGY_LION = 2\\nuint8 POWER_SUPPLY_TECHNOLOGY_LIPO = 3\\nuint8 POWER_SUPPLY_TECHNOLOGY_LIFE = 4\\nuint8 POWER_SUPPLY_TECHNOLOGY_NICD = 5\\nuint8 POWER_SUPPLY_TECHNOLOGY_LIMN = 6\\n\\nHeader  header\\nfloat32 voltage          # Voltage in Volts (Mandatory)\\nfloat32 current          # Negative when discharging (A)  (If unmeasured NaN)\\nfloat32 charge           # Current charge in Ah  (If unmeasured NaN)\\nfloat32 capacity         # Capacity in Ah (last full capacity)  (If unmeasured NaN)\\nfloat32 design_capacity  # Capacity in Ah (design capacity)  (If unmeasured NaN)\\nfloat32 percentage       # Charge percentage on 0 to 1 range  (If unmeasured NaN)\\nuint8   power_supply_status     # The charging status as reported. Values defined above\\nuint8   power_supply_health     # The battery health metric. Values defined above\\nuint8   power_supply_technology # The battery chemistry. Values defined above\\nbool    present          # True if the battery is present\\n\\nfloat32[] cell_voltage   # An array of individual cell voltages for each cell in the pack\\n                         # If individual voltages unknown but number of cells known set each to NaN\\nstring location          # The location into which the battery is inserted. (slot number or plug)\\nstring serial_number     # The best approximation of the battery serial number\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"\">\
  <constant init=\"0\" name=\"POWER_SUPPLY_STATUS_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"POWER_SUPPLY_STATUS_CHARGING\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"POWER_SUPPLY_STATUS_DISCHARGING\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"POWER_SUPPLY_STATUS_NOT_CHARGING\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"POWER_SUPPLY_STATUS_FULL\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"Power supply health constants\"/>\
  <constant init=\"0\" name=\"POWER_SUPPLY_HEALTH_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"POWER_SUPPLY_HEALTH_GOOD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"POWER_SUPPLY_HEALTH_OVERHEAT\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"POWER_SUPPLY_HEALTH_DEAD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"POWER_SUPPLY_HEALTH_OVERVOLTAGE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"5\" name=\"POWER_SUPPLY_HEALTH_UNSPEC_FAILURE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"6\" name=\"POWER_SUPPLY_HEALTH_COLD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"7\" name=\"POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"8\" name=\"POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"Power supply technology (chemistry) constants\"/>\
  <constant init=\"0\" name=\"POWER_SUPPLY_TECHNOLOGY_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"POWER_SUPPLY_TECHNOLOGY_NIMH\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"POWER_SUPPLY_TECHNOLOGY_LION\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"POWER_SUPPLY_TECHNOLOGY_LIPO\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"POWER_SUPPLY_TECHNOLOGY_LIFE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"5\" name=\"POWER_SUPPLY_TECHNOLOGY_NICD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"6\" name=\"POWER_SUPPLY_TECHNOLOGY_LIMN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"\"/>\
  <field name=\"voltage\" type=\"float\" sourceType=\"float32\" comment=\"Voltage in Volts (Mandatory)\"/>\
  <field name=\"current\" type=\"float\" sourceType=\"float32\" comment=\"Negative when discharging (A)  (If unmeasured NaN)\"/>\
  <field name=\"charge\" type=\"float\" sourceType=\"float32\" comment=\"Current charge in Ah  (If unmeasured NaN)\"/>\
  <field name=\"capacity\" type=\"float\" sourceType=\"float32\" comment=\"Capacity in Ah (last full capacity)  (If unmeasured NaN)\"/>\
  <field name=\"design_capacity\" type=\"float\" sourceType=\"float32\" comment=\"Capacity in Ah (design capacity)  (If unmeasured NaN)\"/>\
  <field name=\"percentage\" type=\"float\" sourceType=\"float32\" comment=\"Charge percentage on 0 to 1 range  (If unmeasured NaN)\"/>\
  <field name=\"power_supply_status\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"The charging status as reported. Values defined above\"/>\
  <field name=\"power_supply_health\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"The battery health metric. Values defined above\"/>\
  <field name=\"power_supply_technology\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"The battery chemistry. Values defined above\"/>\
  <field name=\"present\" type=\"bool\" sourceType=\"bool\" comment=\"True if the battery is present\"/>\
  <field name=\"cell_voltage\" type=\"vector(float)\" sourceType=\"float32\" comment=\"An array of individual cell voltages for each cell in the pack  If individual voltages unknown but number of cells known set each to NaN\"/>\
  <field name=\"location\" type=\"string\" sourceType=\"string\" comment=\"The location into which the battery is inserted. (slot number or plug)\"/>\
  <field name=\"serial_number\" type=\"string\" sourceType=\"string\" comment=\"The best approximation of the battery serial number\"/>\
</class>\
\
<class name=\"CameraInfo\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"c9a58c1b0b154e0e6da7578cb991d214\" rosDesc=\"# This message defines meta information for a camera. It should be in a\\n# camera namespace on topic \\&quot;camera_info\\&quot; and accompanied by up to five\\n# image topics named:\\n#\\n#   image_raw - raw data from the camera driver, possibly Bayer encoded\\n#   image            - monochrome, distorted\\n#   image_color      - color, distorted\\n#   image_rect       - monochrome, rectified\\n#   image_rect_color - color, rectified\\n#\\n# The image_pipeline contains packages (image_proc, stereo_image_proc)\\n# for producing the four processed image topics from image_raw and\\n# camera_info. The meaning of the camera parameters are described in\\n# detail at http://www.ros.org/wiki/image_pipeline/CameraInfo.\\n#\\n# The image_geometry package provides a user-friendly interface to\\n# common operations using this meta information. If you want to, e.g.,\\n# project a 3d point into image coordinates, we strongly recommend\\n# using image_geometry.\\n#\\n# If the camera is uncalibrated, the matrices D, K, R, P should be left\\n# zeroed out. In particular, clients may assume that K[0] == 0.0\\n# indicates an uncalibrated camera.\\n\\n#######################################################################\\n#                     Image acquisition info                          #\\n#######################################################################\\n\\n# Time of image acquisition, camera coordinate frame ID\\nHeader header    # Header timestamp should be acquisition time of image\\n                 # Header frame_id should be optical frame of camera\\n                 # origin of frame should be optical center of camera\\n                 # +x should point to the right in the image\\n                 # +y should point down in the image\\n                 # +z should point into the plane of the image\\n\\n\\n#######################################################################\\n#                      Calibration Parameters                         #\\n#######################################################################\\n# These are fixed during camera calibration. Their values will be the #\\n# same in all messages until the camera is recalibrated. Note that    #\\n# self-calibrating systems may \\&quot;recalibrate\\&quot; frequently.              #\\n#                                                                     #\\n# The internal parameters can be used to warp a raw (distorted) image #\\n# to:                                                                 #\\n#   1. An undistorted image (requires D and K)                        #\\n#   2. A rectified image (requires D, K, R)                           #\\n# The projection matrix P projects 3D points into the rectified image.#\\n#######################################################################\\n\\n# The image dimensions with which the camera was calibrated. Normally\\n# this will be the full camera resolution in pixels.\\nuint32 height\\nuint32 width\\n\\n# The distortion model used. Supported models are listed in\\n# sensor_msgs/distortion_models.h. For most cameras, \\&quot;plumb_bob\\&quot; - a\\n# simple model of radial and tangential distortion - is sufficent.\\nstring distortion_model\\n\\n# The distortion parameters, size depending on the distortion model.\\n# For \\&quot;plumb_bob\\&quot;, the 5 parameters are: (k1, k2, t1, t2, k3).\\nfloat64[] D\\n\\n# Intrinsic camera matrix for the raw (distorted) images.\\n#     [fx  0 cx]\\n# K = [ 0 fy cy]\\n#     [ 0  0  1]\\n# Projects 3D points in the camera coordinate frame to 2D pixel\\n# coordinates using the focal lengths (fx, fy) and principal point\\n# (cx, cy).\\nfloat64[9]  K # 3x3 row-major matrix\\n\\n# Rectification matrix (stereo cameras only)\\n# A rotation matrix aligning the camera coordinate system to the ideal\\n# stereo image plane so that epipolar lines in both stereo images are\\n# parallel.\\nfloat64[9]  R # 3x3 row-major matrix\\n\\n# Projection/camera matrix\\n#     [fx'  0  cx' Tx]\\n# P = [ 0  fy' cy' Ty]\\n#     [ 0   0   1   0]\\n# By convention, this matrix specifies the intrinsic (camera) matrix\\n#  of the processed (rectified) image. That is, the left 3x3 portion\\n#  is the normal camera intrinsic matrix for the rectified image.\\n# It projects 3D points in the camera coordinate frame to 2D pixel\\n#  coordinates using the focal lengths (fx', fy') and principal point\\n#  (cx', cy') - these may differ from the values in K.\\n# For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will\\n#  also have R = the identity and P[1:3,1:3] = K.\\n# For a stereo pair, the fourth column [Tx Ty 0]' is related to the\\n#  position of the optical center of the second camera in the first\\n#  camera's frame. We assume Tz = 0 so both cameras are in the same\\n#  stereo image plane. The first camera always has Tx = Ty = 0. For\\n#  the right (second) camera of a horizontal stereo pair, Ty = 0 and\\n#  Tx = -fx' * B, where B is the baseline between the cameras.\\n# Given a 3D point [X Y Z]', the projection (x, y) of the point onto\\n#  the rectified image is given by:\\n#  [u v w]' = P * [X Y Z 1]'\\n#         x = u / w\\n#         y = v / w\\n#  This holds for both images of a stereo pair.\\nfloat64[12] P # 3x4 row-major matrix\\n\\n\\n#######################################################################\\n#                      Operational Parameters                         #\\n#######################################################################\\n# These define the image region actually captured by the camera       #\\n# driver. Although they affect the geometry of the output image, they #\\n# may be changed freely without recalibrating the camera.             #\\n#######################################################################\\n\\n# Binning refers here to any camera setting which combines rectangular\\n#  neighborhoods of pixels into larger \\&quot;super-pixels.\\&quot; It reduces the\\n#  resolution of the output image to\\n#  (width / binning_x) x (height / binning_y).\\n# The default values binning_x = binning_y = 0 is considered the same\\n#  as binning_x = binning_y = 1 (no subsampling).\\nuint32 binning_x\\nuint32 binning_y\\n\\n# Region of interest (subwindow of full camera resolution), given in\\n#  full resolution (unbinned) image coordinates. A particular ROI\\n#  always denotes the same window of pixels on the camera sensor,\\n#  regardless of binning settings.\\n# The default setting of roi (all values 0) is considered the same as\\n#  full resolution (roi.width = width, roi.height = height).\\nRegionOfInterest roi\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: sensor_msgs/RegionOfInterest\\n# This message is used to specify a region of interest within an image.\\n#\\n# When used to specify the ROI setting of the camera when the image was\\n# taken, the height and width fields should either match the height and\\n# width fields for the associated image; or height = width = 0\\n# indicates that the full resolution image was captured.\\n\\nuint32 x_offset  # Leftmost pixel of the ROI\\n                 # (0 if the ROI includes the left edge of the image)\\nuint32 y_offset  # Topmost pixel of the ROI\\n                 # (0 if the ROI includes the top edge of the image)\\nuint32 height    # Height of ROI\\nuint32 width     # Width of ROI\\n\\n# True if a distinct rectified ROI should be calculated from the \\&quot;raw\\&quot;\\n# ROI in this message. Typically this should be False if the full image\\n# is captured (ROI not used), and True if a subwindow is captured (ROI\\n# used).\\nbool do_rectify\\n\" comment=\"This message defines meta information for a camera. It should be in a  camera namespace on topic &quot;camera_info&quot; and accompanied by up to five  image topics named:     image_raw - raw data from the camera driver, possibly Bayer encoded    image            - monochrome, distorted    image_color      - color, distorted    image_rect       - monochrome, rectified    image_rect_color - color, rectified   The image_pipeline contains packages (image_proc, stereo_image_proc)  for producing the four processed image topics from image_raw and  camera_info. The meaning of the camera parameters are described in  detail at http://www.ros.org/wiki/image_pipeline/CameraInfo.   The image_geometry package provides a user-friendly interface to  common operations using this meta information. If you want to, e.g.,  project a 3d point into image coordinates, we strongly recommend  using image_geometry.   If the camera is uncalibrated, the matrices D, K, R, P should be left  zeroed out. In particular, clients may assume that K[0] == 0.0  indicates an uncalibrated camera.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"Header timestamp should be acquisition time of image  Header frame_id should be optical frame of camera  origin of frame should be optical center of camera  +x should point to the right in the image  +y should point down in the image  +z should point into the plane of the image                        Calibration Parameters                            These are fixed during camera calibration. Their values will be the   same in all messages until the camera is recalibrated. Note that      self-calibrating systems may &quot;recalibrate&quot; frequently.                                                                                      The internal parameters can be used to warp a raw (distorted) image   to:                                                                     1. An undistorted image (requires D and K)                            2. A rectified image (requires D, K, R)                             The projection matrix P projects 3D points into the rectified image.   The image dimensions with which the camera was calibrated. Normally  this will be the full camera resolution in pixels.\"/>\
  <field name=\"height\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"\"/>\
  <field name=\"width\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"The distortion model used. Supported models are listed in  sensor_msgs/distortion_models.h. For most cameras, &quot;plumb_bob&quot; - a  simple model of radial and tangential distortion - is sufficent.\"/>\
  <field name=\"distortion_model\" type=\"string\" sourceType=\"string\" comment=\"The distortion parameters, size depending on the distortion model.  For &quot;plumb_bob&quot;, the 5 parameters are: (k1, k2, t1, t2, k3).\"/>\
  <field name=\"D\" type=\"vector(double)\" sourceType=\"float64\" comment=\"Intrinsic camera matrix for the raw (distorted) images.      [fx  0 cx]  K = [ 0 fy cy]      [ 0  0  1]  Projects 3D points in the camera coordinate frame to 2D pixel  coordinates using the focal lengths (fx, fy) and principal point  (cx, cy).\"/>\
  <field name=\"K\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"3x3 row-major matrix  Rectification matrix (stereo cameras only)  A rotation matrix aligning the camera coordinate system to the ideal  stereo image plane so that epipolar lines in both stereo images are  parallel.\"/>\
  <field name=\"R\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"3x3 row-major matrix  Projection/camera matrix      [fx'  0  cx' Tx]  P = [ 0  fy' cy' Ty]      [ 0   0   1   0]  By convention, this matrix specifies the intrinsic (camera) matrix   of the processed (rectified) image. That is, the left 3x3 portion   is the normal camera intrinsic matrix for the rectified image.  It projects 3D points in the camera coordinate frame to 2D pixel   coordinates using the focal lengths (fx', fy') and principal point   (cx', cy') - these may differ from the values in K.  For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will   also have R = the identity and P[1:3,1:3] = K.  For a stereo pair, the fourth column [Tx Ty 0]' is related to the   position of the optical center of the second camera in the first   camera's frame. We assume Tz = 0 so both cameras are in the same   stereo image plane. The first camera always has Tx = Ty = 0. For   the right (second) camera of a horizontal stereo pair, Ty = 0 and   Tx = -fx' * B, where B is the baseline between the cameras.  Given a 3D point [X Y Z]', the projection (x, y) of the point onto   the rectified image is given by:   [u v w]' = P * [X Y Z 1]'          x = u / w          y = v / w   This holds for both images of a stereo pair.\"/>\
  <field name=\"P\" type=\"double\" size=\"12\" sourceType=\"float64\" comment=\"3x4 row-major matrix                        Operational Parameters                            These define the image region actually captured by the camera         driver. Although they affect the geometry of the output image, they   may be changed freely without recalibrating the camera.                Binning refers here to any camera setting which combines rectangular   neighborhoods of pixels into larger &quot;super-pixels.&quot; It reduces the   resolution of the output image to   (width / binning_x) x (height / binning_y).  The default values binning_x = binning_y = 0 is considered the same   as binning_x = binning_y = 1 (no subsampling).\"/>\
  <field name=\"binning_x\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"\"/>\
  <field name=\"binning_y\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Region of interest (subwindow of full camera resolution), given in   full resolution (unbinned) image coordinates. A particular ROI   always denotes the same window of pixels on the camera sensor,   regardless of binning settings.  The default setting of roi (all values 0) is considered the same as   full resolution (roi.width = width, roi.height = height).\"/>\
  <field name=\"roi\" type=\"RegionOfInterest\" sourceType=\"RegionOfInterest\" comment=\"\"/>\
</class>\
\
<class name=\"ChannelFloat32\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"3d40139cdd33dfedcb71ffeeeb42ae7f\" rosDesc=\"# This message is used by the PointCloud message to hold optional data\\n# associated with each point in the cloud. The length of the values\\n# array should be the same as the length of the points array in the\\n# PointCloud, and each value should be associated with the corresponding\\n# point.\\n\\n# Channel names in existing practice include:\\n#   \\&quot;u\\&quot;, \\&quot;v\\&quot; - row and column (respectively) in the left stereo image.\\n#              This is opposite to usual conventions but remains for\\n#              historical reasons. The newer PointCloud2 message has no\\n#              such problem.\\n#   \\&quot;rgb\\&quot; - For point clouds produced by color stereo cameras. uint8\\n#           (R,G,B) values packed into the least significant 24 bits,\\n#           in order.\\n#   \\&quot;intensity\\&quot; - laser or pixel intensity.\\n#   \\&quot;distance\\&quot;\\n\\n# The channel name should give semantics of the channel (e.g.\\n# \\&quot;intensity\\&quot; instead of \\&quot;value\\&quot;).\\nstring name\\n\\n# The values array should be 1-1 with the elements of the associated\\n# PointCloud.\\nfloat32[] values\\n\" comment=\"This message is used by the PointCloud message to hold optional data  associated with each point in the cloud. The length of the values  array should be the same as the length of the points array in the  PointCloud, and each value should be associated with the corresponding  point.\">\
  <field name=\"name\" type=\"string\" sourceType=\"string\" comment=\"The values array should be 1-1 with the elements of the associated  PointCloud.\"/>\
  <field name=\"values\" type=\"vector(float)\" sourceType=\"float32\" comment=\"\"/>\
</class>\
\
<class name=\"CompressedImage\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"8f7a12909da2c9d3332d540a0977563f\" rosDesc=\"# This message contains a compressed image\\n\\nHeader header        # Header timestamp should be acquisition time of image\\n                     # Header frame_id should be optical frame of camera\\n                     # origin of frame should be optical center of cameara\\n                     # +x should point to the right in the image\\n                     # +y should point down in the image\\n                     # +z should point into to plane of the image\\n\\nstring format        # Specifies the format of the data\\n                     #   Acceptable values:\\n                     #     jpeg, png\\nuint8[] data         # Compressed image buffer\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"This message contains a compressed image\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"Header timestamp should be acquisition time of image  Header frame_id should be optical frame of camera  origin of frame should be optical center of cameara  +x should point to the right in the image  +y should point down in the image  +z should point into to plane of the image\"/>\
  <field name=\"format\" type=\"string\" sourceType=\"string\" comment=\"Specifies the format of the data    Acceptable values:      jpeg, png\"/>\
  <field name=\"data\" type=\"vector(unsigned char)\" sourceType=\"uint8\" comment=\"Compressed image buffer\"/>\
</class>\
\
<class name=\"FluidPressure\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"804dc5cea1c5306d6a2eb80b9833befe\" rosDesc=\"# Single pressure reading.  This message is appropriate for measuring the\\n # pressure inside of a fluid (air, water, etc).  This also includes\\n # atmospheric or barometric pressure.\\n\\n # This message is not appropriate for force/pressure contact sensors.\\n\\n Header header           # timestamp of the measurement\\n                         # frame_id is the location of the pressure sensor\\n\\n float64 fluid_pressure  # Absolute pressure reading in Pascals.\\n\\n float64 variance        # 0 is interpreted as variance unknown\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Single pressure reading.  This message is appropriate for measuring the  pressure inside of a fluid (air, water, etc).  This also includes  atmospheric or barometric pressure.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp of the measurement  frame_id is the location of the pressure sensor\"/>\
  <field name=\"fluid_pressure\" type=\"double\" sourceType=\"float64\" comment=\"Absolute pressure reading in Pascals.\"/>\
  <field name=\"variance\" type=\"double\" sourceType=\"float64\" comment=\"0 is interpreted as variance unknown\"/>\
</class>\
\
<class name=\"Illuminance\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"8cf5febb0952fca9d650c3d11a81a188\" rosDesc=\"# Single photometric illuminance measurement.  Light should be assumed to be\\n # measured along the sensor's x-axis (the area of detection is the y-z plane).\\n # The illuminance should have a 0 or positive value and be received with\\n # the sensor's +X axis pointing toward the light source.\\n\\n # Photometric illuminance is the measure of the human eye's sensitivity of the\\n # intensity of light encountering or passing through a surface.\\n\\n # All other Photometric and Radiometric measurements should\\n # not use this message.\\n # This message cannot represent:\\n # Luminous intensity (candela/light source output)\\n # Luminance (nits/light output per area)\\n # Irradiance (watt/area), etc.\\n\\n Header header           # timestamp is the time the illuminance was measured\\n                         # frame_id is the location and direction of the reading\\n\\n float64 illuminance     # Measurement of the Photometric Illuminance in Lux.\\n\\n float64 variance        # 0 is interpreted as variance unknown\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Single photometric illuminance measurement.  Light should be assumed to be  measured along the sensor's x-axis (the area of detection is the y-z plane).  The illuminance should have a 0 or positive value and be received with  the sensor's +X axis pointing toward the light source.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp is the time the illuminance was measured  frame_id is the location and direction of the reading\"/>\
  <field name=\"illuminance\" type=\"double\" sourceType=\"float64\" comment=\"Measurement of the Photometric Illuminance in Lux.\"/>\
  <field name=\"variance\" type=\"double\" sourceType=\"float64\" comment=\"0 is interpreted as variance unknown\"/>\
</class>\
\
<class name=\"Image\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"060021388200f6f0f447d0fcd9c64743\" rosDesc=\"# This message contains an uncompressed image\\n# (0, 0) is at top-left corner of image\\n#\\n\\nHeader header        # Header timestamp should be acquisition time of image\\n                     # Header frame_id should be optical frame of camera\\n                     # origin of frame should be optical center of cameara\\n                     # +x should point to the right in the image\\n                     # +y should point down in the image\\n                     # +z should point into to plane of the image\\n                     # If the frame_id here and the frame_id of the CameraInfo\\n                     # message associated with the image conflict\\n                     # the behavior is undefined\\n\\nuint32 height         # image height, that is, number of rows\\nuint32 width          # image width, that is, number of columns\\n\\n# The legal values for encoding are in file src/image_encodings.cpp\\n# If you want to standardize a new string format, join\\n# ros-users@lists.sourceforge.net and send an email proposing a new encoding.\\n\\nstring encoding       # Encoding of pixels -- channel meaning, ordering, size\\n                      # taken from the list of strings in include/sensor_msgs/image_encodings.h\\n\\nuint8 is_bigendian    # is this data bigendian?\\nuint32 step           # Full row length in bytes\\nuint8[] data          # actual matrix data, size is (step * rows)\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"This message contains an uncompressed image  (0, 0) is at top-left corner of image\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"Header timestamp should be acquisition time of image  Header frame_id should be optical frame of camera  origin of frame should be optical center of cameara  +x should point to the right in the image  +y should point down in the image  +z should point into to plane of the image  If the frame_id here and the frame_id of the CameraInfo  message associated with the image conflict  the behavior is undefined\"/>\
  <field name=\"height\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"image height, that is, number of rows\"/>\
  <field name=\"width\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"image width, that is, number of columns  The legal values for encoding are in file src/image_encodings.cpp  If you want to standardize a new string format, join  ros-users@lists.sourceforge.net and send an email proposing a new encoding.\"/>\
  <field name=\"encoding\" type=\"string\" sourceType=\"string\" comment=\"Encoding of pixels -- channel meaning, ordering, size  taken from the list of strings in include/sensor_msgs/image_encodings.h\"/>\
  <field name=\"is_bigendian\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"is this data bigendian?\"/>\
  <field name=\"step\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Full row length in bytes\"/>\
  <field name=\"data\" type=\"vector(unsigned char)\" sourceType=\"uint8\" comment=\"actual matrix data, size is (step * rows)\"/>\
</class>\
\
<class name=\"Imu\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"6a62c6daae103f4ff57a132d6f95cec2\" rosDesc=\"# This is a message to hold data from an IMU (Inertial Measurement Unit)\\n#\\n# Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec\\n#\\n# If the covariance of the measurement is known, it should be filled in (if all you know is the \\n# variance of each measurement, e.g. from the datasheet, just put those along the diagonal)\\n# A covariance matrix of all zeros will be interpreted as \\&quot;covariance unknown\\&quot;, and to use the\\n# data a covariance will have to be assumed or gotten from some other source\\n#\\n# If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation \\n# estimate), please set element 0 of the associated covariance matrix to -1\\n# If you are interpreting this message, please check for a value of -1 in the first element of each \\n# covariance matrix, and disregard the associated estimate.\\n\\nHeader header\\n\\ngeometry_msgs/Quaternion orientation\\nfloat64[9] orientation_covariance # Row major about x, y, z axes\\n\\ngeometry_msgs/Vector3 angular_velocity\\nfloat64[9] angular_velocity_covariance # Row major about x, y, z axes\\n\\ngeometry_msgs/Vector3 linear_acceleration\\nfloat64[9] linear_acceleration_covariance # Row major x, y z \\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"This is a message to hold data from an IMU (Inertial Measurement Unit)   Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec   If the covariance of the measurement is known, it should be filled in (if all you know is the   variance of each measurement, e.g. from the datasheet, just put those along the diagonal)  A covariance matrix of all zeros will be interpreted as &quot;covariance unknown&quot;, and to use the  data a covariance will have to be assumed or gotten from some other source   If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation   estimate), please set element 0 of the associated covariance matrix to -1  If you are interpreting this message, please check for a value of -1 in the first element of each   covariance matrix, and disregard the associated estimate.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"\"/>\
  <field name=\"orientation\" type=\"geometry_msgs::Quaternion\" sourceType=\"geometry_msgs::Quaternion\" comment=\"\"/>\
  <field name=\"orientation_covariance\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"Row major about x, y, z axes\"/>\
  <field name=\"angular_velocity\" type=\"geometry_msgs::Vector3\" sourceType=\"geometry_msgs::Vector3\" comment=\"\"/>\
  <field name=\"angular_velocity_covariance\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"Row major about x, y, z axes\"/>\
  <field name=\"linear_acceleration\" type=\"geometry_msgs::Vector3\" sourceType=\"geometry_msgs::Vector3\" comment=\"\"/>\
  <field name=\"linear_acceleration_covariance\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"Row major x, y z\"/>\
</class>\
\
<class name=\"JointState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"3066dcd76a6cfaef579bd0f34173e9fd\" rosDesc=\"# This is a message that holds data to describe the state of a set of torque controlled joints. \\n#\\n# The state of each joint (revolute or prismatic) is defined by:\\n#  * the position of the joint (rad or m),\\n#  * the velocity of the joint (rad/s or m/s) and \\n#  * the effort that is applied in the joint (Nm or N).\\n#\\n# Each joint is uniquely identified by its name\\n# The header specifies the time at which the joint states were recorded. All the joint states\\n# in one message have to be recorded at the same time.\\n#\\n# This message consists of a multiple arrays, one for each part of the joint state. \\n# The goal is to make each of the fields optional. When e.g. your joints have no\\n# effort associated with them, you can leave the effort array empty. \\n#\\n# All arrays in this message should have the same size, or be empty.\\n# This is the only way to uniquely associate the joint name with the correct\\n# states.\\n\\n\\nHeader header\\n\\nstring[] name\\nfloat64[] position\\nfloat64[] velocity\\nfloat64[] effort\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"This is a message that holds data to describe the state of a set of torque controlled joints.    The state of each joint (revolute or prismatic) is defined by:   * the position of the joint (rad or m),   * the velocity of the joint (rad/s or m/s) and    * the effort that is applied in the joint (Nm or N).   Each joint is uniquely identified by its name  The header specifies the time at which the joint states were recorded. All the joint states  in one message have to be recorded at the same time.   This message consists of a multiple arrays, one for each part of the joint state.   The goal is to make each of the fields optional. When e.g. your joints have no  effort associated with them, you can leave the effort array empty.    All arrays in this message should have the same size, or be empty.  This is the only way to uniquely associate the joint name with the correct  states.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"\"/>\
  <field name=\"name\" type=\"vector(string)\" sourceType=\"string\" comment=\"\"/>\
  <field name=\"position\" type=\"vector(double)\" sourceType=\"float64\" comment=\"\"/>\
  <field name=\"velocity\" type=\"vector(double)\" sourceType=\"float64\" comment=\"\"/>\
  <field name=\"effort\" type=\"vector(double)\" sourceType=\"float64\" comment=\"\"/>\
</class>\
\
<class name=\"Joy\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"5a9ea5f83505693b71e785041e67a8bb\" rosDesc=\"# Reports the state of a joysticks axes and buttons.\\nHeader header           # timestamp in the header is the time the data is received from the joystick\\nfloat32[] axes          # the axes measurements from a joystick\\nint32[] buttons         # the buttons measurements from a joystick \\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Reports the state of a joysticks axes and buttons.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp in the header is the time the data is received from the joystick\"/>\
  <field name=\"axes\" type=\"vector(float)\" sourceType=\"float32\" comment=\"the axes measurements from a joystick\"/>\
  <field name=\"buttons\" type=\"vector(int)\" sourceType=\"int32\" comment=\"the buttons measurements from a joystick\"/>\
</class>\
\
<class name=\"JoyFeedback\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"f4dcd73460360d98f36e55ee7f2e46f1\" rosDesc=\"# Declare of the type of feedback\\nuint8 TYPE_LED    = 0\\nuint8 TYPE_RUMBLE = 1\\nuint8 TYPE_BUZZER = 2\\n\\nuint8 type\\n\\n# This will hold an id number for each type of each feedback.\\n# Example, the first led would be id=0, the second would be id=1\\nuint8 id\\n\\n# Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is\\n# actually binary, driver should treat 0&lt;=x&lt;0.5 as off, 0.5&lt;=x&lt;=1 as on.\\nfloat32 intensity\\n\\n\" comment=\"Declare of the type of feedback\">\
  <constant init=\"0\" name=\"TYPE_LED\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"TYPE_RUMBLE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"TYPE_BUZZER\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <field name=\"type\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"This will hold an id number for each type of each feedback.  Example, the first led would be id=0, the second would be id=1\"/>\
  <field name=\"id\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is  actually binary, driver should treat 0&lt;=x&lt;0.5 as off, 0.5&lt;=x&lt;=1 as on.\"/>\
  <field name=\"intensity\" type=\"float\" sourceType=\"float32\" comment=\"\"/>\
</class>\
\
<class name=\"JoyFeedbackArray\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"cde5730a895b1fc4dee6f91b754b213d\" rosDesc=\"# This message publishes values for multiple feedback at once. \\nJoyFeedback[] array\\n================================================================================\\nMSG: sensor_msgs/JoyFeedback\\n# Declare of the type of feedback\\nuint8 TYPE_LED    = 0\\nuint8 TYPE_RUMBLE = 1\\nuint8 TYPE_BUZZER = 2\\n\\nuint8 type\\n\\n# This will hold an id number for each type of each feedback.\\n# Example, the first led would be id=0, the second would be id=1\\nuint8 id\\n\\n# Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is\\n# actually binary, driver should treat 0&lt;=x&lt;0.5 as off, 0.5&lt;=x&lt;=1 as on.\\nfloat32 intensity\\n\\n\" comment=\"This message publishes values for multiple feedback at once.\">\
  <field name=\"array\" type=\"vector(JoyFeedback)\" sourceType=\"JoyFeedback\" comment=\"\"/>\
</class>\
\
<class name=\"LaserEcho\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"8bc5ae449b200fba4d552b4225586696\" rosDesc=\"# This message is a submessage of MultiEchoLaserScan and is not intended\\n# to be used separately.\\n\\nfloat32[] echoes  # Multiple values of ranges or intensities.\\n\" comment=\"This message is a submessage of MultiEchoLaserScan and is not intended  to be used separately.\">\
  <field name=\"echoes\" type=\"vector(float)\" sourceType=\"float32\" comment=\"Multiple values of ranges or intensities.  Each array represents data from the same angle increment.\"/>\
</class>\
\
<class name=\"LaserScan\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"90c7ef2dc6895d81024acba2ac42f369\" rosDesc=\"# Single scan from a planar laser range-finder\\n#\\n# If you have another ranging device with different behavior (e.g. a sonar\\n# array), please find or create a different message, since applications\\n# will make fairly laser-specific assumptions about this data\\n\\nHeader header            # timestamp in the header is the acquisition time of \\n                         # the first ray in the scan.\\n                         #\\n                         # in frame frame_id, angles are measured around \\n                         # the positive Z axis (counterclockwise, if Z is up)\\n                         # with zero angle being forward along the x axis\\n                         \\nfloat32 angle_min        # start angle of the scan [rad]\\nfloat32 angle_max        # end angle of the scan [rad]\\nfloat32 angle_increment  # angular distance between measurements [rad]\\n\\nfloat32 time_increment   # time between measurements [seconds] - if your scanner\\n                         # is moving, this will be used in interpolating position\\n                         # of 3d points\\nfloat32 scan_time        # time between scans [seconds]\\n\\nfloat32 range_min        # minimum range value [m]\\nfloat32 range_max        # maximum range value [m]\\n\\nfloat32[] ranges         # range data [m] (Note: values &lt; range_min or &gt; range_max should be discarded)\\nfloat32[] intensities    # intensity data [device-specific units].  If your\\n                         # device does not provide intensities, please leave\\n                         # the array empty.\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Single scan from a planar laser range-finder   If you have another ranging device with different behavior (e.g. a sonar  array), please find or create a different message, since applications  will make fairly laser-specific assumptions about this data\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp in the header is the acquisition time of   the first ray in the scan.   in frame frame_id, angles are measured around   the positive Z axis (counterclockwise, if Z is up)  with zero angle being forward along the x axis\"/>\
  <field name=\"angle_min\" type=\"float\" sourceType=\"float32\" comment=\"start angle of the scan [rad]\"/>\
  <field name=\"angle_max\" type=\"float\" sourceType=\"float32\" comment=\"end angle of the scan [rad]\"/>\
  <field name=\"angle_increment\" type=\"float\" sourceType=\"float32\" comment=\"angular distance between measurements [rad]\"/>\
  <field name=\"time_increment\" type=\"float\" sourceType=\"float32\" comment=\"time between measurements [seconds] - if your scanner  is moving, this will be used in interpolating position  of 3d points\"/>\
  <field name=\"scan_time\" type=\"float\" sourceType=\"float32\" comment=\"time between scans [seconds]\"/>\
  <field name=\"range_min\" type=\"float\" sourceType=\"float32\" comment=\"minimum range value [m]\"/>\
  <field name=\"range_max\" type=\"float\" sourceType=\"float32\" comment=\"maximum range value [m]\"/>\
  <field name=\"ranges\" type=\"vector(float)\" sourceType=\"float32\" comment=\"range data [m] (Note: values &lt; range_min or &gt; range_max should be discarded)\"/>\
  <field name=\"intensities\" type=\"vector(float)\" sourceType=\"float32\" comment=\"intensity data [device-specific units].  If your  device does not provide intensities, please leave  the array empty.\"/>\
</class>\
\
<class name=\"MagneticField\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"2f3b0b43eed0c9501de0fa3ff89a45aa\" rosDesc=\"# Measurement of the Magnetic Field vector at a specific location.\\n\\n # If the covariance of the measurement is known, it should be filled in\\n # (if all you know is the variance of each measurement, e.g. from the datasheet,\\n #just put those along the diagonal)\\n # A covariance matrix of all zeros will be interpreted as \\&quot;covariance unknown\\&quot;,\\n # and to use the data a covariance will have to be assumed or gotten from some\\n # other source\\n\\n\\n Header header                        # timestamp is the time the\\n                                      # field was measured\\n                                      # frame_id is the location and orientation\\n                                      # of the field measurement\\n\\n geometry_msgs/Vector3 magnetic_field # x, y, and z components of the\\n                                      # field vector in Tesla\\n                                      # If your sensor does not output 3 axes,\\n                                      # put NaNs in the components not reported.\\n\\n float64[9] magnetic_field_covariance # Row major about x, y, z axes\\n                                      # 0 is interpreted as variance unknown\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"Measurement of the Magnetic Field vector at a specific location.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp is the time the  field was measured  frame_id is the location and orientation  of the field measurement\"/>\
  <field name=\"magnetic_field\" type=\"geometry_msgs::Vector3\" sourceType=\"geometry_msgs::Vector3\" comment=\"x, y, and z components of the  field vector in Tesla  If your sensor does not output 3 axes,  put NaNs in the components not reported.\"/>\
  <field name=\"magnetic_field_covariance\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"Row major about x, y, z axes  0 is interpreted as variance unknown\"/>\
</class>\
\
<class name=\"MultiDOFJointState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"690f272f0640d2631c305eeb8301e59d\" rosDesc=\"# Representation of state for joints with multiple degrees of freedom, \\n# following the structure of JointState.\\n#\\n# It is assumed that a joint in a system corresponds to a transform that gets applied \\n# along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)\\n# and those 3DOF can be expressed as a transformation matrix, and that transformation\\n# matrix can be converted back to (x, y, yaw)\\n#\\n# Each joint is uniquely identified by its name\\n# The header specifies the time at which the joint states were recorded. All the joint states\\n# in one message have to be recorded at the same time.\\n#\\n# This message consists of a multiple arrays, one for each part of the joint state. \\n# The goal is to make each of the fields optional. When e.g. your joints have no\\n# wrench associated with them, you can leave the wrench array empty. \\n#\\n# All arrays in this message should have the same size, or be empty.\\n# This is the only way to uniquely associate the joint name with the correct\\n# states.\\n\\nHeader header\\n\\nstring[] joint_names\\ngeometry_msgs/Transform[] transforms\\ngeometry_msgs/Twist[] twist\\ngeometry_msgs/Wrench[] wrench\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: geometry_msgs/Transform\\n# This represents the transform between two coordinate frames in free space.\\n\\nVector3 translation\\nQuaternion rotation\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Twist\\n# This expresses velocity in free space broken into its linear and angular parts.\\nVector3  linear\\nVector3  angular\\n\\n================================================================================\\nMSG: geometry_msgs/Wrench\\n# This represents force in free space, separated into\\n# its linear and angular parts.\\nVector3  force\\nVector3  torque\\n\" comment=\"Representation of state for joints with multiple degrees of freedom,   following the structure of JointState.   It is assumed that a joint in a system corresponds to a transform that gets applied   along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)  and those 3DOF can be expressed as a transformation matrix, and that transformation  matrix can be converted back to (x, y, yaw)   Each joint is uniquely identified by its name  The header specifies the time at which the joint states were recorded. All the joint states  in one message have to be recorded at the same time.   This message consists of a multiple arrays, one for each part of the joint state.   The goal is to make each of the fields optional. When e.g. your joints have no  wrench associated with them, you can leave the wrench array empty.    All arrays in this message should have the same size, or be empty.  This is the only way to uniquely associate the joint name with the correct  states.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"\"/>\
  <field name=\"joint_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"\"/>\
  <field name=\"transforms\" type=\"vector(geometry_msgs::Transform)\" sourceType=\"geometry_msgs::Transform\" comment=\"\"/>\
  <field name=\"twist\" type=\"vector(geometry_msgs::Twist)\" sourceType=\"geometry_msgs::Twist\" comment=\"\"/>\
  <field name=\"wrench\" type=\"vector(geometry_msgs::Wrench)\" sourceType=\"geometry_msgs::Wrench\" comment=\"\"/>\
</class>\
\
<class name=\"MultiEchoLaserScan\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"6fefb0c6da89d7c8abe4b339f5c2f8fb\" rosDesc=\"# Single scan from a multi-echo planar laser range-finder\\n#\\n# If you have another ranging device with different behavior (e.g. a sonar\\n# array), please find or create a different message, since applications\\n# will make fairly laser-specific assumptions about this data\\n\\nHeader header            # timestamp in the header is the acquisition time of \\n                         # the first ray in the scan.\\n                         #\\n                         # in frame frame_id, angles are measured around \\n                         # the positive Z axis (counterclockwise, if Z is up)\\n                         # with zero angle being forward along the x axis\\n                         \\nfloat32 angle_min        # start angle of the scan [rad]\\nfloat32 angle_max        # end angle of the scan [rad]\\nfloat32 angle_increment  # angular distance between measurements [rad]\\n\\nfloat32 time_increment   # time between measurements [seconds] - if your scanner\\n                         # is moving, this will be used in interpolating position\\n                         # of 3d points\\nfloat32 scan_time        # time between scans [seconds]\\n\\nfloat32 range_min        # minimum range value [m]\\nfloat32 range_max        # maximum range value [m]\\n\\nLaserEcho[] ranges       # range data [m] (Note: NaNs, values &lt; range_min or &gt; range_max should be discarded)\\n                         # +Inf measurements are out of range\\n                         # -Inf measurements are too close to determine exact distance.\\nLaserEcho[] intensities  # intensity data [device-specific units].  If your\\n                         # device does not provide intensities, please leave\\n                         # the array empty.\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: sensor_msgs/LaserEcho\\n# This message is a submessage of MultiEchoLaserScan and is not intended\\n# to be used separately.\\n\\nfloat32[] echoes  # Multiple values of ranges or intensities.\\n\" comment=\"Single scan from a multi-echo planar laser range-finder   If you have another ranging device with different behavior (e.g. a sonar  array), please find or create a different message, since applications  will make fairly laser-specific assumptions about this data\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp in the header is the acquisition time of   the first ray in the scan.   in frame frame_id, angles are measured around   the positive Z axis (counterclockwise, if Z is up)  with zero angle being forward along the x axis\"/>\
  <field name=\"angle_min\" type=\"float\" sourceType=\"float32\" comment=\"start angle of the scan [rad]\"/>\
  <field name=\"angle_max\" type=\"float\" sourceType=\"float32\" comment=\"end angle of the scan [rad]\"/>\
  <field name=\"angle_increment\" type=\"float\" sourceType=\"float32\" comment=\"angular distance between measurements [rad]\"/>\
  <field name=\"time_increment\" type=\"float\" sourceType=\"float32\" comment=\"time between measurements [seconds] - if your scanner  is moving, this will be used in interpolating position  of 3d points\"/>\
  <field name=\"scan_time\" type=\"float\" sourceType=\"float32\" comment=\"time between scans [seconds]\"/>\
  <field name=\"range_min\" type=\"float\" sourceType=\"float32\" comment=\"minimum range value [m]\"/>\
  <field name=\"range_max\" type=\"float\" sourceType=\"float32\" comment=\"maximum range value [m]\"/>\
  <field name=\"ranges\" type=\"vector(LaserEcho)\" sourceType=\"LaserEcho\" comment=\"range data [m] (Note: NaNs, values &lt; range_min or &gt; range_max should be discarded)  +Inf measurements are out of range  -Inf measurements are too close to determine exact distance.\"/>\
  <field name=\"intensities\" type=\"vector(LaserEcho)\" sourceType=\"LaserEcho\" comment=\"intensity data [device-specific units].  If your  device does not provide intensities, please leave  the array empty.\"/>\
</class>\
\
<class name=\"NavSatFix\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"2d3a8cd499b9b4a0249fb98fd05cfa48\" rosDesc=\"# Navigation Satellite fix for any Global Navigation Satellite System\\n#\\n# Specified using the WGS 84 reference ellipsoid\\n\\n# header.stamp specifies the ROS time for this measurement (the\\n#        corresponding satellite time may be reported using the\\n#        sensor_msgs/TimeReference message).\\n#\\n# header.frame_id is the frame of reference reported by the satellite\\n#        receiver, usually the location of the antenna.  This is a\\n#        Euclidean frame relative to the vehicle, not a reference\\n#        ellipsoid.\\nHeader header\\n\\n# satellite fix status information\\nNavSatStatus status\\n\\n# Latitude [degrees]. Positive is north of equator; negative is south.\\nfloat64 latitude\\n\\n# Longitude [degrees]. Positive is east of prime meridian; negative is west.\\nfloat64 longitude\\n\\n# Altitude [m]. Positive is above the WGS 84 ellipsoid\\n# (quiet NaN if no altitude is available).\\nfloat64 altitude\\n\\n# Position covariance [m^2] defined relative to a tangential plane\\n# through the reported position. The components are East, North, and\\n# Up (ENU), in row-major order.\\n#\\n# Beware: this coordinate system exhibits singularities at the poles.\\n\\nfloat64[9] position_covariance\\n\\n# If the covariance of the fix is known, fill it in completely. If the\\n# GPS receiver provides the variance of each measurement, put them\\n# along the diagonal. If only Dilution of Precision is available,\\n# estimate an approximate covariance from that.\\n\\nuint8 COVARIANCE_TYPE_UNKNOWN = 0\\nuint8 COVARIANCE_TYPE_APPROXIMATED = 1\\nuint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2\\nuint8 COVARIANCE_TYPE_KNOWN = 3\\n\\nuint8 position_covariance_type\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: sensor_msgs/NavSatStatus\\n# Navigation Satellite fix status for any Global Navigation Satellite System\\n\\n# Whether to output an augmented fix is determined by both the fix\\n# type and the last time differential corrections were received.  A\\n# fix is valid when status &gt;= STATUS_FIX.\\n\\nint8 STATUS_NO_FIX =  -1        # unable to fix position\\nint8 STATUS_FIX =      0        # unaugmented fix\\nint8 STATUS_SBAS_FIX = 1        # with satellite-based augmentation\\nint8 STATUS_GBAS_FIX = 2        # with ground-based augmentation\\n\\nint8 status\\n\\n# Bits defining which Global Navigation Satellite System signals were\\n# used by the receiver.\\n\\nuint16 SERVICE_GPS =     1\\nuint16 SERVICE_GLONASS = 2\\nuint16 SERVICE_COMPASS = 4      # includes BeiDou.\\nuint16 SERVICE_GALILEO = 8\\n\\nuint16 service\\n\" comment=\"Navigation Satellite fix for any Global Navigation Satellite System   Specified using the WGS 84 reference ellipsoid\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"satellite fix status information\"/>\
  <field name=\"status\" type=\"NavSatStatus\" sourceType=\"NavSatStatus\" comment=\"Latitude [degrees]. Positive is north of equator; negative is south.\"/>\
  <field name=\"latitude\" type=\"double\" sourceType=\"float64\" comment=\"Longitude [degrees]. Positive is east of prime meridian; negative is west.\"/>\
  <field name=\"longitude\" type=\"double\" sourceType=\"float64\" comment=\"Altitude [m]. Positive is above the WGS 84 ellipsoid  (quiet NaN if no altitude is available).\"/>\
  <field name=\"altitude\" type=\"double\" sourceType=\"float64\" comment=\"Position covariance [m^2] defined relative to a tangential plane  through the reported position. The components are East, North, and  Up (ENU), in row-major order.   Beware: this coordinate system exhibits singularities at the poles.\"/>\
  <field name=\"position_covariance\" type=\"double\" size=\"9\" sourceType=\"float64\" comment=\"If the covariance of the fix is known, fill it in completely. If the  GPS receiver provides the variance of each measurement, put them  along the diagonal. If only Dilution of Precision is available,  estimate an approximate covariance from that.\"/>\
  <constant init=\"0\" name=\"COVARIANCE_TYPE_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"COVARIANCE_TYPE_APPROXIMATED\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"COVARIANCE_TYPE_DIAGONAL_KNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"COVARIANCE_TYPE_KNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <field name=\"position_covariance_type\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
</class>\
\
<class name=\"NavSatStatus\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"331cdbddfa4bc96ffc3b9ad98900a54c\" rosDesc=\"# Navigation Satellite fix status for any Global Navigation Satellite System\\n\\n# Whether to output an augmented fix is determined by both the fix\\n# type and the last time differential corrections were received.  A\\n# fix is valid when status &gt;= STATUS_FIX.\\n\\nint8 STATUS_NO_FIX =  -1        # unable to fix position\\nint8 STATUS_FIX =      0        # unaugmented fix\\nint8 STATUS_SBAS_FIX = 1        # with satellite-based augmentation\\nint8 STATUS_GBAS_FIX = 2        # with ground-based augmentation\\n\\nint8 status\\n\\n# Bits defining which Global Navigation Satellite System signals were\\n# used by the receiver.\\n\\nuint16 SERVICE_GPS =     1\\nuint16 SERVICE_GLONASS = 2\\nuint16 SERVICE_COMPASS = 4      # includes BeiDou.\\nuint16 SERVICE_GALILEO = 8\\n\\nuint16 service\\n\" comment=\"Navigation Satellite fix status for any Global Navigation Satellite System\">\
  <constant init=\"-1\" name=\"STATUS_NO_FIX\" type=\"char\" sourceType=\"int8\" comment=\"unable to fix position\"/>\
  <constant init=\"0\" name=\"STATUS_FIX\" type=\"char\" sourceType=\"int8\" comment=\"unaugmented fix\"/>\
  <constant init=\"1\" name=\"STATUS_SBAS_FIX\" type=\"char\" sourceType=\"int8\" comment=\"with satellite-based augmentation\"/>\
  <constant init=\"2\" name=\"STATUS_GBAS_FIX\" type=\"char\" sourceType=\"int8\" comment=\"with ground-based augmentation\"/>\
  <field name=\"status\" type=\"char\" sourceType=\"int8\" comment=\"Bits defining which Global Navigation Satellite System signals were  used by the receiver.\"/>\
  <constant init=\"1\" name=\"SERVICE_GPS\" type=\"unsigned short int\" sourceType=\"uint16\" comment=\"\"/>\
  <constant init=\"2\" name=\"SERVICE_GLONASS\" type=\"unsigned short int\" sourceType=\"uint16\" comment=\"\"/>\
  <constant init=\"4\" name=\"SERVICE_COMPASS\" type=\"unsigned short int\" sourceType=\"uint16\" comment=\"includes BeiDou.\"/>\
  <constant init=\"8\" name=\"SERVICE_GALILEO\" type=\"unsigned short int\" sourceType=\"uint16\" comment=\"\"/>\
  <field name=\"service\" type=\"unsigned short int\" sourceType=\"uint16\" comment=\"\"/>\
</class>\
\
<class name=\"PointCloud\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"d8e9c3f5afbdd8a130fd1d2763945fca\" rosDesc=\"# This message holds a collection of 3d points, plus optional additional\\n# information about each point.\\n\\n# Time of sensor data acquisition, coordinate frame ID.\\nHeader header\\n\\n# Array of 3d points. Each Point32 should be interpreted as a 3d point\\n# in the frame given in the header.\\ngeometry_msgs/Point32[] points\\n\\n# Each channel should have the same number of elements as points array,\\n# and the data in each channel should correspond 1:1 with each point.\\n# Channel names in common practice are listed in ChannelFloat32.msg.\\nChannelFloat32[] channels\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: geometry_msgs/Point32\\n# This contains the position of a point in free space(with 32 bits of precision).\\n# It is recommeded to use Point wherever possible instead of Point32.  \\n# \\n# This recommendation is to promote interoperability.  \\n#\\n# This message is designed to take up less space when sending\\n# lots of points at once, as in the case of a PointCloud.  \\n\\nfloat32 x\\nfloat32 y\\nfloat32 z\\n================================================================================\\nMSG: sensor_msgs/ChannelFloat32\\n# This message is used by the PointCloud message to hold optional data\\n# associated with each point in the cloud. The length of the values\\n# array should be the same as the length of the points array in the\\n# PointCloud, and each value should be associated with the corresponding\\n# point.\\n\\n# Channel names in existing practice include:\\n#   \\&quot;u\\&quot;, \\&quot;v\\&quot; - row and column (respectively) in the left stereo image.\\n#              This is opposite to usual conventions but remains for\\n#              historical reasons. The newer PointCloud2 message has no\\n#              such problem.\\n#   \\&quot;rgb\\&quot; - For point clouds produced by color stereo cameras. uint8\\n#           (R,G,B) values packed into the least significant 24 bits,\\n#           in order.\\n#   \\&quot;intensity\\&quot; - laser or pixel intensity.\\n#   \\&quot;distance\\&quot;\\n\\n# The channel name should give semantics of the channel (e.g.\\n# \\&quot;intensity\\&quot; instead of \\&quot;value\\&quot;).\\nstring name\\n\\n# The values array should be 1-1 with the elements of the associated\\n# PointCloud.\\nfloat32[] values\\n\" comment=\"This message holds a collection of 3d points, plus optional additional  information about each point.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"Array of 3d points. Each Point32 should be interpreted as a 3d point  in the frame given in the header.\"/>\
  <field name=\"points\" type=\"vector(geometry_msgs::Point32)\" sourceType=\"geometry_msgs::Point32\" comment=\"Each channel should have the same number of elements as points array,  and the data in each channel should correspond 1:1 with each point.  Channel names in common practice are listed in ChannelFloat32.msg.\"/>\
  <field name=\"channels\" type=\"vector(ChannelFloat32)\" sourceType=\"ChannelFloat32\" comment=\"\"/>\
</class>\
\
<class name=\"PointCloud2\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"1158d486dd51d683ce2f1be655c3c181\" rosDesc=\"# This message holds a collection of N-dimensional points, which may\\n# contain additional information such as normals, intensity, etc. The\\n# point data is stored as a binary blob, its layout described by the\\n# contents of the \\&quot;fields\\&quot; array.\\n\\n# The point cloud data may be organized 2d (image-like) or 1d\\n# (unordered). Point clouds organized as 2d images may be produced by\\n# camera depth sensors such as stereo or time-of-flight.\\n\\n# Time of sensor data acquisition, and the coordinate frame ID (for 3d\\n# points).\\nHeader header\\n\\n# 2D structure of the point cloud. If the cloud is unordered, height is\\n# 1 and width is the length of the point cloud.\\nuint32 height\\nuint32 width\\n\\n# Describes the channels and their layout in the binary data blob.\\nPointField[] fields\\n\\nbool    is_bigendian # Is this data bigendian?\\nuint32  point_step   # Length of a point in bytes\\nuint32  row_step     # Length of a row in bytes\\nuint8[] data         # Actual point data, size is (row_step*height)\\n\\nbool is_dense        # True if there are no invalid points\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: sensor_msgs/PointField\\n# This message holds the description of one point entry in the\\n# PointCloud2 message format.\\nuint8 INT8    = 1\\nuint8 UINT8   = 2\\nuint8 INT16   = 3\\nuint8 UINT16  = 4\\nuint8 INT32   = 5\\nuint8 UINT32  = 6\\nuint8 FLOAT32 = 7\\nuint8 FLOAT64 = 8\\n\\nstring name      # Name of field\\nuint32 offset    # Offset from start of point struct\\nuint8  datatype  # Datatype enumeration, see above\\nuint32 count     # How many elements in the field\\n\" comment=\"This message holds a collection of N-dimensional points, which may  contain additional information such as normals, intensity, etc. The  point data is stored as a binary blob, its layout described by the  contents of the &quot;fields&quot; array.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"2D structure of the point cloud. If the cloud is unordered, height is  1 and width is the length of the point cloud.\"/>\
  <field name=\"height\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"\"/>\
  <field name=\"width\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Describes the channels and their layout in the binary data blob.\"/>\
  <field name=\"fields\" type=\"vector(PointField)\" sourceType=\"PointField\" comment=\"\"/>\
  <field name=\"is_bigendian\" type=\"bool\" sourceType=\"bool\" comment=\"Is this data bigendian?\"/>\
  <field name=\"point_step\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Length of a point in bytes\"/>\
  <field name=\"row_step\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Length of a row in bytes\"/>\
  <field name=\"data\" type=\"vector(unsigned char)\" sourceType=\"uint8\" comment=\"Actual point data, size is (row_step*height)\"/>\
  <field name=\"is_dense\" type=\"bool\" sourceType=\"bool\" comment=\"True if there are no invalid points\"/>\
</class>\
\
<class name=\"PointField\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"268eacb2962780ceac86cbd17e328150\" rosDesc=\"# This message holds the description of one point entry in the\\n# PointCloud2 message format.\\nuint8 INT8    = 1\\nuint8 UINT8   = 2\\nuint8 INT16   = 3\\nuint8 UINT16  = 4\\nuint8 INT32   = 5\\nuint8 UINT32  = 6\\nuint8 FLOAT32 = 7\\nuint8 FLOAT64 = 8\\n\\nstring name      # Name of field\\nuint32 offset    # Offset from start of point struct\\nuint8  datatype  # Datatype enumeration, see above\\nuint32 count     # How many elements in the field\\n\" comment=\"This message holds the description of one point entry in the  PointCloud2 message format.\">\
  <constant init=\"1\" name=\"INT8\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"UINT8\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"INT16\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"UINT16\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"5\" name=\"INT32\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"6\" name=\"UINT32\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"7\" name=\"FLOAT32\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"8\" name=\"FLOAT64\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <field name=\"name\" type=\"string\" sourceType=\"string\" comment=\"Name of field\"/>\
  <field name=\"offset\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Offset from start of point struct\"/>\
  <field name=\"datatype\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"Datatype enumeration, see above\"/>\
  <field name=\"count\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"How many elements in the field\"/>\
</class>\
\
<class name=\"Range\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"c005c34273dc426c67a020a87bc24148\" rosDesc=\"# Single range reading from an active ranger that emits energy and reports\\n# one range reading that is valid along an arc at the distance measured. \\n# This message is  not appropriate for laser scanners. See the LaserScan\\n# message if you are working with a laser scanner.\\n\\n# This message also can represent a fixed-distance (binary) ranger.  This\\n# sensor will have min_range===max_range===distance of detection.\\n# These sensors follow REP 117 and will output -Inf if the object is detected\\n# and +Inf if the object is outside of the detection range.\\n\\nHeader header           # timestamp in the header is the time the ranger\\n                        # returned the distance reading\\n\\n# Radiation type enums\\n# If you want a value added to this list, send an email to the ros-users list\\nuint8 ULTRASOUND=0\\nuint8 INFRARED=1\\n\\nuint8 radiation_type    # the type of radiation used by the sensor\\n                        # (sound, IR, etc) [enum]\\n\\nfloat32 field_of_view   # the size of the arc that the distance reading is\\n                        # valid for [rad]\\n                        # the object causing the range reading may have\\n                        # been anywhere within -field_of_view/2 and\\n                        # field_of_view/2 at the measured range. \\n                        # 0 angle corresponds to the x-axis of the sensor.\\n\\nfloat32 min_range       # minimum range value [m]\\nfloat32 max_range       # maximum range value [m]\\n                        # Fixed distance rangers require min_range==max_range\\n\\nfloat32 range           # range data [m]\\n                        # (Note: values &lt; range_min or &gt; range_max\\n                        # should be discarded)\\n                        # Fixed distance rangers only output -Inf or +Inf.\\n                        # -Inf represents a detection within fixed distance.\\n                        # (Detection too close to the sensor to quantify)\\n                        # +Inf represents no detection within the fixed distance.\\n                        # (Object out of range)\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Single range reading from an active ranger that emits energy and reports  one range reading that is valid along an arc at the distance measured.   This message is  not appropriate for laser scanners. See the LaserScan  message if you are working with a laser scanner.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp in the header is the time the ranger  returned the distance reading  Radiation type enums  If you want a value added to this list, send an email to the ros-users list\"/>\
  <constant init=\"0\" name=\"ULTRASOUND\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"INFRARED\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <field name=\"radiation_type\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"the type of radiation used by the sensor  (sound, IR, etc) [enum]\"/>\
  <field name=\"field_of_view\" type=\"float\" sourceType=\"float32\" comment=\"the size of the arc that the distance reading is  valid for [rad]  the object causing the range reading may have  been anywhere within -field_of_view/2 and  field_of_view/2 at the measured range.   0 angle corresponds to the x-axis of the sensor.\"/>\
  <field name=\"min_range\" type=\"float\" sourceType=\"float32\" comment=\"minimum range value [m]\"/>\
  <field name=\"max_range\" type=\"float\" sourceType=\"float32\" comment=\"maximum range value [m]  Fixed distance rangers require min_range==max_range\"/>\
  <field name=\"range\" type=\"float\" sourceType=\"float32\" comment=\"range data [m]  (Note: values &lt; range_min or &gt; range_max  should be discarded)  Fixed distance rangers only output -Inf or +Inf.  -Inf represents a detection within fixed distance.  (Detection too close to the sensor to quantify)  +Inf represents no detection within the fixed distance.  (Object out of range)\"/>\
</class>\
\
<class name=\"RegionOfInterest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"bdb633039d588fcccb441a4d43ccfe09\" rosDesc=\"# This message is used to specify a region of interest within an image.\\n#\\n# When used to specify the ROI setting of the camera when the image was\\n# taken, the height and width fields should either match the height and\\n# width fields for the associated image; or height = width = 0\\n# indicates that the full resolution image was captured.\\n\\nuint32 x_offset  # Leftmost pixel of the ROI\\n                 # (0 if the ROI includes the left edge of the image)\\nuint32 y_offset  # Topmost pixel of the ROI\\n                 # (0 if the ROI includes the top edge of the image)\\nuint32 height    # Height of ROI\\nuint32 width     # Width of ROI\\n\\n# True if a distinct rectified ROI should be calculated from the \\&quot;raw\\&quot;\\n# ROI in this message. Typically this should be False if the full image\\n# is captured (ROI not used), and True if a subwindow is captured (ROI\\n# used).\\nbool do_rectify\\n\" comment=\"This message is used to specify a region of interest within an image.   When used to specify the ROI setting of the camera when the image was  taken, the height and width fields should either match the height and  width fields for the associated image; or height = width = 0  indicates that the full resolution image was captured.\">\
  <field name=\"x_offset\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Leftmost pixel of the ROI  (0 if the ROI includes the left edge of the image)\"/>\
  <field name=\"y_offset\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Topmost pixel of the ROI  (0 if the ROI includes the top edge of the image)\"/>\
  <field name=\"height\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Height of ROI\"/>\
  <field name=\"width\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"Width of ROI  True if a distinct rectified ROI should be calculated from the &quot;raw&quot;  ROI in this message. Typically this should be False if the full image  is captured (ROI not used), and True if a subwindow is captured (ROI  used).\"/>\
  <field name=\"do_rectify\" type=\"bool\" sourceType=\"bool\" comment=\"\"/>\
</class>\
\
<class name=\"RelativeHumidity\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"8730015b05955b7e992ce29a2678d90f\" rosDesc=\"# Single reading from a relative humidity sensor.  Defines the ratio of partial\\n # pressure of water vapor to the saturated vapor pressure at a temperature.\\n\\n Header header             # timestamp of the measurement\\n                           # frame_id is the location of the humidity sensor\\n\\n float64 relative_humidity # Expression of the relative humidity\\n                           # from 0.0 to 1.0.\\n                           # 0.0 is no partial pressure of water vapor\\n                           # 1.0 represents partial pressure of saturation\\n\\n float64 variance          # 0 is interpreted as variance unknown\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Single reading from a relative humidity sensor.  Defines the ratio of partial  pressure of water vapor to the saturated vapor pressure at a temperature.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp of the measurement  frame_id is the location of the humidity sensor\"/>\
  <field name=\"relative_humidity\" type=\"double\" sourceType=\"float64\" comment=\"Expression of the relative humidity  from 0.0 to 1.0.  0.0 is no partial pressure of water vapor  1.0 represents partial pressure of saturation\"/>\
  <field name=\"variance\" type=\"double\" sourceType=\"float64\" comment=\"0 is interpreted as variance unknown\"/>\
</class>\
\
<class name=\"Temperature\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"ff71b307acdbe7c871a5a6d7ed359100\" rosDesc=\"# Single temperature reading.\\n\\n Header header           # timestamp is the time the temperature was measured\\n                         # frame_id is the location of the temperature reading\\n\\n float64 temperature     # Measurement of the Temperature in Degrees Celsius\\n\\n float64 variance        # 0 is interpreted as variance unknown\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Single temperature reading.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"timestamp is the time the temperature was measured  frame_id is the location of the temperature reading\"/>\
  <field name=\"temperature\" type=\"double\" sourceType=\"float64\" comment=\"Measurement of the Temperature in Degrees Celsius\"/>\
  <field name=\"variance\" type=\"double\" sourceType=\"float64\" comment=\"0 is interpreted as variance unknown\"/>\
</class>\
\
<class name=\"TimeReference\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"fded64a0265108ba86c3d38fb11c0c16\" rosDesc=\"# Measurement from an external time source not actively synchronized with the system clock.\\n\\nHeader header    # stamp is system time for which measurement was valid\\n                 # frame_id is not used \\n\\ntime   time_ref  # corresponding time from this external source\\nstring source    # (optional) name of time source\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"Measurement from an external time source not actively synchronized with the system clock.\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"stamp is system time for which measurement was valid  frame_id is not used\"/>\
  <field name=\"time_ref\" type=\"std_msgs::RosTime\" sourceType=\"time\" comment=\"corresponding time from this external source\"/>\
  <field name=\"source\" type=\"string\" sourceType=\"string\" comment=\"(optional) name of time source\"/>\
</class>\
\
<class name=\"SetCameraInfoRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"This service requests that a camera stores the given CameraInfo   as that camera's calibration information.   The width and height in the camera_info field should match what the  camera is currently outputting on its camera_info topic, and the camera  will assume that the region of the imager that is being referred to is  the region that the camera is currently capturing.\">\
  <field name=\"camera_info\" type=\"sensor_msgs::CameraInfo\" sourceType=\"sensor_msgs::CameraInfo\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetCameraInfoResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"This service requests that a camera stores the given CameraInfo   as that camera's calibration information.   The width and height in the camera_info field should match what the  camera is currently outputting on its camera_info topic, and the camera  will assume that the region of the imager that is being referred to is  the region that the camera is currently capturing.\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"True if the call succeeded\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"Used to give details about success\"/>\
</class>\
\
<class name=\"SetCameraInfo\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"This service requests that a camera stores the given CameraInfo   as that camera's calibration information.   The width and height in the camera_info field should match what the  camera is currently outputting on its camera_info topic, and the camera  will assume that the region of the imager that is being referred to is  the region that the camera is currently capturing.\">\
  <definition name=\"Request\" type=\"SetCameraInfoRequest\"/>\
  <definition name=\"Response\" type=\"SetCameraInfoResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<dependency name=\"geometry_msgs_gencpp\"/>\
<dependency name=\"std_msgs_gencpp\"/>\
<dependency name=\"std_srvs_gencpp\"/>\
\
</classes>\
";
    }

}; // end namespace sensor_msgs

