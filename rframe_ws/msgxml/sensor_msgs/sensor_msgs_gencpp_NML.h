// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:54 -0500
//  From Template/Script: data_templates/NMLHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_SENSOR_MSGS_GENCPPNML_H_
#define _CODEGEN_SENSOR_MSGS_GENCPPNML_H_

#include <messaging/nml/NMLMessageFactory.h>
//#include <DataTypeInfo.h>
#include <messaging/Message.h>

#include "sensor_msgs_gencpp_NMLSupport.h"

namespace rframe { class DataTypeInfo; };

#include "BatteryState.h"
#include "CameraInfo.h"
#include "ChannelFloat32.h"
#include "CompressedImage.h"
#include "FluidPressure.h"
#include "Illuminance.h"
#include "Image.h"
#include "Imu.h"
#include "JointState.h"
#include "Joy.h"
#include "JoyFeedback.h"
#include "JoyFeedbackArray.h"
#include "LaserEcho.h"
#include "LaserScan.h"
#include "MagneticField.h"
#include "MultiDOFJointState.h"
#include "MultiEchoLaserScan.h"
#include "NavSatFix.h"
#include "NavSatStatus.h"
#include "PointCloud.h"
#include "PointCloud2.h"
#include "PointField.h"
#include "Range.h"
#include "RegionOfInterest.h"
#include "RelativeHumidity.h"
#include "Temperature.h"
#include "TimeReference.h"
#include "SetCameraInfoRequest.h"
#include "SetCameraInfoResponse.h"
#include "SetCameraInfo.h"

namespace sensor_msgs {

    /** definition of message factory for sensor_msgs_gencpp */
    class sensor_msgs_gencppNMLMessageFactory : public NMLMessageFactory
    {
    public:
        /** constructor */
        sensor_msgs_gencppNMLMessageFactory();
        /** destructor */
        virtual ~sensor_msgs_gencppNMLMessageFactory();

        /** see  rframe::MessageFactoryInterface */
        virtual void dataTypes(std::vector<DataTypeInfo> & ids);
        /** see  rframe::MessageFactoryInterface */
        virtual int dataType(NMLmsg & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateTransport(NMLmsg * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateMessage(MessageBase * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int toTransport( MessageBase & src, NMLmsg & dst);
        /** see  rframe::MessageFactoryInterface */
        virtual int fromTransport( NMLmsg & src, MessageBase & dst);

        /** \return poitner to nml format function */
        virtual NML_FORMAT_PTR FormatPointer();
        /** run constructor for class of type id in the provided buffer */
        virtual int constructBuffer(rframe::ID_TYPE id, void * buffer);
        /** run destructor for class of type id in the buffer */
        virtual int destructBuffer(rframe::ID_TYPE id, void * buffer);
    };

    /** factory allocation function for use when not dynamically loading the factory library  */
    NMLMessageFactory * allocate_sensor_msgs_gencpp();

    /** NML interface for BatteryState 

    */
    class BatteryStateNML : public NMLmsg
    {
    public:

        /** constructor */
        BatteryStateNML();
        /** destructor */
        ~BatteryStateNML();

        /** assignment operator */
        BatteryStateNML & operator=(const BatteryStateNML &inobj);
        /** assignment operator for base data class */
        BatteryStateNML & operator=(const BatteryState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        BatteryState nmlPayload;

        /** set payload */
        void payload(const BatteryState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<BatteryState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        BatteryState * payload() { return & nmlPayload; };

    //     std::shared_ptr<BatteryState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for CameraInfo 

    */
    class CameraInfoNML : public NMLmsg
    {
    public:

        /** constructor */
        CameraInfoNML();
        /** destructor */
        ~CameraInfoNML();

        /** assignment operator */
        CameraInfoNML & operator=(const CameraInfoNML &inobj);
        /** assignment operator for base data class */
        CameraInfoNML & operator=(const CameraInfo &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        CameraInfo nmlPayload;

        /** set payload */
        void payload(const CameraInfo &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<CameraInfo> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        CameraInfo * payload() { return & nmlPayload; };

    //     std::shared_ptr<CameraInfo> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ChannelFloat32 

    */
    class ChannelFloat32NML : public NMLmsg
    {
    public:

        /** constructor */
        ChannelFloat32NML();
        /** destructor */
        ~ChannelFloat32NML();

        /** assignment operator */
        ChannelFloat32NML & operator=(const ChannelFloat32NML &inobj);
        /** assignment operator for base data class */
        ChannelFloat32NML & operator=(const ChannelFloat32 &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ChannelFloat32 nmlPayload;

        /** set payload */
        void payload(const ChannelFloat32 &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ChannelFloat32> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ChannelFloat32 * payload() { return & nmlPayload; };

    //     std::shared_ptr<ChannelFloat32> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for CompressedImage 

    */
    class CompressedImageNML : public NMLmsg
    {
    public:

        /** constructor */
        CompressedImageNML();
        /** destructor */
        ~CompressedImageNML();

        /** assignment operator */
        CompressedImageNML & operator=(const CompressedImageNML &inobj);
        /** assignment operator for base data class */
        CompressedImageNML & operator=(const CompressedImage &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        CompressedImage nmlPayload;

        /** set payload */
        void payload(const CompressedImage &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<CompressedImage> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        CompressedImage * payload() { return & nmlPayload; };

    //     std::shared_ptr<CompressedImage> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FluidPressure 

    */
    class FluidPressureNML : public NMLmsg
    {
    public:

        /** constructor */
        FluidPressureNML();
        /** destructor */
        ~FluidPressureNML();

        /** assignment operator */
        FluidPressureNML & operator=(const FluidPressureNML &inobj);
        /** assignment operator for base data class */
        FluidPressureNML & operator=(const FluidPressure &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FluidPressure nmlPayload;

        /** set payload */
        void payload(const FluidPressure &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FluidPressure> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FluidPressure * payload() { return & nmlPayload; };

    //     std::shared_ptr<FluidPressure> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for Illuminance 

    */
    class IlluminanceNML : public NMLmsg
    {
    public:

        /** constructor */
        IlluminanceNML();
        /** destructor */
        ~IlluminanceNML();

        /** assignment operator */
        IlluminanceNML & operator=(const IlluminanceNML &inobj);
        /** assignment operator for base data class */
        IlluminanceNML & operator=(const Illuminance &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        Illuminance nmlPayload;

        /** set payload */
        void payload(const Illuminance &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<Illuminance> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        Illuminance * payload() { return & nmlPayload; };

    //     std::shared_ptr<Illuminance> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for Image 

    */
    class ImageNML : public NMLmsg
    {
    public:

        /** constructor */
        ImageNML();
        /** destructor */
        ~ImageNML();

        /** assignment operator */
        ImageNML & operator=(const ImageNML &inobj);
        /** assignment operator for base data class */
        ImageNML & operator=(const Image &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        Image nmlPayload;

        /** set payload */
        void payload(const Image &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<Image> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        Image * payload() { return & nmlPayload; };

    //     std::shared_ptr<Image> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for Imu 

    */
    class ImuNML : public NMLmsg
    {
    public:

        /** constructor */
        ImuNML();
        /** destructor */
        ~ImuNML();

        /** assignment operator */
        ImuNML & operator=(const ImuNML &inobj);
        /** assignment operator for base data class */
        ImuNML & operator=(const Imu &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        Imu nmlPayload;

        /** set payload */
        void payload(const Imu &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<Imu> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        Imu * payload() { return & nmlPayload; };

    //     std::shared_ptr<Imu> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointState 

    */
    class JointStateNML : public NMLmsg
    {
    public:

        /** constructor */
        JointStateNML();
        /** destructor */
        ~JointStateNML();

        /** assignment operator */
        JointStateNML & operator=(const JointStateNML &inobj);
        /** assignment operator for base data class */
        JointStateNML & operator=(const JointState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointState nmlPayload;

        /** set payload */
        void payload(const JointState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointState * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for Joy 

    */
    class JoyNML : public NMLmsg
    {
    public:

        /** constructor */
        JoyNML();
        /** destructor */
        ~JoyNML();

        /** assignment operator */
        JoyNML & operator=(const JoyNML &inobj);
        /** assignment operator for base data class */
        JoyNML & operator=(const Joy &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        Joy nmlPayload;

        /** set payload */
        void payload(const Joy &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<Joy> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        Joy * payload() { return & nmlPayload; };

    //     std::shared_ptr<Joy> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JoyFeedback 

    */
    class JoyFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        JoyFeedbackNML();
        /** destructor */
        ~JoyFeedbackNML();

        /** assignment operator */
        JoyFeedbackNML & operator=(const JoyFeedbackNML &inobj);
        /** assignment operator for base data class */
        JoyFeedbackNML & operator=(const JoyFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JoyFeedback nmlPayload;

        /** set payload */
        void payload(const JoyFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JoyFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JoyFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<JoyFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JoyFeedbackArray 

    */
    class JoyFeedbackArrayNML : public NMLmsg
    {
    public:

        /** constructor */
        JoyFeedbackArrayNML();
        /** destructor */
        ~JoyFeedbackArrayNML();

        /** assignment operator */
        JoyFeedbackArrayNML & operator=(const JoyFeedbackArrayNML &inobj);
        /** assignment operator for base data class */
        JoyFeedbackArrayNML & operator=(const JoyFeedbackArray &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JoyFeedbackArray nmlPayload;

        /** set payload */
        void payload(const JoyFeedbackArray &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JoyFeedbackArray> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JoyFeedbackArray * payload() { return & nmlPayload; };

    //     std::shared_ptr<JoyFeedbackArray> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for LaserEcho 

    */
    class LaserEchoNML : public NMLmsg
    {
    public:

        /** constructor */
        LaserEchoNML();
        /** destructor */
        ~LaserEchoNML();

        /** assignment operator */
        LaserEchoNML & operator=(const LaserEchoNML &inobj);
        /** assignment operator for base data class */
        LaserEchoNML & operator=(const LaserEcho &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        LaserEcho nmlPayload;

        /** set payload */
        void payload(const LaserEcho &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<LaserEcho> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        LaserEcho * payload() { return & nmlPayload; };

    //     std::shared_ptr<LaserEcho> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for LaserScan 

    */
    class LaserScanNML : public NMLmsg
    {
    public:

        /** constructor */
        LaserScanNML();
        /** destructor */
        ~LaserScanNML();

        /** assignment operator */
        LaserScanNML & operator=(const LaserScanNML &inobj);
        /** assignment operator for base data class */
        LaserScanNML & operator=(const LaserScan &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        LaserScan nmlPayload;

        /** set payload */
        void payload(const LaserScan &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<LaserScan> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        LaserScan * payload() { return & nmlPayload; };

    //     std::shared_ptr<LaserScan> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MagneticField 

    */
    class MagneticFieldNML : public NMLmsg
    {
    public:

        /** constructor */
        MagneticFieldNML();
        /** destructor */
        ~MagneticFieldNML();

        /** assignment operator */
        MagneticFieldNML & operator=(const MagneticFieldNML &inobj);
        /** assignment operator for base data class */
        MagneticFieldNML & operator=(const MagneticField &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MagneticField nmlPayload;

        /** set payload */
        void payload(const MagneticField &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MagneticField> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MagneticField * payload() { return & nmlPayload; };

    //     std::shared_ptr<MagneticField> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MultiDOFJointState 

    */
    class MultiDOFJointStateNML : public NMLmsg
    {
    public:

        /** constructor */
        MultiDOFJointStateNML();
        /** destructor */
        ~MultiDOFJointStateNML();

        /** assignment operator */
        MultiDOFJointStateNML & operator=(const MultiDOFJointStateNML &inobj);
        /** assignment operator for base data class */
        MultiDOFJointStateNML & operator=(const MultiDOFJointState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MultiDOFJointState nmlPayload;

        /** set payload */
        void payload(const MultiDOFJointState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MultiDOFJointState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MultiDOFJointState * payload() { return & nmlPayload; };

    //     std::shared_ptr<MultiDOFJointState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for MultiEchoLaserScan 

    */
    class MultiEchoLaserScanNML : public NMLmsg
    {
    public:

        /** constructor */
        MultiEchoLaserScanNML();
        /** destructor */
        ~MultiEchoLaserScanNML();

        /** assignment operator */
        MultiEchoLaserScanNML & operator=(const MultiEchoLaserScanNML &inobj);
        /** assignment operator for base data class */
        MultiEchoLaserScanNML & operator=(const MultiEchoLaserScan &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        MultiEchoLaserScan nmlPayload;

        /** set payload */
        void payload(const MultiEchoLaserScan &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<MultiEchoLaserScan> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        MultiEchoLaserScan * payload() { return & nmlPayload; };

    //     std::shared_ptr<MultiEchoLaserScan> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for NavSatFix 

    */
    class NavSatFixNML : public NMLmsg
    {
    public:

        /** constructor */
        NavSatFixNML();
        /** destructor */
        ~NavSatFixNML();

        /** assignment operator */
        NavSatFixNML & operator=(const NavSatFixNML &inobj);
        /** assignment operator for base data class */
        NavSatFixNML & operator=(const NavSatFix &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        NavSatFix nmlPayload;

        /** set payload */
        void payload(const NavSatFix &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<NavSatFix> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        NavSatFix * payload() { return & nmlPayload; };

    //     std::shared_ptr<NavSatFix> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for NavSatStatus 

    */
    class NavSatStatusNML : public NMLmsg
    {
    public:

        /** constructor */
        NavSatStatusNML();
        /** destructor */
        ~NavSatStatusNML();

        /** assignment operator */
        NavSatStatusNML & operator=(const NavSatStatusNML &inobj);
        /** assignment operator for base data class */
        NavSatStatusNML & operator=(const NavSatStatus &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        NavSatStatus nmlPayload;

        /** set payload */
        void payload(const NavSatStatus &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<NavSatStatus> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        NavSatStatus * payload() { return & nmlPayload; };

    //     std::shared_ptr<NavSatStatus> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointCloud 

    */
    class PointCloudNML : public NMLmsg
    {
    public:

        /** constructor */
        PointCloudNML();
        /** destructor */
        ~PointCloudNML();

        /** assignment operator */
        PointCloudNML & operator=(const PointCloudNML &inobj);
        /** assignment operator for base data class */
        PointCloudNML & operator=(const PointCloud &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointCloud nmlPayload;

        /** set payload */
        void payload(const PointCloud &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointCloud> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointCloud * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointCloud> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointCloud2 

    */
    class PointCloud2NML : public NMLmsg
    {
    public:

        /** constructor */
        PointCloud2NML();
        /** destructor */
        ~PointCloud2NML();

        /** assignment operator */
        PointCloud2NML & operator=(const PointCloud2NML &inobj);
        /** assignment operator for base data class */
        PointCloud2NML & operator=(const PointCloud2 &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointCloud2 nmlPayload;

        /** set payload */
        void payload(const PointCloud2 &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointCloud2> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointCloud2 * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointCloud2> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointField 

    */
    class PointFieldNML : public NMLmsg
    {
    public:

        /** constructor */
        PointFieldNML();
        /** destructor */
        ~PointFieldNML();

        /** assignment operator */
        PointFieldNML & operator=(const PointFieldNML &inobj);
        /** assignment operator for base data class */
        PointFieldNML & operator=(const PointField &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointField nmlPayload;

        /** set payload */
        void payload(const PointField &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointField> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointField * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointField> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for Range 

    */
    class RangeNML : public NMLmsg
    {
    public:

        /** constructor */
        RangeNML();
        /** destructor */
        ~RangeNML();

        /** assignment operator */
        RangeNML & operator=(const RangeNML &inobj);
        /** assignment operator for base data class */
        RangeNML & operator=(const Range &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        Range nmlPayload;

        /** set payload */
        void payload(const Range &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<Range> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        Range * payload() { return & nmlPayload; };

    //     std::shared_ptr<Range> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for RegionOfInterest 

    */
    class RegionOfInterestNML : public NMLmsg
    {
    public:

        /** constructor */
        RegionOfInterestNML();
        /** destructor */
        ~RegionOfInterestNML();

        /** assignment operator */
        RegionOfInterestNML & operator=(const RegionOfInterestNML &inobj);
        /** assignment operator for base data class */
        RegionOfInterestNML & operator=(const RegionOfInterest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        RegionOfInterest nmlPayload;

        /** set payload */
        void payload(const RegionOfInterest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<RegionOfInterest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        RegionOfInterest * payload() { return & nmlPayload; };

    //     std::shared_ptr<RegionOfInterest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for RelativeHumidity 

    */
    class RelativeHumidityNML : public NMLmsg
    {
    public:

        /** constructor */
        RelativeHumidityNML();
        /** destructor */
        ~RelativeHumidityNML();

        /** assignment operator */
        RelativeHumidityNML & operator=(const RelativeHumidityNML &inobj);
        /** assignment operator for base data class */
        RelativeHumidityNML & operator=(const RelativeHumidity &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        RelativeHumidity nmlPayload;

        /** set payload */
        void payload(const RelativeHumidity &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<RelativeHumidity> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        RelativeHumidity * payload() { return & nmlPayload; };

    //     std::shared_ptr<RelativeHumidity> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for Temperature 

    */
    class TemperatureNML : public NMLmsg
    {
    public:

        /** constructor */
        TemperatureNML();
        /** destructor */
        ~TemperatureNML();

        /** assignment operator */
        TemperatureNML & operator=(const TemperatureNML &inobj);
        /** assignment operator for base data class */
        TemperatureNML & operator=(const Temperature &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        Temperature nmlPayload;

        /** set payload */
        void payload(const Temperature &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<Temperature> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        Temperature * payload() { return & nmlPayload; };

    //     std::shared_ptr<Temperature> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for TimeReference 

    */
    class TimeReferenceNML : public NMLmsg
    {
    public:

        /** constructor */
        TimeReferenceNML();
        /** destructor */
        ~TimeReferenceNML();

        /** assignment operator */
        TimeReferenceNML & operator=(const TimeReferenceNML &inobj);
        /** assignment operator for base data class */
        TimeReferenceNML & operator=(const TimeReference &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        TimeReference nmlPayload;

        /** set payload */
        void payload(const TimeReference &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<TimeReference> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        TimeReference * payload() { return & nmlPayload; };

    //     std::shared_ptr<TimeReference> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetCameraInfoRequest 

    */
    class SetCameraInfoRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetCameraInfoRequestNML();
        /** destructor */
        ~SetCameraInfoRequestNML();

        /** assignment operator */
        SetCameraInfoRequestNML & operator=(const SetCameraInfoRequestNML &inobj);
        /** assignment operator for base data class */
        SetCameraInfoRequestNML & operator=(const SetCameraInfoRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetCameraInfoRequest nmlPayload;

        /** set payload */
        void payload(const SetCameraInfoRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetCameraInfoRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetCameraInfoRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetCameraInfoRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetCameraInfoResponse 

    */
    class SetCameraInfoResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetCameraInfoResponseNML();
        /** destructor */
        ~SetCameraInfoResponseNML();

        /** assignment operator */
        SetCameraInfoResponseNML & operator=(const SetCameraInfoResponseNML &inobj);
        /** assignment operator for base data class */
        SetCameraInfoResponseNML & operator=(const SetCameraInfoResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetCameraInfoResponse nmlPayload;

        /** set payload */
        void payload(const SetCameraInfoResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetCameraInfoResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetCameraInfoResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetCameraInfoResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetCameraInfo 

    */
    class SetCameraInfoNML : public NMLmsg
    {
    public:

        /** constructor */
        SetCameraInfoNML();
        /** destructor */
        ~SetCameraInfoNML();

        /** assignment operator */
        SetCameraInfoNML & operator=(const SetCameraInfoNML &inobj);
        /** assignment operator for base data class */
        SetCameraInfoNML & operator=(const SetCameraInfo &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetCameraInfo nmlPayload;

        /** set payload */
        void payload(const SetCameraInfo &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetCameraInfo> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetCameraInfo * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetCameraInfo> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    // predeclaration of nmlupdate functions (necessary due to namespaces )

    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::BatteryState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::CameraInfo & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::ChannelFloat32 & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::CompressedImage & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::FluidPressure & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::Illuminance & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::Image & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::Imu & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::JointState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::Joy & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::JoyFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::JoyFeedbackArray & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::LaserEcho & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::LaserScan & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::MagneticField & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::MultiDOFJointState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::MultiEchoLaserScan & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::NavSatFix & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::NavSatStatus & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::PointCloud & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::PointCloud2 & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::PointField & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::Range & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::RegionOfInterest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::RelativeHumidity & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::Temperature & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::TimeReference & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::SetCameraInfoRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::SetCameraInfoResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, sensor_msgs::SetCameraInfo & inobj);

    /** nml format function */
    int sensor_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms);

}; // end namespace sensor_msgs

#endif // _SENSOR_MSGS_GENCPPNML_H_
