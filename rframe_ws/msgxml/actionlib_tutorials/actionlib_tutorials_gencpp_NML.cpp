// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:03 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "actionlib_tutorials_gencpp_NML.h"
#include "actionlib_tutorials_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <AveragingAction.h>
#include <AveragingActionFeedback.h>
#include <AveragingActionGoal.h>
#include <AveragingActionResult.h>
#include <AveragingFeedback.h>
#include <AveragingGoal.h>
#include <AveragingResult.h>
#include <FibonacciAction.h>
#include <FibonacciActionFeedback.h>
#include <FibonacciActionGoal.h>
#include <FibonacciActionResult.h>
#include <FibonacciFeedback.h>
#include <FibonacciGoal.h>
#include <FibonacciResult.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace actionlib_tutorials;

rframe::NMLMessageFactory * NML_actionlib_tutorials_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_actionlib_tutorials_gencppfactory = new actionlib_tutorials_gencppNMLMessageFactory();
        return NML_actionlib_tutorials_gencppfactory;
    };
}

rframe::NMLMessageFactory * actionlib_tutorials::allocate_actionlib_tutorials_gencpp()
{
    NML_actionlib_tutorials_gencppfactory = new actionlib_tutorials_gencppNMLMessageFactory();
    return NML_actionlib_tutorials_gencppfactory;
};

actionlib_tutorials_gencppNMLMessageFactory::actionlib_tutorials_gencppNMLMessageFactory()
{
    name("actionlib_tutorials_gencpp");
    // use constructor to register data types
    actionlib_tutorials::registerLibrary();
}

actionlib_tutorials_gencppNMLMessageFactory::~actionlib_tutorials_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR actionlib_tutorials_gencppNMLMessageFactory::FormatPointer()
{
    return actionlib_tutorials_gencpp_format;
}

int actionlib_tutorials_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void actionlib_tutorials_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(AveragingAction::ID);
    info.name(AveragingAction::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingAction::DATA_VERSION);
    info.md5Key(AveragingAction::VERSION_MD5);
    info.xmlSource(AveragingAction::XML_SOURCE);
    info.flat(AveragingAction::dataTypeFlat());
    ids.push_back(info);

    info.id(AveragingActionFeedback::ID);
    info.name(AveragingActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingActionFeedback::DATA_VERSION);
    info.md5Key(AveragingActionFeedback::VERSION_MD5);
    info.xmlSource(AveragingActionFeedback::XML_SOURCE);
    info.flat(AveragingActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(AveragingActionGoal::ID);
    info.name(AveragingActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingActionGoal::DATA_VERSION);
    info.md5Key(AveragingActionGoal::VERSION_MD5);
    info.xmlSource(AveragingActionGoal::XML_SOURCE);
    info.flat(AveragingActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(AveragingActionResult::ID);
    info.name(AveragingActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingActionResult::DATA_VERSION);
    info.md5Key(AveragingActionResult::VERSION_MD5);
    info.xmlSource(AveragingActionResult::XML_SOURCE);
    info.flat(AveragingActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(AveragingFeedback::ID);
    info.name(AveragingFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingFeedback::DATA_VERSION);
    info.md5Key(AveragingFeedback::VERSION_MD5);
    info.xmlSource(AveragingFeedback::XML_SOURCE);
    info.flat(AveragingFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(AveragingGoal::ID);
    info.name(AveragingGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingGoal::DATA_VERSION);
    info.md5Key(AveragingGoal::VERSION_MD5);
    info.xmlSource(AveragingGoal::XML_SOURCE);
    info.flat(AveragingGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(AveragingResult::ID);
    info.name(AveragingResult::DATA_TYPE_FULL_NAME);
    info.hashKey(AveragingResult::DATA_VERSION);
    info.md5Key(AveragingResult::VERSION_MD5);
    info.xmlSource(AveragingResult::XML_SOURCE);
    info.flat(AveragingResult::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciAction::ID);
    info.name(FibonacciAction::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciAction::DATA_VERSION);
    info.md5Key(FibonacciAction::VERSION_MD5);
    info.xmlSource(FibonacciAction::XML_SOURCE);
    info.flat(FibonacciAction::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciActionFeedback::ID);
    info.name(FibonacciActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciActionFeedback::DATA_VERSION);
    info.md5Key(FibonacciActionFeedback::VERSION_MD5);
    info.xmlSource(FibonacciActionFeedback::XML_SOURCE);
    info.flat(FibonacciActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciActionGoal::ID);
    info.name(FibonacciActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciActionGoal::DATA_VERSION);
    info.md5Key(FibonacciActionGoal::VERSION_MD5);
    info.xmlSource(FibonacciActionGoal::XML_SOURCE);
    info.flat(FibonacciActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciActionResult::ID);
    info.name(FibonacciActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciActionResult::DATA_VERSION);
    info.md5Key(FibonacciActionResult::VERSION_MD5);
    info.xmlSource(FibonacciActionResult::XML_SOURCE);
    info.flat(FibonacciActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciFeedback::ID);
    info.name(FibonacciFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciFeedback::DATA_VERSION);
    info.md5Key(FibonacciFeedback::VERSION_MD5);
    info.xmlSource(FibonacciFeedback::XML_SOURCE);
    info.flat(FibonacciFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciGoal::ID);
    info.name(FibonacciGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciGoal::DATA_VERSION);
    info.md5Key(FibonacciGoal::VERSION_MD5);
    info.xmlSource(FibonacciGoal::XML_SOURCE);
    info.flat(FibonacciGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(FibonacciResult::ID);
    info.name(FibonacciResult::DATA_TYPE_FULL_NAME);
    info.hashKey(FibonacciResult::DATA_VERSION);
    info.md5Key(FibonacciResult::VERSION_MD5);
    info.xmlSource(FibonacciResult::XML_SOURCE);
    info.flat(FibonacciResult::dataTypeFlat());
    ids.push_back(info);

}

int actionlib_tutorials_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case AveragingAction::ID:
        {
            //AveragingActionNML * newmsg = new AveragingActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingActionNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AveragingActionFeedback::ID:
        {
            //AveragingActionFeedbackNML * newmsg = new AveragingActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingActionFeedbackNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AveragingActionGoal::ID:
        {
            //AveragingActionGoalNML * newmsg = new AveragingActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingActionGoalNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AveragingActionResult::ID:
        {
            //AveragingActionResultNML * newmsg = new AveragingActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingActionResultNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AveragingFeedback::ID:
        {
            //AveragingFeedbackNML * newmsg = new AveragingFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingFeedbackNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AveragingGoal::ID:
        {
            //AveragingGoalNML * newmsg = new AveragingGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingGoalNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AveragingResult::ID:
        {
            //AveragingResultNML * newmsg = new AveragingResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AveragingResultNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciAction::ID:
        {
            //FibonacciActionNML * newmsg = new FibonacciActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciActionNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciActionFeedback::ID:
        {
            //FibonacciActionFeedbackNML * newmsg = new FibonacciActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciActionFeedbackNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciActionGoal::ID:
        {
            //FibonacciActionGoalNML * newmsg = new FibonacciActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciActionGoalNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciActionResult::ID:
        {
            //FibonacciActionResultNML * newmsg = new FibonacciActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciActionResultNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciFeedback::ID:
        {
            //FibonacciFeedbackNML * newmsg = new FibonacciFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciFeedbackNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciGoal::ID:
        {
            //FibonacciGoalNML * newmsg = new FibonacciGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciGoalNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FibonacciResult::ID:
        {
            //FibonacciResultNML * newmsg = new FibonacciResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FibonacciResultNML(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case AveragingAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingAction>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AveragingActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingActionFeedback>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AveragingActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingActionGoal>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AveragingActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingActionResult>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AveragingFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingFeedback>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AveragingGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingGoal>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AveragingResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AveragingResult>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciAction>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciActionFeedback>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciActionGoal>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciActionResult>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciFeedback>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciGoal>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FibonacciResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FibonacciResult>(),std::bind(&actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case AveragingAction::ID:
            {
                AveragingActionNML * tempmsg = static_cast<AveragingActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AveragingActionFeedback::ID:
            {
                AveragingActionFeedbackNML * tempmsg = static_cast<AveragingActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AveragingActionGoal::ID:
            {
                AveragingActionGoalNML * tempmsg = static_cast<AveragingActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AveragingActionResult::ID:
            {
                AveragingActionResultNML * tempmsg = static_cast<AveragingActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AveragingFeedback::ID:
            {
                AveragingFeedbackNML * tempmsg = static_cast<AveragingFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AveragingGoal::ID:
            {
                AveragingGoalNML * tempmsg = static_cast<AveragingGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AveragingResult::ID:
            {
                AveragingResultNML * tempmsg = static_cast<AveragingResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciAction::ID:
            {
                FibonacciActionNML * tempmsg = static_cast<FibonacciActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciActionFeedback::ID:
            {
                FibonacciActionFeedbackNML * tempmsg = static_cast<FibonacciActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciActionGoal::ID:
            {
                FibonacciActionGoalNML * tempmsg = static_cast<FibonacciActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciActionResult::ID:
            {
                FibonacciActionResultNML * tempmsg = static_cast<FibonacciActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciFeedback::ID:
            {
                FibonacciFeedbackNML * tempmsg = static_cast<FibonacciFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciGoal::ID:
            {
                FibonacciGoalNML * tempmsg = static_cast<FibonacciGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FibonacciResult::ID:
            {
                FibonacciResultNML * tempmsg = static_cast<FibonacciResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case AveragingAction::ID:
            {
                AveragingActionNML & tempDst = static_cast<AveragingActionNML&>(dst);
                Message<AveragingAction > & tempSrc = static_cast<Message<AveragingAction>&>(src);

                if (tempSrc.version() != AveragingAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingAction: " << __FILE__ << " expected: " 
                             << AveragingAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingAction: " << __FILE__ << " expected: " 
                         << AveragingAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AveragingActionFeedback::ID:
            {
                AveragingActionFeedbackNML & tempDst = static_cast<AveragingActionFeedbackNML&>(dst);
                Message<AveragingActionFeedback > & tempSrc = static_cast<Message<AveragingActionFeedback>&>(src);

                if (tempSrc.version() != AveragingActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingActionFeedback: " << __FILE__ << " expected: " 
                             << AveragingActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingActionFeedback: " << __FILE__ << " expected: " 
                         << AveragingActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AveragingActionGoal::ID:
            {
                AveragingActionGoalNML & tempDst = static_cast<AveragingActionGoalNML&>(dst);
                Message<AveragingActionGoal > & tempSrc = static_cast<Message<AveragingActionGoal>&>(src);

                if (tempSrc.version() != AveragingActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingActionGoal: " << __FILE__ << " expected: " 
                             << AveragingActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingActionGoal: " << __FILE__ << " expected: " 
                         << AveragingActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AveragingActionResult::ID:
            {
                AveragingActionResultNML & tempDst = static_cast<AveragingActionResultNML&>(dst);
                Message<AveragingActionResult > & tempSrc = static_cast<Message<AveragingActionResult>&>(src);

                if (tempSrc.version() != AveragingActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingActionResult: " << __FILE__ << " expected: " 
                             << AveragingActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingActionResult: " << __FILE__ << " expected: " 
                         << AveragingActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AveragingFeedback::ID:
            {
                AveragingFeedbackNML & tempDst = static_cast<AveragingFeedbackNML&>(dst);
                Message<AveragingFeedback > & tempSrc = static_cast<Message<AveragingFeedback>&>(src);

                if (tempSrc.version() != AveragingFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingFeedback: " << __FILE__ << " expected: " 
                             << AveragingFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingFeedback: " << __FILE__ << " expected: " 
                         << AveragingFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AveragingGoal::ID:
            {
                AveragingGoalNML & tempDst = static_cast<AveragingGoalNML&>(dst);
                Message<AveragingGoal > & tempSrc = static_cast<Message<AveragingGoal>&>(src);

                if (tempSrc.version() != AveragingGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingGoal: " << __FILE__ << " expected: " 
                             << AveragingGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingGoal: " << __FILE__ << " expected: " 
                         << AveragingGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AveragingResult::ID:
            {
                AveragingResultNML & tempDst = static_cast<AveragingResultNML&>(dst);
                Message<AveragingResult > & tempSrc = static_cast<Message<AveragingResult>&>(src);

                if (tempSrc.version() != AveragingResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AveragingResult: " << __FILE__ << " expected: " 
                             << AveragingResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AveragingResult: " << __FILE__ << " expected: " 
                         << AveragingResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciAction::ID:
            {
                FibonacciActionNML & tempDst = static_cast<FibonacciActionNML&>(dst);
                Message<FibonacciAction > & tempSrc = static_cast<Message<FibonacciAction>&>(src);

                if (tempSrc.version() != FibonacciAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciAction: " << __FILE__ << " expected: " 
                             << FibonacciAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciAction: " << __FILE__ << " expected: " 
                         << FibonacciAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciActionFeedback::ID:
            {
                FibonacciActionFeedbackNML & tempDst = static_cast<FibonacciActionFeedbackNML&>(dst);
                Message<FibonacciActionFeedback > & tempSrc = static_cast<Message<FibonacciActionFeedback>&>(src);

                if (tempSrc.version() != FibonacciActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciActionFeedback: " << __FILE__ << " expected: " 
                             << FibonacciActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciActionFeedback: " << __FILE__ << " expected: " 
                         << FibonacciActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciActionGoal::ID:
            {
                FibonacciActionGoalNML & tempDst = static_cast<FibonacciActionGoalNML&>(dst);
                Message<FibonacciActionGoal > & tempSrc = static_cast<Message<FibonacciActionGoal>&>(src);

                if (tempSrc.version() != FibonacciActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciActionGoal: " << __FILE__ << " expected: " 
                             << FibonacciActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciActionGoal: " << __FILE__ << " expected: " 
                         << FibonacciActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciActionResult::ID:
            {
                FibonacciActionResultNML & tempDst = static_cast<FibonacciActionResultNML&>(dst);
                Message<FibonacciActionResult > & tempSrc = static_cast<Message<FibonacciActionResult>&>(src);

                if (tempSrc.version() != FibonacciActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciActionResult: " << __FILE__ << " expected: " 
                             << FibonacciActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciActionResult: " << __FILE__ << " expected: " 
                         << FibonacciActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciFeedback::ID:
            {
                FibonacciFeedbackNML & tempDst = static_cast<FibonacciFeedbackNML&>(dst);
                Message<FibonacciFeedback > & tempSrc = static_cast<Message<FibonacciFeedback>&>(src);

                if (tempSrc.version() != FibonacciFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciFeedback: " << __FILE__ << " expected: " 
                             << FibonacciFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciFeedback: " << __FILE__ << " expected: " 
                         << FibonacciFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciGoal::ID:
            {
                FibonacciGoalNML & tempDst = static_cast<FibonacciGoalNML&>(dst);
                Message<FibonacciGoal > & tempSrc = static_cast<Message<FibonacciGoal>&>(src);

                if (tempSrc.version() != FibonacciGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciGoal: " << __FILE__ << " expected: " 
                             << FibonacciGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciGoal: " << __FILE__ << " expected: " 
                         << FibonacciGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FibonacciResult::ID:
            {
                FibonacciResultNML & tempDst = static_cast<FibonacciResultNML&>(dst);
                Message<FibonacciResult > & tempSrc = static_cast<Message<FibonacciResult>&>(src);

                if (tempSrc.version() != FibonacciResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FibonacciResult: " << __FILE__ << " expected: " 
                             << FibonacciResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FibonacciResult: " << __FILE__ << " expected: " 
                         << FibonacciResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case AveragingAction::ID:
            {
                AveragingActionNML & tempSrc = static_cast<AveragingActionNML&>(src);
                Message<AveragingAction > & tempDst = static_cast<Message<AveragingAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AveragingActionFeedback::ID:
            {
                AveragingActionFeedbackNML & tempSrc = static_cast<AveragingActionFeedbackNML&>(src);
                Message<AveragingActionFeedback > & tempDst = static_cast<Message<AveragingActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AveragingActionGoal::ID:
            {
                AveragingActionGoalNML & tempSrc = static_cast<AveragingActionGoalNML&>(src);
                Message<AveragingActionGoal > & tempDst = static_cast<Message<AveragingActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AveragingActionResult::ID:
            {
                AveragingActionResultNML & tempSrc = static_cast<AveragingActionResultNML&>(src);
                Message<AveragingActionResult > & tempDst = static_cast<Message<AveragingActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AveragingFeedback::ID:
            {
                AveragingFeedbackNML & tempSrc = static_cast<AveragingFeedbackNML&>(src);
                Message<AveragingFeedback > & tempDst = static_cast<Message<AveragingFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AveragingGoal::ID:
            {
                AveragingGoalNML & tempSrc = static_cast<AveragingGoalNML&>(src);
                Message<AveragingGoal > & tempDst = static_cast<Message<AveragingGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AveragingResult::ID:
            {
                AveragingResultNML & tempSrc = static_cast<AveragingResultNML&>(src);
                Message<AveragingResult > & tempDst = static_cast<Message<AveragingResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AveragingResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciAction::ID:
            {
                FibonacciActionNML & tempSrc = static_cast<FibonacciActionNML&>(src);
                Message<FibonacciAction > & tempDst = static_cast<Message<FibonacciAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciActionFeedback::ID:
            {
                FibonacciActionFeedbackNML & tempSrc = static_cast<FibonacciActionFeedbackNML&>(src);
                Message<FibonacciActionFeedback > & tempDst = static_cast<Message<FibonacciActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciActionGoal::ID:
            {
                FibonacciActionGoalNML & tempSrc = static_cast<FibonacciActionGoalNML&>(src);
                Message<FibonacciActionGoal > & tempDst = static_cast<Message<FibonacciActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciActionResult::ID:
            {
                FibonacciActionResultNML & tempSrc = static_cast<FibonacciActionResultNML&>(src);
                Message<FibonacciActionResult > & tempDst = static_cast<Message<FibonacciActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciFeedback::ID:
            {
                FibonacciFeedbackNML & tempSrc = static_cast<FibonacciFeedbackNML&>(src);
                Message<FibonacciFeedback > & tempDst = static_cast<Message<FibonacciFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciGoal::ID:
            {
                FibonacciGoalNML & tempSrc = static_cast<FibonacciGoalNML&>(src);
                Message<FibonacciGoal > & tempDst = static_cast<Message<FibonacciGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FibonacciResult::ID:
            {
                FibonacciResultNML & tempSrc = static_cast<FibonacciResultNML&>(src);
                Message<FibonacciResult > & tempDst = static_cast<Message<FibonacciResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FibonacciResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case AveragingAction::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingAction at %p\n",buffer);
                AveragingActionNML * p = static_cast<AveragingActionNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AveragingActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingActionFeedback at %p\n",buffer);
                AveragingActionFeedbackNML * p = static_cast<AveragingActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AveragingActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingActionGoal at %p\n",buffer);
                AveragingActionGoalNML * p = static_cast<AveragingActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AveragingActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingActionResult at %p\n",buffer);
                AveragingActionResultNML * p = static_cast<AveragingActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AveragingFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingFeedback at %p\n",buffer);
                AveragingFeedbackNML * p = static_cast<AveragingFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AveragingGoal::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingGoal at %p\n",buffer);
                AveragingGoalNML * p = static_cast<AveragingGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AveragingResult::ID:
        {
            // only need to construct if data type is not flat
            if (AveragingResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AveragingResult at %p\n",buffer);
                AveragingResultNML * p = static_cast<AveragingResultNML*>(buffer);
                // construct the type at pointer p
                new (p) AveragingResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AveragingResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciAction::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciAction at %p\n",buffer);
                FibonacciActionNML * p = static_cast<FibonacciActionNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciActionFeedback at %p\n",buffer);
                FibonacciActionFeedbackNML * p = static_cast<FibonacciActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciActionGoal at %p\n",buffer);
                FibonacciActionGoalNML * p = static_cast<FibonacciActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciActionResult at %p\n",buffer);
                FibonacciActionResultNML * p = static_cast<FibonacciActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciFeedback at %p\n",buffer);
                FibonacciFeedbackNML * p = static_cast<FibonacciFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciGoal::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciGoal at %p\n",buffer);
                FibonacciGoalNML * p = static_cast<FibonacciGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciResult::ID:
        {
            // only need to construct if data type is not flat
            if (FibonacciResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FibonacciResult at %p\n",buffer);
                FibonacciResultNML * p = static_cast<FibonacciResultNML*>(buffer);
                // construct the type at pointer p
                new (p) FibonacciResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FibonacciResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int actionlib_tutorials_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case AveragingAction::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingAction at %p\n",buffer);
                AveragingActionNML * p = static_cast<AveragingActionNML*>(buffer);
                p->~AveragingActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case AveragingActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingActionFeedback at %p\n",buffer);
                AveragingActionFeedbackNML * p = static_cast<AveragingActionFeedbackNML*>(buffer);
                p->~AveragingActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case AveragingActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingActionGoal at %p\n",buffer);
                AveragingActionGoalNML * p = static_cast<AveragingActionGoalNML*>(buffer);
                p->~AveragingActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case AveragingActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingActionResult at %p\n",buffer);
                AveragingActionResultNML * p = static_cast<AveragingActionResultNML*>(buffer);
                p->~AveragingActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case AveragingFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingFeedback at %p\n",buffer);
                AveragingFeedbackNML * p = static_cast<AveragingFeedbackNML*>(buffer);
                p->~AveragingFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case AveragingGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingGoal at %p\n",buffer);
                AveragingGoalNML * p = static_cast<AveragingGoalNML*>(buffer);
                p->~AveragingGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case AveragingResult::ID:
        {
            // only need to destruct if data type is not flat
            if (AveragingResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AveragingResult at %p\n",buffer);
                AveragingResultNML * p = static_cast<AveragingResultNML*>(buffer);
                p->~AveragingResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AveragingResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciAction::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciAction at %p\n",buffer);
                FibonacciActionNML * p = static_cast<FibonacciActionNML*>(buffer);
                p->~FibonacciActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciActionFeedback at %p\n",buffer);
                FibonacciActionFeedbackNML * p = static_cast<FibonacciActionFeedbackNML*>(buffer);
                p->~FibonacciActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciActionGoal at %p\n",buffer);
                FibonacciActionGoalNML * p = static_cast<FibonacciActionGoalNML*>(buffer);
                p->~FibonacciActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciActionResult at %p\n",buffer);
                FibonacciActionResultNML * p = static_cast<FibonacciActionResultNML*>(buffer);
                p->~FibonacciActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciFeedback at %p\n",buffer);
                FibonacciFeedbackNML * p = static_cast<FibonacciFeedbackNML*>(buffer);
                p->~FibonacciFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciGoal at %p\n",buffer);
                FibonacciGoalNML * p = static_cast<FibonacciGoalNML*>(buffer);
                p->~FibonacciGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case FibonacciResult::ID:
        {
            // only need to destruct if data type is not flat
            if (FibonacciResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FibonacciResult at %p\n",buffer);
                FibonacciResultNML * p = static_cast<FibonacciResultNML*>(buffer);
                p->~FibonacciResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FibonacciResult at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

AveragingActionNML::AveragingActionNML() : NMLmsg((NMLTYPE)AveragingAction::ID,sizeof(AveragingActionNML)), nmlVersion(AveragingAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingAction()*/)
{
};

AveragingActionNML::~AveragingActionNML()
{
};

AveragingActionNML & AveragingActionNML::operator=(const AveragingActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingActionNML & AveragingActionNML::operator=(const AveragingAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingAction> temp(new AveragingAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingAction Message version mismatch, expected " << AveragingAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingAction Message version mismatch, expected " << AveragingAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

AveragingActionFeedbackNML::AveragingActionFeedbackNML() : NMLmsg((NMLTYPE)AveragingActionFeedback::ID,sizeof(AveragingActionFeedbackNML)), nmlVersion(AveragingActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingActionFeedback()*/)
{
};

AveragingActionFeedbackNML::~AveragingActionFeedbackNML()
{
};

AveragingActionFeedbackNML & AveragingActionFeedbackNML::operator=(const AveragingActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingActionFeedbackNML & AveragingActionFeedbackNML::operator=(const AveragingActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingActionFeedback> temp(new AveragingActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingActionFeedback Message version mismatch, expected " << AveragingActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingActionFeedback Message version mismatch, expected " << AveragingActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

AveragingActionGoalNML::AveragingActionGoalNML() : NMLmsg((NMLTYPE)AveragingActionGoal::ID,sizeof(AveragingActionGoalNML)), nmlVersion(AveragingActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingActionGoal()*/)
{
};

AveragingActionGoalNML::~AveragingActionGoalNML()
{
};

AveragingActionGoalNML & AveragingActionGoalNML::operator=(const AveragingActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingActionGoalNML & AveragingActionGoalNML::operator=(const AveragingActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingActionGoal> temp(new AveragingActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingActionGoal Message version mismatch, expected " << AveragingActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingActionGoal Message version mismatch, expected " << AveragingActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

AveragingActionResultNML::AveragingActionResultNML() : NMLmsg((NMLTYPE)AveragingActionResult::ID,sizeof(AveragingActionResultNML)), nmlVersion(AveragingActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingActionResult()*/)
{
};

AveragingActionResultNML::~AveragingActionResultNML()
{
};

AveragingActionResultNML & AveragingActionResultNML::operator=(const AveragingActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingActionResultNML & AveragingActionResultNML::operator=(const AveragingActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingActionResult> temp(new AveragingActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingActionResult Message version mismatch, expected " << AveragingActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingActionResult Message version mismatch, expected " << AveragingActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.sample);
        cms->update(inobj.data);
        cms->update(inobj.mean);
        cms->update(inobj.std_dev);

    }  
 }

AveragingFeedbackNML::AveragingFeedbackNML() : NMLmsg((NMLTYPE)AveragingFeedback::ID,sizeof(AveragingFeedbackNML)), nmlVersion(AveragingFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingFeedback()*/)
{
};

AveragingFeedbackNML::~AveragingFeedbackNML()
{
};

AveragingFeedbackNML & AveragingFeedbackNML::operator=(const AveragingFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingFeedbackNML & AveragingFeedbackNML::operator=(const AveragingFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingFeedback> temp(new AveragingFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingFeedback Message version mismatch, expected " << AveragingFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingFeedback Message version mismatch, expected " << AveragingFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.samples);

    }  
 }

AveragingGoalNML::AveragingGoalNML() : NMLmsg((NMLTYPE)AveragingGoal::ID,sizeof(AveragingGoalNML)), nmlVersion(AveragingGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingGoal()*/)
{
};

AveragingGoalNML::~AveragingGoalNML()
{
};

AveragingGoalNML & AveragingGoalNML::operator=(const AveragingGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingGoalNML & AveragingGoalNML::operator=(const AveragingGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingGoal> temp(new AveragingGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingGoal Message version mismatch, expected " << AveragingGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingGoal Message version mismatch, expected " << AveragingGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, AveragingResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AveragingResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.mean);
        cms->update(inobj.std_dev);

    }  
 }

AveragingResultNML::AveragingResultNML() : NMLmsg((NMLTYPE)AveragingResult::ID,sizeof(AveragingResultNML)), nmlVersion(AveragingResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AveragingResult()*/)
{
};

AveragingResultNML::~AveragingResultNML()
{
};

AveragingResultNML & AveragingResultNML::operator=(const AveragingResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AveragingResultNML & AveragingResultNML::operator=(const AveragingResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AveragingResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AveragingResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AveragingResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AveragingResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AveragingResult> temp(new AveragingResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AveragingResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AveragingResult Message version mismatch, expected " << AveragingResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AveragingResult Message version mismatch, expected " << AveragingResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

FibonacciActionNML::FibonacciActionNML() : NMLmsg((NMLTYPE)FibonacciAction::ID,sizeof(FibonacciActionNML)), nmlVersion(FibonacciAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciAction()*/)
{
};

FibonacciActionNML::~FibonacciActionNML()
{
};

FibonacciActionNML & FibonacciActionNML::operator=(const FibonacciActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciActionNML & FibonacciActionNML::operator=(const FibonacciAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciAction> temp(new FibonacciAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciAction Message version mismatch, expected " << FibonacciAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciAction Message version mismatch, expected " << FibonacciAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

FibonacciActionFeedbackNML::FibonacciActionFeedbackNML() : NMLmsg((NMLTYPE)FibonacciActionFeedback::ID,sizeof(FibonacciActionFeedbackNML)), nmlVersion(FibonacciActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciActionFeedback()*/)
{
};

FibonacciActionFeedbackNML::~FibonacciActionFeedbackNML()
{
};

FibonacciActionFeedbackNML & FibonacciActionFeedbackNML::operator=(const FibonacciActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciActionFeedbackNML & FibonacciActionFeedbackNML::operator=(const FibonacciActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciActionFeedback> temp(new FibonacciActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciActionFeedback Message version mismatch, expected " << FibonacciActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciActionFeedback Message version mismatch, expected " << FibonacciActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

FibonacciActionGoalNML::FibonacciActionGoalNML() : NMLmsg((NMLTYPE)FibonacciActionGoal::ID,sizeof(FibonacciActionGoalNML)), nmlVersion(FibonacciActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciActionGoal()*/)
{
};

FibonacciActionGoalNML::~FibonacciActionGoalNML()
{
};

FibonacciActionGoalNML & FibonacciActionGoalNML::operator=(const FibonacciActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciActionGoalNML & FibonacciActionGoalNML::operator=(const FibonacciActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciActionGoal> temp(new FibonacciActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciActionGoal Message version mismatch, expected " << FibonacciActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciActionGoal Message version mismatch, expected " << FibonacciActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

FibonacciActionResultNML::FibonacciActionResultNML() : NMLmsg((NMLTYPE)FibonacciActionResult::ID,sizeof(FibonacciActionResultNML)), nmlVersion(FibonacciActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciActionResult()*/)
{
};

FibonacciActionResultNML::~FibonacciActionResultNML()
{
};

FibonacciActionResultNML & FibonacciActionResultNML::operator=(const FibonacciActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciActionResultNML & FibonacciActionResultNML::operator=(const FibonacciActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciActionResult> temp(new FibonacciActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciActionResult Message version mismatch, expected " << FibonacciActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciActionResult Message version mismatch, expected " << FibonacciActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.sequence);

    }  
 }

FibonacciFeedbackNML::FibonacciFeedbackNML() : NMLmsg((NMLTYPE)FibonacciFeedback::ID,sizeof(FibonacciFeedbackNML)), nmlVersion(FibonacciFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciFeedback()*/)
{
};

FibonacciFeedbackNML::~FibonacciFeedbackNML()
{
};

FibonacciFeedbackNML & FibonacciFeedbackNML::operator=(const FibonacciFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciFeedbackNML & FibonacciFeedbackNML::operator=(const FibonacciFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciFeedback> temp(new FibonacciFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciFeedback Message version mismatch, expected " << FibonacciFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciFeedback Message version mismatch, expected " << FibonacciFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.order);

    }  
 }

FibonacciGoalNML::FibonacciGoalNML() : NMLmsg((NMLTYPE)FibonacciGoal::ID,sizeof(FibonacciGoalNML)), nmlVersion(FibonacciGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciGoal()*/)
{
};

FibonacciGoalNML::~FibonacciGoalNML()
{
};

FibonacciGoalNML & FibonacciGoalNML::operator=(const FibonacciGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciGoalNML & FibonacciGoalNML::operator=(const FibonacciGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciGoal> temp(new FibonacciGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciGoal Message version mismatch, expected " << FibonacciGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciGoal Message version mismatch, expected " << FibonacciGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void actionlib_tutorials::nmlupdate(CMS * cms, FibonacciResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FibonacciResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.sequence);

    }  
 }

FibonacciResultNML::FibonacciResultNML() : NMLmsg((NMLTYPE)FibonacciResult::ID,sizeof(FibonacciResultNML)), nmlVersion(FibonacciResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FibonacciResult()*/)
{
};

FibonacciResultNML::~FibonacciResultNML()
{
};

FibonacciResultNML & FibonacciResultNML::operator=(const FibonacciResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FibonacciResultNML & FibonacciResultNML::operator=(const FibonacciResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FibonacciResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FibonacciResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FibonacciResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FibonacciResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FibonacciResult> temp(new FibonacciResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: actionlib_tutorials_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FibonacciResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FibonacciResult Message version mismatch, expected " << FibonacciResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FibonacciResult Message version mismatch, expected " << FibonacciResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int actionlib_tutorials::actionlib_tutorials_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("actionlib_tutorials_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case AveragingAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingAction, id " << AveragingAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AveragingActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingActionFeedback, id " << AveragingActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AveragingActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingActionGoal, id " << AveragingActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AveragingActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingActionResult, id " << AveragingActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AveragingFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingFeedback, id " << AveragingFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AveragingGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingGoal, id " << AveragingGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AveragingResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AveragingResult, id " << AveragingResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AveragingResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciAction, id " << FibonacciAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciActionFeedback, id " << FibonacciActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciActionGoal, id " << FibonacciActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciActionResult, id " << FibonacciActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciFeedback, id " << FibonacciFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciGoal, id " << FibonacciGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FibonacciResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FibonacciResult, id " << FibonacciResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_actionlib_tutorials_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"actionlib_tutorials_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FibonacciResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

