// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:45 -0500
//  From Template/Script: data_templates/NMLHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_ACTIONLIB_TUTORIALS_GENCPPNML_H_
#define _CODEGEN_ACTIONLIB_TUTORIALS_GENCPPNML_H_

#include <messaging/nml/NMLMessageFactory.h>
//#include <DataTypeInfo.h>
#include <messaging/Message.h>

#include "actionlib_tutorials_gencpp_NMLSupport.h"

namespace rframe { class DataTypeInfo; };

#include "AveragingAction.h"
#include "AveragingActionFeedback.h"
#include "AveragingActionGoal.h"
#include "AveragingActionResult.h"
#include "AveragingFeedback.h"
#include "AveragingGoal.h"
#include "AveragingResult.h"
#include "FibonacciAction.h"
#include "FibonacciActionFeedback.h"
#include "FibonacciActionGoal.h"
#include "FibonacciActionResult.h"
#include "FibonacciFeedback.h"
#include "FibonacciGoal.h"
#include "FibonacciResult.h"

namespace actionlib_tutorials {

    /** definition of message factory for actionlib_tutorials_gencpp */
    class actionlib_tutorials_gencppNMLMessageFactory : public NMLMessageFactory
    {
    public:
        /** constructor */
        actionlib_tutorials_gencppNMLMessageFactory();
        /** destructor */
        virtual ~actionlib_tutorials_gencppNMLMessageFactory();

        /** see  rframe::MessageFactoryInterface */
        virtual void dataTypes(std::vector<DataTypeInfo> & ids);
        /** see  rframe::MessageFactoryInterface */
        virtual int dataType(NMLmsg & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateTransport(NMLmsg * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateMessage(MessageBase * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int toTransport( MessageBase & src, NMLmsg & dst);
        /** see  rframe::MessageFactoryInterface */
        virtual int fromTransport( NMLmsg & src, MessageBase & dst);

        /** \return poitner to nml format function */
        virtual NML_FORMAT_PTR FormatPointer();
        /** run constructor for class of type id in the provided buffer */
        virtual int constructBuffer(rframe::ID_TYPE id, void * buffer);
        /** run destructor for class of type id in the buffer */
        virtual int destructBuffer(rframe::ID_TYPE id, void * buffer);
    };

    /** factory allocation function for use when not dynamically loading the factory library  */
    NMLMessageFactory * allocate_actionlib_tutorials_gencpp();

    /** NML interface for AveragingAction 

    */
    class AveragingActionNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingActionNML();
        /** destructor */
        ~AveragingActionNML();

        /** assignment operator */
        AveragingActionNML & operator=(const AveragingActionNML &inobj);
        /** assignment operator for base data class */
        AveragingActionNML & operator=(const AveragingAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingAction nmlPayload;

        /** set payload */
        void payload(const AveragingAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for AveragingActionFeedback 

    */
    class AveragingActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingActionFeedbackNML();
        /** destructor */
        ~AveragingActionFeedbackNML();

        /** assignment operator */
        AveragingActionFeedbackNML & operator=(const AveragingActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        AveragingActionFeedbackNML & operator=(const AveragingActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingActionFeedback nmlPayload;

        /** set payload */
        void payload(const AveragingActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for AveragingActionGoal 

    */
    class AveragingActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingActionGoalNML();
        /** destructor */
        ~AveragingActionGoalNML();

        /** assignment operator */
        AveragingActionGoalNML & operator=(const AveragingActionGoalNML &inobj);
        /** assignment operator for base data class */
        AveragingActionGoalNML & operator=(const AveragingActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingActionGoal nmlPayload;

        /** set payload */
        void payload(const AveragingActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for AveragingActionResult 

    */
    class AveragingActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingActionResultNML();
        /** destructor */
        ~AveragingActionResultNML();

        /** assignment operator */
        AveragingActionResultNML & operator=(const AveragingActionResultNML &inobj);
        /** assignment operator for base data class */
        AveragingActionResultNML & operator=(const AveragingActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingActionResult nmlPayload;

        /** set payload */
        void payload(const AveragingActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for AveragingFeedback 

    */
    class AveragingFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingFeedbackNML();
        /** destructor */
        ~AveragingFeedbackNML();

        /** assignment operator */
        AveragingFeedbackNML & operator=(const AveragingFeedbackNML &inobj);
        /** assignment operator for base data class */
        AveragingFeedbackNML & operator=(const AveragingFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingFeedback nmlPayload;

        /** set payload */
        void payload(const AveragingFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for AveragingGoal 

    */
    class AveragingGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingGoalNML();
        /** destructor */
        ~AveragingGoalNML();

        /** assignment operator */
        AveragingGoalNML & operator=(const AveragingGoalNML &inobj);
        /** assignment operator for base data class */
        AveragingGoalNML & operator=(const AveragingGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingGoal nmlPayload;

        /** set payload */
        void payload(const AveragingGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for AveragingResult 

    */
    class AveragingResultNML : public NMLmsg
    {
    public:

        /** constructor */
        AveragingResultNML();
        /** destructor */
        ~AveragingResultNML();

        /** assignment operator */
        AveragingResultNML & operator=(const AveragingResultNML &inobj);
        /** assignment operator for base data class */
        AveragingResultNML & operator=(const AveragingResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        AveragingResult nmlPayload;

        /** set payload */
        void payload(const AveragingResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<AveragingResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        AveragingResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<AveragingResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciAction 

    */
    class FibonacciActionNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciActionNML();
        /** destructor */
        ~FibonacciActionNML();

        /** assignment operator */
        FibonacciActionNML & operator=(const FibonacciActionNML &inobj);
        /** assignment operator for base data class */
        FibonacciActionNML & operator=(const FibonacciAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciAction nmlPayload;

        /** set payload */
        void payload(const FibonacciAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciActionFeedback 

    */
    class FibonacciActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciActionFeedbackNML();
        /** destructor */
        ~FibonacciActionFeedbackNML();

        /** assignment operator */
        FibonacciActionFeedbackNML & operator=(const FibonacciActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        FibonacciActionFeedbackNML & operator=(const FibonacciActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciActionFeedback nmlPayload;

        /** set payload */
        void payload(const FibonacciActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciActionGoal 

    */
    class FibonacciActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciActionGoalNML();
        /** destructor */
        ~FibonacciActionGoalNML();

        /** assignment operator */
        FibonacciActionGoalNML & operator=(const FibonacciActionGoalNML &inobj);
        /** assignment operator for base data class */
        FibonacciActionGoalNML & operator=(const FibonacciActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciActionGoal nmlPayload;

        /** set payload */
        void payload(const FibonacciActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciActionResult 

    */
    class FibonacciActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciActionResultNML();
        /** destructor */
        ~FibonacciActionResultNML();

        /** assignment operator */
        FibonacciActionResultNML & operator=(const FibonacciActionResultNML &inobj);
        /** assignment operator for base data class */
        FibonacciActionResultNML & operator=(const FibonacciActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciActionResult nmlPayload;

        /** set payload */
        void payload(const FibonacciActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciFeedback 

    */
    class FibonacciFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciFeedbackNML();
        /** destructor */
        ~FibonacciFeedbackNML();

        /** assignment operator */
        FibonacciFeedbackNML & operator=(const FibonacciFeedbackNML &inobj);
        /** assignment operator for base data class */
        FibonacciFeedbackNML & operator=(const FibonacciFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciFeedback nmlPayload;

        /** set payload */
        void payload(const FibonacciFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciGoal 

    */
    class FibonacciGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciGoalNML();
        /** destructor */
        ~FibonacciGoalNML();

        /** assignment operator */
        FibonacciGoalNML & operator=(const FibonacciGoalNML &inobj);
        /** assignment operator for base data class */
        FibonacciGoalNML & operator=(const FibonacciGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciGoal nmlPayload;

        /** set payload */
        void payload(const FibonacciGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FibonacciResult 

    */
    class FibonacciResultNML : public NMLmsg
    {
    public:

        /** constructor */
        FibonacciResultNML();
        /** destructor */
        ~FibonacciResultNML();

        /** assignment operator */
        FibonacciResultNML & operator=(const FibonacciResultNML &inobj);
        /** assignment operator for base data class */
        FibonacciResultNML & operator=(const FibonacciResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FibonacciResult nmlPayload;

        /** set payload */
        void payload(const FibonacciResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FibonacciResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FibonacciResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<FibonacciResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    // predeclaration of nmlupdate functions (necessary due to namespaces )

    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::AveragingResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, actionlib_tutorials::FibonacciResult & inobj);

    /** nml format function */
    int actionlib_tutorials_gencpp_format(NMLTYPE type, void * buffer, CMS* cms);

}; // end namespace actionlib_tutorials

#endif // _ACTIONLIB_TUTORIALS_GENCPPNML_H_
