// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:05 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "geometry_msgs_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace geometry_msgs;

rframe::ROSMessageFactory * ROS_geometry_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_geometry_msgs_gencppfactory = new geometry_msgs_gencppROSMessageFactory();

        return ROS_geometry_msgs_gencppfactory;
    };
}

rframe::ROSMessageFactory * geometry_msgs::allocate_geometry_msgs_gencpp()
{
    ROS_geometry_msgs_gencppfactory = new geometry_msgs_gencppROSMessageFactory();
    return ROS_geometry_msgs_gencppfactory;
};

geometry_msgs_gencppROSMessageFactory::geometry_msgs_gencppROSMessageFactory()
{
    name("geometry_msgs_gencpp");
    // use constructor to register data types
    geometry_msgs::registerLibrary();
}

geometry_msgs_gencppROSMessageFactory::~geometry_msgs_gencppROSMessageFactory()
{
}

int geometry_msgs_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void geometry_msgs_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(Accel::ID);
    info.name(Accel::DATA_TYPE_FULL_NAME);
    info.hashKey(Accel::DATA_VERSION);
    info.md5Key(Accel::VERSION_MD5);
    info.xmlSource(Accel::XML_SOURCE);
    info.flat(Accel::dataTypeFlat());
    ids.push_back(info);

    info.id(AccelStamped::ID);
    info.name(AccelStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(AccelStamped::DATA_VERSION);
    info.md5Key(AccelStamped::VERSION_MD5);
    info.xmlSource(AccelStamped::XML_SOURCE);
    info.flat(AccelStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(AccelWithCovariance::ID);
    info.name(AccelWithCovariance::DATA_TYPE_FULL_NAME);
    info.hashKey(AccelWithCovariance::DATA_VERSION);
    info.md5Key(AccelWithCovariance::VERSION_MD5);
    info.xmlSource(AccelWithCovariance::XML_SOURCE);
    info.flat(AccelWithCovariance::dataTypeFlat());
    ids.push_back(info);

    info.id(AccelWithCovarianceStamped::ID);
    info.name(AccelWithCovarianceStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(AccelWithCovarianceStamped::DATA_VERSION);
    info.md5Key(AccelWithCovarianceStamped::VERSION_MD5);
    info.xmlSource(AccelWithCovarianceStamped::XML_SOURCE);
    info.flat(AccelWithCovarianceStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Inertia::ID);
    info.name(Inertia::DATA_TYPE_FULL_NAME);
    info.hashKey(Inertia::DATA_VERSION);
    info.md5Key(Inertia::VERSION_MD5);
    info.xmlSource(Inertia::XML_SOURCE);
    info.flat(Inertia::dataTypeFlat());
    ids.push_back(info);

    info.id(InertiaStamped::ID);
    info.name(InertiaStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(InertiaStamped::DATA_VERSION);
    info.md5Key(InertiaStamped::VERSION_MD5);
    info.xmlSource(InertiaStamped::XML_SOURCE);
    info.flat(InertiaStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Point::ID);
    info.name(Point::DATA_TYPE_FULL_NAME);
    info.hashKey(Point::DATA_VERSION);
    info.md5Key(Point::VERSION_MD5);
    info.xmlSource(Point::XML_SOURCE);
    info.flat(Point::dataTypeFlat());
    ids.push_back(info);

    info.id(Point32::ID);
    info.name(Point32::DATA_TYPE_FULL_NAME);
    info.hashKey(Point32::DATA_VERSION);
    info.md5Key(Point32::VERSION_MD5);
    info.xmlSource(Point32::XML_SOURCE);
    info.flat(Point32::dataTypeFlat());
    ids.push_back(info);

    info.id(PointStamped::ID);
    info.name(PointStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PointStamped::DATA_VERSION);
    info.md5Key(PointStamped::VERSION_MD5);
    info.xmlSource(PointStamped::XML_SOURCE);
    info.flat(PointStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Polygon::ID);
    info.name(Polygon::DATA_TYPE_FULL_NAME);
    info.hashKey(Polygon::DATA_VERSION);
    info.md5Key(Polygon::VERSION_MD5);
    info.xmlSource(Polygon::XML_SOURCE);
    info.flat(Polygon::dataTypeFlat());
    ids.push_back(info);

    info.id(PolygonStamped::ID);
    info.name(PolygonStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PolygonStamped::DATA_VERSION);
    info.md5Key(PolygonStamped::VERSION_MD5);
    info.xmlSource(PolygonStamped::XML_SOURCE);
    info.flat(PolygonStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Pose::ID);
    info.name(Pose::DATA_TYPE_FULL_NAME);
    info.hashKey(Pose::DATA_VERSION);
    info.md5Key(Pose::VERSION_MD5);
    info.xmlSource(Pose::XML_SOURCE);
    info.flat(Pose::dataTypeFlat());
    ids.push_back(info);

    info.id(Pose2D::ID);
    info.name(Pose2D::DATA_TYPE_FULL_NAME);
    info.hashKey(Pose2D::DATA_VERSION);
    info.md5Key(Pose2D::VERSION_MD5);
    info.xmlSource(Pose2D::XML_SOURCE);
    info.flat(Pose2D::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseArray::ID);
    info.name(PoseArray::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseArray::DATA_VERSION);
    info.md5Key(PoseArray::VERSION_MD5);
    info.xmlSource(PoseArray::XML_SOURCE);
    info.flat(PoseArray::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseStamped::ID);
    info.name(PoseStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseStamped::DATA_VERSION);
    info.md5Key(PoseStamped::VERSION_MD5);
    info.xmlSource(PoseStamped::XML_SOURCE);
    info.flat(PoseStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseWithCovariance::ID);
    info.name(PoseWithCovariance::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseWithCovariance::DATA_VERSION);
    info.md5Key(PoseWithCovariance::VERSION_MD5);
    info.xmlSource(PoseWithCovariance::XML_SOURCE);
    info.flat(PoseWithCovariance::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseWithCovarianceStamped::ID);
    info.name(PoseWithCovarianceStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseWithCovarianceStamped::DATA_VERSION);
    info.md5Key(PoseWithCovarianceStamped::VERSION_MD5);
    info.xmlSource(PoseWithCovarianceStamped::XML_SOURCE);
    info.flat(PoseWithCovarianceStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Quaternion::ID);
    info.name(Quaternion::DATA_TYPE_FULL_NAME);
    info.hashKey(Quaternion::DATA_VERSION);
    info.md5Key(Quaternion::VERSION_MD5);
    info.xmlSource(Quaternion::XML_SOURCE);
    info.flat(Quaternion::dataTypeFlat());
    ids.push_back(info);

    info.id(QuaternionStamped::ID);
    info.name(QuaternionStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(QuaternionStamped::DATA_VERSION);
    info.md5Key(QuaternionStamped::VERSION_MD5);
    info.xmlSource(QuaternionStamped::XML_SOURCE);
    info.flat(QuaternionStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Transform::ID);
    info.name(Transform::DATA_TYPE_FULL_NAME);
    info.hashKey(Transform::DATA_VERSION);
    info.md5Key(Transform::VERSION_MD5);
    info.xmlSource(Transform::XML_SOURCE);
    info.flat(Transform::dataTypeFlat());
    ids.push_back(info);

    info.id(TransformStamped::ID);
    info.name(TransformStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(TransformStamped::DATA_VERSION);
    info.md5Key(TransformStamped::VERSION_MD5);
    info.xmlSource(TransformStamped::XML_SOURCE);
    info.flat(TransformStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Twist::ID);
    info.name(Twist::DATA_TYPE_FULL_NAME);
    info.hashKey(Twist::DATA_VERSION);
    info.md5Key(Twist::VERSION_MD5);
    info.xmlSource(Twist::XML_SOURCE);
    info.flat(Twist::dataTypeFlat());
    ids.push_back(info);

    info.id(TwistStamped::ID);
    info.name(TwistStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(TwistStamped::DATA_VERSION);
    info.md5Key(TwistStamped::VERSION_MD5);
    info.xmlSource(TwistStamped::XML_SOURCE);
    info.flat(TwistStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(TwistWithCovariance::ID);
    info.name(TwistWithCovariance::DATA_TYPE_FULL_NAME);
    info.hashKey(TwistWithCovariance::DATA_VERSION);
    info.md5Key(TwistWithCovariance::VERSION_MD5);
    info.xmlSource(TwistWithCovariance::XML_SOURCE);
    info.flat(TwistWithCovariance::dataTypeFlat());
    ids.push_back(info);

    info.id(TwistWithCovarianceStamped::ID);
    info.name(TwistWithCovarianceStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(TwistWithCovarianceStamped::DATA_VERSION);
    info.md5Key(TwistWithCovarianceStamped::VERSION_MD5);
    info.xmlSource(TwistWithCovarianceStamped::XML_SOURCE);
    info.flat(TwistWithCovarianceStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Vector3::ID);
    info.name(Vector3::DATA_TYPE_FULL_NAME);
    info.hashKey(Vector3::DATA_VERSION);
    info.md5Key(Vector3::VERSION_MD5);
    info.xmlSource(Vector3::XML_SOURCE);
    info.flat(Vector3::dataTypeFlat());
    ids.push_back(info);

    info.id(Vector3Stamped::ID);
    info.name(Vector3Stamped::DATA_TYPE_FULL_NAME);
    info.hashKey(Vector3Stamped::DATA_VERSION);
    info.md5Key(Vector3Stamped::VERSION_MD5);
    info.xmlSource(Vector3Stamped::XML_SOURCE);
    info.flat(Vector3Stamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Wrench::ID);
    info.name(Wrench::DATA_TYPE_FULL_NAME);
    info.hashKey(Wrench::DATA_VERSION);
    info.md5Key(Wrench::VERSION_MD5);
    info.xmlSource(Wrench::XML_SOURCE);
    info.flat(Wrench::dataTypeFlat());
    ids.push_back(info);

    info.id(WrenchStamped::ID);
    info.name(WrenchStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(WrenchStamped::DATA_VERSION);
    info.md5Key(WrenchStamped::VERSION_MD5);
    info.xmlSource(WrenchStamped::XML_SOURCE);
    info.flat(WrenchStamped::dataTypeFlat());
    ids.push_back(info);

}

int geometry_msgs_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Accel::ID:
        {
            str = "geometry_msgs/Accel";
            break;
        }
        case AccelStamped::ID:
        {
            str = "geometry_msgs/AccelStamped";
            break;
        }
        case AccelWithCovariance::ID:
        {
            str = "geometry_msgs/AccelWithCovariance";
            break;
        }
        case AccelWithCovarianceStamped::ID:
        {
            str = "geometry_msgs/AccelWithCovarianceStamped";
            break;
        }
        case Inertia::ID:
        {
            str = "geometry_msgs/Inertia";
            break;
        }
        case InertiaStamped::ID:
        {
            str = "geometry_msgs/InertiaStamped";
            break;
        }
        case Point::ID:
        {
            str = "geometry_msgs/Point";
            break;
        }
        case Point32::ID:
        {
            str = "geometry_msgs/Point32";
            break;
        }
        case PointStamped::ID:
        {
            str = "geometry_msgs/PointStamped";
            break;
        }
        case Polygon::ID:
        {
            str = "geometry_msgs/Polygon";
            break;
        }
        case PolygonStamped::ID:
        {
            str = "geometry_msgs/PolygonStamped";
            break;
        }
        case Pose::ID:
        {
            str = "geometry_msgs/Pose";
            break;
        }
        case Pose2D::ID:
        {
            str = "geometry_msgs/Pose2D";
            break;
        }
        case PoseArray::ID:
        {
            str = "geometry_msgs/PoseArray";
            break;
        }
        case PoseStamped::ID:
        {
            str = "geometry_msgs/PoseStamped";
            break;
        }
        case PoseWithCovariance::ID:
        {
            str = "geometry_msgs/PoseWithCovariance";
            break;
        }
        case PoseWithCovarianceStamped::ID:
        {
            str = "geometry_msgs/PoseWithCovarianceStamped";
            break;
        }
        case Quaternion::ID:
        {
            str = "geometry_msgs/Quaternion";
            break;
        }
        case QuaternionStamped::ID:
        {
            str = "geometry_msgs/QuaternionStamped";
            break;
        }
        case Transform::ID:
        {
            str = "geometry_msgs/Transform";
            break;
        }
        case TransformStamped::ID:
        {
            str = "geometry_msgs/TransformStamped";
            break;
        }
        case Twist::ID:
        {
            str = "geometry_msgs/Twist";
            break;
        }
        case TwistStamped::ID:
        {
            str = "geometry_msgs/TwistStamped";
            break;
        }
        case TwistWithCovariance::ID:
        {
            str = "geometry_msgs/TwistWithCovariance";
            break;
        }
        case TwistWithCovarianceStamped::ID:
        {
            str = "geometry_msgs/TwistWithCovarianceStamped";
            break;
        }
        case Vector3::ID:
        {
            str = "geometry_msgs/Vector3";
            break;
        }
        case Vector3Stamped::ID:
        {
            str = "geometry_msgs/Vector3Stamped";
            break;
        }
        case Wrench::ID:
        {
            str = "geometry_msgs/Wrench";
            break;
        }
        case WrenchStamped::ID:
        {
            str = "geometry_msgs/WrenchStamped";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Accel::ID:
        {
            str = "# This expresses acceleration in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case AccelStamped::ID:
        {
            str = "# An accel with reference coordinate frame and timestamp\nHeader header\nAccel accel\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Accel\n# This expresses acceleration in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case AccelWithCovariance::ID:
        {
            str = "# This expresses acceleration in free space with uncertainty.\n\nAccel accel\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Accel\n# This expresses acceleration in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case AccelWithCovarianceStamped::ID:
        {
            str = "# This represents an estimated accel with reference coordinate frame and timestamp.\nHeader header\nAccelWithCovariance accel\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/AccelWithCovariance\n# This expresses acceleration in free space with uncertainty.\n\nAccel accel\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Accel\n# This expresses acceleration in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case Inertia::ID:
        {
            str = "# Mass [kg]\nfloat64 m\n\n# Center of mass [m]\ngeometry_msgs/Vector3 com\n\n# Inertia Tensor [kg-m^2]\n#     | ixx ixy ixz |\n# I = | ixy iyy iyz |\n#     | ixz iyz izz |\nfloat64 ixx\nfloat64 ixy\nfloat64 ixz\nfloat64 iyy\nfloat64 iyz\nfloat64 izz\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case InertiaStamped::ID:
        {
            str = "Header header\nInertia inertia\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Inertia\n# Mass [kg]\nfloat64 m\n\n# Center of mass [m]\ngeometry_msgs/Vector3 com\n\n# Inertia Tensor [kg-m^2]\n#     | ixx ixy ixz |\n# I = | ixy iyy iyz |\n#     | ixz iyz izz |\nfloat64 ixx\nfloat64 ixy\nfloat64 ixz\nfloat64 iyy\nfloat64 iyz\nfloat64 izz\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case Point::ID:
        {
            str = "# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n";
            break;
        }
        case Point32::ID:
        {
            str = "# This contains the position of a point in free space(with 32 bits of precision).\n# It is recommeded to use Point wherever possible instead of Point32.  \n# \n# This recommendation is to promote interoperability.  \n#\n# This message is designed to take up less space when sending\n# lots of points at once, as in the case of a PointCloud.  \n\nfloat32 x\nfloat32 y\n";
            break;
        }
        case PointStamped::ID:
        {
            str = "# This represents a Point with reference coordinate frame and timestamp\nHeader header\nPoint point\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n";
            break;
        }
        case Polygon::ID:
        {
            str = "#A specification of a polygon where the first and last points are assumed to be connected\nPoint32[] points\n\n================================================================================\nMSG: geometry_msgs/Point32\n# This contains the position of a point in free space(with 32 bits of precision).\n# It is recommeded to use Point wherever possible instead of Point32.  \n# \n# This recommendation is to promote interoperability.  \n#\n# This message is designed to take up less space when sending\n# lots of points at once, as in the case of a PointCloud.  \n\nfloat32 x\nfloat32 y\n";
            break;
        }
        case PolygonStamped::ID:
        {
            str = "# This represents a Polygon with reference coordinate frame and timestamp\nHeader header\nPolygon polygon\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Polygon\n#A specification of a polygon where the first and last points are assumed to be connected\nPoint32[] points\n\n================================================================================\nMSG: geometry_msgs/Point32\n# This contains the position of a point in free space(with 32 bits of precision).\n# It is recommeded to use Point wherever possible instead of Point32.  \n# \n# This recommendation is to promote interoperability.  \n#\n# This message is designed to take up less space when sending\n# lots of points at once, as in the case of a PointCloud.  \n\nfloat32 x\nfloat32 y\n";
            break;
        }
        case Pose::ID:
        {
            str = "float32 x\nfloat32 y\nfloat32 theta\n\nfloat32 linear_velocity\n";
            break;
        }
        case Pose2D::ID:
        {
            str = "# This expresses a position and orientation on a 2D manifold.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case PoseArray::ID:
        {
            str = "# An array of poses with a header for global reference.\n\nHeader header\n\nPose[] poses\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case PoseStamped::ID:
        {
            str = "# A Pose with reference coordinate frame and timestamp\nHeader header\nPose pose\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case PoseWithCovariance::ID:
        {
            str = "# This represents a pose in free space with uncertainty.\n\nPose pose\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case PoseWithCovarianceStamped::ID:
        {
            str = "# This expresses an estimated pose with a reference coordinate frame and timestamp\n\nHeader header\nPoseWithCovariance pose\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/PoseWithCovariance\n# This represents a pose in free space with uncertainty.\n\nPose pose\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case Quaternion::ID:
        {
            str = "# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case QuaternionStamped::ID:
        {
            str = "# This represents an orientation with reference coordinate frame and timestamp.\n\nHeader header\nQuaternion quaternion\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case Transform::ID:
        {
            str = "# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\nfloat64 z\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case TransformStamped::ID:
        {
            str = "# This expresses a transform from coordinate frame header.frame_id\n# to the coordinate frame child_frame_id\n#\n# This message is mostly used by the \n# <a href=\"http://wiki.ros.org/tf\">tf</a> package. \n# See its documentation for more information.\n\nHeader header\nstring child_frame_id # the frame id of the child frame\nTransform transform\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\nfloat64 z\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n";
            break;
        }
        case Twist::ID:
        {
            str = "# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case TwistStamped::ID:
        {
            str = "# A twist with reference coordinate frame and timestamp\nHeader header\nTwist twist\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case TwistWithCovariance::ID:
        {
            str = "# This expresses velocity in free space with uncertainty.\n\nTwist twist\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case TwistWithCovarianceStamped::ID:
        {
            str = "# This represents an estimated twist with reference coordinate frame and timestamp.\nHeader header\nTwistWithCovariance twist\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/TwistWithCovariance\n# This expresses velocity in free space with uncertainty.\n\nTwist twist\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case Vector3::ID:
        {
            str = "# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case Vector3Stamped::ID:
        {
            str = "# This represents a Vector3 with reference coordinate frame and timestamp\nHeader header\nVector3 vector\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case Wrench::ID:
        {
            str = "# This represents force in free space, separated into\n# its linear and angular parts.\nVector3  force\nVector3  torque\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case WrenchStamped::ID:
        {
            str = "# A wrench with reference coordinate frame and timestamp\nHeader header\nWrench wrench\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Wrench\n# This represents force in free space, separated into\n# its linear and angular parts.\nVector3  force\nVector3  torque\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Accel::ID:
        {
            str = "9f195f881246fdfa2798d1d3eebca84a";
            break;
        }
        case AccelStamped::ID:
        {
            str = "d8a98a5d81351b6eb0578c78557e7659";
            break;
        }
        case AccelWithCovariance::ID:
        {
            str = "ad5a718d699c6be72a02b8d6a139f334";
            break;
        }
        case AccelWithCovarianceStamped::ID:
        {
            str = "96adb295225031ec8d57fb4251b0a886";
            break;
        }
        case Inertia::ID:
        {
            str = "1d26e4bb6c83ff141c5cf0d883c2b0fe";
            break;
        }
        case InertiaStamped::ID:
        {
            str = "ddee48caeab5a966c5e8d166654a9ac7";
            break;
        }
        case Point::ID:
        {
            str = "4a842b65f413084dc2b10fb484ea7f17";
            break;
        }
        case Point32::ID:
        {
            str = "cc153912f1453b708d221682bc23d9ac";
            break;
        }
        case PointStamped::ID:
        {
            str = "c63aecb41bfdfd6b7e1fac37c7cbe7bf";
            break;
        }
        case Polygon::ID:
        {
            str = "cd60a26494a087f577976f0329fa120e";
            break;
        }
        case PolygonStamped::ID:
        {
            str = "c6be8f7dc3bee7fe9e8d296070f53340";
            break;
        }
        case Pose::ID:
        {
            str = "863b248d5016ca62ea2e895ae5265cf9";
            break;
        }
        case Pose2D::ID:
        {
            str = "938fa65709584ad8e77d238529be13b8";
            break;
        }
        case PoseArray::ID:
        {
            str = "916c28c5764443f268b296bb671b9d97";
            break;
        }
        case PoseStamped::ID:
        {
            str = "d3812c3cbc69362b77dc0b19b345f8f5";
            break;
        }
        case PoseWithCovariance::ID:
        {
            str = "c23e848cf1b7533a8d7c259073a97e6f";
            break;
        }
        case PoseWithCovarianceStamped::ID:
        {
            str = "953b798c0f514ff060a53a3498ce6246";
            break;
        }
        case Quaternion::ID:
        {
            str = "a779879fadf0160734f906b8c19c7004";
            break;
        }
        case QuaternionStamped::ID:
        {
            str = "e57f1e547e0e1fd13504588ffc8334e2";
            break;
        }
        case Transform::ID:
        {
            str = "ac9eff44abf714214112b05d54a3cf9b";
            break;
        }
        case TransformStamped::ID:
        {
            str = "b5764a33bfeb3588febc2682852579b0";
            break;
        }
        case Twist::ID:
        {
            str = "9f195f881246fdfa2798d1d3eebca84a";
            break;
        }
        case TwistStamped::ID:
        {
            str = "98d34b0043a2093cf9d9345ab6eef12e";
            break;
        }
        case TwistWithCovariance::ID:
        {
            str = "1fe8a28e6890a4cc3ae4c3ca5c7d82e6";
            break;
        }
        case TwistWithCovarianceStamped::ID:
        {
            str = "8927a1a12fb2607ceea095b2dc440a96";
            break;
        }
        case Vector3::ID:
        {
            str = "4a842b65f413084dc2b10fb484ea7f17";
            break;
        }
        case Vector3Stamped::ID:
        {
            str = "7b324c7325e683bf02a9b14b01090ec7";
            break;
        }
        case Wrench::ID:
        {
            str = "4f539cf138b23283b520fd271b567936";
            break;
        }
        case WrenchStamped::ID:
        {
            str = "d78d3cb249ce23087ade7e7d0c40cfa7";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case Accel::ID:
        {   
		    highOrder = 0x9f195f881246fdfaULL;
            lowOrder = 0x2798d1d3eebca84aULL;
            break;
        }
        case AccelStamped::ID:
        {   
		    highOrder = 0xd8a98a5d81351b6eULL;
            lowOrder = 0xb0578c78557e7659ULL;
            break;
        }
        case AccelWithCovariance::ID:
        {   
		    highOrder = 0xad5a718d699c6be7ULL;
            lowOrder = 0x2a02b8d6a139f334ULL;
            break;
        }
        case AccelWithCovarianceStamped::ID:
        {   
		    highOrder = 0x96adb295225031ecULL;
            lowOrder = 0x8d57fb4251b0a886ULL;
            break;
        }
        case Inertia::ID:
        {   
		    highOrder = 0x1d26e4bb6c83ff14ULL;
            lowOrder = 0x1c5cf0d883c2b0feULL;
            break;
        }
        case InertiaStamped::ID:
        {   
		    highOrder = 0xddee48caeab5a966ULL;
            lowOrder = 0xc5e8d166654a9ac7ULL;
            break;
        }
        case Point::ID:
        {   
		    highOrder = 0x4a842b65f413084dULL;
            lowOrder = 0xc2b10fb484ea7f17ULL;
            break;
        }
        case Point32::ID:
        {   
		    highOrder = 0xcc153912f1453b70ULL;
            lowOrder = 0x8d221682bc23d9acULL;
            break;
        }
        case PointStamped::ID:
        {   
		    highOrder = 0xc63aecb41bfdfd6bULL;
            lowOrder = 0x7e1fac37c7cbe7bfULL;
            break;
        }
        case Polygon::ID:
        {   
		    highOrder = 0xcd60a26494a087f5ULL;
            lowOrder = 0x77976f0329fa120eULL;
            break;
        }
        case PolygonStamped::ID:
        {   
		    highOrder = 0xc6be8f7dc3bee7feULL;
            lowOrder = 0x9e8d296070f53340ULL;
            break;
        }
        case Pose::ID:
        {   
		    highOrder = 0x863b248d5016ca62ULL;
            lowOrder = 0xea2e895ae5265cf9ULL;
            break;
        }
        case Pose2D::ID:
        {   
		    highOrder = 0x938fa65709584ad8ULL;
            lowOrder = 0xe77d238529be13b8ULL;
            break;
        }
        case PoseArray::ID:
        {   
		    highOrder = 0x916c28c5764443f2ULL;
            lowOrder = 0x68b296bb671b9d97ULL;
            break;
        }
        case PoseStamped::ID:
        {   
		    highOrder = 0xd3812c3cbc69362bULL;
            lowOrder = 0x77dc0b19b345f8f5ULL;
            break;
        }
        case PoseWithCovariance::ID:
        {   
		    highOrder = 0xc23e848cf1b7533aULL;
            lowOrder = 0x8d7c259073a97e6fULL;
            break;
        }
        case PoseWithCovarianceStamped::ID:
        {   
		    highOrder = 0x953b798c0f514ff0ULL;
            lowOrder = 0x60a53a3498ce6246ULL;
            break;
        }
        case Quaternion::ID:
        {   
		    highOrder = 0xa779879fadf01607ULL;
            lowOrder = 0x34f906b8c19c7004ULL;
            break;
        }
        case QuaternionStamped::ID:
        {   
		    highOrder = 0xe57f1e547e0e1fd1ULL;
            lowOrder = 0x3504588ffc8334e2ULL;
            break;
        }
        case Transform::ID:
        {   
		    highOrder = 0xac9eff44abf71421ULL;
            lowOrder = 0x4112b05d54a3cf9bULL;
            break;
        }
        case TransformStamped::ID:
        {   
		    highOrder = 0xb5764a33bfeb3588ULL;
            lowOrder = 0xfebc2682852579b0ULL;
            break;
        }
        case Twist::ID:
        {   
		    highOrder = 0x9f195f881246fdfaULL;
            lowOrder = 0x2798d1d3eebca84aULL;
            break;
        }
        case TwistStamped::ID:
        {   
		    highOrder = 0x98d34b0043a2093cULL;
            lowOrder = 0xf9d9345ab6eef12eULL;
            break;
        }
        case TwistWithCovariance::ID:
        {   
		    highOrder = 0x1fe8a28e6890a4ccULL;
            lowOrder = 0x3ae4c3ca5c7d82e6ULL;
            break;
        }
        case TwistWithCovarianceStamped::ID:
        {   
		    highOrder = 0x8927a1a12fb2607cULL;
            lowOrder = 0xeea095b2dc440a96ULL;
            break;
        }
        case Vector3::ID:
        {   
		    highOrder = 0x4a842b65f413084dULL;
            lowOrder = 0xc2b10fb484ea7f17ULL;
            break;
        }
        case Vector3Stamped::ID:
        {   
		    highOrder = 0x7b324c7325e683bfULL;
            lowOrder = 0x02a9b14b01090ec7ULL;
            break;
        }
        case Wrench::ID:
        {   
		    highOrder = 0x4f539cf138b23283ULL;
            lowOrder = 0xb520fd271b567936ULL;
            break;
        }
        case WrenchStamped::ID:
        {   
		    highOrder = 0xd78d3cb249ce2308ULL;
            lowOrder = 0x7ade7e7d0c40cfa7ULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case Accel::ID:
        case AccelStamped::ID:
        case AccelWithCovariance::ID:
        case AccelWithCovarianceStamped::ID:
        case Inertia::ID:
        case InertiaStamped::ID:
        case Point::ID:
        case Point32::ID:
        case PointStamped::ID:
        case Polygon::ID:
        case PolygonStamped::ID:
        case Pose::ID:
        case Pose2D::ID:
        case PoseArray::ID:
        case PoseStamped::ID:
        case PoseWithCovariance::ID:
        case PoseWithCovarianceStamped::ID:
        case Quaternion::ID:
        case QuaternionStamped::ID:
        case Transform::ID:
        case TransformStamped::ID:
        case Twist::ID:
        case TwistStamped::ID:
        case TwistWithCovariance::ID:
        case TwistWithCovarianceStamped::ID:
        case Vector3::ID:
        case Vector3Stamped::ID:
        case Wrench::ID:
        case WrenchStamped::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case Accel::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Accel>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AccelStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AccelStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AccelWithCovariance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AccelWithCovariance>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AccelWithCovarianceStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AccelWithCovarianceStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Inertia::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Inertia>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case InertiaStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<InertiaStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Point::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Point>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Point32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Point32>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Polygon::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Polygon>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PolygonStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PolygonStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Pose::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Pose>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Pose2D::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Pose2D>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseArray>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseWithCovariance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseWithCovariance>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseWithCovarianceStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseWithCovarianceStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Quaternion::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Quaternion>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QuaternionStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QuaternionStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Transform::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Transform>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TransformStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TransformStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Twist::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Twist>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwistStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwistStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwistWithCovariance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwistWithCovariance>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwistWithCovarianceStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwistWithCovarianceStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Vector3::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Vector3>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Vector3Stamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Vector3Stamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Wrench::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Wrench>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case WrenchStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<WrenchStamped>(),std::bind(&geometry_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case Accel::ID:
            {
                Message<Accel > & tempSrc = static_cast<Message<Accel>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Accel buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case AccelStamped::ID:
            {
                Message<AccelStamped > & tempSrc = static_cast<Message<AccelStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::AccelStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case AccelWithCovariance::ID:
            {
                Message<AccelWithCovariance > & tempSrc = static_cast<Message<AccelWithCovariance>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::AccelWithCovariance buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case AccelWithCovarianceStamped::ID:
            {
                Message<AccelWithCovarianceStamped > & tempSrc = static_cast<Message<AccelWithCovarianceStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::AccelWithCovarianceStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Inertia::ID:
            {
                Message<Inertia > & tempSrc = static_cast<Message<Inertia>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Inertia buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case InertiaStamped::ID:
            {
                Message<InertiaStamped > & tempSrc = static_cast<Message<InertiaStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::InertiaStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Point::ID:
            {
                Message<Point > & tempSrc = static_cast<Message<Point>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Point buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Point32::ID:
            {
                Message<Point32 > & tempSrc = static_cast<Message<Point32>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Point32 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointStamped::ID:
            {
                Message<PointStamped > & tempSrc = static_cast<Message<PointStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::PointStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Polygon::ID:
            {
                Message<Polygon > & tempSrc = static_cast<Message<Polygon>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Polygon buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PolygonStamped::ID:
            {
                Message<PolygonStamped > & tempSrc = static_cast<Message<PolygonStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::PolygonStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Pose::ID:
            {
                Message<Pose > & tempSrc = static_cast<Message<Pose>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Pose buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Pose2D::ID:
            {
                Message<Pose2D > & tempSrc = static_cast<Message<Pose2D>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Pose2D buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PoseArray::ID:
            {
                Message<PoseArray > & tempSrc = static_cast<Message<PoseArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::PoseArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PoseStamped::ID:
            {
                Message<PoseStamped > & tempSrc = static_cast<Message<PoseStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::PoseStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PoseWithCovariance::ID:
            {
                Message<PoseWithCovariance > & tempSrc = static_cast<Message<PoseWithCovariance>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::PoseWithCovariance buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PoseWithCovarianceStamped::ID:
            {
                Message<PoseWithCovarianceStamped > & tempSrc = static_cast<Message<PoseWithCovarianceStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::PoseWithCovarianceStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Quaternion::ID:
            {
                Message<Quaternion > & tempSrc = static_cast<Message<Quaternion>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Quaternion buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QuaternionStamped::ID:
            {
                Message<QuaternionStamped > & tempSrc = static_cast<Message<QuaternionStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::QuaternionStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Transform::ID:
            {
                Message<Transform > & tempSrc = static_cast<Message<Transform>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Transform buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TransformStamped::ID:
            {
                Message<TransformStamped > & tempSrc = static_cast<Message<TransformStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::TransformStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Twist::ID:
            {
                Message<Twist > & tempSrc = static_cast<Message<Twist>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Twist buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwistStamped::ID:
            {
                Message<TwistStamped > & tempSrc = static_cast<Message<TwistStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::TwistStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwistWithCovariance::ID:
            {
                Message<TwistWithCovariance > & tempSrc = static_cast<Message<TwistWithCovariance>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::TwistWithCovariance buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case TwistWithCovarianceStamped::ID:
            {
                Message<TwistWithCovarianceStamped > & tempSrc = static_cast<Message<TwistWithCovarianceStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::TwistWithCovarianceStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Vector3::ID:
            {
                Message<Vector3 > & tempSrc = static_cast<Message<Vector3>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Vector3 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Vector3Stamped::ID:
            {
                Message<Vector3Stamped > & tempSrc = static_cast<Message<Vector3Stamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Vector3Stamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Wrench::ID:
            {
                Message<Wrench > & tempSrc = static_cast<Message<Wrench>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::Wrench buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case WrenchStamped::ID:
            {
                Message<WrenchStamped > & tempSrc = static_cast<Message<WrenchStamped>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: geometry_msgs_gencpp::WrenchStamped buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case Accel::ID:
            {
                Message<Accel > & tempDst = static_cast<Message<Accel>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case AccelStamped::ID:
            {
                Message<AccelStamped > & tempDst = static_cast<Message<AccelStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case AccelWithCovariance::ID:
            {
                Message<AccelWithCovariance > & tempDst = static_cast<Message<AccelWithCovariance>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case AccelWithCovarianceStamped::ID:
            {
                Message<AccelWithCovarianceStamped > & tempDst = static_cast<Message<AccelWithCovarianceStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Inertia::ID:
            {
                Message<Inertia > & tempDst = static_cast<Message<Inertia>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case InertiaStamped::ID:
            {
                Message<InertiaStamped > & tempDst = static_cast<Message<InertiaStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Point::ID:
            {
                Message<Point > & tempDst = static_cast<Message<Point>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Point32::ID:
            {
                Message<Point32 > & tempDst = static_cast<Message<Point32>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PointStamped::ID:
            {
                Message<PointStamped > & tempDst = static_cast<Message<PointStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Polygon::ID:
            {
                Message<Polygon > & tempDst = static_cast<Message<Polygon>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PolygonStamped::ID:
            {
                Message<PolygonStamped > & tempDst = static_cast<Message<PolygonStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Pose::ID:
            {
                Message<Pose > & tempDst = static_cast<Message<Pose>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Pose2D::ID:
            {
                Message<Pose2D > & tempDst = static_cast<Message<Pose2D>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PoseArray::ID:
            {
                Message<PoseArray > & tempDst = static_cast<Message<PoseArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case PoseStamped::ID:
            {
                Message<PoseStamped > & tempDst = static_cast<Message<PoseStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case PoseWithCovariance::ID:
            {
                Message<PoseWithCovariance > & tempDst = static_cast<Message<PoseWithCovariance>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PoseWithCovarianceStamped::ID:
            {
                Message<PoseWithCovarianceStamped > & tempDst = static_cast<Message<PoseWithCovarianceStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Quaternion::ID:
            {
                Message<Quaternion > & tempDst = static_cast<Message<Quaternion>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QuaternionStamped::ID:
            {
                Message<QuaternionStamped > & tempDst = static_cast<Message<QuaternionStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Transform::ID:
            {
                Message<Transform > & tempDst = static_cast<Message<Transform>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TransformStamped::ID:
            {
                Message<TransformStamped > & tempDst = static_cast<Message<TransformStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Twist::ID:
            {
                Message<Twist > & tempDst = static_cast<Message<Twist>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TwistStamped::ID:
            {
                Message<TwistStamped > & tempDst = static_cast<Message<TwistStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case TwistWithCovariance::ID:
            {
                Message<TwistWithCovariance > & tempDst = static_cast<Message<TwistWithCovariance>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case TwistWithCovarianceStamped::ID:
            {
                Message<TwistWithCovarianceStamped > & tempDst = static_cast<Message<TwistWithCovarianceStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Vector3::ID:
            {
                Message<Vector3 > & tempDst = static_cast<Message<Vector3>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Vector3Stamped::ID:
            {
                Message<Vector3Stamped > & tempDst = static_cast<Message<Vector3Stamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Wrench::ID:
            {
                Message<Wrench > & tempDst = static_cast<Message<Wrench>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case WrenchStamped::ID:
            {
                Message<WrenchStamped > & tempDst = static_cast<Message<WrenchStamped>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int geometry_msgs_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // Accel does not have a Header as its first member 
        case AccelStamped::ID:
        {
            Message<AccelStamped > & tempMsg = static_cast<Message<AccelStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // AccelWithCovariance does not have a Header as its first member 
        case AccelWithCovarianceStamped::ID:
        {
            Message<AccelWithCovarianceStamped > & tempMsg = static_cast<Message<AccelWithCovarianceStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Inertia does not have a Header as its first member 
        case InertiaStamped::ID:
        {
            Message<InertiaStamped > & tempMsg = static_cast<Message<InertiaStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Point does not have a Header as its first member 
        // Point32 does not have a Header as its first member 
        case PointStamped::ID:
        {
            Message<PointStamped > & tempMsg = static_cast<Message<PointStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Polygon does not have a Header as its first member 
        case PolygonStamped::ID:
        {
            Message<PolygonStamped > & tempMsg = static_cast<Message<PolygonStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Pose does not have a Header as its first member 
        // Pose2D does not have a Header as its first member 
        case PoseArray::ID:
        {
            Message<PoseArray > & tempMsg = static_cast<Message<PoseArray>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case PoseStamped::ID:
        {
            Message<PoseStamped > & tempMsg = static_cast<Message<PoseStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // PoseWithCovariance does not have a Header as its first member 
        case PoseWithCovarianceStamped::ID:
        {
            Message<PoseWithCovarianceStamped > & tempMsg = static_cast<Message<PoseWithCovarianceStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Quaternion does not have a Header as its first member 
        case QuaternionStamped::ID:
        {
            Message<QuaternionStamped > & tempMsg = static_cast<Message<QuaternionStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Transform does not have a Header as its first member 
        case TransformStamped::ID:
        {
            Message<TransformStamped > & tempMsg = static_cast<Message<TransformStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Twist does not have a Header as its first member 
        case TwistStamped::ID:
        {
            Message<TwistStamped > & tempMsg = static_cast<Message<TwistStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // TwistWithCovariance does not have a Header as its first member 
        case TwistWithCovarianceStamped::ID:
        {
            Message<TwistWithCovarianceStamped > & tempMsg = static_cast<Message<TwistWithCovarianceStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Vector3 does not have a Header as its first member 
        case Vector3Stamped::ID:
        {
            Message<Vector3Stamped > & tempMsg = static_cast<Message<Vector3Stamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Wrench does not have a Header as its first member 
        case WrenchStamped::ID:
        {
            Message<WrenchStamped > & tempMsg = static_cast<Message<WrenchStamped>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
