// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:30:54 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "geometry_msgs_gencpp_NML.h"
#include "geometry_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <Accel.h>
#include <AccelStamped.h>
#include <AccelWithCovariance.h>
#include <AccelWithCovarianceStamped.h>
#include <Inertia.h>
#include <InertiaStamped.h>
#include <Point.h>
#include <Point32.h>
#include <PointStamped.h>
#include <Polygon.h>
#include <PolygonStamped.h>
#include <Pose.h>
#include <Pose2D.h>
#include <PoseArray.h>
#include <PoseStamped.h>
#include <PoseWithCovariance.h>
#include <PoseWithCovarianceStamped.h>
#include <Quaternion.h>
#include <QuaternionStamped.h>
#include <Transform.h>
#include <TransformStamped.h>
#include <Twist.h>
#include <TwistStamped.h>
#include <TwistWithCovariance.h>
#include <TwistWithCovarianceStamped.h>
#include <Vector3.h>
#include <Vector3Stamped.h>
#include <Wrench.h>
#include <WrenchStamped.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace geometry_msgs;

rframe::NMLMessageFactory * NML_geometry_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_geometry_msgs_gencppfactory = new geometry_msgs_gencppNMLMessageFactory();
        return NML_geometry_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * geometry_msgs::allocate_geometry_msgs_gencpp()
{
    NML_geometry_msgs_gencppfactory = new geometry_msgs_gencppNMLMessageFactory();
    return NML_geometry_msgs_gencppfactory;
};

geometry_msgs_gencppNMLMessageFactory::geometry_msgs_gencppNMLMessageFactory()
{
    name("geometry_msgs_gencpp");
    // use constructor to register data types
    geometry_msgs::registerLibrary();
}

geometry_msgs_gencppNMLMessageFactory::~geometry_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR geometry_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return geometry_msgs_gencpp_format;
}

int geometry_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void geometry_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(Accel::ID);
    info.name(Accel::DATA_TYPE_FULL_NAME);
    info.hashKey(Accel::DATA_VERSION);
    info.md5Key(Accel::VERSION_MD5);
    info.xmlSource(Accel::XML_SOURCE);
    info.flat(Accel::dataTypeFlat());
    ids.push_back(info);

    info.id(AccelStamped::ID);
    info.name(AccelStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(AccelStamped::DATA_VERSION);
    info.md5Key(AccelStamped::VERSION_MD5);
    info.xmlSource(AccelStamped::XML_SOURCE);
    info.flat(AccelStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(AccelWithCovariance::ID);
    info.name(AccelWithCovariance::DATA_TYPE_FULL_NAME);
    info.hashKey(AccelWithCovariance::DATA_VERSION);
    info.md5Key(AccelWithCovariance::VERSION_MD5);
    info.xmlSource(AccelWithCovariance::XML_SOURCE);
    info.flat(AccelWithCovariance::dataTypeFlat());
    ids.push_back(info);

    info.id(AccelWithCovarianceStamped::ID);
    info.name(AccelWithCovarianceStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(AccelWithCovarianceStamped::DATA_VERSION);
    info.md5Key(AccelWithCovarianceStamped::VERSION_MD5);
    info.xmlSource(AccelWithCovarianceStamped::XML_SOURCE);
    info.flat(AccelWithCovarianceStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Inertia::ID);
    info.name(Inertia::DATA_TYPE_FULL_NAME);
    info.hashKey(Inertia::DATA_VERSION);
    info.md5Key(Inertia::VERSION_MD5);
    info.xmlSource(Inertia::XML_SOURCE);
    info.flat(Inertia::dataTypeFlat());
    ids.push_back(info);

    info.id(InertiaStamped::ID);
    info.name(InertiaStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(InertiaStamped::DATA_VERSION);
    info.md5Key(InertiaStamped::VERSION_MD5);
    info.xmlSource(InertiaStamped::XML_SOURCE);
    info.flat(InertiaStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Point::ID);
    info.name(Point::DATA_TYPE_FULL_NAME);
    info.hashKey(Point::DATA_VERSION);
    info.md5Key(Point::VERSION_MD5);
    info.xmlSource(Point::XML_SOURCE);
    info.flat(Point::dataTypeFlat());
    ids.push_back(info);

    info.id(Point32::ID);
    info.name(Point32::DATA_TYPE_FULL_NAME);
    info.hashKey(Point32::DATA_VERSION);
    info.md5Key(Point32::VERSION_MD5);
    info.xmlSource(Point32::XML_SOURCE);
    info.flat(Point32::dataTypeFlat());
    ids.push_back(info);

    info.id(PointStamped::ID);
    info.name(PointStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PointStamped::DATA_VERSION);
    info.md5Key(PointStamped::VERSION_MD5);
    info.xmlSource(PointStamped::XML_SOURCE);
    info.flat(PointStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Polygon::ID);
    info.name(Polygon::DATA_TYPE_FULL_NAME);
    info.hashKey(Polygon::DATA_VERSION);
    info.md5Key(Polygon::VERSION_MD5);
    info.xmlSource(Polygon::XML_SOURCE);
    info.flat(Polygon::dataTypeFlat());
    ids.push_back(info);

    info.id(PolygonStamped::ID);
    info.name(PolygonStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PolygonStamped::DATA_VERSION);
    info.md5Key(PolygonStamped::VERSION_MD5);
    info.xmlSource(PolygonStamped::XML_SOURCE);
    info.flat(PolygonStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Pose::ID);
    info.name(Pose::DATA_TYPE_FULL_NAME);
    info.hashKey(Pose::DATA_VERSION);
    info.md5Key(Pose::VERSION_MD5);
    info.xmlSource(Pose::XML_SOURCE);
    info.flat(Pose::dataTypeFlat());
    ids.push_back(info);

    info.id(Pose2D::ID);
    info.name(Pose2D::DATA_TYPE_FULL_NAME);
    info.hashKey(Pose2D::DATA_VERSION);
    info.md5Key(Pose2D::VERSION_MD5);
    info.xmlSource(Pose2D::XML_SOURCE);
    info.flat(Pose2D::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseArray::ID);
    info.name(PoseArray::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseArray::DATA_VERSION);
    info.md5Key(PoseArray::VERSION_MD5);
    info.xmlSource(PoseArray::XML_SOURCE);
    info.flat(PoseArray::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseStamped::ID);
    info.name(PoseStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseStamped::DATA_VERSION);
    info.md5Key(PoseStamped::VERSION_MD5);
    info.xmlSource(PoseStamped::XML_SOURCE);
    info.flat(PoseStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseWithCovariance::ID);
    info.name(PoseWithCovariance::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseWithCovariance::DATA_VERSION);
    info.md5Key(PoseWithCovariance::VERSION_MD5);
    info.xmlSource(PoseWithCovariance::XML_SOURCE);
    info.flat(PoseWithCovariance::dataTypeFlat());
    ids.push_back(info);

    info.id(PoseWithCovarianceStamped::ID);
    info.name(PoseWithCovarianceStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(PoseWithCovarianceStamped::DATA_VERSION);
    info.md5Key(PoseWithCovarianceStamped::VERSION_MD5);
    info.xmlSource(PoseWithCovarianceStamped::XML_SOURCE);
    info.flat(PoseWithCovarianceStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Quaternion::ID);
    info.name(Quaternion::DATA_TYPE_FULL_NAME);
    info.hashKey(Quaternion::DATA_VERSION);
    info.md5Key(Quaternion::VERSION_MD5);
    info.xmlSource(Quaternion::XML_SOURCE);
    info.flat(Quaternion::dataTypeFlat());
    ids.push_back(info);

    info.id(QuaternionStamped::ID);
    info.name(QuaternionStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(QuaternionStamped::DATA_VERSION);
    info.md5Key(QuaternionStamped::VERSION_MD5);
    info.xmlSource(QuaternionStamped::XML_SOURCE);
    info.flat(QuaternionStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Transform::ID);
    info.name(Transform::DATA_TYPE_FULL_NAME);
    info.hashKey(Transform::DATA_VERSION);
    info.md5Key(Transform::VERSION_MD5);
    info.xmlSource(Transform::XML_SOURCE);
    info.flat(Transform::dataTypeFlat());
    ids.push_back(info);

    info.id(TransformStamped::ID);
    info.name(TransformStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(TransformStamped::DATA_VERSION);
    info.md5Key(TransformStamped::VERSION_MD5);
    info.xmlSource(TransformStamped::XML_SOURCE);
    info.flat(TransformStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Twist::ID);
    info.name(Twist::DATA_TYPE_FULL_NAME);
    info.hashKey(Twist::DATA_VERSION);
    info.md5Key(Twist::VERSION_MD5);
    info.xmlSource(Twist::XML_SOURCE);
    info.flat(Twist::dataTypeFlat());
    ids.push_back(info);

    info.id(TwistStamped::ID);
    info.name(TwistStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(TwistStamped::DATA_VERSION);
    info.md5Key(TwistStamped::VERSION_MD5);
    info.xmlSource(TwistStamped::XML_SOURCE);
    info.flat(TwistStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(TwistWithCovariance::ID);
    info.name(TwistWithCovariance::DATA_TYPE_FULL_NAME);
    info.hashKey(TwistWithCovariance::DATA_VERSION);
    info.md5Key(TwistWithCovariance::VERSION_MD5);
    info.xmlSource(TwistWithCovariance::XML_SOURCE);
    info.flat(TwistWithCovariance::dataTypeFlat());
    ids.push_back(info);

    info.id(TwistWithCovarianceStamped::ID);
    info.name(TwistWithCovarianceStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(TwistWithCovarianceStamped::DATA_VERSION);
    info.md5Key(TwistWithCovarianceStamped::VERSION_MD5);
    info.xmlSource(TwistWithCovarianceStamped::XML_SOURCE);
    info.flat(TwistWithCovarianceStamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Vector3::ID);
    info.name(Vector3::DATA_TYPE_FULL_NAME);
    info.hashKey(Vector3::DATA_VERSION);
    info.md5Key(Vector3::VERSION_MD5);
    info.xmlSource(Vector3::XML_SOURCE);
    info.flat(Vector3::dataTypeFlat());
    ids.push_back(info);

    info.id(Vector3Stamped::ID);
    info.name(Vector3Stamped::DATA_TYPE_FULL_NAME);
    info.hashKey(Vector3Stamped::DATA_VERSION);
    info.md5Key(Vector3Stamped::VERSION_MD5);
    info.xmlSource(Vector3Stamped::XML_SOURCE);
    info.flat(Vector3Stamped::dataTypeFlat());
    ids.push_back(info);

    info.id(Wrench::ID);
    info.name(Wrench::DATA_TYPE_FULL_NAME);
    info.hashKey(Wrench::DATA_VERSION);
    info.md5Key(Wrench::VERSION_MD5);
    info.xmlSource(Wrench::XML_SOURCE);
    info.flat(Wrench::dataTypeFlat());
    ids.push_back(info);

    info.id(WrenchStamped::ID);
    info.name(WrenchStamped::DATA_TYPE_FULL_NAME);
    info.hashKey(WrenchStamped::DATA_VERSION);
    info.md5Key(WrenchStamped::VERSION_MD5);
    info.xmlSource(WrenchStamped::XML_SOURCE);
    info.flat(WrenchStamped::dataTypeFlat());
    ids.push_back(info);

}

int geometry_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case Accel::ID:
        {
            //AccelNML * newmsg = new AccelNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AccelNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AccelStamped::ID:
        {
            //AccelStampedNML * newmsg = new AccelStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AccelStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AccelWithCovariance::ID:
        {
            //AccelWithCovarianceNML * newmsg = new AccelWithCovarianceNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AccelWithCovarianceNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case AccelWithCovarianceStamped::ID:
        {
            //AccelWithCovarianceStampedNML * newmsg = new AccelWithCovarianceStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new AccelWithCovarianceStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Inertia::ID:
        {
            //InertiaNML * newmsg = new InertiaNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new InertiaNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case InertiaStamped::ID:
        {
            //InertiaStampedNML * newmsg = new InertiaStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new InertiaStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Point::ID:
        {
            //PointNML * newmsg = new PointNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Point32::ID:
        {
            //Point32NML * newmsg = new Point32NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Point32NML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointStamped::ID:
        {
            //PointStampedNML * newmsg = new PointStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Polygon::ID:
        {
            //PolygonNML * newmsg = new PolygonNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PolygonNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PolygonStamped::ID:
        {
            //PolygonStampedNML * newmsg = new PolygonStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PolygonStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Pose::ID:
        {
            //PoseNML * newmsg = new PoseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PoseNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Pose2D::ID:
        {
            //Pose2DNML * newmsg = new Pose2DNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Pose2DNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PoseArray::ID:
        {
            //PoseArrayNML * newmsg = new PoseArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PoseArrayNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PoseStamped::ID:
        {
            //PoseStampedNML * newmsg = new PoseStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PoseStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PoseWithCovariance::ID:
        {
            //PoseWithCovarianceNML * newmsg = new PoseWithCovarianceNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PoseWithCovarianceNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PoseWithCovarianceStamped::ID:
        {
            //PoseWithCovarianceStampedNML * newmsg = new PoseWithCovarianceStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PoseWithCovarianceStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Quaternion::ID:
        {
            //QuaternionNML * newmsg = new QuaternionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QuaternionNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QuaternionStamped::ID:
        {
            //QuaternionStampedNML * newmsg = new QuaternionStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QuaternionStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Transform::ID:
        {
            //TransformNML * newmsg = new TransformNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TransformNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TransformStamped::ID:
        {
            //TransformStampedNML * newmsg = new TransformStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TransformStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Twist::ID:
        {
            //TwistNML * newmsg = new TwistNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwistNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwistStamped::ID:
        {
            //TwistStampedNML * newmsg = new TwistStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwistStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwistWithCovariance::ID:
        {
            //TwistWithCovarianceNML * newmsg = new TwistWithCovarianceNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwistWithCovarianceNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TwistWithCovarianceStamped::ID:
        {
            //TwistWithCovarianceStampedNML * newmsg = new TwistWithCovarianceStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TwistWithCovarianceStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Vector3::ID:
        {
            //Vector3NML * newmsg = new Vector3NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Vector3NML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Vector3Stamped::ID:
        {
            //Vector3StampedNML * newmsg = new Vector3StampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Vector3StampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Wrench::ID:
        {
            //WrenchNML * newmsg = new WrenchNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new WrenchNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case WrenchStamped::ID:
        {
            //WrenchStampedNML * newmsg = new WrenchStampedNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new WrenchStampedNML(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case Accel::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Accel>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AccelStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AccelStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AccelWithCovariance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AccelWithCovariance>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case AccelWithCovarianceStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<AccelWithCovarianceStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Inertia::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Inertia>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case InertiaStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<InertiaStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Point::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Point>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Point32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Point32>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Polygon::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Polygon>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PolygonStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PolygonStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Pose::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Pose>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Pose2D::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Pose2D>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseArray>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseWithCovariance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseWithCovariance>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PoseWithCovarianceStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PoseWithCovarianceStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Quaternion::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Quaternion>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QuaternionStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QuaternionStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Transform::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Transform>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TransformStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TransformStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Twist::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Twist>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwistStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwistStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwistWithCovariance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwistWithCovariance>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TwistWithCovarianceStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TwistWithCovarianceStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Vector3::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Vector3>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Vector3Stamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Vector3Stamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Wrench::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Wrench>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case WrenchStamped::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<WrenchStamped>(),std::bind(&geometry_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case Accel::ID:
            {
                AccelNML * tempmsg = static_cast<AccelNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AccelStamped::ID:
            {
                AccelStampedNML * tempmsg = static_cast<AccelStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AccelWithCovariance::ID:
            {
                AccelWithCovarianceNML * tempmsg = static_cast<AccelWithCovarianceNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case AccelWithCovarianceStamped::ID:
            {
                AccelWithCovarianceStampedNML * tempmsg = static_cast<AccelWithCovarianceStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Inertia::ID:
            {
                InertiaNML * tempmsg = static_cast<InertiaNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case InertiaStamped::ID:
            {
                InertiaStampedNML * tempmsg = static_cast<InertiaStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Point::ID:
            {
                PointNML * tempmsg = static_cast<PointNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Point32::ID:
            {
                Point32NML * tempmsg = static_cast<Point32NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointStamped::ID:
            {
                PointStampedNML * tempmsg = static_cast<PointStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Polygon::ID:
            {
                PolygonNML * tempmsg = static_cast<PolygonNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PolygonStamped::ID:
            {
                PolygonStampedNML * tempmsg = static_cast<PolygonStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Pose::ID:
            {
                PoseNML * tempmsg = static_cast<PoseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Pose2D::ID:
            {
                Pose2DNML * tempmsg = static_cast<Pose2DNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PoseArray::ID:
            {
                PoseArrayNML * tempmsg = static_cast<PoseArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PoseStamped::ID:
            {
                PoseStampedNML * tempmsg = static_cast<PoseStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PoseWithCovariance::ID:
            {
                PoseWithCovarianceNML * tempmsg = static_cast<PoseWithCovarianceNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PoseWithCovarianceStamped::ID:
            {
                PoseWithCovarianceStampedNML * tempmsg = static_cast<PoseWithCovarianceStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Quaternion::ID:
            {
                QuaternionNML * tempmsg = static_cast<QuaternionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QuaternionStamped::ID:
            {
                QuaternionStampedNML * tempmsg = static_cast<QuaternionStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Transform::ID:
            {
                TransformNML * tempmsg = static_cast<TransformNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TransformStamped::ID:
            {
                TransformStampedNML * tempmsg = static_cast<TransformStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Twist::ID:
            {
                TwistNML * tempmsg = static_cast<TwistNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwistStamped::ID:
            {
                TwistStampedNML * tempmsg = static_cast<TwistStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwistWithCovariance::ID:
            {
                TwistWithCovarianceNML * tempmsg = static_cast<TwistWithCovarianceNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TwistWithCovarianceStamped::ID:
            {
                TwistWithCovarianceStampedNML * tempmsg = static_cast<TwistWithCovarianceStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Vector3::ID:
            {
                Vector3NML * tempmsg = static_cast<Vector3NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Vector3Stamped::ID:
            {
                Vector3StampedNML * tempmsg = static_cast<Vector3StampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Wrench::ID:
            {
                WrenchNML * tempmsg = static_cast<WrenchNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case WrenchStamped::ID:
            {
                WrenchStampedNML * tempmsg = static_cast<WrenchStampedNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case Accel::ID:
            {
                AccelNML & tempDst = static_cast<AccelNML&>(dst);
                Message<Accel > & tempSrc = static_cast<Message<Accel>&>(src);

                if (tempSrc.version() != Accel::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Accel: " << __FILE__ << " expected: " 
                             << Accel::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Accel: " << __FILE__ << " expected: " 
                         << Accel::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AccelStamped::ID:
            {
                AccelStampedNML & tempDst = static_cast<AccelStampedNML&>(dst);
                Message<AccelStamped > & tempSrc = static_cast<Message<AccelStamped>&>(src);

                if (tempSrc.version() != AccelStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AccelStamped: " << __FILE__ << " expected: " 
                             << AccelStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AccelStamped: " << __FILE__ << " expected: " 
                         << AccelStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AccelWithCovariance::ID:
            {
                AccelWithCovarianceNML & tempDst = static_cast<AccelWithCovarianceNML&>(dst);
                Message<AccelWithCovariance > & tempSrc = static_cast<Message<AccelWithCovariance>&>(src);

                if (tempSrc.version() != AccelWithCovariance::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AccelWithCovariance: " << __FILE__ << " expected: " 
                             << AccelWithCovariance::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AccelWithCovariance: " << __FILE__ << " expected: " 
                         << AccelWithCovariance::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case AccelWithCovarianceStamped::ID:
            {
                AccelWithCovarianceStampedNML & tempDst = static_cast<AccelWithCovarianceStampedNML&>(dst);
                Message<AccelWithCovarianceStamped > & tempSrc = static_cast<Message<AccelWithCovarianceStamped>&>(src);

                if (tempSrc.version() != AccelWithCovarianceStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of AccelWithCovarianceStamped: " << __FILE__ << " expected: " 
                             << AccelWithCovarianceStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of AccelWithCovarianceStamped: " << __FILE__ << " expected: " 
                         << AccelWithCovarianceStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Inertia::ID:
            {
                InertiaNML & tempDst = static_cast<InertiaNML&>(dst);
                Message<Inertia > & tempSrc = static_cast<Message<Inertia>&>(src);

                if (tempSrc.version() != Inertia::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Inertia: " << __FILE__ << " expected: " 
                             << Inertia::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Inertia: " << __FILE__ << " expected: " 
                         << Inertia::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case InertiaStamped::ID:
            {
                InertiaStampedNML & tempDst = static_cast<InertiaStampedNML&>(dst);
                Message<InertiaStamped > & tempSrc = static_cast<Message<InertiaStamped>&>(src);

                if (tempSrc.version() != InertiaStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of InertiaStamped: " << __FILE__ << " expected: " 
                             << InertiaStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of InertiaStamped: " << __FILE__ << " expected: " 
                         << InertiaStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Point::ID:
            {
                PointNML & tempDst = static_cast<PointNML&>(dst);
                Message<Point > & tempSrc = static_cast<Message<Point>&>(src);

                if (tempSrc.version() != Point::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Point: " << __FILE__ << " expected: " 
                             << Point::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Point: " << __FILE__ << " expected: " 
                         << Point::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Point32::ID:
            {
                Point32NML & tempDst = static_cast<Point32NML&>(dst);
                Message<Point32 > & tempSrc = static_cast<Message<Point32>&>(src);

                if (tempSrc.version() != Point32::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Point32: " << __FILE__ << " expected: " 
                             << Point32::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Point32: " << __FILE__ << " expected: " 
                         << Point32::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointStamped::ID:
            {
                PointStampedNML & tempDst = static_cast<PointStampedNML&>(dst);
                Message<PointStamped > & tempSrc = static_cast<Message<PointStamped>&>(src);

                if (tempSrc.version() != PointStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointStamped: " << __FILE__ << " expected: " 
                             << PointStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointStamped: " << __FILE__ << " expected: " 
                         << PointStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Polygon::ID:
            {
                PolygonNML & tempDst = static_cast<PolygonNML&>(dst);
                Message<Polygon > & tempSrc = static_cast<Message<Polygon>&>(src);

                if (tempSrc.version() != Polygon::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Polygon: " << __FILE__ << " expected: " 
                             << Polygon::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Polygon: " << __FILE__ << " expected: " 
                         << Polygon::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PolygonStamped::ID:
            {
                PolygonStampedNML & tempDst = static_cast<PolygonStampedNML&>(dst);
                Message<PolygonStamped > & tempSrc = static_cast<Message<PolygonStamped>&>(src);

                if (tempSrc.version() != PolygonStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PolygonStamped: " << __FILE__ << " expected: " 
                             << PolygonStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PolygonStamped: " << __FILE__ << " expected: " 
                         << PolygonStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Pose::ID:
            {
                PoseNML & tempDst = static_cast<PoseNML&>(dst);
                Message<Pose > & tempSrc = static_cast<Message<Pose>&>(src);

                if (tempSrc.version() != Pose::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Pose: " << __FILE__ << " expected: " 
                             << Pose::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Pose: " << __FILE__ << " expected: " 
                         << Pose::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Pose2D::ID:
            {
                Pose2DNML & tempDst = static_cast<Pose2DNML&>(dst);
                Message<Pose2D > & tempSrc = static_cast<Message<Pose2D>&>(src);

                if (tempSrc.version() != Pose2D::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Pose2D: " << __FILE__ << " expected: " 
                             << Pose2D::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Pose2D: " << __FILE__ << " expected: " 
                         << Pose2D::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PoseArray::ID:
            {
                PoseArrayNML & tempDst = static_cast<PoseArrayNML&>(dst);
                Message<PoseArray > & tempSrc = static_cast<Message<PoseArray>&>(src);

                if (tempSrc.version() != PoseArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PoseArray: " << __FILE__ << " expected: " 
                             << PoseArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PoseArray: " << __FILE__ << " expected: " 
                         << PoseArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PoseStamped::ID:
            {
                PoseStampedNML & tempDst = static_cast<PoseStampedNML&>(dst);
                Message<PoseStamped > & tempSrc = static_cast<Message<PoseStamped>&>(src);

                if (tempSrc.version() != PoseStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PoseStamped: " << __FILE__ << " expected: " 
                             << PoseStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PoseStamped: " << __FILE__ << " expected: " 
                         << PoseStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PoseWithCovariance::ID:
            {
                PoseWithCovarianceNML & tempDst = static_cast<PoseWithCovarianceNML&>(dst);
                Message<PoseWithCovariance > & tempSrc = static_cast<Message<PoseWithCovariance>&>(src);

                if (tempSrc.version() != PoseWithCovariance::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PoseWithCovariance: " << __FILE__ << " expected: " 
                             << PoseWithCovariance::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PoseWithCovariance: " << __FILE__ << " expected: " 
                         << PoseWithCovariance::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PoseWithCovarianceStamped::ID:
            {
                PoseWithCovarianceStampedNML & tempDst = static_cast<PoseWithCovarianceStampedNML&>(dst);
                Message<PoseWithCovarianceStamped > & tempSrc = static_cast<Message<PoseWithCovarianceStamped>&>(src);

                if (tempSrc.version() != PoseWithCovarianceStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PoseWithCovarianceStamped: " << __FILE__ << " expected: " 
                             << PoseWithCovarianceStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PoseWithCovarianceStamped: " << __FILE__ << " expected: " 
                         << PoseWithCovarianceStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Quaternion::ID:
            {
                QuaternionNML & tempDst = static_cast<QuaternionNML&>(dst);
                Message<Quaternion > & tempSrc = static_cast<Message<Quaternion>&>(src);

                if (tempSrc.version() != Quaternion::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Quaternion: " << __FILE__ << " expected: " 
                             << Quaternion::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Quaternion: " << __FILE__ << " expected: " 
                         << Quaternion::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QuaternionStamped::ID:
            {
                QuaternionStampedNML & tempDst = static_cast<QuaternionStampedNML&>(dst);
                Message<QuaternionStamped > & tempSrc = static_cast<Message<QuaternionStamped>&>(src);

                if (tempSrc.version() != QuaternionStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QuaternionStamped: " << __FILE__ << " expected: " 
                             << QuaternionStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QuaternionStamped: " << __FILE__ << " expected: " 
                         << QuaternionStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Transform::ID:
            {
                TransformNML & tempDst = static_cast<TransformNML&>(dst);
                Message<Transform > & tempSrc = static_cast<Message<Transform>&>(src);

                if (tempSrc.version() != Transform::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Transform: " << __FILE__ << " expected: " 
                             << Transform::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Transform: " << __FILE__ << " expected: " 
                         << Transform::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TransformStamped::ID:
            {
                TransformStampedNML & tempDst = static_cast<TransformStampedNML&>(dst);
                Message<TransformStamped > & tempSrc = static_cast<Message<TransformStamped>&>(src);

                if (tempSrc.version() != TransformStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TransformStamped: " << __FILE__ << " expected: " 
                             << TransformStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TransformStamped: " << __FILE__ << " expected: " 
                         << TransformStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Twist::ID:
            {
                TwistNML & tempDst = static_cast<TwistNML&>(dst);
                Message<Twist > & tempSrc = static_cast<Message<Twist>&>(src);

                if (tempSrc.version() != Twist::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Twist: " << __FILE__ << " expected: " 
                             << Twist::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Twist: " << __FILE__ << " expected: " 
                         << Twist::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwistStamped::ID:
            {
                TwistStampedNML & tempDst = static_cast<TwistStampedNML&>(dst);
                Message<TwistStamped > & tempSrc = static_cast<Message<TwistStamped>&>(src);

                if (tempSrc.version() != TwistStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwistStamped: " << __FILE__ << " expected: " 
                             << TwistStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwistStamped: " << __FILE__ << " expected: " 
                         << TwistStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwistWithCovariance::ID:
            {
                TwistWithCovarianceNML & tempDst = static_cast<TwistWithCovarianceNML&>(dst);
                Message<TwistWithCovariance > & tempSrc = static_cast<Message<TwistWithCovariance>&>(src);

                if (tempSrc.version() != TwistWithCovariance::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwistWithCovariance: " << __FILE__ << " expected: " 
                             << TwistWithCovariance::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwistWithCovariance: " << __FILE__ << " expected: " 
                         << TwistWithCovariance::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TwistWithCovarianceStamped::ID:
            {
                TwistWithCovarianceStampedNML & tempDst = static_cast<TwistWithCovarianceStampedNML&>(dst);
                Message<TwistWithCovarianceStamped > & tempSrc = static_cast<Message<TwistWithCovarianceStamped>&>(src);

                if (tempSrc.version() != TwistWithCovarianceStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TwistWithCovarianceStamped: " << __FILE__ << " expected: " 
                             << TwistWithCovarianceStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TwistWithCovarianceStamped: " << __FILE__ << " expected: " 
                         << TwistWithCovarianceStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Vector3::ID:
            {
                Vector3NML & tempDst = static_cast<Vector3NML&>(dst);
                Message<Vector3 > & tempSrc = static_cast<Message<Vector3>&>(src);

                if (tempSrc.version() != Vector3::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Vector3: " << __FILE__ << " expected: " 
                             << Vector3::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Vector3: " << __FILE__ << " expected: " 
                         << Vector3::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Vector3Stamped::ID:
            {
                Vector3StampedNML & tempDst = static_cast<Vector3StampedNML&>(dst);
                Message<Vector3Stamped > & tempSrc = static_cast<Message<Vector3Stamped>&>(src);

                if (tempSrc.version() != Vector3Stamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Vector3Stamped: " << __FILE__ << " expected: " 
                             << Vector3Stamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Vector3Stamped: " << __FILE__ << " expected: " 
                         << Vector3Stamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Wrench::ID:
            {
                WrenchNML & tempDst = static_cast<WrenchNML&>(dst);
                Message<Wrench > & tempSrc = static_cast<Message<Wrench>&>(src);

                if (tempSrc.version() != Wrench::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Wrench: " << __FILE__ << " expected: " 
                             << Wrench::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Wrench: " << __FILE__ << " expected: " 
                         << Wrench::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case WrenchStamped::ID:
            {
                WrenchStampedNML & tempDst = static_cast<WrenchStampedNML&>(dst);
                Message<WrenchStamped > & tempSrc = static_cast<Message<WrenchStamped>&>(src);

                if (tempSrc.version() != WrenchStamped::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of WrenchStamped: " << __FILE__ << " expected: " 
                             << WrenchStamped::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of WrenchStamped: " << __FILE__ << " expected: " 
                         << WrenchStamped::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case Accel::ID:
            {
                AccelNML & tempSrc = static_cast<AccelNML&>(src);
                Message<Accel > & tempDst = static_cast<Message<Accel>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Accel::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AccelStamped::ID:
            {
                AccelStampedNML & tempSrc = static_cast<AccelStampedNML&>(src);
                Message<AccelStamped > & tempDst = static_cast<Message<AccelStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AccelStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AccelWithCovariance::ID:
            {
                AccelWithCovarianceNML & tempSrc = static_cast<AccelWithCovarianceNML&>(src);
                Message<AccelWithCovariance > & tempDst = static_cast<Message<AccelWithCovariance>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AccelWithCovariance::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case AccelWithCovarianceStamped::ID:
            {
                AccelWithCovarianceStampedNML & tempSrc = static_cast<AccelWithCovarianceStampedNML&>(src);
                Message<AccelWithCovarianceStamped > & tempDst = static_cast<Message<AccelWithCovarianceStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (AccelWithCovarianceStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Inertia::ID:
            {
                InertiaNML & tempSrc = static_cast<InertiaNML&>(src);
                Message<Inertia > & tempDst = static_cast<Message<Inertia>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Inertia::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case InertiaStamped::ID:
            {
                InertiaStampedNML & tempSrc = static_cast<InertiaStampedNML&>(src);
                Message<InertiaStamped > & tempDst = static_cast<Message<InertiaStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (InertiaStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Point::ID:
            {
                PointNML & tempSrc = static_cast<PointNML&>(src);
                Message<Point > & tempDst = static_cast<Message<Point>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Point::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Point32::ID:
            {
                Point32NML & tempSrc = static_cast<Point32NML&>(src);
                Message<Point32 > & tempDst = static_cast<Message<Point32>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Point32::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointStamped::ID:
            {
                PointStampedNML & tempSrc = static_cast<PointStampedNML&>(src);
                Message<PointStamped > & tempDst = static_cast<Message<PointStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Polygon::ID:
            {
                PolygonNML & tempSrc = static_cast<PolygonNML&>(src);
                Message<Polygon > & tempDst = static_cast<Message<Polygon>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Polygon::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PolygonStamped::ID:
            {
                PolygonStampedNML & tempSrc = static_cast<PolygonStampedNML&>(src);
                Message<PolygonStamped > & tempDst = static_cast<Message<PolygonStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PolygonStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Pose::ID:
            {
                PoseNML & tempSrc = static_cast<PoseNML&>(src);
                Message<Pose > & tempDst = static_cast<Message<Pose>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Pose::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Pose2D::ID:
            {
                Pose2DNML & tempSrc = static_cast<Pose2DNML&>(src);
                Message<Pose2D > & tempDst = static_cast<Message<Pose2D>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Pose2D::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PoseArray::ID:
            {
                PoseArrayNML & tempSrc = static_cast<PoseArrayNML&>(src);
                Message<PoseArray > & tempDst = static_cast<Message<PoseArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PoseArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PoseStamped::ID:
            {
                PoseStampedNML & tempSrc = static_cast<PoseStampedNML&>(src);
                Message<PoseStamped > & tempDst = static_cast<Message<PoseStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PoseStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PoseWithCovariance::ID:
            {
                PoseWithCovarianceNML & tempSrc = static_cast<PoseWithCovarianceNML&>(src);
                Message<PoseWithCovariance > & tempDst = static_cast<Message<PoseWithCovariance>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PoseWithCovariance::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PoseWithCovarianceStamped::ID:
            {
                PoseWithCovarianceStampedNML & tempSrc = static_cast<PoseWithCovarianceStampedNML&>(src);
                Message<PoseWithCovarianceStamped > & tempDst = static_cast<Message<PoseWithCovarianceStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PoseWithCovarianceStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Quaternion::ID:
            {
                QuaternionNML & tempSrc = static_cast<QuaternionNML&>(src);
                Message<Quaternion > & tempDst = static_cast<Message<Quaternion>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Quaternion::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QuaternionStamped::ID:
            {
                QuaternionStampedNML & tempSrc = static_cast<QuaternionStampedNML&>(src);
                Message<QuaternionStamped > & tempDst = static_cast<Message<QuaternionStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QuaternionStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Transform::ID:
            {
                TransformNML & tempSrc = static_cast<TransformNML&>(src);
                Message<Transform > & tempDst = static_cast<Message<Transform>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Transform::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TransformStamped::ID:
            {
                TransformStampedNML & tempSrc = static_cast<TransformStampedNML&>(src);
                Message<TransformStamped > & tempDst = static_cast<Message<TransformStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TransformStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Twist::ID:
            {
                TwistNML & tempSrc = static_cast<TwistNML&>(src);
                Message<Twist > & tempDst = static_cast<Message<Twist>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Twist::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwistStamped::ID:
            {
                TwistStampedNML & tempSrc = static_cast<TwistStampedNML&>(src);
                Message<TwistStamped > & tempDst = static_cast<Message<TwistStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwistStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwistWithCovariance::ID:
            {
                TwistWithCovarianceNML & tempSrc = static_cast<TwistWithCovarianceNML&>(src);
                Message<TwistWithCovariance > & tempDst = static_cast<Message<TwistWithCovariance>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwistWithCovariance::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TwistWithCovarianceStamped::ID:
            {
                TwistWithCovarianceStampedNML & tempSrc = static_cast<TwistWithCovarianceStampedNML&>(src);
                Message<TwistWithCovarianceStamped > & tempDst = static_cast<Message<TwistWithCovarianceStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TwistWithCovarianceStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Vector3::ID:
            {
                Vector3NML & tempSrc = static_cast<Vector3NML&>(src);
                Message<Vector3 > & tempDst = static_cast<Message<Vector3>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Vector3::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Vector3Stamped::ID:
            {
                Vector3StampedNML & tempSrc = static_cast<Vector3StampedNML&>(src);
                Message<Vector3Stamped > & tempDst = static_cast<Message<Vector3Stamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Vector3Stamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Wrench::ID:
            {
                WrenchNML & tempSrc = static_cast<WrenchNML&>(src);
                Message<Wrench > & tempDst = static_cast<Message<Wrench>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Wrench::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case WrenchStamped::ID:
            {
                WrenchStampedNML & tempSrc = static_cast<WrenchStampedNML&>(src);
                Message<WrenchStamped > & tempDst = static_cast<Message<WrenchStamped>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (WrenchStamped::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case Accel::ID:
        {
            // only need to construct if data type is not flat
            if (Accel::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Accel at %p\n",buffer);
                AccelNML * p = static_cast<AccelNML*>(buffer);
                // construct the type at pointer p
                new (p) AccelNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Accel at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AccelStamped::ID:
        {
            // only need to construct if data type is not flat
            if (AccelStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AccelStamped at %p\n",buffer);
                AccelStampedNML * p = static_cast<AccelStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) AccelStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AccelStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AccelWithCovariance::ID:
        {
            // only need to construct if data type is not flat
            if (AccelWithCovariance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AccelWithCovariance at %p\n",buffer);
                AccelWithCovarianceNML * p = static_cast<AccelWithCovarianceNML*>(buffer);
                // construct the type at pointer p
                new (p) AccelWithCovarianceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AccelWithCovariance at %p,, is flat\n",buffer);
            }
            break;
        } 
        case AccelWithCovarianceStamped::ID:
        {
            // only need to construct if data type is not flat
            if (AccelWithCovarianceStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing AccelWithCovarianceStamped at %p\n",buffer);
                AccelWithCovarianceStampedNML * p = static_cast<AccelWithCovarianceStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) AccelWithCovarianceStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing AccelWithCovarianceStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Inertia::ID:
        {
            // only need to construct if data type is not flat
            if (Inertia::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Inertia at %p\n",buffer);
                InertiaNML * p = static_cast<InertiaNML*>(buffer);
                // construct the type at pointer p
                new (p) InertiaNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Inertia at %p,, is flat\n",buffer);
            }
            break;
        } 
        case InertiaStamped::ID:
        {
            // only need to construct if data type is not flat
            if (InertiaStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing InertiaStamped at %p\n",buffer);
                InertiaStampedNML * p = static_cast<InertiaStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) InertiaStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing InertiaStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Point::ID:
        {
            // only need to construct if data type is not flat
            if (Point::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Point at %p\n",buffer);
                PointNML * p = static_cast<PointNML*>(buffer);
                // construct the type at pointer p
                new (p) PointNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Point at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Point32::ID:
        {
            // only need to construct if data type is not flat
            if (Point32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Point32 at %p\n",buffer);
                Point32NML * p = static_cast<Point32NML*>(buffer);
                // construct the type at pointer p
                new (p) Point32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Point32 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointStamped::ID:
        {
            // only need to construct if data type is not flat
            if (PointStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointStamped at %p\n",buffer);
                PointStampedNML * p = static_cast<PointStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) PointStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Polygon::ID:
        {
            // only need to construct if data type is not flat
            if (Polygon::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Polygon at %p\n",buffer);
                PolygonNML * p = static_cast<PolygonNML*>(buffer);
                // construct the type at pointer p
                new (p) PolygonNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Polygon at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PolygonStamped::ID:
        {
            // only need to construct if data type is not flat
            if (PolygonStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PolygonStamped at %p\n",buffer);
                PolygonStampedNML * p = static_cast<PolygonStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) PolygonStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PolygonStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Pose::ID:
        {
            // only need to construct if data type is not flat
            if (Pose::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Pose at %p\n",buffer);
                PoseNML * p = static_cast<PoseNML*>(buffer);
                // construct the type at pointer p
                new (p) PoseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Pose at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Pose2D::ID:
        {
            // only need to construct if data type is not flat
            if (Pose2D::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Pose2D at %p\n",buffer);
                Pose2DNML * p = static_cast<Pose2DNML*>(buffer);
                // construct the type at pointer p
                new (p) Pose2DNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Pose2D at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PoseArray::ID:
        {
            // only need to construct if data type is not flat
            if (PoseArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PoseArray at %p\n",buffer);
                PoseArrayNML * p = static_cast<PoseArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) PoseArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PoseArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PoseStamped::ID:
        {
            // only need to construct if data type is not flat
            if (PoseStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PoseStamped at %p\n",buffer);
                PoseStampedNML * p = static_cast<PoseStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) PoseStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PoseStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PoseWithCovariance::ID:
        {
            // only need to construct if data type is not flat
            if (PoseWithCovariance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PoseWithCovariance at %p\n",buffer);
                PoseWithCovarianceNML * p = static_cast<PoseWithCovarianceNML*>(buffer);
                // construct the type at pointer p
                new (p) PoseWithCovarianceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PoseWithCovariance at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PoseWithCovarianceStamped::ID:
        {
            // only need to construct if data type is not flat
            if (PoseWithCovarianceStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PoseWithCovarianceStamped at %p\n",buffer);
                PoseWithCovarianceStampedNML * p = static_cast<PoseWithCovarianceStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) PoseWithCovarianceStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PoseWithCovarianceStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Quaternion::ID:
        {
            // only need to construct if data type is not flat
            if (Quaternion::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Quaternion at %p\n",buffer);
                QuaternionNML * p = static_cast<QuaternionNML*>(buffer);
                // construct the type at pointer p
                new (p) QuaternionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Quaternion at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QuaternionStamped::ID:
        {
            // only need to construct if data type is not flat
            if (QuaternionStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QuaternionStamped at %p\n",buffer);
                QuaternionStampedNML * p = static_cast<QuaternionStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) QuaternionStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QuaternionStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Transform::ID:
        {
            // only need to construct if data type is not flat
            if (Transform::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Transform at %p\n",buffer);
                TransformNML * p = static_cast<TransformNML*>(buffer);
                // construct the type at pointer p
                new (p) TransformNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Transform at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TransformStamped::ID:
        {
            // only need to construct if data type is not flat
            if (TransformStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TransformStamped at %p\n",buffer);
                TransformStampedNML * p = static_cast<TransformStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) TransformStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TransformStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Twist::ID:
        {
            // only need to construct if data type is not flat
            if (Twist::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Twist at %p\n",buffer);
                TwistNML * p = static_cast<TwistNML*>(buffer);
                // construct the type at pointer p
                new (p) TwistNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Twist at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwistStamped::ID:
        {
            // only need to construct if data type is not flat
            if (TwistStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwistStamped at %p\n",buffer);
                TwistStampedNML * p = static_cast<TwistStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) TwistStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwistStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwistWithCovariance::ID:
        {
            // only need to construct if data type is not flat
            if (TwistWithCovariance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwistWithCovariance at %p\n",buffer);
                TwistWithCovarianceNML * p = static_cast<TwistWithCovarianceNML*>(buffer);
                // construct the type at pointer p
                new (p) TwistWithCovarianceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwistWithCovariance at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TwistWithCovarianceStamped::ID:
        {
            // only need to construct if data type is not flat
            if (TwistWithCovarianceStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TwistWithCovarianceStamped at %p\n",buffer);
                TwistWithCovarianceStampedNML * p = static_cast<TwistWithCovarianceStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) TwistWithCovarianceStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TwistWithCovarianceStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Vector3::ID:
        {
            // only need to construct if data type is not flat
            if (Vector3::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Vector3 at %p\n",buffer);
                Vector3NML * p = static_cast<Vector3NML*>(buffer);
                // construct the type at pointer p
                new (p) Vector3NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Vector3 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Vector3Stamped::ID:
        {
            // only need to construct if data type is not flat
            if (Vector3Stamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Vector3Stamped at %p\n",buffer);
                Vector3StampedNML * p = static_cast<Vector3StampedNML*>(buffer);
                // construct the type at pointer p
                new (p) Vector3StampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Vector3Stamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Wrench::ID:
        {
            // only need to construct if data type is not flat
            if (Wrench::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Wrench at %p\n",buffer);
                WrenchNML * p = static_cast<WrenchNML*>(buffer);
                // construct the type at pointer p
                new (p) WrenchNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Wrench at %p,, is flat\n",buffer);
            }
            break;
        } 
        case WrenchStamped::ID:
        {
            // only need to construct if data type is not flat
            if (WrenchStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing WrenchStamped at %p\n",buffer);
                WrenchStampedNML * p = static_cast<WrenchStampedNML*>(buffer);
                // construct the type at pointer p
                new (p) WrenchStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing WrenchStamped at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int geometry_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case Accel::ID:
        {
            // only need to destruct if data type is not flat
            if (Accel::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Accel at %p\n",buffer);
                AccelNML * p = static_cast<AccelNML*>(buffer);
                p->~AccelNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Accel at %p, is flat\n",buffer);
            }
            break;
        } 
        case AccelStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (AccelStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AccelStamped at %p\n",buffer);
                AccelStampedNML * p = static_cast<AccelStampedNML*>(buffer);
                p->~AccelStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AccelStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case AccelWithCovariance::ID:
        {
            // only need to destruct if data type is not flat
            if (AccelWithCovariance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AccelWithCovariance at %p\n",buffer);
                AccelWithCovarianceNML * p = static_cast<AccelWithCovarianceNML*>(buffer);
                p->~AccelWithCovarianceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AccelWithCovariance at %p, is flat\n",buffer);
            }
            break;
        } 
        case AccelWithCovarianceStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (AccelWithCovarianceStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing AccelWithCovarianceStamped at %p\n",buffer);
                AccelWithCovarianceStampedNML * p = static_cast<AccelWithCovarianceStampedNML*>(buffer);
                p->~AccelWithCovarianceStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction AccelWithCovarianceStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Inertia::ID:
        {
            // only need to destruct if data type is not flat
            if (Inertia::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Inertia at %p\n",buffer);
                InertiaNML * p = static_cast<InertiaNML*>(buffer);
                p->~InertiaNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Inertia at %p, is flat\n",buffer);
            }
            break;
        } 
        case InertiaStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (InertiaStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing InertiaStamped at %p\n",buffer);
                InertiaStampedNML * p = static_cast<InertiaStampedNML*>(buffer);
                p->~InertiaStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction InertiaStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Point::ID:
        {
            // only need to destruct if data type is not flat
            if (Point::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Point at %p\n",buffer);
                PointNML * p = static_cast<PointNML*>(buffer);
                p->~PointNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Point at %p, is flat\n",buffer);
            }
            break;
        } 
        case Point32::ID:
        {
            // only need to destruct if data type is not flat
            if (Point32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Point32 at %p\n",buffer);
                Point32NML * p = static_cast<Point32NML*>(buffer);
                p->~Point32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Point32 at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (PointStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointStamped at %p\n",buffer);
                PointStampedNML * p = static_cast<PointStampedNML*>(buffer);
                p->~PointStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Polygon::ID:
        {
            // only need to destruct if data type is not flat
            if (Polygon::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Polygon at %p\n",buffer);
                PolygonNML * p = static_cast<PolygonNML*>(buffer);
                p->~PolygonNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Polygon at %p, is flat\n",buffer);
            }
            break;
        } 
        case PolygonStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (PolygonStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PolygonStamped at %p\n",buffer);
                PolygonStampedNML * p = static_cast<PolygonStampedNML*>(buffer);
                p->~PolygonStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PolygonStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Pose::ID:
        {
            // only need to destruct if data type is not flat
            if (Pose::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Pose at %p\n",buffer);
                PoseNML * p = static_cast<PoseNML*>(buffer);
                p->~PoseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Pose at %p, is flat\n",buffer);
            }
            break;
        } 
        case Pose2D::ID:
        {
            // only need to destruct if data type is not flat
            if (Pose2D::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Pose2D at %p\n",buffer);
                Pose2DNML * p = static_cast<Pose2DNML*>(buffer);
                p->~Pose2DNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Pose2D at %p, is flat\n",buffer);
            }
            break;
        } 
        case PoseArray::ID:
        {
            // only need to destruct if data type is not flat
            if (PoseArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PoseArray at %p\n",buffer);
                PoseArrayNML * p = static_cast<PoseArrayNML*>(buffer);
                p->~PoseArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PoseArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case PoseStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (PoseStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PoseStamped at %p\n",buffer);
                PoseStampedNML * p = static_cast<PoseStampedNML*>(buffer);
                p->~PoseStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PoseStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case PoseWithCovariance::ID:
        {
            // only need to destruct if data type is not flat
            if (PoseWithCovariance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PoseWithCovariance at %p\n",buffer);
                PoseWithCovarianceNML * p = static_cast<PoseWithCovarianceNML*>(buffer);
                p->~PoseWithCovarianceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PoseWithCovariance at %p, is flat\n",buffer);
            }
            break;
        } 
        case PoseWithCovarianceStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (PoseWithCovarianceStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PoseWithCovarianceStamped at %p\n",buffer);
                PoseWithCovarianceStampedNML * p = static_cast<PoseWithCovarianceStampedNML*>(buffer);
                p->~PoseWithCovarianceStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PoseWithCovarianceStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Quaternion::ID:
        {
            // only need to destruct if data type is not flat
            if (Quaternion::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Quaternion at %p\n",buffer);
                QuaternionNML * p = static_cast<QuaternionNML*>(buffer);
                p->~QuaternionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Quaternion at %p, is flat\n",buffer);
            }
            break;
        } 
        case QuaternionStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (QuaternionStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QuaternionStamped at %p\n",buffer);
                QuaternionStampedNML * p = static_cast<QuaternionStampedNML*>(buffer);
                p->~QuaternionStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QuaternionStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Transform::ID:
        {
            // only need to destruct if data type is not flat
            if (Transform::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Transform at %p\n",buffer);
                TransformNML * p = static_cast<TransformNML*>(buffer);
                p->~TransformNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Transform at %p, is flat\n",buffer);
            }
            break;
        } 
        case TransformStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (TransformStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TransformStamped at %p\n",buffer);
                TransformStampedNML * p = static_cast<TransformStampedNML*>(buffer);
                p->~TransformStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TransformStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Twist::ID:
        {
            // only need to destruct if data type is not flat
            if (Twist::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Twist at %p\n",buffer);
                TwistNML * p = static_cast<TwistNML*>(buffer);
                p->~TwistNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Twist at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwistStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (TwistStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwistStamped at %p\n",buffer);
                TwistStampedNML * p = static_cast<TwistStampedNML*>(buffer);
                p->~TwistStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwistStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwistWithCovariance::ID:
        {
            // only need to destruct if data type is not flat
            if (TwistWithCovariance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwistWithCovariance at %p\n",buffer);
                TwistWithCovarianceNML * p = static_cast<TwistWithCovarianceNML*>(buffer);
                p->~TwistWithCovarianceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwistWithCovariance at %p, is flat\n",buffer);
            }
            break;
        } 
        case TwistWithCovarianceStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (TwistWithCovarianceStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TwistWithCovarianceStamped at %p\n",buffer);
                TwistWithCovarianceStampedNML * p = static_cast<TwistWithCovarianceStampedNML*>(buffer);
                p->~TwistWithCovarianceStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TwistWithCovarianceStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Vector3::ID:
        {
            // only need to destruct if data type is not flat
            if (Vector3::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Vector3 at %p\n",buffer);
                Vector3NML * p = static_cast<Vector3NML*>(buffer);
                p->~Vector3NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Vector3 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Vector3Stamped::ID:
        {
            // only need to destruct if data type is not flat
            if (Vector3Stamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Vector3Stamped at %p\n",buffer);
                Vector3StampedNML * p = static_cast<Vector3StampedNML*>(buffer);
                p->~Vector3StampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Vector3Stamped at %p, is flat\n",buffer);
            }
            break;
        } 
        case Wrench::ID:
        {
            // only need to destruct if data type is not flat
            if (Wrench::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Wrench at %p\n",buffer);
                WrenchNML * p = static_cast<WrenchNML*>(buffer);
                p->~WrenchNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Wrench at %p, is flat\n",buffer);
            }
            break;
        } 
        case WrenchStamped::ID:
        {
            // only need to destruct if data type is not flat
            if (WrenchStamped::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing WrenchStamped at %p\n",buffer);
                WrenchStampedNML * p = static_cast<WrenchStampedNML*>(buffer);
                p->~WrenchStampedNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction WrenchStamped at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void geometry_msgs::nmlupdate(CMS * cms, Accel & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Accel, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.linear);
        nmlupdate(cms,inobj.angular);

    }  
 }

AccelNML::AccelNML() : NMLmsg((NMLTYPE)Accel::ID,sizeof(AccelNML)), nmlVersion(Accel::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Accel()*/)
{
};

AccelNML::~AccelNML()
{
};

AccelNML & AccelNML::operator=(const AccelNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AccelNML & AccelNML::operator=(const Accel & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Accel);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AccelNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Accel&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AccelNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Accel> temp(new Accel());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Accel::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Accel Message version mismatch, expected " << Accel::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Accel Message version mismatch, expected " << Accel::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, AccelStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AccelStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.accel);

    }  
 }

AccelStampedNML::AccelStampedNML() : NMLmsg((NMLTYPE)AccelStamped::ID,sizeof(AccelStampedNML)), nmlVersion(AccelStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AccelStamped()*/)
{
};

AccelStampedNML::~AccelStampedNML()
{
};

AccelStampedNML & AccelStampedNML::operator=(const AccelStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AccelStampedNML & AccelStampedNML::operator=(const AccelStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AccelStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AccelStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AccelStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AccelStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AccelStamped> temp(new AccelStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AccelStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AccelStamped Message version mismatch, expected " << AccelStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AccelStamped Message version mismatch, expected " << AccelStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, AccelWithCovariance & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AccelWithCovariance, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.accel);
        cms->update(inobj.covariance.data(),36); 

    }  
 }

AccelWithCovarianceNML::AccelWithCovarianceNML() : NMLmsg((NMLTYPE)AccelWithCovariance::ID,sizeof(AccelWithCovarianceNML)), nmlVersion(AccelWithCovariance::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AccelWithCovariance()*/)
{
};

AccelWithCovarianceNML::~AccelWithCovarianceNML()
{
};

AccelWithCovarianceNML & AccelWithCovarianceNML::operator=(const AccelWithCovarianceNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AccelWithCovarianceNML & AccelWithCovarianceNML::operator=(const AccelWithCovariance & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AccelWithCovariance);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AccelWithCovarianceNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AccelWithCovariance&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AccelWithCovarianceNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AccelWithCovariance> temp(new AccelWithCovariance());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AccelWithCovariance::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AccelWithCovariance Message version mismatch, expected " << AccelWithCovariance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AccelWithCovariance Message version mismatch, expected " << AccelWithCovariance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, AccelWithCovarianceStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate AccelWithCovarianceStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.accel);

    }  
 }

AccelWithCovarianceStampedNML::AccelWithCovarianceStampedNML() : NMLmsg((NMLTYPE)AccelWithCovarianceStamped::ID,sizeof(AccelWithCovarianceStampedNML)), nmlVersion(AccelWithCovarianceStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new AccelWithCovarianceStamped()*/)
{
};

AccelWithCovarianceStampedNML::~AccelWithCovarianceStampedNML()
{
};

AccelWithCovarianceStampedNML & AccelWithCovarianceStampedNML::operator=(const AccelWithCovarianceStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

AccelWithCovarianceStampedNML & AccelWithCovarianceStampedNML::operator=(const AccelWithCovarianceStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(AccelWithCovarianceStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void AccelWithCovarianceStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<AccelWithCovarianceStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: AccelWithCovarianceStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<AccelWithCovarianceStamped> temp(new AccelWithCovarianceStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (AccelWithCovarianceStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: AccelWithCovarianceStamped Message version mismatch, expected " << AccelWithCovarianceStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: AccelWithCovarianceStamped Message version mismatch, expected " << AccelWithCovarianceStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Inertia & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Inertia, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.m);
        nmlupdate(cms,inobj.com);
        cms->update(inobj.ixx);
        cms->update(inobj.ixy);
        cms->update(inobj.ixz);
        cms->update(inobj.iyy);
        cms->update(inobj.iyz);
        cms->update(inobj.izz);

    }  
 }

InertiaNML::InertiaNML() : NMLmsg((NMLTYPE)Inertia::ID,sizeof(InertiaNML)), nmlVersion(Inertia::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Inertia()*/)
{
};

InertiaNML::~InertiaNML()
{
};

InertiaNML & InertiaNML::operator=(const InertiaNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

InertiaNML & InertiaNML::operator=(const Inertia & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Inertia);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void InertiaNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Inertia&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: InertiaNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Inertia> temp(new Inertia());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Inertia::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Inertia Message version mismatch, expected " << Inertia::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Inertia Message version mismatch, expected " << Inertia::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, InertiaStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate InertiaStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.inertia);

    }  
 }

InertiaStampedNML::InertiaStampedNML() : NMLmsg((NMLTYPE)InertiaStamped::ID,sizeof(InertiaStampedNML)), nmlVersion(InertiaStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new InertiaStamped()*/)
{
};

InertiaStampedNML::~InertiaStampedNML()
{
};

InertiaStampedNML & InertiaStampedNML::operator=(const InertiaStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

InertiaStampedNML & InertiaStampedNML::operator=(const InertiaStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(InertiaStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void InertiaStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<InertiaStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: InertiaStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<InertiaStamped> temp(new InertiaStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (InertiaStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: InertiaStamped Message version mismatch, expected " << InertiaStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: InertiaStamped Message version mismatch, expected " << InertiaStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Point & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Point, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.z);

    }  
 }

PointNML::PointNML() : NMLmsg((NMLTYPE)Point::ID,sizeof(PointNML)), nmlVersion(Point::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Point()*/)
{
};

PointNML::~PointNML()
{
};

PointNML & PointNML::operator=(const PointNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointNML & PointNML::operator=(const Point & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Point);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Point&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Point> temp(new Point());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Point::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Point Message version mismatch, expected " << Point::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Point Message version mismatch, expected " << Point::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Point32 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Point32, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.z);

    }  
 }

Point32NML::Point32NML() : NMLmsg((NMLTYPE)Point32::ID,sizeof(Point32NML)), nmlVersion(Point32::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Point32()*/)
{
};

Point32NML::~Point32NML()
{
};

Point32NML & Point32NML::operator=(const Point32NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Point32NML & Point32NML::operator=(const Point32 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Point32);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Point32NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Point32&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Point32NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Point32> temp(new Point32());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Point32::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Point32 Message version mismatch, expected " << Point32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Point32 Message version mismatch, expected " << Point32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, PointStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.point);

    }  
 }

PointStampedNML::PointStampedNML() : NMLmsg((NMLTYPE)PointStamped::ID,sizeof(PointStampedNML)), nmlVersion(PointStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointStamped()*/)
{
};

PointStampedNML::~PointStampedNML()
{
};

PointStampedNML & PointStampedNML::operator=(const PointStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointStampedNML & PointStampedNML::operator=(const PointStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointStamped> temp(new PointStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointStamped Message version mismatch, expected " << PointStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointStamped Message version mismatch, expected " << PointStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Polygon & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Polygon, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.points);

    }  
 }

PolygonNML::PolygonNML() : NMLmsg((NMLTYPE)Polygon::ID,sizeof(PolygonNML)), nmlVersion(Polygon::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Polygon()*/)
{
};

PolygonNML::~PolygonNML()
{
};

PolygonNML & PolygonNML::operator=(const PolygonNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PolygonNML & PolygonNML::operator=(const Polygon & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Polygon);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PolygonNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Polygon&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PolygonNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Polygon> temp(new Polygon());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Polygon::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Polygon Message version mismatch, expected " << Polygon::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Polygon Message version mismatch, expected " << Polygon::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, PolygonStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PolygonStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.polygon);

    }  
 }

PolygonStampedNML::PolygonStampedNML() : NMLmsg((NMLTYPE)PolygonStamped::ID,sizeof(PolygonStampedNML)), nmlVersion(PolygonStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PolygonStamped()*/)
{
};

PolygonStampedNML::~PolygonStampedNML()
{
};

PolygonStampedNML & PolygonStampedNML::operator=(const PolygonStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PolygonStampedNML & PolygonStampedNML::operator=(const PolygonStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PolygonStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PolygonStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PolygonStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PolygonStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PolygonStamped> temp(new PolygonStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PolygonStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PolygonStamped Message version mismatch, expected " << PolygonStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PolygonStamped Message version mismatch, expected " << PolygonStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Pose & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Pose, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.position);
        nmlupdate(cms,inobj.orientation);

    }  
 }

PoseNML::PoseNML() : NMLmsg((NMLTYPE)Pose::ID,sizeof(PoseNML)), nmlVersion(Pose::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Pose()*/)
{
};

PoseNML::~PoseNML()
{
};

PoseNML & PoseNML::operator=(const PoseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PoseNML & PoseNML::operator=(const Pose & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Pose);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PoseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Pose&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PoseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Pose> temp(new Pose());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Pose::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Pose Message version mismatch, expected " << Pose::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Pose Message version mismatch, expected " << Pose::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Pose2D & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Pose2D, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.theta);

    }  
 }

Pose2DNML::Pose2DNML() : NMLmsg((NMLTYPE)Pose2D::ID,sizeof(Pose2DNML)), nmlVersion(Pose2D::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Pose2D()*/)
{
};

Pose2DNML::~Pose2DNML()
{
};

Pose2DNML & Pose2DNML::operator=(const Pose2DNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Pose2DNML & Pose2DNML::operator=(const Pose2D & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Pose2D);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Pose2DNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Pose2D&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Pose2DNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Pose2D> temp(new Pose2D());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Pose2D::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Pose2D Message version mismatch, expected " << Pose2D::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Pose2D Message version mismatch, expected " << Pose2D::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, PoseArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PoseArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.poses);

    }  
 }

PoseArrayNML::PoseArrayNML() : NMLmsg((NMLTYPE)PoseArray::ID,sizeof(PoseArrayNML)), nmlVersion(PoseArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PoseArray()*/)
{
};

PoseArrayNML::~PoseArrayNML()
{
};

PoseArrayNML & PoseArrayNML::operator=(const PoseArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PoseArrayNML & PoseArrayNML::operator=(const PoseArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PoseArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PoseArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PoseArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PoseArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PoseArray> temp(new PoseArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PoseArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PoseArray Message version mismatch, expected " << PoseArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PoseArray Message version mismatch, expected " << PoseArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, PoseStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PoseStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.pose);

    }  
 }

PoseStampedNML::PoseStampedNML() : NMLmsg((NMLTYPE)PoseStamped::ID,sizeof(PoseStampedNML)), nmlVersion(PoseStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PoseStamped()*/)
{
};

PoseStampedNML::~PoseStampedNML()
{
};

PoseStampedNML & PoseStampedNML::operator=(const PoseStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PoseStampedNML & PoseStampedNML::operator=(const PoseStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PoseStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PoseStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PoseStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PoseStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PoseStamped> temp(new PoseStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PoseStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PoseStamped Message version mismatch, expected " << PoseStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PoseStamped Message version mismatch, expected " << PoseStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, PoseWithCovariance & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PoseWithCovariance, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.pose);
        cms->update(inobj.covariance.data(),36); 

    }  
 }

PoseWithCovarianceNML::PoseWithCovarianceNML() : NMLmsg((NMLTYPE)PoseWithCovariance::ID,sizeof(PoseWithCovarianceNML)), nmlVersion(PoseWithCovariance::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PoseWithCovariance()*/)
{
};

PoseWithCovarianceNML::~PoseWithCovarianceNML()
{
};

PoseWithCovarianceNML & PoseWithCovarianceNML::operator=(const PoseWithCovarianceNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PoseWithCovarianceNML & PoseWithCovarianceNML::operator=(const PoseWithCovariance & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PoseWithCovariance);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PoseWithCovarianceNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PoseWithCovariance&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PoseWithCovarianceNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PoseWithCovariance> temp(new PoseWithCovariance());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PoseWithCovariance::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PoseWithCovariance Message version mismatch, expected " << PoseWithCovariance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PoseWithCovariance Message version mismatch, expected " << PoseWithCovariance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, PoseWithCovarianceStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PoseWithCovarianceStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.pose);

    }  
 }

PoseWithCovarianceStampedNML::PoseWithCovarianceStampedNML() : NMLmsg((NMLTYPE)PoseWithCovarianceStamped::ID,sizeof(PoseWithCovarianceStampedNML)), nmlVersion(PoseWithCovarianceStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PoseWithCovarianceStamped()*/)
{
};

PoseWithCovarianceStampedNML::~PoseWithCovarianceStampedNML()
{
};

PoseWithCovarianceStampedNML & PoseWithCovarianceStampedNML::operator=(const PoseWithCovarianceStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PoseWithCovarianceStampedNML & PoseWithCovarianceStampedNML::operator=(const PoseWithCovarianceStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PoseWithCovarianceStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PoseWithCovarianceStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PoseWithCovarianceStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PoseWithCovarianceStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PoseWithCovarianceStamped> temp(new PoseWithCovarianceStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PoseWithCovarianceStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PoseWithCovarianceStamped Message version mismatch, expected " << PoseWithCovarianceStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PoseWithCovarianceStamped Message version mismatch, expected " << PoseWithCovarianceStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Quaternion & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Quaternion, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.z);
        cms->update(inobj.w);

    }  
 }

QuaternionNML::QuaternionNML() : NMLmsg((NMLTYPE)Quaternion::ID,sizeof(QuaternionNML)), nmlVersion(Quaternion::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Quaternion()*/)
{
};

QuaternionNML::~QuaternionNML()
{
};

QuaternionNML & QuaternionNML::operator=(const QuaternionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QuaternionNML & QuaternionNML::operator=(const Quaternion & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Quaternion);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QuaternionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Quaternion&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QuaternionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Quaternion> temp(new Quaternion());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Quaternion::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Quaternion Message version mismatch, expected " << Quaternion::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Quaternion Message version mismatch, expected " << Quaternion::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, QuaternionStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QuaternionStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.quaternion);

    }  
 }

QuaternionStampedNML::QuaternionStampedNML() : NMLmsg((NMLTYPE)QuaternionStamped::ID,sizeof(QuaternionStampedNML)), nmlVersion(QuaternionStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QuaternionStamped()*/)
{
};

QuaternionStampedNML::~QuaternionStampedNML()
{
};

QuaternionStampedNML & QuaternionStampedNML::operator=(const QuaternionStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QuaternionStampedNML & QuaternionStampedNML::operator=(const QuaternionStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QuaternionStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QuaternionStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QuaternionStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QuaternionStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QuaternionStamped> temp(new QuaternionStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QuaternionStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QuaternionStamped Message version mismatch, expected " << QuaternionStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QuaternionStamped Message version mismatch, expected " << QuaternionStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Transform & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Transform, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.translation);
        nmlupdate(cms,inobj.rotation);

    }  
 }

TransformNML::TransformNML() : NMLmsg((NMLTYPE)Transform::ID,sizeof(TransformNML)), nmlVersion(Transform::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Transform()*/)
{
};

TransformNML::~TransformNML()
{
};

TransformNML & TransformNML::operator=(const TransformNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TransformNML & TransformNML::operator=(const Transform & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Transform);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TransformNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Transform&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TransformNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Transform> temp(new Transform());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Transform::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Transform Message version mismatch, expected " << Transform::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Transform Message version mismatch, expected " << Transform::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, TransformStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TransformStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.child_frame_id);
        nmlupdate(cms,inobj.transform);

    }  
 }

TransformStampedNML::TransformStampedNML() : NMLmsg((NMLTYPE)TransformStamped::ID,sizeof(TransformStampedNML)), nmlVersion(TransformStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TransformStamped()*/)
{
};

TransformStampedNML::~TransformStampedNML()
{
};

TransformStampedNML & TransformStampedNML::operator=(const TransformStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TransformStampedNML & TransformStampedNML::operator=(const TransformStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TransformStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TransformStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TransformStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TransformStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TransformStamped> temp(new TransformStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TransformStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TransformStamped Message version mismatch, expected " << TransformStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TransformStamped Message version mismatch, expected " << TransformStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Twist & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Twist, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.linear);
        nmlupdate(cms,inobj.angular);

    }  
 }

TwistNML::TwistNML() : NMLmsg((NMLTYPE)Twist::ID,sizeof(TwistNML)), nmlVersion(Twist::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Twist()*/)
{
};

TwistNML::~TwistNML()
{
};

TwistNML & TwistNML::operator=(const TwistNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwistNML & TwistNML::operator=(const Twist & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Twist);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwistNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Twist&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwistNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Twist> temp(new Twist());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Twist::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Twist Message version mismatch, expected " << Twist::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Twist Message version mismatch, expected " << Twist::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, TwistStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwistStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.twist);

    }  
 }

TwistStampedNML::TwistStampedNML() : NMLmsg((NMLTYPE)TwistStamped::ID,sizeof(TwistStampedNML)), nmlVersion(TwistStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwistStamped()*/)
{
};

TwistStampedNML::~TwistStampedNML()
{
};

TwistStampedNML & TwistStampedNML::operator=(const TwistStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwistStampedNML & TwistStampedNML::operator=(const TwistStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwistStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwistStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwistStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwistStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwistStamped> temp(new TwistStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwistStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwistStamped Message version mismatch, expected " << TwistStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwistStamped Message version mismatch, expected " << TwistStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, TwistWithCovariance & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwistWithCovariance, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.twist);
        cms->update(inobj.covariance.data(),36); 

    }  
 }

TwistWithCovarianceNML::TwistWithCovarianceNML() : NMLmsg((NMLTYPE)TwistWithCovariance::ID,sizeof(TwistWithCovarianceNML)), nmlVersion(TwistWithCovariance::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwistWithCovariance()*/)
{
};

TwistWithCovarianceNML::~TwistWithCovarianceNML()
{
};

TwistWithCovarianceNML & TwistWithCovarianceNML::operator=(const TwistWithCovarianceNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwistWithCovarianceNML & TwistWithCovarianceNML::operator=(const TwistWithCovariance & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwistWithCovariance);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwistWithCovarianceNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwistWithCovariance&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwistWithCovarianceNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwistWithCovariance> temp(new TwistWithCovariance());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwistWithCovariance::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwistWithCovariance Message version mismatch, expected " << TwistWithCovariance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwistWithCovariance Message version mismatch, expected " << TwistWithCovariance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, TwistWithCovarianceStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TwistWithCovarianceStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.twist);

    }  
 }

TwistWithCovarianceStampedNML::TwistWithCovarianceStampedNML() : NMLmsg((NMLTYPE)TwistWithCovarianceStamped::ID,sizeof(TwistWithCovarianceStampedNML)), nmlVersion(TwistWithCovarianceStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TwistWithCovarianceStamped()*/)
{
};

TwistWithCovarianceStampedNML::~TwistWithCovarianceStampedNML()
{
};

TwistWithCovarianceStampedNML & TwistWithCovarianceStampedNML::operator=(const TwistWithCovarianceStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TwistWithCovarianceStampedNML & TwistWithCovarianceStampedNML::operator=(const TwistWithCovarianceStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TwistWithCovarianceStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TwistWithCovarianceStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TwistWithCovarianceStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TwistWithCovarianceStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TwistWithCovarianceStamped> temp(new TwistWithCovarianceStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TwistWithCovarianceStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TwistWithCovarianceStamped Message version mismatch, expected " << TwistWithCovarianceStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TwistWithCovarianceStamped Message version mismatch, expected " << TwistWithCovarianceStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Vector3 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Vector3, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.x);
        cms->update(inobj.y);
        cms->update(inobj.z);

    }  
 }

Vector3NML::Vector3NML() : NMLmsg((NMLTYPE)Vector3::ID,sizeof(Vector3NML)), nmlVersion(Vector3::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Vector3()*/)
{
};

Vector3NML::~Vector3NML()
{
};

Vector3NML & Vector3NML::operator=(const Vector3NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Vector3NML & Vector3NML::operator=(const Vector3 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Vector3);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Vector3NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Vector3&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Vector3NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Vector3> temp(new Vector3());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Vector3::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Vector3 Message version mismatch, expected " << Vector3::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Vector3 Message version mismatch, expected " << Vector3::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Vector3Stamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Vector3Stamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.vector);

    }  
 }

Vector3StampedNML::Vector3StampedNML() : NMLmsg((NMLTYPE)Vector3Stamped::ID,sizeof(Vector3StampedNML)), nmlVersion(Vector3Stamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Vector3Stamped()*/)
{
};

Vector3StampedNML::~Vector3StampedNML()
{
};

Vector3StampedNML & Vector3StampedNML::operator=(const Vector3StampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Vector3StampedNML & Vector3StampedNML::operator=(const Vector3Stamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Vector3Stamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Vector3StampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Vector3Stamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Vector3StampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Vector3Stamped> temp(new Vector3Stamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Vector3Stamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Vector3Stamped Message version mismatch, expected " << Vector3Stamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Vector3Stamped Message version mismatch, expected " << Vector3Stamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, Wrench & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Wrench, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.force);
        nmlupdate(cms,inobj.torque);

    }  
 }

WrenchNML::WrenchNML() : NMLmsg((NMLTYPE)Wrench::ID,sizeof(WrenchNML)), nmlVersion(Wrench::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Wrench()*/)
{
};

WrenchNML::~WrenchNML()
{
};

WrenchNML & WrenchNML::operator=(const WrenchNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

WrenchNML & WrenchNML::operator=(const Wrench & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Wrench);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void WrenchNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Wrench&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: WrenchNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Wrench> temp(new Wrench());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Wrench::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Wrench Message version mismatch, expected " << Wrench::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Wrench Message version mismatch, expected " << Wrench::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void geometry_msgs::nmlupdate(CMS * cms, WrenchStamped & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate WrenchStamped, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.wrench);

    }  
 }

WrenchStampedNML::WrenchStampedNML() : NMLmsg((NMLTYPE)WrenchStamped::ID,sizeof(WrenchStampedNML)), nmlVersion(WrenchStamped::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new WrenchStamped()*/)
{
};

WrenchStampedNML::~WrenchStampedNML()
{
};

WrenchStampedNML & WrenchStampedNML::operator=(const WrenchStampedNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

WrenchStampedNML & WrenchStampedNML::operator=(const WrenchStamped & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(WrenchStamped);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void WrenchStampedNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<WrenchStamped&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: WrenchStampedNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<WrenchStamped> temp(new WrenchStamped());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: geometry_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (WrenchStamped::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: WrenchStamped Message version mismatch, expected " << WrenchStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: WrenchStamped Message version mismatch, expected " << WrenchStamped::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int geometry_msgs::geometry_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("geometry_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case Accel::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Accel, id " << Accel::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AccelNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AccelStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AccelStamped, id " << AccelStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AccelStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AccelWithCovariance::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AccelWithCovariance, id " << AccelWithCovariance::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AccelWithCovarianceNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case AccelWithCovarianceStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for AccelWithCovarianceStamped, id " << AccelWithCovarianceStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((AccelWithCovarianceStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Inertia::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Inertia, id " << Inertia::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((InertiaNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case InertiaStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for InertiaStamped, id " << InertiaStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((InertiaStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Point::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Point, id " << Point::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Point32::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Point32, id " << Point32::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Point32NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointStamped, id " << PointStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Polygon::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Polygon, id " << Polygon::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PolygonNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PolygonStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PolygonStamped, id " << PolygonStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PolygonStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Pose::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Pose, id " << Pose::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PoseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Pose2D::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Pose2D, id " << Pose2D::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Pose2DNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PoseArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PoseArray, id " << PoseArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PoseArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PoseStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PoseStamped, id " << PoseStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PoseStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PoseWithCovariance::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PoseWithCovariance, id " << PoseWithCovariance::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PoseWithCovarianceNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PoseWithCovarianceStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PoseWithCovarianceStamped, id " << PoseWithCovarianceStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PoseWithCovarianceStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Quaternion::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Quaternion, id " << Quaternion::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QuaternionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QuaternionStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QuaternionStamped, id " << QuaternionStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QuaternionStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Transform::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Transform, id " << Transform::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TransformNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TransformStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TransformStamped, id " << TransformStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TransformStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Twist::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Twist, id " << Twist::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwistNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwistStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwistStamped, id " << TwistStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwistStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwistWithCovariance::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwistWithCovariance, id " << TwistWithCovariance::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwistWithCovarianceNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TwistWithCovarianceStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TwistWithCovarianceStamped, id " << TwistWithCovarianceStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TwistWithCovarianceStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Vector3::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Vector3, id " << Vector3::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Vector3NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Vector3Stamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Vector3Stamped, id " << Vector3Stamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Vector3StampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Wrench::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Wrench, id " << Wrench::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((WrenchNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case WrenchStamped::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for WrenchStamped, id " << WrenchStamped::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_geometry_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"geometry_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((WrenchStampedNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

