// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:06 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "nav_msgs_gencpp_NML.h"
#include "nav_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <GetMapAction.h>
#include <GetMapActionFeedback.h>
#include <GetMapActionGoal.h>
#include <GetMapActionResult.h>
#include <GetMapFeedback.h>
#include <GetMapGoal.h>
#include <GetMapResult.h>
#include <GridCells.h>
#include <MapMetaData.h>
#include <OccupancyGrid.h>
#include <Odometry.h>
#include <Path.h>
#include <GetMapRequest.h>
#include <GetMapResponse.h>
#include <GetMap.h>
#include <GetPlanRequest.h>
#include <GetPlanResponse.h>
#include <GetPlan.h>
#include <SetMapRequest.h>
#include <SetMapResponse.h>
#include <SetMap.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace nav_msgs;

rframe::NMLMessageFactory * NML_nav_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_nav_msgs_gencppfactory = new nav_msgs_gencppNMLMessageFactory();
        return NML_nav_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * nav_msgs::allocate_nav_msgs_gencpp()
{
    NML_nav_msgs_gencppfactory = new nav_msgs_gencppNMLMessageFactory();
    return NML_nav_msgs_gencppfactory;
};

nav_msgs_gencppNMLMessageFactory::nav_msgs_gencppNMLMessageFactory()
{
    name("nav_msgs_gencpp");
    // use constructor to register data types
    nav_msgs::registerLibrary();
}

nav_msgs_gencppNMLMessageFactory::~nav_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR nav_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return nav_msgs_gencpp_format;
}

int nav_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void nav_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(GetMapAction::ID);
    info.name(GetMapAction::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapAction::DATA_VERSION);
    info.md5Key(GetMapAction::VERSION_MD5);
    info.xmlSource(GetMapAction::XML_SOURCE);
    info.flat(GetMapAction::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapActionFeedback::ID);
    info.name(GetMapActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapActionFeedback::DATA_VERSION);
    info.md5Key(GetMapActionFeedback::VERSION_MD5);
    info.xmlSource(GetMapActionFeedback::XML_SOURCE);
    info.flat(GetMapActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapActionGoal::ID);
    info.name(GetMapActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapActionGoal::DATA_VERSION);
    info.md5Key(GetMapActionGoal::VERSION_MD5);
    info.xmlSource(GetMapActionGoal::XML_SOURCE);
    info.flat(GetMapActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapActionResult::ID);
    info.name(GetMapActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapActionResult::DATA_VERSION);
    info.md5Key(GetMapActionResult::VERSION_MD5);
    info.xmlSource(GetMapActionResult::XML_SOURCE);
    info.flat(GetMapActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapFeedback::ID);
    info.name(GetMapFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapFeedback::DATA_VERSION);
    info.md5Key(GetMapFeedback::VERSION_MD5);
    info.xmlSource(GetMapFeedback::XML_SOURCE);
    info.flat(GetMapFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapGoal::ID);
    info.name(GetMapGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapGoal::DATA_VERSION);
    info.md5Key(GetMapGoal::VERSION_MD5);
    info.xmlSource(GetMapGoal::XML_SOURCE);
    info.flat(GetMapGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapResult::ID);
    info.name(GetMapResult::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapResult::DATA_VERSION);
    info.md5Key(GetMapResult::VERSION_MD5);
    info.xmlSource(GetMapResult::XML_SOURCE);
    info.flat(GetMapResult::dataTypeFlat());
    ids.push_back(info);

    info.id(GridCells::ID);
    info.name(GridCells::DATA_TYPE_FULL_NAME);
    info.hashKey(GridCells::DATA_VERSION);
    info.md5Key(GridCells::VERSION_MD5);
    info.xmlSource(GridCells::XML_SOURCE);
    info.flat(GridCells::dataTypeFlat());
    ids.push_back(info);

    info.id(MapMetaData::ID);
    info.name(MapMetaData::DATA_TYPE_FULL_NAME);
    info.hashKey(MapMetaData::DATA_VERSION);
    info.md5Key(MapMetaData::VERSION_MD5);
    info.xmlSource(MapMetaData::XML_SOURCE);
    info.flat(MapMetaData::dataTypeFlat());
    ids.push_back(info);

    info.id(OccupancyGrid::ID);
    info.name(OccupancyGrid::DATA_TYPE_FULL_NAME);
    info.hashKey(OccupancyGrid::DATA_VERSION);
    info.md5Key(OccupancyGrid::VERSION_MD5);
    info.xmlSource(OccupancyGrid::XML_SOURCE);
    info.flat(OccupancyGrid::dataTypeFlat());
    ids.push_back(info);

    info.id(Odometry::ID);
    info.name(Odometry::DATA_TYPE_FULL_NAME);
    info.hashKey(Odometry::DATA_VERSION);
    info.md5Key(Odometry::VERSION_MD5);
    info.xmlSource(Odometry::XML_SOURCE);
    info.flat(Odometry::dataTypeFlat());
    ids.push_back(info);

    info.id(Path::ID);
    info.name(Path::DATA_TYPE_FULL_NAME);
    info.hashKey(Path::DATA_VERSION);
    info.md5Key(Path::VERSION_MD5);
    info.xmlSource(Path::XML_SOURCE);
    info.flat(Path::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapRequest::ID);
    info.name(GetMapRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapRequest::DATA_VERSION);
    info.md5Key(GetMapRequest::VERSION_MD5);
    info.xmlSource(GetMapRequest::XML_SOURCE);
    info.flat(GetMapRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMapResponse::ID);
    info.name(GetMapResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMapResponse::DATA_VERSION);
    info.md5Key(GetMapResponse::VERSION_MD5);
    info.xmlSource(GetMapResponse::XML_SOURCE);
    info.flat(GetMapResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetMap::ID);
    info.name(GetMap::DATA_TYPE_FULL_NAME);
    info.hashKey(GetMap::DATA_VERSION);
    info.md5Key(GetMap::VERSION_MD5);
    info.xmlSource(GetMap::XML_SOURCE);
    info.flat(GetMap::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPlanRequest::ID);
    info.name(GetPlanRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPlanRequest::DATA_VERSION);
    info.md5Key(GetPlanRequest::VERSION_MD5);
    info.xmlSource(GetPlanRequest::XML_SOURCE);
    info.flat(GetPlanRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPlanResponse::ID);
    info.name(GetPlanResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPlanResponse::DATA_VERSION);
    info.md5Key(GetPlanResponse::VERSION_MD5);
    info.xmlSource(GetPlanResponse::XML_SOURCE);
    info.flat(GetPlanResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPlan::ID);
    info.name(GetPlan::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPlan::DATA_VERSION);
    info.md5Key(GetPlan::VERSION_MD5);
    info.xmlSource(GetPlan::XML_SOURCE);
    info.flat(GetPlan::dataTypeFlat());
    ids.push_back(info);

    info.id(SetMapRequest::ID);
    info.name(SetMapRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetMapRequest::DATA_VERSION);
    info.md5Key(SetMapRequest::VERSION_MD5);
    info.xmlSource(SetMapRequest::XML_SOURCE);
    info.flat(SetMapRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetMapResponse::ID);
    info.name(SetMapResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetMapResponse::DATA_VERSION);
    info.md5Key(SetMapResponse::VERSION_MD5);
    info.xmlSource(SetMapResponse::XML_SOURCE);
    info.flat(SetMapResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetMap::ID);
    info.name(SetMap::DATA_TYPE_FULL_NAME);
    info.hashKey(SetMap::DATA_VERSION);
    info.md5Key(SetMap::VERSION_MD5);
    info.xmlSource(SetMap::XML_SOURCE);
    info.flat(SetMap::dataTypeFlat());
    ids.push_back(info);

}

int nav_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case GetMapAction::ID:
        {
            //GetMapActionNML * newmsg = new GetMapActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapActionNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapActionFeedback::ID:
        {
            //GetMapActionFeedbackNML * newmsg = new GetMapActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapActionFeedbackNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapActionGoal::ID:
        {
            //GetMapActionGoalNML * newmsg = new GetMapActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapActionGoalNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapActionResult::ID:
        {
            //GetMapActionResultNML * newmsg = new GetMapActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapActionResultNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapFeedback::ID:
        {
            //GetMapFeedbackNML * newmsg = new GetMapFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapFeedbackNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapGoal::ID:
        {
            //GetMapGoalNML * newmsg = new GetMapGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapGoalNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapResult::ID:
        {
            //GetMapResultNML * newmsg = new GetMapResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapResultNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GridCells::ID:
        {
            //GridCellsNML * newmsg = new GridCellsNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GridCellsNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MapMetaData::ID:
        {
            //MapMetaDataNML * newmsg = new MapMetaDataNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MapMetaDataNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case OccupancyGrid::ID:
        {
            //OccupancyGridNML * newmsg = new OccupancyGridNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new OccupancyGridNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Odometry::ID:
        {
            //OdometryNML * newmsg = new OdometryNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new OdometryNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Path::ID:
        {
            //PathNML * newmsg = new PathNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PathNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapRequest::ID:
        {
            //GetMapRequestNML * newmsg = new GetMapRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapRequestNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMapResponse::ID:
        {
            //GetMapResponseNML * newmsg = new GetMapResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapResponseNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetMap::ID:
        {
            //GetMapNML * newmsg = new GetMapNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetMapNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPlanRequest::ID:
        {
            //GetPlanRequestNML * newmsg = new GetPlanRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPlanRequestNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPlanResponse::ID:
        {
            //GetPlanResponseNML * newmsg = new GetPlanResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPlanResponseNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPlan::ID:
        {
            //GetPlanNML * newmsg = new GetPlanNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPlanNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetMapRequest::ID:
        {
            //SetMapRequestNML * newmsg = new SetMapRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetMapRequestNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetMapResponse::ID:
        {
            //SetMapResponseNML * newmsg = new SetMapResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetMapResponseNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetMap::ID:
        {
            //SetMapNML * newmsg = new SetMapNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetMapNML(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case GetMapAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapAction>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapActionFeedback>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapActionGoal>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapActionResult>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapFeedback>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapGoal>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapResult>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GridCells::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GridCells>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MapMetaData::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MapMetaData>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case OccupancyGrid::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<OccupancyGrid>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Odometry::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Odometry>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Path::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Path>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapRequest>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMapResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMapResponse>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetMap::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetMap>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPlanRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPlanRequest>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPlanResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPlanResponse>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPlan::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPlan>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetMapRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetMapRequest>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetMapResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetMapResponse>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetMap::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetMap>(),std::bind(&nav_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case GetMapAction::ID:
            {
                GetMapActionNML * tempmsg = static_cast<GetMapActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapActionFeedback::ID:
            {
                GetMapActionFeedbackNML * tempmsg = static_cast<GetMapActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapActionGoal::ID:
            {
                GetMapActionGoalNML * tempmsg = static_cast<GetMapActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapActionResult::ID:
            {
                GetMapActionResultNML * tempmsg = static_cast<GetMapActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapFeedback::ID:
            {
                GetMapFeedbackNML * tempmsg = static_cast<GetMapFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapGoal::ID:
            {
                GetMapGoalNML * tempmsg = static_cast<GetMapGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapResult::ID:
            {
                GetMapResultNML * tempmsg = static_cast<GetMapResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GridCells::ID:
            {
                GridCellsNML * tempmsg = static_cast<GridCellsNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MapMetaData::ID:
            {
                MapMetaDataNML * tempmsg = static_cast<MapMetaDataNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case OccupancyGrid::ID:
            {
                OccupancyGridNML * tempmsg = static_cast<OccupancyGridNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Odometry::ID:
            {
                OdometryNML * tempmsg = static_cast<OdometryNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Path::ID:
            {
                PathNML * tempmsg = static_cast<PathNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapRequest::ID:
            {
                GetMapRequestNML * tempmsg = static_cast<GetMapRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMapResponse::ID:
            {
                GetMapResponseNML * tempmsg = static_cast<GetMapResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetMap::ID:
            {
                GetMapNML * tempmsg = static_cast<GetMapNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPlanRequest::ID:
            {
                GetPlanRequestNML * tempmsg = static_cast<GetPlanRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPlanResponse::ID:
            {
                GetPlanResponseNML * tempmsg = static_cast<GetPlanResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPlan::ID:
            {
                GetPlanNML * tempmsg = static_cast<GetPlanNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetMapRequest::ID:
            {
                SetMapRequestNML * tempmsg = static_cast<SetMapRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetMapResponse::ID:
            {
                SetMapResponseNML * tempmsg = static_cast<SetMapResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetMap::ID:
            {
                SetMapNML * tempmsg = static_cast<SetMapNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case GetMapAction::ID:
            {
                GetMapActionNML & tempDst = static_cast<GetMapActionNML&>(dst);
                Message<GetMapAction > & tempSrc = static_cast<Message<GetMapAction>&>(src);

                if (tempSrc.version() != GetMapAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapAction: " << __FILE__ << " expected: " 
                             << GetMapAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapAction: " << __FILE__ << " expected: " 
                         << GetMapAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapActionFeedback::ID:
            {
                GetMapActionFeedbackNML & tempDst = static_cast<GetMapActionFeedbackNML&>(dst);
                Message<GetMapActionFeedback > & tempSrc = static_cast<Message<GetMapActionFeedback>&>(src);

                if (tempSrc.version() != GetMapActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapActionFeedback: " << __FILE__ << " expected: " 
                             << GetMapActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapActionFeedback: " << __FILE__ << " expected: " 
                         << GetMapActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapActionGoal::ID:
            {
                GetMapActionGoalNML & tempDst = static_cast<GetMapActionGoalNML&>(dst);
                Message<GetMapActionGoal > & tempSrc = static_cast<Message<GetMapActionGoal>&>(src);

                if (tempSrc.version() != GetMapActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapActionGoal: " << __FILE__ << " expected: " 
                             << GetMapActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapActionGoal: " << __FILE__ << " expected: " 
                         << GetMapActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapActionResult::ID:
            {
                GetMapActionResultNML & tempDst = static_cast<GetMapActionResultNML&>(dst);
                Message<GetMapActionResult > & tempSrc = static_cast<Message<GetMapActionResult>&>(src);

                if (tempSrc.version() != GetMapActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapActionResult: " << __FILE__ << " expected: " 
                             << GetMapActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapActionResult: " << __FILE__ << " expected: " 
                         << GetMapActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapFeedback::ID:
            {
                GetMapFeedbackNML & tempDst = static_cast<GetMapFeedbackNML&>(dst);
                Message<GetMapFeedback > & tempSrc = static_cast<Message<GetMapFeedback>&>(src);

                if (tempSrc.version() != GetMapFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapFeedback: " << __FILE__ << " expected: " 
                             << GetMapFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapFeedback: " << __FILE__ << " expected: " 
                         << GetMapFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapGoal::ID:
            {
                GetMapGoalNML & tempDst = static_cast<GetMapGoalNML&>(dst);
                Message<GetMapGoal > & tempSrc = static_cast<Message<GetMapGoal>&>(src);

                if (tempSrc.version() != GetMapGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapGoal: " << __FILE__ << " expected: " 
                             << GetMapGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapGoal: " << __FILE__ << " expected: " 
                         << GetMapGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapResult::ID:
            {
                GetMapResultNML & tempDst = static_cast<GetMapResultNML&>(dst);
                Message<GetMapResult > & tempSrc = static_cast<Message<GetMapResult>&>(src);

                if (tempSrc.version() != GetMapResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapResult: " << __FILE__ << " expected: " 
                             << GetMapResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapResult: " << __FILE__ << " expected: " 
                         << GetMapResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GridCells::ID:
            {
                GridCellsNML & tempDst = static_cast<GridCellsNML&>(dst);
                Message<GridCells > & tempSrc = static_cast<Message<GridCells>&>(src);

                if (tempSrc.version() != GridCells::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GridCells: " << __FILE__ << " expected: " 
                             << GridCells::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GridCells: " << __FILE__ << " expected: " 
                         << GridCells::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MapMetaData::ID:
            {
                MapMetaDataNML & tempDst = static_cast<MapMetaDataNML&>(dst);
                Message<MapMetaData > & tempSrc = static_cast<Message<MapMetaData>&>(src);

                if (tempSrc.version() != MapMetaData::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MapMetaData: " << __FILE__ << " expected: " 
                             << MapMetaData::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MapMetaData: " << __FILE__ << " expected: " 
                         << MapMetaData::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case OccupancyGrid::ID:
            {
                OccupancyGridNML & tempDst = static_cast<OccupancyGridNML&>(dst);
                Message<OccupancyGrid > & tempSrc = static_cast<Message<OccupancyGrid>&>(src);

                if (tempSrc.version() != OccupancyGrid::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of OccupancyGrid: " << __FILE__ << " expected: " 
                             << OccupancyGrid::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of OccupancyGrid: " << __FILE__ << " expected: " 
                         << OccupancyGrid::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Odometry::ID:
            {
                OdometryNML & tempDst = static_cast<OdometryNML&>(dst);
                Message<Odometry > & tempSrc = static_cast<Message<Odometry>&>(src);

                if (tempSrc.version() != Odometry::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Odometry: " << __FILE__ << " expected: " 
                             << Odometry::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Odometry: " << __FILE__ << " expected: " 
                         << Odometry::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Path::ID:
            {
                PathNML & tempDst = static_cast<PathNML&>(dst);
                Message<Path > & tempSrc = static_cast<Message<Path>&>(src);

                if (tempSrc.version() != Path::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Path: " << __FILE__ << " expected: " 
                             << Path::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Path: " << __FILE__ << " expected: " 
                         << Path::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapRequest::ID:
            {
                GetMapRequestNML & tempDst = static_cast<GetMapRequestNML&>(dst);
                Message<GetMapRequest > & tempSrc = static_cast<Message<GetMapRequest>&>(src);

                if (tempSrc.version() != GetMapRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapRequest: " << __FILE__ << " expected: " 
                             << GetMapRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapRequest: " << __FILE__ << " expected: " 
                         << GetMapRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMapResponse::ID:
            {
                GetMapResponseNML & tempDst = static_cast<GetMapResponseNML&>(dst);
                Message<GetMapResponse > & tempSrc = static_cast<Message<GetMapResponse>&>(src);

                if (tempSrc.version() != GetMapResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMapResponse: " << __FILE__ << " expected: " 
                             << GetMapResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMapResponse: " << __FILE__ << " expected: " 
                         << GetMapResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetMap::ID:
            {
                GetMapNML & tempDst = static_cast<GetMapNML&>(dst);
                Message<GetMap > & tempSrc = static_cast<Message<GetMap>&>(src);

                if (tempSrc.version() != GetMap::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetMap: " << __FILE__ << " expected: " 
                             << GetMap::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetMap: " << __FILE__ << " expected: " 
                         << GetMap::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPlanRequest::ID:
            {
                GetPlanRequestNML & tempDst = static_cast<GetPlanRequestNML&>(dst);
                Message<GetPlanRequest > & tempSrc = static_cast<Message<GetPlanRequest>&>(src);

                if (tempSrc.version() != GetPlanRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPlanRequest: " << __FILE__ << " expected: " 
                             << GetPlanRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPlanRequest: " << __FILE__ << " expected: " 
                         << GetPlanRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPlanResponse::ID:
            {
                GetPlanResponseNML & tempDst = static_cast<GetPlanResponseNML&>(dst);
                Message<GetPlanResponse > & tempSrc = static_cast<Message<GetPlanResponse>&>(src);

                if (tempSrc.version() != GetPlanResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPlanResponse: " << __FILE__ << " expected: " 
                             << GetPlanResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPlanResponse: " << __FILE__ << " expected: " 
                         << GetPlanResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPlan::ID:
            {
                GetPlanNML & tempDst = static_cast<GetPlanNML&>(dst);
                Message<GetPlan > & tempSrc = static_cast<Message<GetPlan>&>(src);

                if (tempSrc.version() != GetPlan::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPlan: " << __FILE__ << " expected: " 
                             << GetPlan::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPlan: " << __FILE__ << " expected: " 
                         << GetPlan::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetMapRequest::ID:
            {
                SetMapRequestNML & tempDst = static_cast<SetMapRequestNML&>(dst);
                Message<SetMapRequest > & tempSrc = static_cast<Message<SetMapRequest>&>(src);

                if (tempSrc.version() != SetMapRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetMapRequest: " << __FILE__ << " expected: " 
                             << SetMapRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetMapRequest: " << __FILE__ << " expected: " 
                         << SetMapRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetMapResponse::ID:
            {
                SetMapResponseNML & tempDst = static_cast<SetMapResponseNML&>(dst);
                Message<SetMapResponse > & tempSrc = static_cast<Message<SetMapResponse>&>(src);

                if (tempSrc.version() != SetMapResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetMapResponse: " << __FILE__ << " expected: " 
                             << SetMapResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetMapResponse: " << __FILE__ << " expected: " 
                         << SetMapResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetMap::ID:
            {
                SetMapNML & tempDst = static_cast<SetMapNML&>(dst);
                Message<SetMap > & tempSrc = static_cast<Message<SetMap>&>(src);

                if (tempSrc.version() != SetMap::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetMap: " << __FILE__ << " expected: " 
                             << SetMap::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetMap: " << __FILE__ << " expected: " 
                         << SetMap::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case GetMapAction::ID:
            {
                GetMapActionNML & tempSrc = static_cast<GetMapActionNML&>(src);
                Message<GetMapAction > & tempDst = static_cast<Message<GetMapAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapActionFeedback::ID:
            {
                GetMapActionFeedbackNML & tempSrc = static_cast<GetMapActionFeedbackNML&>(src);
                Message<GetMapActionFeedback > & tempDst = static_cast<Message<GetMapActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapActionGoal::ID:
            {
                GetMapActionGoalNML & tempSrc = static_cast<GetMapActionGoalNML&>(src);
                Message<GetMapActionGoal > & tempDst = static_cast<Message<GetMapActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapActionResult::ID:
            {
                GetMapActionResultNML & tempSrc = static_cast<GetMapActionResultNML&>(src);
                Message<GetMapActionResult > & tempDst = static_cast<Message<GetMapActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapFeedback::ID:
            {
                GetMapFeedbackNML & tempSrc = static_cast<GetMapFeedbackNML&>(src);
                Message<GetMapFeedback > & tempDst = static_cast<Message<GetMapFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapGoal::ID:
            {
                GetMapGoalNML & tempSrc = static_cast<GetMapGoalNML&>(src);
                Message<GetMapGoal > & tempDst = static_cast<Message<GetMapGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapResult::ID:
            {
                GetMapResultNML & tempSrc = static_cast<GetMapResultNML&>(src);
                Message<GetMapResult > & tempDst = static_cast<Message<GetMapResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GridCells::ID:
            {
                GridCellsNML & tempSrc = static_cast<GridCellsNML&>(src);
                Message<GridCells > & tempDst = static_cast<Message<GridCells>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GridCells::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MapMetaData::ID:
            {
                MapMetaDataNML & tempSrc = static_cast<MapMetaDataNML&>(src);
                Message<MapMetaData > & tempDst = static_cast<Message<MapMetaData>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MapMetaData::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case OccupancyGrid::ID:
            {
                OccupancyGridNML & tempSrc = static_cast<OccupancyGridNML&>(src);
                Message<OccupancyGrid > & tempDst = static_cast<Message<OccupancyGrid>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (OccupancyGrid::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Odometry::ID:
            {
                OdometryNML & tempSrc = static_cast<OdometryNML&>(src);
                Message<Odometry > & tempDst = static_cast<Message<Odometry>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Odometry::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Path::ID:
            {
                PathNML & tempSrc = static_cast<PathNML&>(src);
                Message<Path > & tempDst = static_cast<Message<Path>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Path::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapRequest::ID:
            {
                GetMapRequestNML & tempSrc = static_cast<GetMapRequestNML&>(src);
                Message<GetMapRequest > & tempDst = static_cast<Message<GetMapRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMapResponse::ID:
            {
                GetMapResponseNML & tempSrc = static_cast<GetMapResponseNML&>(src);
                Message<GetMapResponse > & tempDst = static_cast<Message<GetMapResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMapResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetMap::ID:
            {
                GetMapNML & tempSrc = static_cast<GetMapNML&>(src);
                Message<GetMap > & tempDst = static_cast<Message<GetMap>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetMap::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPlanRequest::ID:
            {
                GetPlanRequestNML & tempSrc = static_cast<GetPlanRequestNML&>(src);
                Message<GetPlanRequest > & tempDst = static_cast<Message<GetPlanRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPlanRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPlanResponse::ID:
            {
                GetPlanResponseNML & tempSrc = static_cast<GetPlanResponseNML&>(src);
                Message<GetPlanResponse > & tempDst = static_cast<Message<GetPlanResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPlanResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPlan::ID:
            {
                GetPlanNML & tempSrc = static_cast<GetPlanNML&>(src);
                Message<GetPlan > & tempDst = static_cast<Message<GetPlan>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPlan::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetMapRequest::ID:
            {
                SetMapRequestNML & tempSrc = static_cast<SetMapRequestNML&>(src);
                Message<SetMapRequest > & tempDst = static_cast<Message<SetMapRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetMapRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetMapResponse::ID:
            {
                SetMapResponseNML & tempSrc = static_cast<SetMapResponseNML&>(src);
                Message<SetMapResponse > & tempDst = static_cast<Message<SetMapResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetMapResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetMap::ID:
            {
                SetMapNML & tempSrc = static_cast<SetMapNML&>(src);
                Message<SetMap > & tempDst = static_cast<Message<SetMap>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetMap::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case GetMapAction::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapAction at %p\n",buffer);
                GetMapActionNML * p = static_cast<GetMapActionNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapActionFeedback at %p\n",buffer);
                GetMapActionFeedbackNML * p = static_cast<GetMapActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapActionGoal at %p\n",buffer);
                GetMapActionGoalNML * p = static_cast<GetMapActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapActionResult at %p\n",buffer);
                GetMapActionResultNML * p = static_cast<GetMapActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapFeedback at %p\n",buffer);
                GetMapFeedbackNML * p = static_cast<GetMapFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapGoal::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapGoal at %p\n",buffer);
                GetMapGoalNML * p = static_cast<GetMapGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapResult::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapResult at %p\n",buffer);
                GetMapResultNML * p = static_cast<GetMapResultNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GridCells::ID:
        {
            // only need to construct if data type is not flat
            if (GridCells::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GridCells at %p\n",buffer);
                GridCellsNML * p = static_cast<GridCellsNML*>(buffer);
                // construct the type at pointer p
                new (p) GridCellsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GridCells at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MapMetaData::ID:
        {
            // only need to construct if data type is not flat
            if (MapMetaData::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MapMetaData at %p\n",buffer);
                MapMetaDataNML * p = static_cast<MapMetaDataNML*>(buffer);
                // construct the type at pointer p
                new (p) MapMetaDataNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MapMetaData at %p,, is flat\n",buffer);
            }
            break;
        } 
        case OccupancyGrid::ID:
        {
            // only need to construct if data type is not flat
            if (OccupancyGrid::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing OccupancyGrid at %p\n",buffer);
                OccupancyGridNML * p = static_cast<OccupancyGridNML*>(buffer);
                // construct the type at pointer p
                new (p) OccupancyGridNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing OccupancyGrid at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Odometry::ID:
        {
            // only need to construct if data type is not flat
            if (Odometry::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Odometry at %p\n",buffer);
                OdometryNML * p = static_cast<OdometryNML*>(buffer);
                // construct the type at pointer p
                new (p) OdometryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Odometry at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Path::ID:
        {
            // only need to construct if data type is not flat
            if (Path::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Path at %p\n",buffer);
                PathNML * p = static_cast<PathNML*>(buffer);
                // construct the type at pointer p
                new (p) PathNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Path at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapRequest at %p\n",buffer);
                GetMapRequestNML * p = static_cast<GetMapRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMapResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetMapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMapResponse at %p\n",buffer);
                GetMapResponseNML * p = static_cast<GetMapResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMapResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetMap::ID:
        {
            // only need to construct if data type is not flat
            if (GetMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetMap at %p\n",buffer);
                GetMapNML * p = static_cast<GetMapNML*>(buffer);
                // construct the type at pointer p
                new (p) GetMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetMap at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPlanRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetPlanRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPlanRequest at %p\n",buffer);
                GetPlanRequestNML * p = static_cast<GetPlanRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPlanRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPlanRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPlanResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetPlanResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPlanResponse at %p\n",buffer);
                GetPlanResponseNML * p = static_cast<GetPlanResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPlanResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPlanResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPlan::ID:
        {
            // only need to construct if data type is not flat
            if (GetPlan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPlan at %p\n",buffer);
                GetPlanNML * p = static_cast<GetPlanNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPlanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPlan at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetMapRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetMapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetMapRequest at %p\n",buffer);
                SetMapRequestNML * p = static_cast<SetMapRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetMapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetMapRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetMapResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetMapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetMapResponse at %p\n",buffer);
                SetMapResponseNML * p = static_cast<SetMapResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetMapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetMapResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetMap::ID:
        {
            // only need to construct if data type is not flat
            if (SetMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetMap at %p\n",buffer);
                SetMapNML * p = static_cast<SetMapNML*>(buffer);
                // construct the type at pointer p
                new (p) SetMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetMap at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int nav_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case GetMapAction::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapAction at %p\n",buffer);
                GetMapActionNML * p = static_cast<GetMapActionNML*>(buffer);
                p->~GetMapActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapActionFeedback at %p\n",buffer);
                GetMapActionFeedbackNML * p = static_cast<GetMapActionFeedbackNML*>(buffer);
                p->~GetMapActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapActionGoal at %p\n",buffer);
                GetMapActionGoalNML * p = static_cast<GetMapActionGoalNML*>(buffer);
                p->~GetMapActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapActionResult at %p\n",buffer);
                GetMapActionResultNML * p = static_cast<GetMapActionResultNML*>(buffer);
                p->~GetMapActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapFeedback at %p\n",buffer);
                GetMapFeedbackNML * p = static_cast<GetMapFeedbackNML*>(buffer);
                p->~GetMapFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapGoal at %p\n",buffer);
                GetMapGoalNML * p = static_cast<GetMapGoalNML*>(buffer);
                p->~GetMapGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapResult::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapResult at %p\n",buffer);
                GetMapResultNML * p = static_cast<GetMapResultNML*>(buffer);
                p->~GetMapResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case GridCells::ID:
        {
            // only need to destruct if data type is not flat
            if (GridCells::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GridCells at %p\n",buffer);
                GridCellsNML * p = static_cast<GridCellsNML*>(buffer);
                p->~GridCellsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GridCells at %p, is flat\n",buffer);
            }
            break;
        } 
        case MapMetaData::ID:
        {
            // only need to destruct if data type is not flat
            if (MapMetaData::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MapMetaData at %p\n",buffer);
                MapMetaDataNML * p = static_cast<MapMetaDataNML*>(buffer);
                p->~MapMetaDataNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MapMetaData at %p, is flat\n",buffer);
            }
            break;
        } 
        case OccupancyGrid::ID:
        {
            // only need to destruct if data type is not flat
            if (OccupancyGrid::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing OccupancyGrid at %p\n",buffer);
                OccupancyGridNML * p = static_cast<OccupancyGridNML*>(buffer);
                p->~OccupancyGridNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction OccupancyGrid at %p, is flat\n",buffer);
            }
            break;
        } 
        case Odometry::ID:
        {
            // only need to destruct if data type is not flat
            if (Odometry::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Odometry at %p\n",buffer);
                OdometryNML * p = static_cast<OdometryNML*>(buffer);
                p->~OdometryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Odometry at %p, is flat\n",buffer);
            }
            break;
        } 
        case Path::ID:
        {
            // only need to destruct if data type is not flat
            if (Path::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Path at %p\n",buffer);
                PathNML * p = static_cast<PathNML*>(buffer);
                p->~PathNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Path at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapRequest at %p\n",buffer);
                GetMapRequestNML * p = static_cast<GetMapRequestNML*>(buffer);
                p->~GetMapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMapResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMapResponse at %p\n",buffer);
                GetMapResponseNML * p = static_cast<GetMapResponseNML*>(buffer);
                p->~GetMapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMapResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetMap::ID:
        {
            // only need to destruct if data type is not flat
            if (GetMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetMap at %p\n",buffer);
                GetMapNML * p = static_cast<GetMapNML*>(buffer);
                p->~GetMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetMap at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPlanRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPlanRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPlanRequest at %p\n",buffer);
                GetPlanRequestNML * p = static_cast<GetPlanRequestNML*>(buffer);
                p->~GetPlanRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPlanRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPlanResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPlanResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPlanResponse at %p\n",buffer);
                GetPlanResponseNML * p = static_cast<GetPlanResponseNML*>(buffer);
                p->~GetPlanResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPlanResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPlan::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPlan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPlan at %p\n",buffer);
                GetPlanNML * p = static_cast<GetPlanNML*>(buffer);
                p->~GetPlanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPlan at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetMapRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetMapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetMapRequest at %p\n",buffer);
                SetMapRequestNML * p = static_cast<SetMapRequestNML*>(buffer);
                p->~SetMapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetMapRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetMapResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetMapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetMapResponse at %p\n",buffer);
                SetMapResponseNML * p = static_cast<SetMapResponseNML*>(buffer);
                p->~SetMapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetMapResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetMap::ID:
        {
            // only need to destruct if data type is not flat
            if (SetMap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetMap at %p\n",buffer);
                SetMapNML * p = static_cast<SetMapNML*>(buffer);
                p->~SetMapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetMap at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void nav_msgs::nmlupdate(CMS * cms, GetMapAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

GetMapActionNML::GetMapActionNML() : NMLmsg((NMLTYPE)GetMapAction::ID,sizeof(GetMapActionNML)), nmlVersion(GetMapAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapAction()*/)
{
};

GetMapActionNML::~GetMapActionNML()
{
};

GetMapActionNML & GetMapActionNML::operator=(const GetMapActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapActionNML & GetMapActionNML::operator=(const GetMapAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapAction> temp(new GetMapAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapAction Message version mismatch, expected " << GetMapAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapAction Message version mismatch, expected " << GetMapAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

GetMapActionFeedbackNML::GetMapActionFeedbackNML() : NMLmsg((NMLTYPE)GetMapActionFeedback::ID,sizeof(GetMapActionFeedbackNML)), nmlVersion(GetMapActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapActionFeedback()*/)
{
};

GetMapActionFeedbackNML::~GetMapActionFeedbackNML()
{
};

GetMapActionFeedbackNML & GetMapActionFeedbackNML::operator=(const GetMapActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapActionFeedbackNML & GetMapActionFeedbackNML::operator=(const GetMapActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapActionFeedback> temp(new GetMapActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapActionFeedback Message version mismatch, expected " << GetMapActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapActionFeedback Message version mismatch, expected " << GetMapActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

GetMapActionGoalNML::GetMapActionGoalNML() : NMLmsg((NMLTYPE)GetMapActionGoal::ID,sizeof(GetMapActionGoalNML)), nmlVersion(GetMapActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapActionGoal()*/)
{
};

GetMapActionGoalNML::~GetMapActionGoalNML()
{
};

GetMapActionGoalNML & GetMapActionGoalNML::operator=(const GetMapActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapActionGoalNML & GetMapActionGoalNML::operator=(const GetMapActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapActionGoal> temp(new GetMapActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapActionGoal Message version mismatch, expected " << GetMapActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapActionGoal Message version mismatch, expected " << GetMapActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

GetMapActionResultNML::GetMapActionResultNML() : NMLmsg((NMLTYPE)GetMapActionResult::ID,sizeof(GetMapActionResultNML)), nmlVersion(GetMapActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapActionResult()*/)
{
};

GetMapActionResultNML::~GetMapActionResultNML()
{
};

GetMapActionResultNML & GetMapActionResultNML::operator=(const GetMapActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapActionResultNML & GetMapActionResultNML::operator=(const GetMapActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapActionResult> temp(new GetMapActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapActionResult Message version mismatch, expected " << GetMapActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapActionResult Message version mismatch, expected " << GetMapActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

GetMapFeedbackNML::GetMapFeedbackNML() : NMLmsg((NMLTYPE)GetMapFeedback::ID,sizeof(GetMapFeedbackNML)), nmlVersion(GetMapFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapFeedback()*/)
{
};

GetMapFeedbackNML::~GetMapFeedbackNML()
{
};

GetMapFeedbackNML & GetMapFeedbackNML::operator=(const GetMapFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapFeedbackNML & GetMapFeedbackNML::operator=(const GetMapFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapFeedback> temp(new GetMapFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapFeedback Message version mismatch, expected " << GetMapFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapFeedback Message version mismatch, expected " << GetMapFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

GetMapGoalNML::GetMapGoalNML() : NMLmsg((NMLTYPE)GetMapGoal::ID,sizeof(GetMapGoalNML)), nmlVersion(GetMapGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapGoal()*/)
{
};

GetMapGoalNML::~GetMapGoalNML()
{
};

GetMapGoalNML & GetMapGoalNML::operator=(const GetMapGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapGoalNML & GetMapGoalNML::operator=(const GetMapGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapGoal> temp(new GetMapGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapGoal Message version mismatch, expected " << GetMapGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapGoal Message version mismatch, expected " << GetMapGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.map);

    }  
 }

GetMapResultNML::GetMapResultNML() : NMLmsg((NMLTYPE)GetMapResult::ID,sizeof(GetMapResultNML)), nmlVersion(GetMapResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapResult()*/)
{
};

GetMapResultNML::~GetMapResultNML()
{
};

GetMapResultNML & GetMapResultNML::operator=(const GetMapResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapResultNML & GetMapResultNML::operator=(const GetMapResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapResult> temp(new GetMapResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapResult Message version mismatch, expected " << GetMapResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapResult Message version mismatch, expected " << GetMapResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GridCells & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GridCells, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.cell_width);
        cms->update(inobj.cell_height);
        nmlupdate(cms,inobj.cells);

    }  
 }

GridCellsNML::GridCellsNML() : NMLmsg((NMLTYPE)GridCells::ID,sizeof(GridCellsNML)), nmlVersion(GridCells::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GridCells()*/)
{
};

GridCellsNML::~GridCellsNML()
{
};

GridCellsNML & GridCellsNML::operator=(const GridCellsNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GridCellsNML & GridCellsNML::operator=(const GridCells & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GridCells);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GridCellsNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GridCells&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GridCellsNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GridCells> temp(new GridCells());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GridCells::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GridCells Message version mismatch, expected " << GridCells::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GridCells Message version mismatch, expected " << GridCells::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, MapMetaData & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MapMetaData, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.map_load_time);
        cms->update(inobj.resolution);
        cms->update(inobj.width);
        cms->update(inobj.height);
        nmlupdate(cms,inobj.origin);

    }  
 }

MapMetaDataNML::MapMetaDataNML() : NMLmsg((NMLTYPE)MapMetaData::ID,sizeof(MapMetaDataNML)), nmlVersion(MapMetaData::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MapMetaData()*/)
{
};

MapMetaDataNML::~MapMetaDataNML()
{
};

MapMetaDataNML & MapMetaDataNML::operator=(const MapMetaDataNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MapMetaDataNML & MapMetaDataNML::operator=(const MapMetaData & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MapMetaData);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MapMetaDataNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MapMetaData&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MapMetaDataNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MapMetaData> temp(new MapMetaData());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MapMetaData::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MapMetaData Message version mismatch, expected " << MapMetaData::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MapMetaData Message version mismatch, expected " << MapMetaData::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, OccupancyGrid & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate OccupancyGrid, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.info);
        nmlupdate(cms,inobj.data);

    }  
 }

OccupancyGridNML::OccupancyGridNML() : NMLmsg((NMLTYPE)OccupancyGrid::ID,sizeof(OccupancyGridNML)), nmlVersion(OccupancyGrid::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new OccupancyGrid()*/)
{
};

OccupancyGridNML::~OccupancyGridNML()
{
};

OccupancyGridNML & OccupancyGridNML::operator=(const OccupancyGridNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

OccupancyGridNML & OccupancyGridNML::operator=(const OccupancyGrid & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(OccupancyGrid);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void OccupancyGridNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<OccupancyGrid&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: OccupancyGridNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<OccupancyGrid> temp(new OccupancyGrid());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (OccupancyGrid::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: OccupancyGrid Message version mismatch, expected " << OccupancyGrid::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: OccupancyGrid Message version mismatch, expected " << OccupancyGrid::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, Odometry & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Odometry, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.child_frame_id);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);

    }  
 }

OdometryNML::OdometryNML() : NMLmsg((NMLTYPE)Odometry::ID,sizeof(OdometryNML)), nmlVersion(Odometry::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Odometry()*/)
{
};

OdometryNML::~OdometryNML()
{
};

OdometryNML & OdometryNML::operator=(const OdometryNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

OdometryNML & OdometryNML::operator=(const Odometry & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Odometry);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void OdometryNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Odometry&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: OdometryNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Odometry> temp(new Odometry());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Odometry::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Odometry Message version mismatch, expected " << Odometry::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Odometry Message version mismatch, expected " << Odometry::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, Path & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Path, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.poses);

    }  
 }

PathNML::PathNML() : NMLmsg((NMLTYPE)Path::ID,sizeof(PathNML)), nmlVersion(Path::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Path()*/)
{
};

PathNML::~PathNML()
{
};

PathNML & PathNML::operator=(const PathNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PathNML & PathNML::operator=(const Path & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Path);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PathNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Path&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PathNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Path> temp(new Path());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Path::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Path Message version mismatch, expected " << Path::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Path Message version mismatch, expected " << Path::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

GetMapRequestNML::GetMapRequestNML() : NMLmsg((NMLTYPE)GetMapRequest::ID,sizeof(GetMapRequestNML)), nmlVersion(GetMapRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapRequest()*/)
{
};

GetMapRequestNML::~GetMapRequestNML()
{
};

GetMapRequestNML & GetMapRequestNML::operator=(const GetMapRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapRequestNML & GetMapRequestNML::operator=(const GetMapRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapRequest> temp(new GetMapRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapRequest Message version mismatch, expected " << GetMapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapRequest Message version mismatch, expected " << GetMapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMapResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMapResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.map);

    }  
 }

GetMapResponseNML::GetMapResponseNML() : NMLmsg((NMLTYPE)GetMapResponse::ID,sizeof(GetMapResponseNML)), nmlVersion(GetMapResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMapResponse()*/)
{
};

GetMapResponseNML::~GetMapResponseNML()
{
};

GetMapResponseNML & GetMapResponseNML::operator=(const GetMapResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapResponseNML & GetMapResponseNML::operator=(const GetMapResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMapResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMapResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMapResponse> temp(new GetMapResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMapResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMapResponse Message version mismatch, expected " << GetMapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMapResponse Message version mismatch, expected " << GetMapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetMap & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetMap, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetMapNML::GetMapNML() : NMLmsg((NMLTYPE)GetMap::ID,sizeof(GetMapNML)), nmlVersion(GetMap::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetMap()*/)
{
};

GetMapNML::~GetMapNML()
{
};

GetMapNML & GetMapNML::operator=(const GetMapNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetMapNML & GetMapNML::operator=(const GetMap & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetMap);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetMapNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetMap&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetMapNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetMap> temp(new GetMap());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetMap::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetMap Message version mismatch, expected " << GetMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetMap Message version mismatch, expected " << GetMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetPlanRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPlanRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.start);
        nmlupdate(cms,inobj.goal);
        cms->update(inobj.tolerance);

    }  
 }

GetPlanRequestNML::GetPlanRequestNML() : NMLmsg((NMLTYPE)GetPlanRequest::ID,sizeof(GetPlanRequestNML)), nmlVersion(GetPlanRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPlanRequest()*/)
{
};

GetPlanRequestNML::~GetPlanRequestNML()
{
};

GetPlanRequestNML & GetPlanRequestNML::operator=(const GetPlanRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPlanRequestNML & GetPlanRequestNML::operator=(const GetPlanRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPlanRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPlanRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPlanRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPlanRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPlanRequest> temp(new GetPlanRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPlanRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPlanRequest Message version mismatch, expected " << GetPlanRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPlanRequest Message version mismatch, expected " << GetPlanRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetPlanResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPlanResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.plan);

    }  
 }

GetPlanResponseNML::GetPlanResponseNML() : NMLmsg((NMLTYPE)GetPlanResponse::ID,sizeof(GetPlanResponseNML)), nmlVersion(GetPlanResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPlanResponse()*/)
{
};

GetPlanResponseNML::~GetPlanResponseNML()
{
};

GetPlanResponseNML & GetPlanResponseNML::operator=(const GetPlanResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPlanResponseNML & GetPlanResponseNML::operator=(const GetPlanResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPlanResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPlanResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPlanResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPlanResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPlanResponse> temp(new GetPlanResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPlanResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPlanResponse Message version mismatch, expected " << GetPlanResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPlanResponse Message version mismatch, expected " << GetPlanResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, GetPlan & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPlan, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetPlanNML::GetPlanNML() : NMLmsg((NMLTYPE)GetPlan::ID,sizeof(GetPlanNML)), nmlVersion(GetPlan::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPlan()*/)
{
};

GetPlanNML::~GetPlanNML()
{
};

GetPlanNML & GetPlanNML::operator=(const GetPlanNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPlanNML & GetPlanNML::operator=(const GetPlan & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPlan);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPlanNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPlan&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPlanNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPlan> temp(new GetPlan());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPlan::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPlan Message version mismatch, expected " << GetPlan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPlan Message version mismatch, expected " << GetPlan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, SetMapRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetMapRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.map);
        nmlupdate(cms,inobj.initial_pose);

    }  
 }

SetMapRequestNML::SetMapRequestNML() : NMLmsg((NMLTYPE)SetMapRequest::ID,sizeof(SetMapRequestNML)), nmlVersion(SetMapRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetMapRequest()*/)
{
};

SetMapRequestNML::~SetMapRequestNML()
{
};

SetMapRequestNML & SetMapRequestNML::operator=(const SetMapRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetMapRequestNML & SetMapRequestNML::operator=(const SetMapRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetMapRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetMapRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetMapRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetMapRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetMapRequest> temp(new SetMapRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetMapRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetMapRequest Message version mismatch, expected " << SetMapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetMapRequest Message version mismatch, expected " << SetMapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, SetMapResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetMapResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);

    }  
 }

SetMapResponseNML::SetMapResponseNML() : NMLmsg((NMLTYPE)SetMapResponse::ID,sizeof(SetMapResponseNML)), nmlVersion(SetMapResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetMapResponse()*/)
{
};

SetMapResponseNML::~SetMapResponseNML()
{
};

SetMapResponseNML & SetMapResponseNML::operator=(const SetMapResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetMapResponseNML & SetMapResponseNML::operator=(const SetMapResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetMapResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetMapResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetMapResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetMapResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetMapResponse> temp(new SetMapResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetMapResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetMapResponse Message version mismatch, expected " << SetMapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetMapResponse Message version mismatch, expected " << SetMapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nav_msgs::nmlupdate(CMS * cms, SetMap & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetMap, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetMapNML::SetMapNML() : NMLmsg((NMLTYPE)SetMap::ID,sizeof(SetMapNML)), nmlVersion(SetMap::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetMap()*/)
{
};

SetMapNML::~SetMapNML()
{
};

SetMapNML & SetMapNML::operator=(const SetMapNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetMapNML & SetMapNML::operator=(const SetMap & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetMap);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetMapNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetMap&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetMapNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetMap> temp(new SetMap());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nav_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetMap::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetMap Message version mismatch, expected " << SetMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetMap Message version mismatch, expected " << SetMap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int nav_msgs::nav_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("nav_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case GetMapAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapAction, id " << GetMapAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapActionFeedback, id " << GetMapActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapActionGoal, id " << GetMapActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapActionResult, id " << GetMapActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapFeedback, id " << GetMapFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapGoal, id " << GetMapGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapResult, id " << GetMapResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GridCells::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GridCells, id " << GridCells::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GridCellsNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MapMetaData::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MapMetaData, id " << MapMetaData::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MapMetaDataNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case OccupancyGrid::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for OccupancyGrid, id " << OccupancyGrid::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((OccupancyGridNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Odometry::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Odometry, id " << Odometry::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((OdometryNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Path::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Path, id " << Path::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PathNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapRequest, id " << GetMapRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMapResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMapResponse, id " << GetMapResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetMap::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetMap, id " << GetMap::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetMapNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPlanRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPlanRequest, id " << GetPlanRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPlanRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPlanResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPlanResponse, id " << GetPlanResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPlanResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPlan::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPlan, id " << GetPlan::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPlanNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetMapRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetMapRequest, id " << SetMapRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetMapRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetMapResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetMapResponse, id " << SetMapResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetMapResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetMap::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetMap, id " << SetMap::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nav_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nav_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetMapNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

