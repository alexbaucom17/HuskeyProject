// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:52 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "nodelet_gencpp_NML.h"
#include "nodelet_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <NodeletListRequest.h>
#include <NodeletListResponse.h>
#include <NodeletList.h>
#include <NodeletLoadRequest.h>
#include <NodeletLoadResponse.h>
#include <NodeletLoad.h>
#include <NodeletUnloadRequest.h>
#include <NodeletUnloadResponse.h>
#include <NodeletUnload.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace nodelet;

rframe::NMLMessageFactory * NML_nodelet_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_nodelet_gencppfactory = new nodelet_gencppNMLMessageFactory();
        return NML_nodelet_gencppfactory;
    };
}

rframe::NMLMessageFactory * nodelet::allocate_nodelet_gencpp()
{
    NML_nodelet_gencppfactory = new nodelet_gencppNMLMessageFactory();
    return NML_nodelet_gencppfactory;
};

nodelet_gencppNMLMessageFactory::nodelet_gencppNMLMessageFactory()
{
    name("nodelet_gencpp");
    // use constructor to register data types
    nodelet::registerLibrary();
}

nodelet_gencppNMLMessageFactory::~nodelet_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR nodelet_gencppNMLMessageFactory::FormatPointer()
{
    return nodelet_gencpp_format;
}

int nodelet_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void nodelet_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(NodeletListRequest::ID);
    info.name(NodeletListRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletListRequest::DATA_VERSION);
    info.md5Key(NodeletListRequest::VERSION_MD5);
    info.xmlSource(NodeletListRequest::XML_SOURCE);
    info.flat(NodeletListRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletListResponse::ID);
    info.name(NodeletListResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletListResponse::DATA_VERSION);
    info.md5Key(NodeletListResponse::VERSION_MD5);
    info.xmlSource(NodeletListResponse::XML_SOURCE);
    info.flat(NodeletListResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletList::ID);
    info.name(NodeletList::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletList::DATA_VERSION);
    info.md5Key(NodeletList::VERSION_MD5);
    info.xmlSource(NodeletList::XML_SOURCE);
    info.flat(NodeletList::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletLoadRequest::ID);
    info.name(NodeletLoadRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletLoadRequest::DATA_VERSION);
    info.md5Key(NodeletLoadRequest::VERSION_MD5);
    info.xmlSource(NodeletLoadRequest::XML_SOURCE);
    info.flat(NodeletLoadRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletLoadResponse::ID);
    info.name(NodeletLoadResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletLoadResponse::DATA_VERSION);
    info.md5Key(NodeletLoadResponse::VERSION_MD5);
    info.xmlSource(NodeletLoadResponse::XML_SOURCE);
    info.flat(NodeletLoadResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletLoad::ID);
    info.name(NodeletLoad::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletLoad::DATA_VERSION);
    info.md5Key(NodeletLoad::VERSION_MD5);
    info.xmlSource(NodeletLoad::XML_SOURCE);
    info.flat(NodeletLoad::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletUnloadRequest::ID);
    info.name(NodeletUnloadRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletUnloadRequest::DATA_VERSION);
    info.md5Key(NodeletUnloadRequest::VERSION_MD5);
    info.xmlSource(NodeletUnloadRequest::XML_SOURCE);
    info.flat(NodeletUnloadRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletUnloadResponse::ID);
    info.name(NodeletUnloadResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletUnloadResponse::DATA_VERSION);
    info.md5Key(NodeletUnloadResponse::VERSION_MD5);
    info.xmlSource(NodeletUnloadResponse::XML_SOURCE);
    info.flat(NodeletUnloadResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletUnload::ID);
    info.name(NodeletUnload::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletUnload::DATA_VERSION);
    info.md5Key(NodeletUnload::VERSION_MD5);
    info.xmlSource(NodeletUnload::XML_SOURCE);
    info.flat(NodeletUnload::dataTypeFlat());
    ids.push_back(info);

}

int nodelet_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case NodeletListRequest::ID:
        {
            //NodeletListRequestNML * newmsg = new NodeletListRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletListRequestNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletListResponse::ID:
        {
            //NodeletListResponseNML * newmsg = new NodeletListResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletListResponseNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletList::ID:
        {
            //NodeletListNML * newmsg = new NodeletListNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletListNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletLoadRequest::ID:
        {
            //NodeletLoadRequestNML * newmsg = new NodeletLoadRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletLoadRequestNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletLoadResponse::ID:
        {
            //NodeletLoadResponseNML * newmsg = new NodeletLoadResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletLoadResponseNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletLoad::ID:
        {
            //NodeletLoadNML * newmsg = new NodeletLoadNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletLoadNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletUnloadRequest::ID:
        {
            //NodeletUnloadRequestNML * newmsg = new NodeletUnloadRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletUnloadRequestNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletUnloadResponse::ID:
        {
            //NodeletUnloadResponseNML * newmsg = new NodeletUnloadResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletUnloadResponseNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case NodeletUnload::ID:
        {
            //NodeletUnloadNML * newmsg = new NodeletUnloadNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new NodeletUnloadNML(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int nodelet_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case NodeletListRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletListRequest>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletListResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletListResponse>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletList::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletList>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletLoadRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletLoadRequest>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletLoadResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletLoadResponse>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletLoad::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletLoad>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletUnloadRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletUnloadRequest>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletUnloadResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletUnloadResponse>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletUnload::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletUnload>(),std::bind(&nodelet_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int nodelet_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int nodelet_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case NodeletListRequest::ID:
            {
                NodeletListRequestNML * tempmsg = static_cast<NodeletListRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletListResponse::ID:
            {
                NodeletListResponseNML * tempmsg = static_cast<NodeletListResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletList::ID:
            {
                NodeletListNML * tempmsg = static_cast<NodeletListNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletLoadRequest::ID:
            {
                NodeletLoadRequestNML * tempmsg = static_cast<NodeletLoadRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletLoadResponse::ID:
            {
                NodeletLoadResponseNML * tempmsg = static_cast<NodeletLoadResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletLoad::ID:
            {
                NodeletLoadNML * tempmsg = static_cast<NodeletLoadNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletUnloadRequest::ID:
            {
                NodeletUnloadRequestNML * tempmsg = static_cast<NodeletUnloadRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletUnloadResponse::ID:
            {
                NodeletUnloadResponseNML * tempmsg = static_cast<NodeletUnloadResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case NodeletUnload::ID:
            {
                NodeletUnloadNML * tempmsg = static_cast<NodeletUnloadNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int nodelet_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case NodeletListRequest::ID:
            {
                NodeletListRequestNML & tempDst = static_cast<NodeletListRequestNML&>(dst);
                Message<NodeletListRequest > & tempSrc = static_cast<Message<NodeletListRequest>&>(src);

                if (tempSrc.version() != NodeletListRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletListRequest: " << __FILE__ << " expected: " 
                             << NodeletListRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletListRequest: " << __FILE__ << " expected: " 
                         << NodeletListRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletListResponse::ID:
            {
                NodeletListResponseNML & tempDst = static_cast<NodeletListResponseNML&>(dst);
                Message<NodeletListResponse > & tempSrc = static_cast<Message<NodeletListResponse>&>(src);

                if (tempSrc.version() != NodeletListResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletListResponse: " << __FILE__ << " expected: " 
                             << NodeletListResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletListResponse: " << __FILE__ << " expected: " 
                         << NodeletListResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletList::ID:
            {
                NodeletListNML & tempDst = static_cast<NodeletListNML&>(dst);
                Message<NodeletList > & tempSrc = static_cast<Message<NodeletList>&>(src);

                if (tempSrc.version() != NodeletList::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletList: " << __FILE__ << " expected: " 
                             << NodeletList::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletList: " << __FILE__ << " expected: " 
                         << NodeletList::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletLoadRequest::ID:
            {
                NodeletLoadRequestNML & tempDst = static_cast<NodeletLoadRequestNML&>(dst);
                Message<NodeletLoadRequest > & tempSrc = static_cast<Message<NodeletLoadRequest>&>(src);

                if (tempSrc.version() != NodeletLoadRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletLoadRequest: " << __FILE__ << " expected: " 
                             << NodeletLoadRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletLoadRequest: " << __FILE__ << " expected: " 
                         << NodeletLoadRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletLoadResponse::ID:
            {
                NodeletLoadResponseNML & tempDst = static_cast<NodeletLoadResponseNML&>(dst);
                Message<NodeletLoadResponse > & tempSrc = static_cast<Message<NodeletLoadResponse>&>(src);

                if (tempSrc.version() != NodeletLoadResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletLoadResponse: " << __FILE__ << " expected: " 
                             << NodeletLoadResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletLoadResponse: " << __FILE__ << " expected: " 
                         << NodeletLoadResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletLoad::ID:
            {
                NodeletLoadNML & tempDst = static_cast<NodeletLoadNML&>(dst);
                Message<NodeletLoad > & tempSrc = static_cast<Message<NodeletLoad>&>(src);

                if (tempSrc.version() != NodeletLoad::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletLoad: " << __FILE__ << " expected: " 
                             << NodeletLoad::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletLoad: " << __FILE__ << " expected: " 
                         << NodeletLoad::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletUnloadRequest::ID:
            {
                NodeletUnloadRequestNML & tempDst = static_cast<NodeletUnloadRequestNML&>(dst);
                Message<NodeletUnloadRequest > & tempSrc = static_cast<Message<NodeletUnloadRequest>&>(src);

                if (tempSrc.version() != NodeletUnloadRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletUnloadRequest: " << __FILE__ << " expected: " 
                             << NodeletUnloadRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletUnloadRequest: " << __FILE__ << " expected: " 
                         << NodeletUnloadRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletUnloadResponse::ID:
            {
                NodeletUnloadResponseNML & tempDst = static_cast<NodeletUnloadResponseNML&>(dst);
                Message<NodeletUnloadResponse > & tempSrc = static_cast<Message<NodeletUnloadResponse>&>(src);

                if (tempSrc.version() != NodeletUnloadResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletUnloadResponse: " << __FILE__ << " expected: " 
                             << NodeletUnloadResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletUnloadResponse: " << __FILE__ << " expected: " 
                         << NodeletUnloadResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case NodeletUnload::ID:
            {
                NodeletUnloadNML & tempDst = static_cast<NodeletUnloadNML&>(dst);
                Message<NodeletUnload > & tempSrc = static_cast<Message<NodeletUnload>&>(src);

                if (tempSrc.version() != NodeletUnload::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of NodeletUnload: " << __FILE__ << " expected: " 
                             << NodeletUnload::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of NodeletUnload: " << __FILE__ << " expected: " 
                         << NodeletUnload::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int nodelet_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case NodeletListRequest::ID:
            {
                NodeletListRequestNML & tempSrc = static_cast<NodeletListRequestNML&>(src);
                Message<NodeletListRequest > & tempDst = static_cast<Message<NodeletListRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletListRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletListResponse::ID:
            {
                NodeletListResponseNML & tempSrc = static_cast<NodeletListResponseNML&>(src);
                Message<NodeletListResponse > & tempDst = static_cast<Message<NodeletListResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletListResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletList::ID:
            {
                NodeletListNML & tempSrc = static_cast<NodeletListNML&>(src);
                Message<NodeletList > & tempDst = static_cast<Message<NodeletList>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletList::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletLoadRequest::ID:
            {
                NodeletLoadRequestNML & tempSrc = static_cast<NodeletLoadRequestNML&>(src);
                Message<NodeletLoadRequest > & tempDst = static_cast<Message<NodeletLoadRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletLoadRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletLoadResponse::ID:
            {
                NodeletLoadResponseNML & tempSrc = static_cast<NodeletLoadResponseNML&>(src);
                Message<NodeletLoadResponse > & tempDst = static_cast<Message<NodeletLoadResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletLoadResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletLoad::ID:
            {
                NodeletLoadNML & tempSrc = static_cast<NodeletLoadNML&>(src);
                Message<NodeletLoad > & tempDst = static_cast<Message<NodeletLoad>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletLoad::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletUnloadRequest::ID:
            {
                NodeletUnloadRequestNML & tempSrc = static_cast<NodeletUnloadRequestNML&>(src);
                Message<NodeletUnloadRequest > & tempDst = static_cast<Message<NodeletUnloadRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletUnloadRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletUnloadResponse::ID:
            {
                NodeletUnloadResponseNML & tempSrc = static_cast<NodeletUnloadResponseNML&>(src);
                Message<NodeletUnloadResponse > & tempDst = static_cast<Message<NodeletUnloadResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletUnloadResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case NodeletUnload::ID:
            {
                NodeletUnloadNML & tempSrc = static_cast<NodeletUnloadNML&>(src);
                Message<NodeletUnload > & tempDst = static_cast<Message<NodeletUnload>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (NodeletUnload::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int nodelet_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case NodeletListRequest::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletListRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletListRequest at %p\n",buffer);
                NodeletListRequestNML * p = static_cast<NodeletListRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletListRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletListRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletListResponse::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletListResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletListResponse at %p\n",buffer);
                NodeletListResponseNML * p = static_cast<NodeletListResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletListResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletListResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletList::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletList::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletList at %p\n",buffer);
                NodeletListNML * p = static_cast<NodeletListNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletListNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletList at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletLoadRequest::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletLoadRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletLoadRequest at %p\n",buffer);
                NodeletLoadRequestNML * p = static_cast<NodeletLoadRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletLoadRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletLoadRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletLoadResponse::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletLoadResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletLoadResponse at %p\n",buffer);
                NodeletLoadResponseNML * p = static_cast<NodeletLoadResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletLoadResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletLoadResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletLoad::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletLoad::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletLoad at %p\n",buffer);
                NodeletLoadNML * p = static_cast<NodeletLoadNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletLoadNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletLoad at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletUnloadRequest::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletUnloadRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletUnloadRequest at %p\n",buffer);
                NodeletUnloadRequestNML * p = static_cast<NodeletUnloadRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletUnloadRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletUnloadRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletUnloadResponse::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletUnloadResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletUnloadResponse at %p\n",buffer);
                NodeletUnloadResponseNML * p = static_cast<NodeletUnloadResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletUnloadResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletUnloadResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case NodeletUnload::ID:
        {
            // only need to construct if data type is not flat
            if (NodeletUnload::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing NodeletUnload at %p\n",buffer);
                NodeletUnloadNML * p = static_cast<NodeletUnloadNML*>(buffer);
                // construct the type at pointer p
                new (p) NodeletUnloadNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing NodeletUnload at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int nodelet_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case NodeletListRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletListRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletListRequest at %p\n",buffer);
                NodeletListRequestNML * p = static_cast<NodeletListRequestNML*>(buffer);
                p->~NodeletListRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletListRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletListResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletListResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletListResponse at %p\n",buffer);
                NodeletListResponseNML * p = static_cast<NodeletListResponseNML*>(buffer);
                p->~NodeletListResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletListResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletList::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletList::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletList at %p\n",buffer);
                NodeletListNML * p = static_cast<NodeletListNML*>(buffer);
                p->~NodeletListNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletList at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletLoadRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletLoadRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletLoadRequest at %p\n",buffer);
                NodeletLoadRequestNML * p = static_cast<NodeletLoadRequestNML*>(buffer);
                p->~NodeletLoadRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletLoadRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletLoadResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletLoadResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletLoadResponse at %p\n",buffer);
                NodeletLoadResponseNML * p = static_cast<NodeletLoadResponseNML*>(buffer);
                p->~NodeletLoadResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletLoadResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletLoad::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletLoad::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletLoad at %p\n",buffer);
                NodeletLoadNML * p = static_cast<NodeletLoadNML*>(buffer);
                p->~NodeletLoadNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletLoad at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletUnloadRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletUnloadRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletUnloadRequest at %p\n",buffer);
                NodeletUnloadRequestNML * p = static_cast<NodeletUnloadRequestNML*>(buffer);
                p->~NodeletUnloadRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletUnloadRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletUnloadResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletUnloadResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletUnloadResponse at %p\n",buffer);
                NodeletUnloadResponseNML * p = static_cast<NodeletUnloadResponseNML*>(buffer);
                p->~NodeletUnloadResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletUnloadResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case NodeletUnload::ID:
        {
            // only need to destruct if data type is not flat
            if (NodeletUnload::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing NodeletUnload at %p\n",buffer);
                NodeletUnloadNML * p = static_cast<NodeletUnloadNML*>(buffer);
                p->~NodeletUnloadNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction NodeletUnload at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void nodelet::nmlupdate(CMS * cms, NodeletListRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletListRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

NodeletListRequestNML::NodeletListRequestNML() : NMLmsg((NMLTYPE)NodeletListRequest::ID,sizeof(NodeletListRequestNML)), nmlVersion(NodeletListRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletListRequest()*/)
{
};

NodeletListRequestNML::~NodeletListRequestNML()
{
};

NodeletListRequestNML & NodeletListRequestNML::operator=(const NodeletListRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletListRequestNML & NodeletListRequestNML::operator=(const NodeletListRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletListRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletListRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletListRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletListRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletListRequest> temp(new NodeletListRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletListRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletListRequest Message version mismatch, expected " << NodeletListRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletListRequest Message version mismatch, expected " << NodeletListRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletListResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletListResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.nodelets);

    }  
 }

NodeletListResponseNML::NodeletListResponseNML() : NMLmsg((NMLTYPE)NodeletListResponse::ID,sizeof(NodeletListResponseNML)), nmlVersion(NodeletListResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletListResponse()*/)
{
};

NodeletListResponseNML::~NodeletListResponseNML()
{
};

NodeletListResponseNML & NodeletListResponseNML::operator=(const NodeletListResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletListResponseNML & NodeletListResponseNML::operator=(const NodeletListResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletListResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletListResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletListResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletListResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletListResponse> temp(new NodeletListResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletListResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletListResponse Message version mismatch, expected " << NodeletListResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletListResponse Message version mismatch, expected " << NodeletListResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletList & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletList, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

NodeletListNML::NodeletListNML() : NMLmsg((NMLTYPE)NodeletList::ID,sizeof(NodeletListNML)), nmlVersion(NodeletList::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletList()*/)
{
};

NodeletListNML::~NodeletListNML()
{
};

NodeletListNML & NodeletListNML::operator=(const NodeletListNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletListNML & NodeletListNML::operator=(const NodeletList & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletList);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletListNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletList&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletListNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletList> temp(new NodeletList());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletList::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletList Message version mismatch, expected " << NodeletList::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletList Message version mismatch, expected " << NodeletList::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletLoadRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletLoadRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.type);
        nmlupdate(cms,inobj.remap_source_args);
        nmlupdate(cms,inobj.remap_target_args);
        nmlupdate(cms,inobj.my_argv);
        nmlupdate(cms,inobj.bond_id);

    }  
 }

NodeletLoadRequestNML::NodeletLoadRequestNML() : NMLmsg((NMLTYPE)NodeletLoadRequest::ID,sizeof(NodeletLoadRequestNML)), nmlVersion(NodeletLoadRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletLoadRequest()*/)
{
};

NodeletLoadRequestNML::~NodeletLoadRequestNML()
{
};

NodeletLoadRequestNML & NodeletLoadRequestNML::operator=(const NodeletLoadRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletLoadRequestNML & NodeletLoadRequestNML::operator=(const NodeletLoadRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletLoadRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletLoadRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletLoadRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletLoadRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletLoadRequest> temp(new NodeletLoadRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletLoadRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletLoadRequest Message version mismatch, expected " << NodeletLoadRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletLoadRequest Message version mismatch, expected " << NodeletLoadRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletLoadResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletLoadResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);

    }  
 }

NodeletLoadResponseNML::NodeletLoadResponseNML() : NMLmsg((NMLTYPE)NodeletLoadResponse::ID,sizeof(NodeletLoadResponseNML)), nmlVersion(NodeletLoadResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletLoadResponse()*/)
{
};

NodeletLoadResponseNML::~NodeletLoadResponseNML()
{
};

NodeletLoadResponseNML & NodeletLoadResponseNML::operator=(const NodeletLoadResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletLoadResponseNML & NodeletLoadResponseNML::operator=(const NodeletLoadResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletLoadResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletLoadResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletLoadResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletLoadResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletLoadResponse> temp(new NodeletLoadResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletLoadResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletLoadResponse Message version mismatch, expected " << NodeletLoadResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletLoadResponse Message version mismatch, expected " << NodeletLoadResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletLoad & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletLoad, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

NodeletLoadNML::NodeletLoadNML() : NMLmsg((NMLTYPE)NodeletLoad::ID,sizeof(NodeletLoadNML)), nmlVersion(NodeletLoad::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletLoad()*/)
{
};

NodeletLoadNML::~NodeletLoadNML()
{
};

NodeletLoadNML & NodeletLoadNML::operator=(const NodeletLoadNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletLoadNML & NodeletLoadNML::operator=(const NodeletLoad & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletLoad);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletLoadNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletLoad&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletLoadNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletLoad> temp(new NodeletLoad());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletLoad::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletLoad Message version mismatch, expected " << NodeletLoad::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletLoad Message version mismatch, expected " << NodeletLoad::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletUnloadRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletUnloadRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);

    }  
 }

NodeletUnloadRequestNML::NodeletUnloadRequestNML() : NMLmsg((NMLTYPE)NodeletUnloadRequest::ID,sizeof(NodeletUnloadRequestNML)), nmlVersion(NodeletUnloadRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletUnloadRequest()*/)
{
};

NodeletUnloadRequestNML::~NodeletUnloadRequestNML()
{
};

NodeletUnloadRequestNML & NodeletUnloadRequestNML::operator=(const NodeletUnloadRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletUnloadRequestNML & NodeletUnloadRequestNML::operator=(const NodeletUnloadRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletUnloadRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletUnloadRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletUnloadRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletUnloadRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletUnloadRequest> temp(new NodeletUnloadRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletUnloadRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletUnloadRequest Message version mismatch, expected " << NodeletUnloadRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletUnloadRequest Message version mismatch, expected " << NodeletUnloadRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletUnloadResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletUnloadResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);

    }  
 }

NodeletUnloadResponseNML::NodeletUnloadResponseNML() : NMLmsg((NMLTYPE)NodeletUnloadResponse::ID,sizeof(NodeletUnloadResponseNML)), nmlVersion(NodeletUnloadResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletUnloadResponse()*/)
{
};

NodeletUnloadResponseNML::~NodeletUnloadResponseNML()
{
};

NodeletUnloadResponseNML & NodeletUnloadResponseNML::operator=(const NodeletUnloadResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletUnloadResponseNML & NodeletUnloadResponseNML::operator=(const NodeletUnloadResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletUnloadResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletUnloadResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletUnloadResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletUnloadResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletUnloadResponse> temp(new NodeletUnloadResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletUnloadResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletUnloadResponse Message version mismatch, expected " << NodeletUnloadResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletUnloadResponse Message version mismatch, expected " << NodeletUnloadResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void nodelet::nmlupdate(CMS * cms, NodeletUnload & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate NodeletUnload, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

NodeletUnloadNML::NodeletUnloadNML() : NMLmsg((NMLTYPE)NodeletUnload::ID,sizeof(NodeletUnloadNML)), nmlVersion(NodeletUnload::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new NodeletUnload()*/)
{
};

NodeletUnloadNML::~NodeletUnloadNML()
{
};

NodeletUnloadNML & NodeletUnloadNML::operator=(const NodeletUnloadNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

NodeletUnloadNML & NodeletUnloadNML::operator=(const NodeletUnload & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(NodeletUnload);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void NodeletUnloadNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<NodeletUnload&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: NodeletUnloadNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<NodeletUnload> temp(new NodeletUnload());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: nodelet_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (NodeletUnload::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: NodeletUnload Message version mismatch, expected " << NodeletUnload::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: NodeletUnload Message version mismatch, expected " << NodeletUnload::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int nodelet::nodelet_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("nodelet_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case NodeletListRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletListRequest, id " << NodeletListRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletListRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletListResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletListResponse, id " << NodeletListResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletListResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletList::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletList, id " << NodeletList::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletListNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletLoadRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletLoadRequest, id " << NodeletLoadRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletLoadRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletLoadResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletLoadResponse, id " << NodeletLoadResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletLoadResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletLoad::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletLoad, id " << NodeletLoad::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletLoadNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletUnloadRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletUnloadRequest, id " << NodeletUnloadRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletUnloadRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletUnloadResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletUnloadResponse, id " << NodeletUnloadResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletUnloadResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case NodeletUnload::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for NodeletUnload, id " << NodeletUnload::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_nodelet_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"nodelet_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((NodeletUnloadNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

