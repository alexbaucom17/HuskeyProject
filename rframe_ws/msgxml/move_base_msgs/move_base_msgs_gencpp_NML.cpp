// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:06 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "move_base_msgs_gencpp_NML.h"
#include "move_base_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <MoveBaseAction.h>
#include <MoveBaseActionFeedback.h>
#include <MoveBaseActionGoal.h>
#include <MoveBaseActionResult.h>
#include <MoveBaseFeedback.h>
#include <MoveBaseGoal.h>
#include <MoveBaseResult.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace move_base_msgs;

rframe::NMLMessageFactory * NML_move_base_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_move_base_msgs_gencppfactory = new move_base_msgs_gencppNMLMessageFactory();
        return NML_move_base_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * move_base_msgs::allocate_move_base_msgs_gencpp()
{
    NML_move_base_msgs_gencppfactory = new move_base_msgs_gencppNMLMessageFactory();
    return NML_move_base_msgs_gencppfactory;
};

move_base_msgs_gencppNMLMessageFactory::move_base_msgs_gencppNMLMessageFactory()
{
    name("move_base_msgs_gencpp");
    // use constructor to register data types
    move_base_msgs::registerLibrary();
}

move_base_msgs_gencppNMLMessageFactory::~move_base_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR move_base_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return move_base_msgs_gencpp_format;
}

int move_base_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void move_base_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(MoveBaseAction::ID);
    info.name(MoveBaseAction::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseAction::DATA_VERSION);
    info.md5Key(MoveBaseAction::VERSION_MD5);
    info.xmlSource(MoveBaseAction::XML_SOURCE);
    info.flat(MoveBaseAction::dataTypeFlat());
    ids.push_back(info);

    info.id(MoveBaseActionFeedback::ID);
    info.name(MoveBaseActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseActionFeedback::DATA_VERSION);
    info.md5Key(MoveBaseActionFeedback::VERSION_MD5);
    info.xmlSource(MoveBaseActionFeedback::XML_SOURCE);
    info.flat(MoveBaseActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(MoveBaseActionGoal::ID);
    info.name(MoveBaseActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseActionGoal::DATA_VERSION);
    info.md5Key(MoveBaseActionGoal::VERSION_MD5);
    info.xmlSource(MoveBaseActionGoal::XML_SOURCE);
    info.flat(MoveBaseActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(MoveBaseActionResult::ID);
    info.name(MoveBaseActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseActionResult::DATA_VERSION);
    info.md5Key(MoveBaseActionResult::VERSION_MD5);
    info.xmlSource(MoveBaseActionResult::XML_SOURCE);
    info.flat(MoveBaseActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(MoveBaseFeedback::ID);
    info.name(MoveBaseFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseFeedback::DATA_VERSION);
    info.md5Key(MoveBaseFeedback::VERSION_MD5);
    info.xmlSource(MoveBaseFeedback::XML_SOURCE);
    info.flat(MoveBaseFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(MoveBaseGoal::ID);
    info.name(MoveBaseGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseGoal::DATA_VERSION);
    info.md5Key(MoveBaseGoal::VERSION_MD5);
    info.xmlSource(MoveBaseGoal::XML_SOURCE);
    info.flat(MoveBaseGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(MoveBaseResult::ID);
    info.name(MoveBaseResult::DATA_TYPE_FULL_NAME);
    info.hashKey(MoveBaseResult::DATA_VERSION);
    info.md5Key(MoveBaseResult::VERSION_MD5);
    info.xmlSource(MoveBaseResult::XML_SOURCE);
    info.flat(MoveBaseResult::dataTypeFlat());
    ids.push_back(info);

}

int move_base_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case MoveBaseAction::ID:
        {
            //MoveBaseActionNML * newmsg = new MoveBaseActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseActionNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MoveBaseActionFeedback::ID:
        {
            //MoveBaseActionFeedbackNML * newmsg = new MoveBaseActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseActionFeedbackNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MoveBaseActionGoal::ID:
        {
            //MoveBaseActionGoalNML * newmsg = new MoveBaseActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseActionGoalNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MoveBaseActionResult::ID:
        {
            //MoveBaseActionResultNML * newmsg = new MoveBaseActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseActionResultNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MoveBaseFeedback::ID:
        {
            //MoveBaseFeedbackNML * newmsg = new MoveBaseFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseFeedbackNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MoveBaseGoal::ID:
        {
            //MoveBaseGoalNML * newmsg = new MoveBaseGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseGoalNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MoveBaseResult::ID:
        {
            //MoveBaseResultNML * newmsg = new MoveBaseResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MoveBaseResultNML(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case MoveBaseAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseAction>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MoveBaseActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseActionFeedback>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MoveBaseActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseActionGoal>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MoveBaseActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseActionResult>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MoveBaseFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseFeedback>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MoveBaseGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseGoal>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MoveBaseResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MoveBaseResult>(),std::bind(&move_base_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case MoveBaseAction::ID:
            {
                MoveBaseActionNML * tempmsg = static_cast<MoveBaseActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MoveBaseActionFeedback::ID:
            {
                MoveBaseActionFeedbackNML * tempmsg = static_cast<MoveBaseActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MoveBaseActionGoal::ID:
            {
                MoveBaseActionGoalNML * tempmsg = static_cast<MoveBaseActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MoveBaseActionResult::ID:
            {
                MoveBaseActionResultNML * tempmsg = static_cast<MoveBaseActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MoveBaseFeedback::ID:
            {
                MoveBaseFeedbackNML * tempmsg = static_cast<MoveBaseFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MoveBaseGoal::ID:
            {
                MoveBaseGoalNML * tempmsg = static_cast<MoveBaseGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MoveBaseResult::ID:
            {
                MoveBaseResultNML * tempmsg = static_cast<MoveBaseResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case MoveBaseAction::ID:
            {
                MoveBaseActionNML & tempDst = static_cast<MoveBaseActionNML&>(dst);
                Message<MoveBaseAction > & tempSrc = static_cast<Message<MoveBaseAction>&>(src);

                if (tempSrc.version() != MoveBaseAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseAction: " << __FILE__ << " expected: " 
                             << MoveBaseAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseAction: " << __FILE__ << " expected: " 
                         << MoveBaseAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MoveBaseActionFeedback::ID:
            {
                MoveBaseActionFeedbackNML & tempDst = static_cast<MoveBaseActionFeedbackNML&>(dst);
                Message<MoveBaseActionFeedback > & tempSrc = static_cast<Message<MoveBaseActionFeedback>&>(src);

                if (tempSrc.version() != MoveBaseActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseActionFeedback: " << __FILE__ << " expected: " 
                             << MoveBaseActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseActionFeedback: " << __FILE__ << " expected: " 
                         << MoveBaseActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MoveBaseActionGoal::ID:
            {
                MoveBaseActionGoalNML & tempDst = static_cast<MoveBaseActionGoalNML&>(dst);
                Message<MoveBaseActionGoal > & tempSrc = static_cast<Message<MoveBaseActionGoal>&>(src);

                if (tempSrc.version() != MoveBaseActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseActionGoal: " << __FILE__ << " expected: " 
                             << MoveBaseActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseActionGoal: " << __FILE__ << " expected: " 
                         << MoveBaseActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MoveBaseActionResult::ID:
            {
                MoveBaseActionResultNML & tempDst = static_cast<MoveBaseActionResultNML&>(dst);
                Message<MoveBaseActionResult > & tempSrc = static_cast<Message<MoveBaseActionResult>&>(src);

                if (tempSrc.version() != MoveBaseActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseActionResult: " << __FILE__ << " expected: " 
                             << MoveBaseActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseActionResult: " << __FILE__ << " expected: " 
                         << MoveBaseActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MoveBaseFeedback::ID:
            {
                MoveBaseFeedbackNML & tempDst = static_cast<MoveBaseFeedbackNML&>(dst);
                Message<MoveBaseFeedback > & tempSrc = static_cast<Message<MoveBaseFeedback>&>(src);

                if (tempSrc.version() != MoveBaseFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseFeedback: " << __FILE__ << " expected: " 
                             << MoveBaseFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseFeedback: " << __FILE__ << " expected: " 
                         << MoveBaseFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MoveBaseGoal::ID:
            {
                MoveBaseGoalNML & tempDst = static_cast<MoveBaseGoalNML&>(dst);
                Message<MoveBaseGoal > & tempSrc = static_cast<Message<MoveBaseGoal>&>(src);

                if (tempSrc.version() != MoveBaseGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseGoal: " << __FILE__ << " expected: " 
                             << MoveBaseGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseGoal: " << __FILE__ << " expected: " 
                         << MoveBaseGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MoveBaseResult::ID:
            {
                MoveBaseResultNML & tempDst = static_cast<MoveBaseResultNML&>(dst);
                Message<MoveBaseResult > & tempSrc = static_cast<Message<MoveBaseResult>&>(src);

                if (tempSrc.version() != MoveBaseResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MoveBaseResult: " << __FILE__ << " expected: " 
                             << MoveBaseResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MoveBaseResult: " << __FILE__ << " expected: " 
                         << MoveBaseResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case MoveBaseAction::ID:
            {
                MoveBaseActionNML & tempSrc = static_cast<MoveBaseActionNML&>(src);
                Message<MoveBaseAction > & tempDst = static_cast<Message<MoveBaseAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MoveBaseActionFeedback::ID:
            {
                MoveBaseActionFeedbackNML & tempSrc = static_cast<MoveBaseActionFeedbackNML&>(src);
                Message<MoveBaseActionFeedback > & tempDst = static_cast<Message<MoveBaseActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MoveBaseActionGoal::ID:
            {
                MoveBaseActionGoalNML & tempSrc = static_cast<MoveBaseActionGoalNML&>(src);
                Message<MoveBaseActionGoal > & tempDst = static_cast<Message<MoveBaseActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MoveBaseActionResult::ID:
            {
                MoveBaseActionResultNML & tempSrc = static_cast<MoveBaseActionResultNML&>(src);
                Message<MoveBaseActionResult > & tempDst = static_cast<Message<MoveBaseActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MoveBaseFeedback::ID:
            {
                MoveBaseFeedbackNML & tempSrc = static_cast<MoveBaseFeedbackNML&>(src);
                Message<MoveBaseFeedback > & tempDst = static_cast<Message<MoveBaseFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MoveBaseGoal::ID:
            {
                MoveBaseGoalNML & tempSrc = static_cast<MoveBaseGoalNML&>(src);
                Message<MoveBaseGoal > & tempDst = static_cast<Message<MoveBaseGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MoveBaseResult::ID:
            {
                MoveBaseResultNML & tempSrc = static_cast<MoveBaseResultNML&>(src);
                Message<MoveBaseResult > & tempDst = static_cast<Message<MoveBaseResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MoveBaseResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case MoveBaseAction::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseAction at %p\n",buffer);
                MoveBaseActionNML * p = static_cast<MoveBaseActionNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseActionFeedback at %p\n",buffer);
                MoveBaseActionFeedbackNML * p = static_cast<MoveBaseActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseActionGoal at %p\n",buffer);
                MoveBaseActionGoalNML * p = static_cast<MoveBaseActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseActionResult at %p\n",buffer);
                MoveBaseActionResultNML * p = static_cast<MoveBaseActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseFeedback at %p\n",buffer);
                MoveBaseFeedbackNML * p = static_cast<MoveBaseFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseGoal::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseGoal at %p\n",buffer);
                MoveBaseGoalNML * p = static_cast<MoveBaseGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseResult::ID:
        {
            // only need to construct if data type is not flat
            if (MoveBaseResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MoveBaseResult at %p\n",buffer);
                MoveBaseResultNML * p = static_cast<MoveBaseResultNML*>(buffer);
                // construct the type at pointer p
                new (p) MoveBaseResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MoveBaseResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int move_base_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case MoveBaseAction::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseAction at %p\n",buffer);
                MoveBaseActionNML * p = static_cast<MoveBaseActionNML*>(buffer);
                p->~MoveBaseActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseActionFeedback at %p\n",buffer);
                MoveBaseActionFeedbackNML * p = static_cast<MoveBaseActionFeedbackNML*>(buffer);
                p->~MoveBaseActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseActionGoal at %p\n",buffer);
                MoveBaseActionGoalNML * p = static_cast<MoveBaseActionGoalNML*>(buffer);
                p->~MoveBaseActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseActionResult at %p\n",buffer);
                MoveBaseActionResultNML * p = static_cast<MoveBaseActionResultNML*>(buffer);
                p->~MoveBaseActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseFeedback at %p\n",buffer);
                MoveBaseFeedbackNML * p = static_cast<MoveBaseFeedbackNML*>(buffer);
                p->~MoveBaseFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseGoal at %p\n",buffer);
                MoveBaseGoalNML * p = static_cast<MoveBaseGoalNML*>(buffer);
                p->~MoveBaseGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case MoveBaseResult::ID:
        {
            // only need to destruct if data type is not flat
            if (MoveBaseResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MoveBaseResult at %p\n",buffer);
                MoveBaseResultNML * p = static_cast<MoveBaseResultNML*>(buffer);
                p->~MoveBaseResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MoveBaseResult at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

MoveBaseActionNML::MoveBaseActionNML() : NMLmsg((NMLTYPE)MoveBaseAction::ID,sizeof(MoveBaseActionNML)), nmlVersion(MoveBaseAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseAction()*/)
{
};

MoveBaseActionNML::~MoveBaseActionNML()
{
};

MoveBaseActionNML & MoveBaseActionNML::operator=(const MoveBaseActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseActionNML & MoveBaseActionNML::operator=(const MoveBaseAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseAction> temp(new MoveBaseAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseAction Message version mismatch, expected " << MoveBaseAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseAction Message version mismatch, expected " << MoveBaseAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

MoveBaseActionFeedbackNML::MoveBaseActionFeedbackNML() : NMLmsg((NMLTYPE)MoveBaseActionFeedback::ID,sizeof(MoveBaseActionFeedbackNML)), nmlVersion(MoveBaseActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseActionFeedback()*/)
{
};

MoveBaseActionFeedbackNML::~MoveBaseActionFeedbackNML()
{
};

MoveBaseActionFeedbackNML & MoveBaseActionFeedbackNML::operator=(const MoveBaseActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseActionFeedbackNML & MoveBaseActionFeedbackNML::operator=(const MoveBaseActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseActionFeedback> temp(new MoveBaseActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseActionFeedback Message version mismatch, expected " << MoveBaseActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseActionFeedback Message version mismatch, expected " << MoveBaseActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

MoveBaseActionGoalNML::MoveBaseActionGoalNML() : NMLmsg((NMLTYPE)MoveBaseActionGoal::ID,sizeof(MoveBaseActionGoalNML)), nmlVersion(MoveBaseActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseActionGoal()*/)
{
};

MoveBaseActionGoalNML::~MoveBaseActionGoalNML()
{
};

MoveBaseActionGoalNML & MoveBaseActionGoalNML::operator=(const MoveBaseActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseActionGoalNML & MoveBaseActionGoalNML::operator=(const MoveBaseActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseActionGoal> temp(new MoveBaseActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseActionGoal Message version mismatch, expected " << MoveBaseActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseActionGoal Message version mismatch, expected " << MoveBaseActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

MoveBaseActionResultNML::MoveBaseActionResultNML() : NMLmsg((NMLTYPE)MoveBaseActionResult::ID,sizeof(MoveBaseActionResultNML)), nmlVersion(MoveBaseActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseActionResult()*/)
{
};

MoveBaseActionResultNML::~MoveBaseActionResultNML()
{
};

MoveBaseActionResultNML & MoveBaseActionResultNML::operator=(const MoveBaseActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseActionResultNML & MoveBaseActionResultNML::operator=(const MoveBaseActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseActionResult> temp(new MoveBaseActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseActionResult Message version mismatch, expected " << MoveBaseActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseActionResult Message version mismatch, expected " << MoveBaseActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.base_position);

    }  
 }

MoveBaseFeedbackNML::MoveBaseFeedbackNML() : NMLmsg((NMLTYPE)MoveBaseFeedback::ID,sizeof(MoveBaseFeedbackNML)), nmlVersion(MoveBaseFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseFeedback()*/)
{
};

MoveBaseFeedbackNML::~MoveBaseFeedbackNML()
{
};

MoveBaseFeedbackNML & MoveBaseFeedbackNML::operator=(const MoveBaseFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseFeedbackNML & MoveBaseFeedbackNML::operator=(const MoveBaseFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseFeedback> temp(new MoveBaseFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseFeedback Message version mismatch, expected " << MoveBaseFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseFeedback Message version mismatch, expected " << MoveBaseFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.target_pose);

    }  
 }

MoveBaseGoalNML::MoveBaseGoalNML() : NMLmsg((NMLTYPE)MoveBaseGoal::ID,sizeof(MoveBaseGoalNML)), nmlVersion(MoveBaseGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseGoal()*/)
{
};

MoveBaseGoalNML::~MoveBaseGoalNML()
{
};

MoveBaseGoalNML & MoveBaseGoalNML::operator=(const MoveBaseGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseGoalNML & MoveBaseGoalNML::operator=(const MoveBaseGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseGoal> temp(new MoveBaseGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseGoal Message version mismatch, expected " << MoveBaseGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseGoal Message version mismatch, expected " << MoveBaseGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void move_base_msgs::nmlupdate(CMS * cms, MoveBaseResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MoveBaseResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

MoveBaseResultNML::MoveBaseResultNML() : NMLmsg((NMLTYPE)MoveBaseResult::ID,sizeof(MoveBaseResultNML)), nmlVersion(MoveBaseResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MoveBaseResult()*/)
{
};

MoveBaseResultNML::~MoveBaseResultNML()
{
};

MoveBaseResultNML & MoveBaseResultNML::operator=(const MoveBaseResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MoveBaseResultNML & MoveBaseResultNML::operator=(const MoveBaseResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MoveBaseResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MoveBaseResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MoveBaseResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MoveBaseResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MoveBaseResult> temp(new MoveBaseResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: move_base_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MoveBaseResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MoveBaseResult Message version mismatch, expected " << MoveBaseResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MoveBaseResult Message version mismatch, expected " << MoveBaseResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int move_base_msgs::move_base_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("move_base_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case MoveBaseAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseAction, id " << MoveBaseAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MoveBaseActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseActionFeedback, id " << MoveBaseActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MoveBaseActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseActionGoal, id " << MoveBaseActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MoveBaseActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseActionResult, id " << MoveBaseActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MoveBaseFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseFeedback, id " << MoveBaseFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MoveBaseGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseGoal, id " << MoveBaseGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MoveBaseResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MoveBaseResult, id " << MoveBaseResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_move_base_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"move_base_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MoveBaseResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

