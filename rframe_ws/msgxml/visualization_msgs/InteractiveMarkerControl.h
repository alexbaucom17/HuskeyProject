// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:09 -0500
//  From Template/Script: data_templates/DataHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_VISUALIZATION_MSGS_INTERACTIVEMARKERCONTROL_H_
#define _CODEGEN_VISUALIZATION_MSGS_INTERACTIVEMARKERCONTROL_H_

//#include <ostream> handled by iosfwd included through <memory> in Common.h
#include <common/Common.h>
#include <common/CodeGenTraits.h>

#include <geometry_msgs/Quaternion.h>
#include <string>
#include <vector>
#include <visualization_msgs/Marker.h>

// predeclaration
namespace visualization_msgs{ 
    class InteractiveMarkerControl; 
}; 

PREDECLARE_BSON(visualization_msgs::InteractiveMarkerControl); // see Common.h, macro used for a cleaner header
PREDECLARE_JSON(visualization_msgs::InteractiveMarkerControl); // see Common.h, macro used for a cleaner header

namespace visualization_msgs
{  

    // definition of nml serialization function for this class, necessary for friend'ing below.
    void nmlupdate(CMS * cms, InteractiveMarkerControl & inobj);   

    /** 
        \ingroup CodeGen
        Represents a control that is to be displayed together with an interactive marker
    */
    class InteractiveMarkerControl
    {
    public: 

        /** constructor */
        InteractiveMarkerControl();
        /** copy constructor */
        InteractiveMarkerControl(const InteractiveMarkerControl & inobj);
        /** destructor */
        ~InteractiveMarkerControl();

        /** allocator, convenience function for bind */
        static InteractiveMarkerControl * New();

        // PUBLIC_POST_PROCESS_INSERT_TAG
        /** definitions */

        /* data member definition */ 
        std::string  name; /**< Defines the local coordinate frame (relative to the pose of the parent  interactive marker) in which is being rotated and translated.  Default: Identity */
        geometry_msgs::Quaternion  orientation; /**< Orientation mode: controls how orientation changes.  INHERIT: Follow orientation of interactive marker  FIXED: Keep orientation fixed at initial state  VIEW_FACING: Align y-z plane with screen (x: forward, y:left, z:up). */
        unsigned char  orientation_mode; /**< Interaction mode for this control    NONE: This control is only meant for visualization; no context menu.  MENU: Like NONE, but right-click menu is active.  BUTTON: Element can be left-clicked.  MOVE_AXIS: Translate along local x-axis.  MOVE_PLANE: Translate in local y-z plane.  ROTATE_AXIS: Rotate around local x-axis.  MOVE_ROTATE: Combines MOVE_PLANE and ROTATE_AXIS. */
        unsigned char  interaction_mode; /**< If true, the contained markers will also be visible  when the gui is not in interactive mode. */
        bool  always_visible; /**< Markers to be displayed as custom visual representation.  Leave this empty to use the default control handles.   Note:   - The markers can be defined in an arbitrary coordinate frame,    but will be transformed into the local frame of the interactive marker.  - If the header of a marker is empty, its pose will be interpreted as     relative to the pose of the parent interactive marker. */
        std::vector<Marker >  markers; /**< In VIEW_FACING mode, set this to true if you don't want the markers  to be aligned with the camera view point. The markers will show up  as in INHERIT mode. */
        bool  independent_marker_orientation; /**< Short description (< 40 characters) of what this control does,  e.g. "Move the robot".   Default: A generic description based on the interaction mode */
        std::string  description; /**<  */

        static const unsigned char INHERIT; /**<  (value: 0) */
        static const unsigned char FIXED; /**<  (value: 1) */
        static const unsigned char VIEW_FACING; /**<  (value: 2) */
        static const unsigned char NONE; /**<  (value: 0) */
        static const unsigned char MENU; /**<  (value: 1) */
        static const unsigned char BUTTON; /**<  (value: 2) */
        static const unsigned char MOVE_AXIS; /**<  (value: 3) */
        static const unsigned char MOVE_PLANE; /**<  (value: 4) */
        static const unsigned char ROTATE_AXIS; /**<  (value: 5) */
        static const unsigned char MOVE_ROTATE; /**< "3D" interaction modes work with the mouse+SHIFT+CTRL or with 3D cursors.  MOVE_3D: Translate freely in 3D space.  ROTATE_3D: Rotate freely in 3D space about the origin of parent frame.  MOVE_ROTATE_3D: Full 6-DOF freedom of translation and rotation about the cursor origin. (value: 6) */
        static const unsigned char MOVE_3D; /**<  (value: 7) */
        static const unsigned char ROTATE_3D; /**<  (value: 8) */
        static const unsigned char MOVE_ROTATE_3D; /**<  (value: 9) */

        /** DAQ enumeration not sure how to use it yet. here for proof of concept. */
        typedef enum
        { 
            DAQ_0_NAME,
            DAQ_1_ORIENTATION,
            DAQ_2_ORIENTATION_MODE,
            DAQ_3_INTERACTION_MODE,
            DAQ_4_ALWAYS_VISIBLE,
            DAQ_5_MARKERS,
            DAQ_6_INDEPENDENT_MARKER_ORIENTATION,
            DAQ_7_DESCRIPTION,
            DAQ_MAX_
        } DAQEnum;

        /* definition of member accessor methods */

        // PROTECTED_POST_PROCESS_INSERT_TAG

        /* data type definitions and methods */

        /** static data type id. capitlized to remove name conflicts with generate class members */
        static const unsigned int ID = 2125420981U;
        /** data class version, created from a hash function. 
            global version of this data type is defined by the pair <id,version>
            as id will be unique between classes, and the hash should be unique within this class */
        static const unsigned int DATA_VERSION = 3904726477U;
        /** if true, this message may be delivered internally */
        static const bool INTRAPROCESS = true;
        /** xml source for this class */
        static const std::string XML_SOURCE;
        /** name of this data type. */
        //        static const char * dataTypeName() { return "InteractiveMarkerControl"; };
        /** name of this data type */
        static const std::string DATA_TYPE_NAME;
        /** full name of data type, including namespace */
        static const std::string DATA_TYPE_FULL_NAME;
        /** does this class have bson support? */
        static const bool BSON_ENABLED = true;
        /** is this a "flat" data structure, meaning it can be memcpy'd safely 
            for now it is assumed that classes with virtual members are not flat
        */
        static bool dataTypeFlat();

        /** MD5sum of a string representation of the class, included as it is more robust than the hash above */
        static const std::string versionMD5() { return "1d5b6ea72d0a7cb8a3f542b2dbfcb0b4"; };
        /** md5 version of this data type */
        static const std::string VERSION_MD5;
        /** top 8 bytes of md5 in binary */
        static const unsigned long long VERSION_MD5_TOP = 0x1d5b6ea72d0a7cb8ULL;
        /** lower 8 bytes of md5 in binary */
        static const unsigned long long VERSION_MD5_BOTTOM = 0xa3f542b2dbfcb0b4ULL;

        /** register this data type with the global type registry */
        //        static int registerType();

        /** \return a copy of this instance.  */
        InteractiveMarkerControl * copy() { return new InteractiveMarkerControl(*this); };

        /** assignment operator(s) */
        InteractiveMarkerControl & operator=(const InteractiveMarkerControl & inobj);
        /** equality operator */
        bool operator==(const InteractiveMarkerControl & inobj) const;
        /** inequality operator */
        bool operator!=(const InteractiveMarkerControl & inobj) const;
        /** less than operator */
        bool operator<(const InteractiveMarkerControl & inobj) const;
        /** greater than operator */
        bool operator>(const InteractiveMarkerControl & inobj) const;

        /** convert to string representation */
        std::string toXML() const;

        /** convert from string representation. class constructor is not provided due to potential conflicts with string derived classes */
        bool fromXML(const std::string &str);

        /** convert this class to a JSON string representation, provides std::bind'able string creation */
        std::string toStr(bool pretty = true) const;

        /** generic serialization encoder entrypoint
            currently instantiated with boost .cpp file
            \param type type of serialization used, values defined in Common.h
            \param buffer object to be casted into proper container based on value of type.
            \return rframe::Error depending on serialization type used */
        int encode(const rframe::SerializationTypes type, void * buffer) const;

        /** generic serialization decoder entrypoint
            currently instantiated with boost .cpp file by the GENERIC_SERIALIZATION_ENTRYPOINTS macro
            \param type type of serialization used, values defined in Common.h
            \param buffer object to be casted into proper container based on value of type.
            \return rframe::Error depending on serialization type used */
        int decode(const rframe::SerializationTypes type, void * buffer);

    private:

        /* definition of friend access for serialization helpers */
        friend void nmlupdate(CMS * cms, InteractiveMarkerControl & inobj);

        DECLARE_BSON_FRIENDS(); // defined in Common.h, declares friend access to bson serializers

        template <class T> friend struct ros::serialization::Serializer;

        friend class boost::serialization::access;       

        /** boost serialization method. See "http://www.boost.org/libs/serialization/doc/tutorial.html#derivedclasses" for reason why serialize() should be private. */
		template<class Archive> void serialize(Archive &ar, const unsigned int version);

        // PRIVATE_POST_PROCESS_INSERT_TAG

    };

}; // end namespace visualization_msgs

namespace rframe
{
    template <> class CodeGenTraits<visualization_msgs::InteractiveMarkerControl>
    {
    public:
        static bool flat() {return visualization_msgs::InteractiveMarkerControl::dataTypeFlat(); };
        static std::string sourceXML() {return visualization_msgs::InteractiveMarkerControl::XML_SOURCE; };
        //        static bool codegen() {return true;};
        static constexpr bool codegen = true;
    };
};

/** ostream operator */
//std::ostream& operator<<(std::ostream &s, const visualization_msgs::InteractiveMarkerControl & value);
std::basic_ostream<char>& operator<<(std::basic_ostream<char> &s, const visualization_msgs::InteractiveMarkerControl & value);

#endif  //  _VISUALIZATION_MSGS_INTERACTIVEMARKERCONTROL_H_
