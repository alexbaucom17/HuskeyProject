// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:30:54 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "navfn_gencpp_NML.h"
#include "navfn_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <MakeNavPlanRequest.h>
#include <MakeNavPlanResponse.h>
#include <MakeNavPlan.h>
#include <SetCostmapRequest.h>
#include <SetCostmapResponse.h>
#include <SetCostmap.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace navfn;

rframe::NMLMessageFactory * NML_navfn_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_navfn_gencppfactory = new navfn_gencppNMLMessageFactory();
        return NML_navfn_gencppfactory;
    };
}

rframe::NMLMessageFactory * navfn::allocate_navfn_gencpp()
{
    NML_navfn_gencppfactory = new navfn_gencppNMLMessageFactory();
    return NML_navfn_gencppfactory;
};

navfn_gencppNMLMessageFactory::navfn_gencppNMLMessageFactory()
{
    name("navfn_gencpp");
    // use constructor to register data types
    navfn::registerLibrary();
}

navfn_gencppNMLMessageFactory::~navfn_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR navfn_gencppNMLMessageFactory::FormatPointer()
{
    return navfn_gencpp_format;
}

int navfn_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void navfn_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(MakeNavPlanRequest::ID);
    info.name(MakeNavPlanRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(MakeNavPlanRequest::DATA_VERSION);
    info.md5Key(MakeNavPlanRequest::VERSION_MD5);
    info.xmlSource(MakeNavPlanRequest::XML_SOURCE);
    info.flat(MakeNavPlanRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(MakeNavPlanResponse::ID);
    info.name(MakeNavPlanResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(MakeNavPlanResponse::DATA_VERSION);
    info.md5Key(MakeNavPlanResponse::VERSION_MD5);
    info.xmlSource(MakeNavPlanResponse::XML_SOURCE);
    info.flat(MakeNavPlanResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(MakeNavPlan::ID);
    info.name(MakeNavPlan::DATA_TYPE_FULL_NAME);
    info.hashKey(MakeNavPlan::DATA_VERSION);
    info.md5Key(MakeNavPlan::VERSION_MD5);
    info.xmlSource(MakeNavPlan::XML_SOURCE);
    info.flat(MakeNavPlan::dataTypeFlat());
    ids.push_back(info);

    info.id(SetCostmapRequest::ID);
    info.name(SetCostmapRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetCostmapRequest::DATA_VERSION);
    info.md5Key(SetCostmapRequest::VERSION_MD5);
    info.xmlSource(SetCostmapRequest::XML_SOURCE);
    info.flat(SetCostmapRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetCostmapResponse::ID);
    info.name(SetCostmapResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetCostmapResponse::DATA_VERSION);
    info.md5Key(SetCostmapResponse::VERSION_MD5);
    info.xmlSource(SetCostmapResponse::XML_SOURCE);
    info.flat(SetCostmapResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetCostmap::ID);
    info.name(SetCostmap::DATA_TYPE_FULL_NAME);
    info.hashKey(SetCostmap::DATA_VERSION);
    info.md5Key(SetCostmap::VERSION_MD5);
    info.xmlSource(SetCostmap::XML_SOURCE);
    info.flat(SetCostmap::dataTypeFlat());
    ids.push_back(info);

}

int navfn_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case MakeNavPlanRequest::ID:
        {
            //MakeNavPlanRequestNML * newmsg = new MakeNavPlanRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MakeNavPlanRequestNML(),std::bind(&navfn_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MakeNavPlanResponse::ID:
        {
            //MakeNavPlanResponseNML * newmsg = new MakeNavPlanResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MakeNavPlanResponseNML(),std::bind(&navfn_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MakeNavPlan::ID:
        {
            //MakeNavPlanNML * newmsg = new MakeNavPlanNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MakeNavPlanNML(),std::bind(&navfn_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetCostmapRequest::ID:
        {
            //SetCostmapRequestNML * newmsg = new SetCostmapRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetCostmapRequestNML(),std::bind(&navfn_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetCostmapResponse::ID:
        {
            //SetCostmapResponseNML * newmsg = new SetCostmapResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetCostmapResponseNML(),std::bind(&navfn_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetCostmap::ID:
        {
            //SetCostmapNML * newmsg = new SetCostmapNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetCostmapNML(),std::bind(&navfn_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int navfn_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case MakeNavPlanRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MakeNavPlanRequest>(),std::bind(&navfn_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MakeNavPlanResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MakeNavPlanResponse>(),std::bind(&navfn_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MakeNavPlan::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MakeNavPlan>(),std::bind(&navfn_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetCostmapRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetCostmapRequest>(),std::bind(&navfn_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetCostmapResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetCostmapResponse>(),std::bind(&navfn_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetCostmap::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetCostmap>(),std::bind(&navfn_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int navfn_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int navfn_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case MakeNavPlanRequest::ID:
            {
                MakeNavPlanRequestNML * tempmsg = static_cast<MakeNavPlanRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MakeNavPlanResponse::ID:
            {
                MakeNavPlanResponseNML * tempmsg = static_cast<MakeNavPlanResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MakeNavPlan::ID:
            {
                MakeNavPlanNML * tempmsg = static_cast<MakeNavPlanNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetCostmapRequest::ID:
            {
                SetCostmapRequestNML * tempmsg = static_cast<SetCostmapRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetCostmapResponse::ID:
            {
                SetCostmapResponseNML * tempmsg = static_cast<SetCostmapResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetCostmap::ID:
            {
                SetCostmapNML * tempmsg = static_cast<SetCostmapNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int navfn_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case MakeNavPlanRequest::ID:
            {
                MakeNavPlanRequestNML & tempDst = static_cast<MakeNavPlanRequestNML&>(dst);
                Message<MakeNavPlanRequest > & tempSrc = static_cast<Message<MakeNavPlanRequest>&>(src);

                if (tempSrc.version() != MakeNavPlanRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MakeNavPlanRequest: " << __FILE__ << " expected: " 
                             << MakeNavPlanRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MakeNavPlanRequest: " << __FILE__ << " expected: " 
                         << MakeNavPlanRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MakeNavPlanResponse::ID:
            {
                MakeNavPlanResponseNML & tempDst = static_cast<MakeNavPlanResponseNML&>(dst);
                Message<MakeNavPlanResponse > & tempSrc = static_cast<Message<MakeNavPlanResponse>&>(src);

                if (tempSrc.version() != MakeNavPlanResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MakeNavPlanResponse: " << __FILE__ << " expected: " 
                             << MakeNavPlanResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MakeNavPlanResponse: " << __FILE__ << " expected: " 
                         << MakeNavPlanResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MakeNavPlan::ID:
            {
                MakeNavPlanNML & tempDst = static_cast<MakeNavPlanNML&>(dst);
                Message<MakeNavPlan > & tempSrc = static_cast<Message<MakeNavPlan>&>(src);

                if (tempSrc.version() != MakeNavPlan::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MakeNavPlan: " << __FILE__ << " expected: " 
                             << MakeNavPlan::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MakeNavPlan: " << __FILE__ << " expected: " 
                         << MakeNavPlan::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetCostmapRequest::ID:
            {
                SetCostmapRequestNML & tempDst = static_cast<SetCostmapRequestNML&>(dst);
                Message<SetCostmapRequest > & tempSrc = static_cast<Message<SetCostmapRequest>&>(src);

                if (tempSrc.version() != SetCostmapRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetCostmapRequest: " << __FILE__ << " expected: " 
                             << SetCostmapRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetCostmapRequest: " << __FILE__ << " expected: " 
                         << SetCostmapRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetCostmapResponse::ID:
            {
                SetCostmapResponseNML & tempDst = static_cast<SetCostmapResponseNML&>(dst);
                Message<SetCostmapResponse > & tempSrc = static_cast<Message<SetCostmapResponse>&>(src);

                if (tempSrc.version() != SetCostmapResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetCostmapResponse: " << __FILE__ << " expected: " 
                             << SetCostmapResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetCostmapResponse: " << __FILE__ << " expected: " 
                         << SetCostmapResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetCostmap::ID:
            {
                SetCostmapNML & tempDst = static_cast<SetCostmapNML&>(dst);
                Message<SetCostmap > & tempSrc = static_cast<Message<SetCostmap>&>(src);

                if (tempSrc.version() != SetCostmap::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetCostmap: " << __FILE__ << " expected: " 
                             << SetCostmap::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetCostmap: " << __FILE__ << " expected: " 
                         << SetCostmap::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int navfn_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case MakeNavPlanRequest::ID:
            {
                MakeNavPlanRequestNML & tempSrc = static_cast<MakeNavPlanRequestNML&>(src);
                Message<MakeNavPlanRequest > & tempDst = static_cast<Message<MakeNavPlanRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MakeNavPlanRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MakeNavPlanResponse::ID:
            {
                MakeNavPlanResponseNML & tempSrc = static_cast<MakeNavPlanResponseNML&>(src);
                Message<MakeNavPlanResponse > & tempDst = static_cast<Message<MakeNavPlanResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MakeNavPlanResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MakeNavPlan::ID:
            {
                MakeNavPlanNML & tempSrc = static_cast<MakeNavPlanNML&>(src);
                Message<MakeNavPlan > & tempDst = static_cast<Message<MakeNavPlan>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MakeNavPlan::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetCostmapRequest::ID:
            {
                SetCostmapRequestNML & tempSrc = static_cast<SetCostmapRequestNML&>(src);
                Message<SetCostmapRequest > & tempDst = static_cast<Message<SetCostmapRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetCostmapRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetCostmapResponse::ID:
            {
                SetCostmapResponseNML & tempSrc = static_cast<SetCostmapResponseNML&>(src);
                Message<SetCostmapResponse > & tempDst = static_cast<Message<SetCostmapResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetCostmapResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetCostmap::ID:
            {
                SetCostmapNML & tempSrc = static_cast<SetCostmapNML&>(src);
                Message<SetCostmap > & tempDst = static_cast<Message<SetCostmap>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetCostmap::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int navfn_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case MakeNavPlanRequest::ID:
        {
            // only need to construct if data type is not flat
            if (MakeNavPlanRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MakeNavPlanRequest at %p\n",buffer);
                MakeNavPlanRequestNML * p = static_cast<MakeNavPlanRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) MakeNavPlanRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MakeNavPlanRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MakeNavPlanResponse::ID:
        {
            // only need to construct if data type is not flat
            if (MakeNavPlanResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MakeNavPlanResponse at %p\n",buffer);
                MakeNavPlanResponseNML * p = static_cast<MakeNavPlanResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) MakeNavPlanResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MakeNavPlanResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MakeNavPlan::ID:
        {
            // only need to construct if data type is not flat
            if (MakeNavPlan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MakeNavPlan at %p\n",buffer);
                MakeNavPlanNML * p = static_cast<MakeNavPlanNML*>(buffer);
                // construct the type at pointer p
                new (p) MakeNavPlanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MakeNavPlan at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetCostmapRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetCostmapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetCostmapRequest at %p\n",buffer);
                SetCostmapRequestNML * p = static_cast<SetCostmapRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetCostmapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetCostmapRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetCostmapResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetCostmapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetCostmapResponse at %p\n",buffer);
                SetCostmapResponseNML * p = static_cast<SetCostmapResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetCostmapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetCostmapResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetCostmap::ID:
        {
            // only need to construct if data type is not flat
            if (SetCostmap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetCostmap at %p\n",buffer);
                SetCostmapNML * p = static_cast<SetCostmapNML*>(buffer);
                // construct the type at pointer p
                new (p) SetCostmapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetCostmap at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int navfn_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case MakeNavPlanRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (MakeNavPlanRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MakeNavPlanRequest at %p\n",buffer);
                MakeNavPlanRequestNML * p = static_cast<MakeNavPlanRequestNML*>(buffer);
                p->~MakeNavPlanRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MakeNavPlanRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case MakeNavPlanResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (MakeNavPlanResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MakeNavPlanResponse at %p\n",buffer);
                MakeNavPlanResponseNML * p = static_cast<MakeNavPlanResponseNML*>(buffer);
                p->~MakeNavPlanResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MakeNavPlanResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case MakeNavPlan::ID:
        {
            // only need to destruct if data type is not flat
            if (MakeNavPlan::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MakeNavPlan at %p\n",buffer);
                MakeNavPlanNML * p = static_cast<MakeNavPlanNML*>(buffer);
                p->~MakeNavPlanNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MakeNavPlan at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetCostmapRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetCostmapRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetCostmapRequest at %p\n",buffer);
                SetCostmapRequestNML * p = static_cast<SetCostmapRequestNML*>(buffer);
                p->~SetCostmapRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetCostmapRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetCostmapResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetCostmapResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetCostmapResponse at %p\n",buffer);
                SetCostmapResponseNML * p = static_cast<SetCostmapResponseNML*>(buffer);
                p->~SetCostmapResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetCostmapResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetCostmap::ID:
        {
            // only need to destruct if data type is not flat
            if (SetCostmap::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetCostmap at %p\n",buffer);
                SetCostmapNML * p = static_cast<SetCostmapNML*>(buffer);
                p->~SetCostmapNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetCostmap at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void navfn::nmlupdate(CMS * cms, MakeNavPlanRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MakeNavPlanRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.start);
        nmlupdate(cms,inobj.goal);

    }  
 }

MakeNavPlanRequestNML::MakeNavPlanRequestNML() : NMLmsg((NMLTYPE)MakeNavPlanRequest::ID,sizeof(MakeNavPlanRequestNML)), nmlVersion(MakeNavPlanRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MakeNavPlanRequest()*/)
{
};

MakeNavPlanRequestNML::~MakeNavPlanRequestNML()
{
};

MakeNavPlanRequestNML & MakeNavPlanRequestNML::operator=(const MakeNavPlanRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MakeNavPlanRequestNML & MakeNavPlanRequestNML::operator=(const MakeNavPlanRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MakeNavPlanRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MakeNavPlanRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MakeNavPlanRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MakeNavPlanRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MakeNavPlanRequest> temp(new MakeNavPlanRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: navfn_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MakeNavPlanRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MakeNavPlanRequest Message version mismatch, expected " << MakeNavPlanRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MakeNavPlanRequest Message version mismatch, expected " << MakeNavPlanRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void navfn::nmlupdate(CMS * cms, MakeNavPlanResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MakeNavPlanResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.plan_found);
        nmlupdate(cms,inobj.error_message);
        nmlupdate(cms,inobj.path);

    }  
 }

MakeNavPlanResponseNML::MakeNavPlanResponseNML() : NMLmsg((NMLTYPE)MakeNavPlanResponse::ID,sizeof(MakeNavPlanResponseNML)), nmlVersion(MakeNavPlanResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MakeNavPlanResponse()*/)
{
};

MakeNavPlanResponseNML::~MakeNavPlanResponseNML()
{
};

MakeNavPlanResponseNML & MakeNavPlanResponseNML::operator=(const MakeNavPlanResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MakeNavPlanResponseNML & MakeNavPlanResponseNML::operator=(const MakeNavPlanResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MakeNavPlanResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MakeNavPlanResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MakeNavPlanResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MakeNavPlanResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MakeNavPlanResponse> temp(new MakeNavPlanResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: navfn_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MakeNavPlanResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MakeNavPlanResponse Message version mismatch, expected " << MakeNavPlanResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MakeNavPlanResponse Message version mismatch, expected " << MakeNavPlanResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void navfn::nmlupdate(CMS * cms, MakeNavPlan & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MakeNavPlan, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

MakeNavPlanNML::MakeNavPlanNML() : NMLmsg((NMLTYPE)MakeNavPlan::ID,sizeof(MakeNavPlanNML)), nmlVersion(MakeNavPlan::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MakeNavPlan()*/)
{
};

MakeNavPlanNML::~MakeNavPlanNML()
{
};

MakeNavPlanNML & MakeNavPlanNML::operator=(const MakeNavPlanNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MakeNavPlanNML & MakeNavPlanNML::operator=(const MakeNavPlan & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MakeNavPlan);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MakeNavPlanNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MakeNavPlan&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MakeNavPlanNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MakeNavPlan> temp(new MakeNavPlan());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: navfn_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MakeNavPlan::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MakeNavPlan Message version mismatch, expected " << MakeNavPlan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MakeNavPlan Message version mismatch, expected " << MakeNavPlan::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void navfn::nmlupdate(CMS * cms, SetCostmapRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetCostmapRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.costs);
        cms->update(inobj.height);
        cms->update(inobj.width);

    }  
 }

SetCostmapRequestNML::SetCostmapRequestNML() : NMLmsg((NMLTYPE)SetCostmapRequest::ID,sizeof(SetCostmapRequestNML)), nmlVersion(SetCostmapRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetCostmapRequest()*/)
{
};

SetCostmapRequestNML::~SetCostmapRequestNML()
{
};

SetCostmapRequestNML & SetCostmapRequestNML::operator=(const SetCostmapRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetCostmapRequestNML & SetCostmapRequestNML::operator=(const SetCostmapRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetCostmapRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetCostmapRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetCostmapRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetCostmapRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetCostmapRequest> temp(new SetCostmapRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: navfn_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetCostmapRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetCostmapRequest Message version mismatch, expected " << SetCostmapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetCostmapRequest Message version mismatch, expected " << SetCostmapRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void navfn::nmlupdate(CMS * cms, SetCostmapResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetCostmapResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

SetCostmapResponseNML::SetCostmapResponseNML() : NMLmsg((NMLTYPE)SetCostmapResponse::ID,sizeof(SetCostmapResponseNML)), nmlVersion(SetCostmapResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetCostmapResponse()*/)
{
};

SetCostmapResponseNML::~SetCostmapResponseNML()
{
};

SetCostmapResponseNML & SetCostmapResponseNML::operator=(const SetCostmapResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetCostmapResponseNML & SetCostmapResponseNML::operator=(const SetCostmapResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetCostmapResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetCostmapResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetCostmapResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetCostmapResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetCostmapResponse> temp(new SetCostmapResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: navfn_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetCostmapResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetCostmapResponse Message version mismatch, expected " << SetCostmapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetCostmapResponse Message version mismatch, expected " << SetCostmapResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void navfn::nmlupdate(CMS * cms, SetCostmap & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetCostmap, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetCostmapNML::SetCostmapNML() : NMLmsg((NMLTYPE)SetCostmap::ID,sizeof(SetCostmapNML)), nmlVersion(SetCostmap::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetCostmap()*/)
{
};

SetCostmapNML::~SetCostmapNML()
{
};

SetCostmapNML & SetCostmapNML::operator=(const SetCostmapNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetCostmapNML & SetCostmapNML::operator=(const SetCostmap & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetCostmap);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetCostmapNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetCostmap&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetCostmapNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetCostmap> temp(new SetCostmap());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: navfn_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetCostmap::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetCostmap Message version mismatch, expected " << SetCostmap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetCostmap Message version mismatch, expected " << SetCostmap::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int navfn::navfn_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("navfn_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case MakeNavPlanRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MakeNavPlanRequest, id " << MakeNavPlanRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_navfn_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"navfn_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MakeNavPlanRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MakeNavPlanResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MakeNavPlanResponse, id " << MakeNavPlanResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_navfn_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"navfn_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MakeNavPlanResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MakeNavPlan::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MakeNavPlan, id " << MakeNavPlan::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_navfn_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"navfn_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MakeNavPlanNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetCostmapRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetCostmapRequest, id " << SetCostmapRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_navfn_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"navfn_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetCostmapRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetCostmapResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetCostmapResponse, id " << SetCostmapResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_navfn_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"navfn_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetCostmapResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetCostmap::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetCostmap, id " << SetCostmap::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_navfn_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"navfn_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetCostmapNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

