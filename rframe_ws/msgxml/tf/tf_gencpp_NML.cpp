// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:08 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "tf_gencpp_NML.h"
#include "tf_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <tfMessage.h>
#include <FrameGraphRequest.h>
#include <FrameGraphResponse.h>
#include <FrameGraph.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace tf;

rframe::NMLMessageFactory * NML_tf_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_tf_gencppfactory = new tf_gencppNMLMessageFactory();
        return NML_tf_gencppfactory;
    };
}

rframe::NMLMessageFactory * tf::allocate_tf_gencpp()
{
    NML_tf_gencppfactory = new tf_gencppNMLMessageFactory();
    return NML_tf_gencppfactory;
};

tf_gencppNMLMessageFactory::tf_gencppNMLMessageFactory()
{
    name("tf_gencpp");
    // use constructor to register data types
    tf::registerLibrary();
}

tf_gencppNMLMessageFactory::~tf_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR tf_gencppNMLMessageFactory::FormatPointer()
{
    return tf_gencpp_format;
}

int tf_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void tf_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(tfMessage::ID);
    info.name(tfMessage::DATA_TYPE_FULL_NAME);
    info.hashKey(tfMessage::DATA_VERSION);
    info.md5Key(tfMessage::VERSION_MD5);
    info.xmlSource(tfMessage::XML_SOURCE);
    info.flat(tfMessage::dataTypeFlat());
    ids.push_back(info);

    info.id(FrameGraphRequest::ID);
    info.name(FrameGraphRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(FrameGraphRequest::DATA_VERSION);
    info.md5Key(FrameGraphRequest::VERSION_MD5);
    info.xmlSource(FrameGraphRequest::XML_SOURCE);
    info.flat(FrameGraphRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(FrameGraphResponse::ID);
    info.name(FrameGraphResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(FrameGraphResponse::DATA_VERSION);
    info.md5Key(FrameGraphResponse::VERSION_MD5);
    info.xmlSource(FrameGraphResponse::XML_SOURCE);
    info.flat(FrameGraphResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(FrameGraph::ID);
    info.name(FrameGraph::DATA_TYPE_FULL_NAME);
    info.hashKey(FrameGraph::DATA_VERSION);
    info.md5Key(FrameGraph::VERSION_MD5);
    info.xmlSource(FrameGraph::XML_SOURCE);
    info.flat(FrameGraph::dataTypeFlat());
    ids.push_back(info);

}

int tf_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case tfMessage::ID:
        {
            //tfMessageNML * newmsg = new tfMessageNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new tfMessageNML(),std::bind(&tf_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            //FrameGraphRequestNML * newmsg = new FrameGraphRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrameGraphRequestNML(),std::bind(&tf_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            //FrameGraphResponseNML * newmsg = new FrameGraphResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrameGraphResponseNML(),std::bind(&tf_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FrameGraph::ID:
        {
            //FrameGraphNML * newmsg = new FrameGraphNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrameGraphNML(),std::bind(&tf_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int tf_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case tfMessage::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<tfMessage>(),std::bind(&tf_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FrameGraphRequest>(),std::bind(&tf_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FrameGraphResponse>(),std::bind(&tf_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FrameGraph::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FrameGraph>(),std::bind(&tf_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int tf_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int tf_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case tfMessage::ID:
            {
                tfMessageNML * tempmsg = static_cast<tfMessageNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FrameGraphRequest::ID:
            {
                FrameGraphRequestNML * tempmsg = static_cast<FrameGraphRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FrameGraphResponse::ID:
            {
                FrameGraphResponseNML * tempmsg = static_cast<FrameGraphResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FrameGraph::ID:
            {
                FrameGraphNML * tempmsg = static_cast<FrameGraphNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int tf_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case tfMessage::ID:
            {
                tfMessageNML & tempDst = static_cast<tfMessageNML&>(dst);
                Message<tfMessage > & tempSrc = static_cast<Message<tfMessage>&>(src);

                if (tempSrc.version() != tfMessage::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of tfMessage: " << __FILE__ << " expected: " 
                             << tfMessage::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of tfMessage: " << __FILE__ << " expected: " 
                         << tfMessage::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FrameGraphRequest::ID:
            {
                FrameGraphRequestNML & tempDst = static_cast<FrameGraphRequestNML&>(dst);
                Message<FrameGraphRequest > & tempSrc = static_cast<Message<FrameGraphRequest>&>(src);

                if (tempSrc.version() != FrameGraphRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FrameGraphRequest: " << __FILE__ << " expected: " 
                             << FrameGraphRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FrameGraphRequest: " << __FILE__ << " expected: " 
                         << FrameGraphRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FrameGraphResponse::ID:
            {
                FrameGraphResponseNML & tempDst = static_cast<FrameGraphResponseNML&>(dst);
                Message<FrameGraphResponse > & tempSrc = static_cast<Message<FrameGraphResponse>&>(src);

                if (tempSrc.version() != FrameGraphResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FrameGraphResponse: " << __FILE__ << " expected: " 
                             << FrameGraphResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FrameGraphResponse: " << __FILE__ << " expected: " 
                         << FrameGraphResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FrameGraph::ID:
            {
                FrameGraphNML & tempDst = static_cast<FrameGraphNML&>(dst);
                Message<FrameGraph > & tempSrc = static_cast<Message<FrameGraph>&>(src);

                if (tempSrc.version() != FrameGraph::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FrameGraph: " << __FILE__ << " expected: " 
                             << FrameGraph::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FrameGraph: " << __FILE__ << " expected: " 
                         << FrameGraph::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int tf_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case tfMessage::ID:
            {
                tfMessageNML & tempSrc = static_cast<tfMessageNML&>(src);
                Message<tfMessage > & tempDst = static_cast<Message<tfMessage>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (tfMessage::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FrameGraphRequest::ID:
            {
                FrameGraphRequestNML & tempSrc = static_cast<FrameGraphRequestNML&>(src);
                Message<FrameGraphRequest > & tempDst = static_cast<Message<FrameGraphRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FrameGraphRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FrameGraphResponse::ID:
            {
                FrameGraphResponseNML & tempSrc = static_cast<FrameGraphResponseNML&>(src);
                Message<FrameGraphResponse > & tempDst = static_cast<Message<FrameGraphResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FrameGraphResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FrameGraph::ID:
            {
                FrameGraphNML & tempSrc = static_cast<FrameGraphNML&>(src);
                Message<FrameGraph > & tempDst = static_cast<Message<FrameGraph>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FrameGraph::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int tf_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case tfMessage::ID:
        {
            // only need to construct if data type is not flat
            if (tfMessage::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing tfMessage at %p\n",buffer);
                tfMessageNML * p = static_cast<tfMessageNML*>(buffer);
                // construct the type at pointer p
                new (p) tfMessageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing tfMessage at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            // only need to construct if data type is not flat
            if (FrameGraphRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FrameGraphRequest at %p\n",buffer);
                FrameGraphRequestNML * p = static_cast<FrameGraphRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) FrameGraphRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FrameGraphRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            // only need to construct if data type is not flat
            if (FrameGraphResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FrameGraphResponse at %p\n",buffer);
                FrameGraphResponseNML * p = static_cast<FrameGraphResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) FrameGraphResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FrameGraphResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraph::ID:
        {
            // only need to construct if data type is not flat
            if (FrameGraph::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FrameGraph at %p\n",buffer);
                FrameGraphNML * p = static_cast<FrameGraphNML*>(buffer);
                // construct the type at pointer p
                new (p) FrameGraphNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FrameGraph at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int tf_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case tfMessage::ID:
        {
            // only need to destruct if data type is not flat
            if (tfMessage::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing tfMessage at %p\n",buffer);
                tfMessageNML * p = static_cast<tfMessageNML*>(buffer);
                p->~tfMessageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction tfMessage at %p, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (FrameGraphRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FrameGraphRequest at %p\n",buffer);
                FrameGraphRequestNML * p = static_cast<FrameGraphRequestNML*>(buffer);
                p->~FrameGraphRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FrameGraphRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (FrameGraphResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FrameGraphResponse at %p\n",buffer);
                FrameGraphResponseNML * p = static_cast<FrameGraphResponseNML*>(buffer);
                p->~FrameGraphResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FrameGraphResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraph::ID:
        {
            // only need to destruct if data type is not flat
            if (FrameGraph::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FrameGraph at %p\n",buffer);
                FrameGraphNML * p = static_cast<FrameGraphNML*>(buffer);
                p->~FrameGraphNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FrameGraph at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void tf::nmlupdate(CMS * cms, tfMessage & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate tfMessage, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.transforms);

    }  
 }

tfMessageNML::tfMessageNML() : NMLmsg((NMLTYPE)tfMessage::ID,sizeof(tfMessageNML)), nmlVersion(tfMessage::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new tfMessage()*/)
{
};

tfMessageNML::~tfMessageNML()
{
};

tfMessageNML & tfMessageNML::operator=(const tfMessageNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

tfMessageNML & tfMessageNML::operator=(const tfMessage & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(tfMessage);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void tfMessageNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<tfMessage&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: tfMessageNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<tfMessage> temp(new tfMessage());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (tfMessage::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: tfMessage Message version mismatch, expected " << tfMessage::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: tfMessage Message version mismatch, expected " << tfMessage::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf::nmlupdate(CMS * cms, FrameGraphRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FrameGraphRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

FrameGraphRequestNML::FrameGraphRequestNML() : NMLmsg((NMLTYPE)FrameGraphRequest::ID,sizeof(FrameGraphRequestNML)), nmlVersion(FrameGraphRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FrameGraphRequest()*/)
{
};

FrameGraphRequestNML::~FrameGraphRequestNML()
{
};

FrameGraphRequestNML & FrameGraphRequestNML::operator=(const FrameGraphRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrameGraphRequestNML & FrameGraphRequestNML::operator=(const FrameGraphRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FrameGraphRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrameGraphRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FrameGraphRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrameGraphRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FrameGraphRequest> temp(new FrameGraphRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FrameGraphRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FrameGraphRequest Message version mismatch, expected " << FrameGraphRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FrameGraphRequest Message version mismatch, expected " << FrameGraphRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf::nmlupdate(CMS * cms, FrameGraphResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FrameGraphResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.dot_graph);

    }  
 }

FrameGraphResponseNML::FrameGraphResponseNML() : NMLmsg((NMLTYPE)FrameGraphResponse::ID,sizeof(FrameGraphResponseNML)), nmlVersion(FrameGraphResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FrameGraphResponse()*/)
{
};

FrameGraphResponseNML::~FrameGraphResponseNML()
{
};

FrameGraphResponseNML & FrameGraphResponseNML::operator=(const FrameGraphResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrameGraphResponseNML & FrameGraphResponseNML::operator=(const FrameGraphResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FrameGraphResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrameGraphResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FrameGraphResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrameGraphResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FrameGraphResponse> temp(new FrameGraphResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FrameGraphResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FrameGraphResponse Message version mismatch, expected " << FrameGraphResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FrameGraphResponse Message version mismatch, expected " << FrameGraphResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf::nmlupdate(CMS * cms, FrameGraph & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FrameGraph, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

FrameGraphNML::FrameGraphNML() : NMLmsg((NMLTYPE)FrameGraph::ID,sizeof(FrameGraphNML)), nmlVersion(FrameGraph::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FrameGraph()*/)
{
};

FrameGraphNML::~FrameGraphNML()
{
};

FrameGraphNML & FrameGraphNML::operator=(const FrameGraphNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrameGraphNML & FrameGraphNML::operator=(const FrameGraph & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FrameGraph);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrameGraphNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FrameGraph&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrameGraphNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FrameGraph> temp(new FrameGraph());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FrameGraph::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FrameGraph Message version mismatch, expected " << FrameGraph::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FrameGraph Message version mismatch, expected " << FrameGraph::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int tf::tf_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("tf_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case tfMessage::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for tfMessage, id " << tfMessage::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((tfMessageNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FrameGraphRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FrameGraphRequest, id " << FrameGraphRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrameGraphRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FrameGraphResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FrameGraphResponse, id " << FrameGraphResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrameGraphResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FrameGraph::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FrameGraph, id " << FrameGraph::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrameGraphNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

