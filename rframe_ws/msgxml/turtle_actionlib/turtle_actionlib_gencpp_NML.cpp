// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:09 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "turtle_actionlib_gencpp_NML.h"
#include "turtle_actionlib_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <ShapeAction.h>
#include <ShapeActionFeedback.h>
#include <ShapeActionGoal.h>
#include <ShapeActionResult.h>
#include <ShapeFeedback.h>
#include <ShapeGoal.h>
#include <ShapeResult.h>
#include <Velocity.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace turtle_actionlib;

rframe::NMLMessageFactory * NML_turtle_actionlib_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_turtle_actionlib_gencppfactory = new turtle_actionlib_gencppNMLMessageFactory();
        return NML_turtle_actionlib_gencppfactory;
    };
}

rframe::NMLMessageFactory * turtle_actionlib::allocate_turtle_actionlib_gencpp()
{
    NML_turtle_actionlib_gencppfactory = new turtle_actionlib_gencppNMLMessageFactory();
    return NML_turtle_actionlib_gencppfactory;
};

turtle_actionlib_gencppNMLMessageFactory::turtle_actionlib_gencppNMLMessageFactory()
{
    name("turtle_actionlib_gencpp");
    // use constructor to register data types
    turtle_actionlib::registerLibrary();
}

turtle_actionlib_gencppNMLMessageFactory::~turtle_actionlib_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR turtle_actionlib_gencppNMLMessageFactory::FormatPointer()
{
    return turtle_actionlib_gencpp_format;
}

int turtle_actionlib_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void turtle_actionlib_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(ShapeAction::ID);
    info.name(ShapeAction::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeAction::DATA_VERSION);
    info.md5Key(ShapeAction::VERSION_MD5);
    info.xmlSource(ShapeAction::XML_SOURCE);
    info.flat(ShapeAction::dataTypeFlat());
    ids.push_back(info);

    info.id(ShapeActionFeedback::ID);
    info.name(ShapeActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeActionFeedback::DATA_VERSION);
    info.md5Key(ShapeActionFeedback::VERSION_MD5);
    info.xmlSource(ShapeActionFeedback::XML_SOURCE);
    info.flat(ShapeActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(ShapeActionGoal::ID);
    info.name(ShapeActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeActionGoal::DATA_VERSION);
    info.md5Key(ShapeActionGoal::VERSION_MD5);
    info.xmlSource(ShapeActionGoal::XML_SOURCE);
    info.flat(ShapeActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(ShapeActionResult::ID);
    info.name(ShapeActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeActionResult::DATA_VERSION);
    info.md5Key(ShapeActionResult::VERSION_MD5);
    info.xmlSource(ShapeActionResult::XML_SOURCE);
    info.flat(ShapeActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(ShapeFeedback::ID);
    info.name(ShapeFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeFeedback::DATA_VERSION);
    info.md5Key(ShapeFeedback::VERSION_MD5);
    info.xmlSource(ShapeFeedback::XML_SOURCE);
    info.flat(ShapeFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(ShapeGoal::ID);
    info.name(ShapeGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeGoal::DATA_VERSION);
    info.md5Key(ShapeGoal::VERSION_MD5);
    info.xmlSource(ShapeGoal::XML_SOURCE);
    info.flat(ShapeGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(ShapeResult::ID);
    info.name(ShapeResult::DATA_TYPE_FULL_NAME);
    info.hashKey(ShapeResult::DATA_VERSION);
    info.md5Key(ShapeResult::VERSION_MD5);
    info.xmlSource(ShapeResult::XML_SOURCE);
    info.flat(ShapeResult::dataTypeFlat());
    ids.push_back(info);

    info.id(Velocity::ID);
    info.name(Velocity::DATA_TYPE_FULL_NAME);
    info.hashKey(Velocity::DATA_VERSION);
    info.md5Key(Velocity::VERSION_MD5);
    info.xmlSource(Velocity::XML_SOURCE);
    info.flat(Velocity::dataTypeFlat());
    ids.push_back(info);

}

int turtle_actionlib_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case ShapeAction::ID:
        {
            //ShapeActionNML * newmsg = new ShapeActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeActionNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ShapeActionFeedback::ID:
        {
            //ShapeActionFeedbackNML * newmsg = new ShapeActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeActionFeedbackNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ShapeActionGoal::ID:
        {
            //ShapeActionGoalNML * newmsg = new ShapeActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeActionGoalNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ShapeActionResult::ID:
        {
            //ShapeActionResultNML * newmsg = new ShapeActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeActionResultNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ShapeFeedback::ID:
        {
            //ShapeFeedbackNML * newmsg = new ShapeFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeFeedbackNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ShapeGoal::ID:
        {
            //ShapeGoalNML * newmsg = new ShapeGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeGoalNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ShapeResult::ID:
        {
            //ShapeResultNML * newmsg = new ShapeResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ShapeResultNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Velocity::ID:
        {
            //VelocityNML * newmsg = new VelocityNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new VelocityNML(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case ShapeAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeAction>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ShapeActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeActionFeedback>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ShapeActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeActionGoal>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ShapeActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeActionResult>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ShapeFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeFeedback>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ShapeGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeGoal>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ShapeResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ShapeResult>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Velocity::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Velocity>(),std::bind(&turtle_actionlib_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case ShapeAction::ID:
            {
                ShapeActionNML * tempmsg = static_cast<ShapeActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ShapeActionFeedback::ID:
            {
                ShapeActionFeedbackNML * tempmsg = static_cast<ShapeActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ShapeActionGoal::ID:
            {
                ShapeActionGoalNML * tempmsg = static_cast<ShapeActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ShapeActionResult::ID:
            {
                ShapeActionResultNML * tempmsg = static_cast<ShapeActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ShapeFeedback::ID:
            {
                ShapeFeedbackNML * tempmsg = static_cast<ShapeFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ShapeGoal::ID:
            {
                ShapeGoalNML * tempmsg = static_cast<ShapeGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ShapeResult::ID:
            {
                ShapeResultNML * tempmsg = static_cast<ShapeResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Velocity::ID:
            {
                VelocityNML * tempmsg = static_cast<VelocityNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case ShapeAction::ID:
            {
                ShapeActionNML & tempDst = static_cast<ShapeActionNML&>(dst);
                Message<ShapeAction > & tempSrc = static_cast<Message<ShapeAction>&>(src);

                if (tempSrc.version() != ShapeAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeAction: " << __FILE__ << " expected: " 
                             << ShapeAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeAction: " << __FILE__ << " expected: " 
                         << ShapeAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ShapeActionFeedback::ID:
            {
                ShapeActionFeedbackNML & tempDst = static_cast<ShapeActionFeedbackNML&>(dst);
                Message<ShapeActionFeedback > & tempSrc = static_cast<Message<ShapeActionFeedback>&>(src);

                if (tempSrc.version() != ShapeActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeActionFeedback: " << __FILE__ << " expected: " 
                             << ShapeActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeActionFeedback: " << __FILE__ << " expected: " 
                         << ShapeActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ShapeActionGoal::ID:
            {
                ShapeActionGoalNML & tempDst = static_cast<ShapeActionGoalNML&>(dst);
                Message<ShapeActionGoal > & tempSrc = static_cast<Message<ShapeActionGoal>&>(src);

                if (tempSrc.version() != ShapeActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeActionGoal: " << __FILE__ << " expected: " 
                             << ShapeActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeActionGoal: " << __FILE__ << " expected: " 
                         << ShapeActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ShapeActionResult::ID:
            {
                ShapeActionResultNML & tempDst = static_cast<ShapeActionResultNML&>(dst);
                Message<ShapeActionResult > & tempSrc = static_cast<Message<ShapeActionResult>&>(src);

                if (tempSrc.version() != ShapeActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeActionResult: " << __FILE__ << " expected: " 
                             << ShapeActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeActionResult: " << __FILE__ << " expected: " 
                         << ShapeActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ShapeFeedback::ID:
            {
                ShapeFeedbackNML & tempDst = static_cast<ShapeFeedbackNML&>(dst);
                Message<ShapeFeedback > & tempSrc = static_cast<Message<ShapeFeedback>&>(src);

                if (tempSrc.version() != ShapeFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeFeedback: " << __FILE__ << " expected: " 
                             << ShapeFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeFeedback: " << __FILE__ << " expected: " 
                         << ShapeFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ShapeGoal::ID:
            {
                ShapeGoalNML & tempDst = static_cast<ShapeGoalNML&>(dst);
                Message<ShapeGoal > & tempSrc = static_cast<Message<ShapeGoal>&>(src);

                if (tempSrc.version() != ShapeGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeGoal: " << __FILE__ << " expected: " 
                             << ShapeGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeGoal: " << __FILE__ << " expected: " 
                         << ShapeGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ShapeResult::ID:
            {
                ShapeResultNML & tempDst = static_cast<ShapeResultNML&>(dst);
                Message<ShapeResult > & tempSrc = static_cast<Message<ShapeResult>&>(src);

                if (tempSrc.version() != ShapeResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ShapeResult: " << __FILE__ << " expected: " 
                             << ShapeResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ShapeResult: " << __FILE__ << " expected: " 
                         << ShapeResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Velocity::ID:
            {
                VelocityNML & tempDst = static_cast<VelocityNML&>(dst);
                Message<Velocity > & tempSrc = static_cast<Message<Velocity>&>(src);

                if (tempSrc.version() != Velocity::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Velocity: " << __FILE__ << " expected: " 
                             << Velocity::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Velocity: " << __FILE__ << " expected: " 
                         << Velocity::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case ShapeAction::ID:
            {
                ShapeActionNML & tempSrc = static_cast<ShapeActionNML&>(src);
                Message<ShapeAction > & tempDst = static_cast<Message<ShapeAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ShapeActionFeedback::ID:
            {
                ShapeActionFeedbackNML & tempSrc = static_cast<ShapeActionFeedbackNML&>(src);
                Message<ShapeActionFeedback > & tempDst = static_cast<Message<ShapeActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ShapeActionGoal::ID:
            {
                ShapeActionGoalNML & tempSrc = static_cast<ShapeActionGoalNML&>(src);
                Message<ShapeActionGoal > & tempDst = static_cast<Message<ShapeActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ShapeActionResult::ID:
            {
                ShapeActionResultNML & tempSrc = static_cast<ShapeActionResultNML&>(src);
                Message<ShapeActionResult > & tempDst = static_cast<Message<ShapeActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ShapeFeedback::ID:
            {
                ShapeFeedbackNML & tempSrc = static_cast<ShapeFeedbackNML&>(src);
                Message<ShapeFeedback > & tempDst = static_cast<Message<ShapeFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ShapeGoal::ID:
            {
                ShapeGoalNML & tempSrc = static_cast<ShapeGoalNML&>(src);
                Message<ShapeGoal > & tempDst = static_cast<Message<ShapeGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ShapeResult::ID:
            {
                ShapeResultNML & tempSrc = static_cast<ShapeResultNML&>(src);
                Message<ShapeResult > & tempDst = static_cast<Message<ShapeResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ShapeResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Velocity::ID:
            {
                VelocityNML & tempSrc = static_cast<VelocityNML&>(src);
                Message<Velocity > & tempDst = static_cast<Message<Velocity>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Velocity::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case ShapeAction::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeAction at %p\n",buffer);
                ShapeActionNML * p = static_cast<ShapeActionNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ShapeActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeActionFeedback at %p\n",buffer);
                ShapeActionFeedbackNML * p = static_cast<ShapeActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ShapeActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeActionGoal at %p\n",buffer);
                ShapeActionGoalNML * p = static_cast<ShapeActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ShapeActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeActionResult at %p\n",buffer);
                ShapeActionResultNML * p = static_cast<ShapeActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ShapeFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeFeedback at %p\n",buffer);
                ShapeFeedbackNML * p = static_cast<ShapeFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ShapeGoal::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeGoal at %p\n",buffer);
                ShapeGoalNML * p = static_cast<ShapeGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ShapeResult::ID:
        {
            // only need to construct if data type is not flat
            if (ShapeResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ShapeResult at %p\n",buffer);
                ShapeResultNML * p = static_cast<ShapeResultNML*>(buffer);
                // construct the type at pointer p
                new (p) ShapeResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ShapeResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Velocity::ID:
        {
            // only need to construct if data type is not flat
            if (Velocity::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Velocity at %p\n",buffer);
                VelocityNML * p = static_cast<VelocityNML*>(buffer);
                // construct the type at pointer p
                new (p) VelocityNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Velocity at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int turtle_actionlib_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case ShapeAction::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeAction at %p\n",buffer);
                ShapeActionNML * p = static_cast<ShapeActionNML*>(buffer);
                p->~ShapeActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case ShapeActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeActionFeedback at %p\n",buffer);
                ShapeActionFeedbackNML * p = static_cast<ShapeActionFeedbackNML*>(buffer);
                p->~ShapeActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case ShapeActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeActionGoal at %p\n",buffer);
                ShapeActionGoalNML * p = static_cast<ShapeActionGoalNML*>(buffer);
                p->~ShapeActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case ShapeActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeActionResult at %p\n",buffer);
                ShapeActionResultNML * p = static_cast<ShapeActionResultNML*>(buffer);
                p->~ShapeActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case ShapeFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeFeedback at %p\n",buffer);
                ShapeFeedbackNML * p = static_cast<ShapeFeedbackNML*>(buffer);
                p->~ShapeFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case ShapeGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeGoal at %p\n",buffer);
                ShapeGoalNML * p = static_cast<ShapeGoalNML*>(buffer);
                p->~ShapeGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case ShapeResult::ID:
        {
            // only need to destruct if data type is not flat
            if (ShapeResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ShapeResult at %p\n",buffer);
                ShapeResultNML * p = static_cast<ShapeResultNML*>(buffer);
                p->~ShapeResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ShapeResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case Velocity::ID:
        {
            // only need to destruct if data type is not flat
            if (Velocity::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Velocity at %p\n",buffer);
                VelocityNML * p = static_cast<VelocityNML*>(buffer);
                p->~VelocityNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Velocity at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

ShapeActionNML::ShapeActionNML() : NMLmsg((NMLTYPE)ShapeAction::ID,sizeof(ShapeActionNML)), nmlVersion(ShapeAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeAction()*/)
{
};

ShapeActionNML::~ShapeActionNML()
{
};

ShapeActionNML & ShapeActionNML::operator=(const ShapeActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeActionNML & ShapeActionNML::operator=(const ShapeAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeAction> temp(new ShapeAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeAction Message version mismatch, expected " << ShapeAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeAction Message version mismatch, expected " << ShapeAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

ShapeActionFeedbackNML::ShapeActionFeedbackNML() : NMLmsg((NMLTYPE)ShapeActionFeedback::ID,sizeof(ShapeActionFeedbackNML)), nmlVersion(ShapeActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeActionFeedback()*/)
{
};

ShapeActionFeedbackNML::~ShapeActionFeedbackNML()
{
};

ShapeActionFeedbackNML & ShapeActionFeedbackNML::operator=(const ShapeActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeActionFeedbackNML & ShapeActionFeedbackNML::operator=(const ShapeActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeActionFeedback> temp(new ShapeActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeActionFeedback Message version mismatch, expected " << ShapeActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeActionFeedback Message version mismatch, expected " << ShapeActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

ShapeActionGoalNML::ShapeActionGoalNML() : NMLmsg((NMLTYPE)ShapeActionGoal::ID,sizeof(ShapeActionGoalNML)), nmlVersion(ShapeActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeActionGoal()*/)
{
};

ShapeActionGoalNML::~ShapeActionGoalNML()
{
};

ShapeActionGoalNML & ShapeActionGoalNML::operator=(const ShapeActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeActionGoalNML & ShapeActionGoalNML::operator=(const ShapeActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeActionGoal> temp(new ShapeActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeActionGoal Message version mismatch, expected " << ShapeActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeActionGoal Message version mismatch, expected " << ShapeActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

ShapeActionResultNML::ShapeActionResultNML() : NMLmsg((NMLTYPE)ShapeActionResult::ID,sizeof(ShapeActionResultNML)), nmlVersion(ShapeActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeActionResult()*/)
{
};

ShapeActionResultNML::~ShapeActionResultNML()
{
};

ShapeActionResultNML & ShapeActionResultNML::operator=(const ShapeActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeActionResultNML & ShapeActionResultNML::operator=(const ShapeActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeActionResult> temp(new ShapeActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeActionResult Message version mismatch, expected " << ShapeActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeActionResult Message version mismatch, expected " << ShapeActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

ShapeFeedbackNML::ShapeFeedbackNML() : NMLmsg((NMLTYPE)ShapeFeedback::ID,sizeof(ShapeFeedbackNML)), nmlVersion(ShapeFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeFeedback()*/)
{
};

ShapeFeedbackNML::~ShapeFeedbackNML()
{
};

ShapeFeedbackNML & ShapeFeedbackNML::operator=(const ShapeFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeFeedbackNML & ShapeFeedbackNML::operator=(const ShapeFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeFeedback> temp(new ShapeFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeFeedback Message version mismatch, expected " << ShapeFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeFeedback Message version mismatch, expected " << ShapeFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.edges);
        cms->update(inobj.radius);

    }  
 }

ShapeGoalNML::ShapeGoalNML() : NMLmsg((NMLTYPE)ShapeGoal::ID,sizeof(ShapeGoalNML)), nmlVersion(ShapeGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeGoal()*/)
{
};

ShapeGoalNML::~ShapeGoalNML()
{
};

ShapeGoalNML & ShapeGoalNML::operator=(const ShapeGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeGoalNML & ShapeGoalNML::operator=(const ShapeGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeGoal> temp(new ShapeGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeGoal Message version mismatch, expected " << ShapeGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeGoal Message version mismatch, expected " << ShapeGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, ShapeResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ShapeResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.interior_angle);
        cms->update(inobj.apothem);

    }  
 }

ShapeResultNML::ShapeResultNML() : NMLmsg((NMLTYPE)ShapeResult::ID,sizeof(ShapeResultNML)), nmlVersion(ShapeResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ShapeResult()*/)
{
};

ShapeResultNML::~ShapeResultNML()
{
};

ShapeResultNML & ShapeResultNML::operator=(const ShapeResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ShapeResultNML & ShapeResultNML::operator=(const ShapeResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ShapeResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ShapeResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ShapeResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ShapeResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ShapeResult> temp(new ShapeResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ShapeResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ShapeResult Message version mismatch, expected " << ShapeResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ShapeResult Message version mismatch, expected " << ShapeResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void turtle_actionlib::nmlupdate(CMS * cms, Velocity & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Velocity, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.linear);
        cms->update(inobj.angular);

    }  
 }

VelocityNML::VelocityNML() : NMLmsg((NMLTYPE)Velocity::ID,sizeof(VelocityNML)), nmlVersion(Velocity::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Velocity()*/)
{
};

VelocityNML::~VelocityNML()
{
};

VelocityNML & VelocityNML::operator=(const VelocityNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

VelocityNML & VelocityNML::operator=(const Velocity & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Velocity);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void VelocityNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Velocity&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: VelocityNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Velocity> temp(new Velocity());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: turtle_actionlib_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Velocity::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Velocity Message version mismatch, expected " << Velocity::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Velocity Message version mismatch, expected " << Velocity::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int turtle_actionlib::turtle_actionlib_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("turtle_actionlib_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case ShapeAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeAction, id " << ShapeAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ShapeActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeActionFeedback, id " << ShapeActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ShapeActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeActionGoal, id " << ShapeActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ShapeActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeActionResult, id " << ShapeActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ShapeFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeFeedback, id " << ShapeFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ShapeGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeGoal, id " << ShapeGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ShapeResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ShapeResult, id " << ShapeResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ShapeResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Velocity::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Velocity, id " << Velocity::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_turtle_actionlib_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"turtle_actionlib_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((VelocityNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

