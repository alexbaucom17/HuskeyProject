// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2017-01-26 12:56:52 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "frontier_exploration_gencpp_NML.h"
#include "frontier_exploration_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <ExploreTaskAction.h>
#include <ExploreTaskActionFeedback.h>
#include <ExploreTaskActionGoal.h>
#include <ExploreTaskActionResult.h>
#include <ExploreTaskFeedback.h>
#include <ExploreTaskGoal.h>
#include <ExploreTaskResult.h>
#include <Frontier.h>
#include <GetNextFrontierRequest.h>
#include <GetNextFrontierResponse.h>
#include <GetNextFrontier.h>
#include <UpdateBoundaryPolygonRequest.h>
#include <UpdateBoundaryPolygonResponse.h>
#include <UpdateBoundaryPolygon.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace frontier_exploration;

rframe::NMLMessageFactory * NML_frontier_exploration_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_frontier_exploration_gencppfactory = new frontier_exploration_gencppNMLMessageFactory();
        return NML_frontier_exploration_gencppfactory;
    };
}

rframe::NMLMessageFactory * frontier_exploration::allocate_frontier_exploration_gencpp()
{
    NML_frontier_exploration_gencppfactory = new frontier_exploration_gencppNMLMessageFactory();
    return NML_frontier_exploration_gencppfactory;
};

frontier_exploration_gencppNMLMessageFactory::frontier_exploration_gencppNMLMessageFactory()
{
    name("frontier_exploration_gencpp");
    // use constructor to register data types
    frontier_exploration::registerLibrary();
}

frontier_exploration_gencppNMLMessageFactory::~frontier_exploration_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR frontier_exploration_gencppNMLMessageFactory::FormatPointer()
{
    return frontier_exploration_gencpp_format;
}

int frontier_exploration_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void frontier_exploration_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(ExploreTaskAction::ID);
    info.name(ExploreTaskAction::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskAction::DATA_VERSION);
    info.md5Key(ExploreTaskAction::VERSION_MD5);
    info.xmlSource(ExploreTaskAction::XML_SOURCE);
    info.flat(ExploreTaskAction::dataTypeFlat());
    ids.push_back(info);

    info.id(ExploreTaskActionFeedback::ID);
    info.name(ExploreTaskActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskActionFeedback::DATA_VERSION);
    info.md5Key(ExploreTaskActionFeedback::VERSION_MD5);
    info.xmlSource(ExploreTaskActionFeedback::XML_SOURCE);
    info.flat(ExploreTaskActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(ExploreTaskActionGoal::ID);
    info.name(ExploreTaskActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskActionGoal::DATA_VERSION);
    info.md5Key(ExploreTaskActionGoal::VERSION_MD5);
    info.xmlSource(ExploreTaskActionGoal::XML_SOURCE);
    info.flat(ExploreTaskActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(ExploreTaskActionResult::ID);
    info.name(ExploreTaskActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskActionResult::DATA_VERSION);
    info.md5Key(ExploreTaskActionResult::VERSION_MD5);
    info.xmlSource(ExploreTaskActionResult::XML_SOURCE);
    info.flat(ExploreTaskActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(ExploreTaskFeedback::ID);
    info.name(ExploreTaskFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskFeedback::DATA_VERSION);
    info.md5Key(ExploreTaskFeedback::VERSION_MD5);
    info.xmlSource(ExploreTaskFeedback::XML_SOURCE);
    info.flat(ExploreTaskFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(ExploreTaskGoal::ID);
    info.name(ExploreTaskGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskGoal::DATA_VERSION);
    info.md5Key(ExploreTaskGoal::VERSION_MD5);
    info.xmlSource(ExploreTaskGoal::XML_SOURCE);
    info.flat(ExploreTaskGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(ExploreTaskResult::ID);
    info.name(ExploreTaskResult::DATA_TYPE_FULL_NAME);
    info.hashKey(ExploreTaskResult::DATA_VERSION);
    info.md5Key(ExploreTaskResult::VERSION_MD5);
    info.xmlSource(ExploreTaskResult::XML_SOURCE);
    info.flat(ExploreTaskResult::dataTypeFlat());
    ids.push_back(info);

    info.id(Frontier::ID);
    info.name(Frontier::DATA_TYPE_FULL_NAME);
    info.hashKey(Frontier::DATA_VERSION);
    info.md5Key(Frontier::VERSION_MD5);
    info.xmlSource(Frontier::XML_SOURCE);
    info.flat(Frontier::dataTypeFlat());
    ids.push_back(info);

    info.id(GetNextFrontierRequest::ID);
    info.name(GetNextFrontierRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetNextFrontierRequest::DATA_VERSION);
    info.md5Key(GetNextFrontierRequest::VERSION_MD5);
    info.xmlSource(GetNextFrontierRequest::XML_SOURCE);
    info.flat(GetNextFrontierRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetNextFrontierResponse::ID);
    info.name(GetNextFrontierResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetNextFrontierResponse::DATA_VERSION);
    info.md5Key(GetNextFrontierResponse::VERSION_MD5);
    info.xmlSource(GetNextFrontierResponse::XML_SOURCE);
    info.flat(GetNextFrontierResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetNextFrontier::ID);
    info.name(GetNextFrontier::DATA_TYPE_FULL_NAME);
    info.hashKey(GetNextFrontier::DATA_VERSION);
    info.md5Key(GetNextFrontier::VERSION_MD5);
    info.xmlSource(GetNextFrontier::XML_SOURCE);
    info.flat(GetNextFrontier::dataTypeFlat());
    ids.push_back(info);

    info.id(UpdateBoundaryPolygonRequest::ID);
    info.name(UpdateBoundaryPolygonRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(UpdateBoundaryPolygonRequest::DATA_VERSION);
    info.md5Key(UpdateBoundaryPolygonRequest::VERSION_MD5);
    info.xmlSource(UpdateBoundaryPolygonRequest::XML_SOURCE);
    info.flat(UpdateBoundaryPolygonRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(UpdateBoundaryPolygonResponse::ID);
    info.name(UpdateBoundaryPolygonResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(UpdateBoundaryPolygonResponse::DATA_VERSION);
    info.md5Key(UpdateBoundaryPolygonResponse::VERSION_MD5);
    info.xmlSource(UpdateBoundaryPolygonResponse::XML_SOURCE);
    info.flat(UpdateBoundaryPolygonResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(UpdateBoundaryPolygon::ID);
    info.name(UpdateBoundaryPolygon::DATA_TYPE_FULL_NAME);
    info.hashKey(UpdateBoundaryPolygon::DATA_VERSION);
    info.md5Key(UpdateBoundaryPolygon::VERSION_MD5);
    info.xmlSource(UpdateBoundaryPolygon::XML_SOURCE);
    info.flat(UpdateBoundaryPolygon::dataTypeFlat());
    ids.push_back(info);

}

int frontier_exploration_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case ExploreTaskAction::ID:
        {
            //ExploreTaskActionNML * newmsg = new ExploreTaskActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskActionNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ExploreTaskActionFeedback::ID:
        {
            //ExploreTaskActionFeedbackNML * newmsg = new ExploreTaskActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskActionFeedbackNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ExploreTaskActionGoal::ID:
        {
            //ExploreTaskActionGoalNML * newmsg = new ExploreTaskActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskActionGoalNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ExploreTaskActionResult::ID:
        {
            //ExploreTaskActionResultNML * newmsg = new ExploreTaskActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskActionResultNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ExploreTaskFeedback::ID:
        {
            //ExploreTaskFeedbackNML * newmsg = new ExploreTaskFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskFeedbackNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ExploreTaskGoal::ID:
        {
            //ExploreTaskGoalNML * newmsg = new ExploreTaskGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskGoalNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ExploreTaskResult::ID:
        {
            //ExploreTaskResultNML * newmsg = new ExploreTaskResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ExploreTaskResultNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Frontier::ID:
        {
            //FrontierNML * newmsg = new FrontierNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrontierNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetNextFrontierRequest::ID:
        {
            //GetNextFrontierRequestNML * newmsg = new GetNextFrontierRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetNextFrontierRequestNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetNextFrontierResponse::ID:
        {
            //GetNextFrontierResponseNML * newmsg = new GetNextFrontierResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetNextFrontierResponseNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetNextFrontier::ID:
        {
            //GetNextFrontierNML * newmsg = new GetNextFrontierNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetNextFrontierNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UpdateBoundaryPolygonRequest::ID:
        {
            //UpdateBoundaryPolygonRequestNML * newmsg = new UpdateBoundaryPolygonRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UpdateBoundaryPolygonRequestNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UpdateBoundaryPolygonResponse::ID:
        {
            //UpdateBoundaryPolygonResponseNML * newmsg = new UpdateBoundaryPolygonResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UpdateBoundaryPolygonResponseNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UpdateBoundaryPolygon::ID:
        {
            //UpdateBoundaryPolygonNML * newmsg = new UpdateBoundaryPolygonNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UpdateBoundaryPolygonNML(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case ExploreTaskAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskAction>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ExploreTaskActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskActionFeedback>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ExploreTaskActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskActionGoal>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ExploreTaskActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskActionResult>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ExploreTaskFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskFeedback>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ExploreTaskGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskGoal>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ExploreTaskResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ExploreTaskResult>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Frontier::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Frontier>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetNextFrontierRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetNextFrontierRequest>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetNextFrontierResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetNextFrontierResponse>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetNextFrontier::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetNextFrontier>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UpdateBoundaryPolygonRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UpdateBoundaryPolygonRequest>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UpdateBoundaryPolygonResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UpdateBoundaryPolygonResponse>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UpdateBoundaryPolygon::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UpdateBoundaryPolygon>(),std::bind(&frontier_exploration_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case ExploreTaskAction::ID:
            {
                ExploreTaskActionNML * tempmsg = static_cast<ExploreTaskActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ExploreTaskActionFeedback::ID:
            {
                ExploreTaskActionFeedbackNML * tempmsg = static_cast<ExploreTaskActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ExploreTaskActionGoal::ID:
            {
                ExploreTaskActionGoalNML * tempmsg = static_cast<ExploreTaskActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ExploreTaskActionResult::ID:
            {
                ExploreTaskActionResultNML * tempmsg = static_cast<ExploreTaskActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ExploreTaskFeedback::ID:
            {
                ExploreTaskFeedbackNML * tempmsg = static_cast<ExploreTaskFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ExploreTaskGoal::ID:
            {
                ExploreTaskGoalNML * tempmsg = static_cast<ExploreTaskGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ExploreTaskResult::ID:
            {
                ExploreTaskResultNML * tempmsg = static_cast<ExploreTaskResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Frontier::ID:
            {
                FrontierNML * tempmsg = static_cast<FrontierNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetNextFrontierRequest::ID:
            {
                GetNextFrontierRequestNML * tempmsg = static_cast<GetNextFrontierRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetNextFrontierResponse::ID:
            {
                GetNextFrontierResponseNML * tempmsg = static_cast<GetNextFrontierResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetNextFrontier::ID:
            {
                GetNextFrontierNML * tempmsg = static_cast<GetNextFrontierNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UpdateBoundaryPolygonRequest::ID:
            {
                UpdateBoundaryPolygonRequestNML * tempmsg = static_cast<UpdateBoundaryPolygonRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UpdateBoundaryPolygonResponse::ID:
            {
                UpdateBoundaryPolygonResponseNML * tempmsg = static_cast<UpdateBoundaryPolygonResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UpdateBoundaryPolygon::ID:
            {
                UpdateBoundaryPolygonNML * tempmsg = static_cast<UpdateBoundaryPolygonNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case ExploreTaskAction::ID:
            {
                ExploreTaskActionNML & tempDst = static_cast<ExploreTaskActionNML&>(dst);
                Message<ExploreTaskAction > & tempSrc = static_cast<Message<ExploreTaskAction>&>(src);

                if (tempSrc.version() != ExploreTaskAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskAction: " << __FILE__ << " expected: " 
                             << ExploreTaskAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskAction: " << __FILE__ << " expected: " 
                         << ExploreTaskAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ExploreTaskActionFeedback::ID:
            {
                ExploreTaskActionFeedbackNML & tempDst = static_cast<ExploreTaskActionFeedbackNML&>(dst);
                Message<ExploreTaskActionFeedback > & tempSrc = static_cast<Message<ExploreTaskActionFeedback>&>(src);

                if (tempSrc.version() != ExploreTaskActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskActionFeedback: " << __FILE__ << " expected: " 
                             << ExploreTaskActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskActionFeedback: " << __FILE__ << " expected: " 
                         << ExploreTaskActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ExploreTaskActionGoal::ID:
            {
                ExploreTaskActionGoalNML & tempDst = static_cast<ExploreTaskActionGoalNML&>(dst);
                Message<ExploreTaskActionGoal > & tempSrc = static_cast<Message<ExploreTaskActionGoal>&>(src);

                if (tempSrc.version() != ExploreTaskActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskActionGoal: " << __FILE__ << " expected: " 
                             << ExploreTaskActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskActionGoal: " << __FILE__ << " expected: " 
                         << ExploreTaskActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ExploreTaskActionResult::ID:
            {
                ExploreTaskActionResultNML & tempDst = static_cast<ExploreTaskActionResultNML&>(dst);
                Message<ExploreTaskActionResult > & tempSrc = static_cast<Message<ExploreTaskActionResult>&>(src);

                if (tempSrc.version() != ExploreTaskActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskActionResult: " << __FILE__ << " expected: " 
                             << ExploreTaskActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskActionResult: " << __FILE__ << " expected: " 
                         << ExploreTaskActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ExploreTaskFeedback::ID:
            {
                ExploreTaskFeedbackNML & tempDst = static_cast<ExploreTaskFeedbackNML&>(dst);
                Message<ExploreTaskFeedback > & tempSrc = static_cast<Message<ExploreTaskFeedback>&>(src);

                if (tempSrc.version() != ExploreTaskFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskFeedback: " << __FILE__ << " expected: " 
                             << ExploreTaskFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskFeedback: " << __FILE__ << " expected: " 
                         << ExploreTaskFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ExploreTaskGoal::ID:
            {
                ExploreTaskGoalNML & tempDst = static_cast<ExploreTaskGoalNML&>(dst);
                Message<ExploreTaskGoal > & tempSrc = static_cast<Message<ExploreTaskGoal>&>(src);

                if (tempSrc.version() != ExploreTaskGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskGoal: " << __FILE__ << " expected: " 
                             << ExploreTaskGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskGoal: " << __FILE__ << " expected: " 
                         << ExploreTaskGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ExploreTaskResult::ID:
            {
                ExploreTaskResultNML & tempDst = static_cast<ExploreTaskResultNML&>(dst);
                Message<ExploreTaskResult > & tempSrc = static_cast<Message<ExploreTaskResult>&>(src);

                if (tempSrc.version() != ExploreTaskResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ExploreTaskResult: " << __FILE__ << " expected: " 
                             << ExploreTaskResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ExploreTaskResult: " << __FILE__ << " expected: " 
                         << ExploreTaskResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Frontier::ID:
            {
                FrontierNML & tempDst = static_cast<FrontierNML&>(dst);
                Message<Frontier > & tempSrc = static_cast<Message<Frontier>&>(src);

                if (tempSrc.version() != Frontier::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Frontier: " << __FILE__ << " expected: " 
                             << Frontier::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Frontier: " << __FILE__ << " expected: " 
                         << Frontier::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetNextFrontierRequest::ID:
            {
                GetNextFrontierRequestNML & tempDst = static_cast<GetNextFrontierRequestNML&>(dst);
                Message<GetNextFrontierRequest > & tempSrc = static_cast<Message<GetNextFrontierRequest>&>(src);

                if (tempSrc.version() != GetNextFrontierRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetNextFrontierRequest: " << __FILE__ << " expected: " 
                             << GetNextFrontierRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetNextFrontierRequest: " << __FILE__ << " expected: " 
                         << GetNextFrontierRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetNextFrontierResponse::ID:
            {
                GetNextFrontierResponseNML & tempDst = static_cast<GetNextFrontierResponseNML&>(dst);
                Message<GetNextFrontierResponse > & tempSrc = static_cast<Message<GetNextFrontierResponse>&>(src);

                if (tempSrc.version() != GetNextFrontierResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetNextFrontierResponse: " << __FILE__ << " expected: " 
                             << GetNextFrontierResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetNextFrontierResponse: " << __FILE__ << " expected: " 
                         << GetNextFrontierResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetNextFrontier::ID:
            {
                GetNextFrontierNML & tempDst = static_cast<GetNextFrontierNML&>(dst);
                Message<GetNextFrontier > & tempSrc = static_cast<Message<GetNextFrontier>&>(src);

                if (tempSrc.version() != GetNextFrontier::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetNextFrontier: " << __FILE__ << " expected: " 
                             << GetNextFrontier::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetNextFrontier: " << __FILE__ << " expected: " 
                         << GetNextFrontier::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UpdateBoundaryPolygonRequest::ID:
            {
                UpdateBoundaryPolygonRequestNML & tempDst = static_cast<UpdateBoundaryPolygonRequestNML&>(dst);
                Message<UpdateBoundaryPolygonRequest > & tempSrc = static_cast<Message<UpdateBoundaryPolygonRequest>&>(src);

                if (tempSrc.version() != UpdateBoundaryPolygonRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UpdateBoundaryPolygonRequest: " << __FILE__ << " expected: " 
                             << UpdateBoundaryPolygonRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UpdateBoundaryPolygonRequest: " << __FILE__ << " expected: " 
                         << UpdateBoundaryPolygonRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UpdateBoundaryPolygonResponse::ID:
            {
                UpdateBoundaryPolygonResponseNML & tempDst = static_cast<UpdateBoundaryPolygonResponseNML&>(dst);
                Message<UpdateBoundaryPolygonResponse > & tempSrc = static_cast<Message<UpdateBoundaryPolygonResponse>&>(src);

                if (tempSrc.version() != UpdateBoundaryPolygonResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UpdateBoundaryPolygonResponse: " << __FILE__ << " expected: " 
                             << UpdateBoundaryPolygonResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UpdateBoundaryPolygonResponse: " << __FILE__ << " expected: " 
                         << UpdateBoundaryPolygonResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UpdateBoundaryPolygon::ID:
            {
                UpdateBoundaryPolygonNML & tempDst = static_cast<UpdateBoundaryPolygonNML&>(dst);
                Message<UpdateBoundaryPolygon > & tempSrc = static_cast<Message<UpdateBoundaryPolygon>&>(src);

                if (tempSrc.version() != UpdateBoundaryPolygon::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UpdateBoundaryPolygon: " << __FILE__ << " expected: " 
                             << UpdateBoundaryPolygon::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UpdateBoundaryPolygon: " << __FILE__ << " expected: " 
                         << UpdateBoundaryPolygon::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case ExploreTaskAction::ID:
            {
                ExploreTaskActionNML & tempSrc = static_cast<ExploreTaskActionNML&>(src);
                Message<ExploreTaskAction > & tempDst = static_cast<Message<ExploreTaskAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ExploreTaskActionFeedback::ID:
            {
                ExploreTaskActionFeedbackNML & tempSrc = static_cast<ExploreTaskActionFeedbackNML&>(src);
                Message<ExploreTaskActionFeedback > & tempDst = static_cast<Message<ExploreTaskActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ExploreTaskActionGoal::ID:
            {
                ExploreTaskActionGoalNML & tempSrc = static_cast<ExploreTaskActionGoalNML&>(src);
                Message<ExploreTaskActionGoal > & tempDst = static_cast<Message<ExploreTaskActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ExploreTaskActionResult::ID:
            {
                ExploreTaskActionResultNML & tempSrc = static_cast<ExploreTaskActionResultNML&>(src);
                Message<ExploreTaskActionResult > & tempDst = static_cast<Message<ExploreTaskActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ExploreTaskFeedback::ID:
            {
                ExploreTaskFeedbackNML & tempSrc = static_cast<ExploreTaskFeedbackNML&>(src);
                Message<ExploreTaskFeedback > & tempDst = static_cast<Message<ExploreTaskFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ExploreTaskGoal::ID:
            {
                ExploreTaskGoalNML & tempSrc = static_cast<ExploreTaskGoalNML&>(src);
                Message<ExploreTaskGoal > & tempDst = static_cast<Message<ExploreTaskGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ExploreTaskResult::ID:
            {
                ExploreTaskResultNML & tempSrc = static_cast<ExploreTaskResultNML&>(src);
                Message<ExploreTaskResult > & tempDst = static_cast<Message<ExploreTaskResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ExploreTaskResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Frontier::ID:
            {
                FrontierNML & tempSrc = static_cast<FrontierNML&>(src);
                Message<Frontier > & tempDst = static_cast<Message<Frontier>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Frontier::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetNextFrontierRequest::ID:
            {
                GetNextFrontierRequestNML & tempSrc = static_cast<GetNextFrontierRequestNML&>(src);
                Message<GetNextFrontierRequest > & tempDst = static_cast<Message<GetNextFrontierRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetNextFrontierRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetNextFrontierResponse::ID:
            {
                GetNextFrontierResponseNML & tempSrc = static_cast<GetNextFrontierResponseNML&>(src);
                Message<GetNextFrontierResponse > & tempDst = static_cast<Message<GetNextFrontierResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetNextFrontierResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetNextFrontier::ID:
            {
                GetNextFrontierNML & tempSrc = static_cast<GetNextFrontierNML&>(src);
                Message<GetNextFrontier > & tempDst = static_cast<Message<GetNextFrontier>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetNextFrontier::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UpdateBoundaryPolygonRequest::ID:
            {
                UpdateBoundaryPolygonRequestNML & tempSrc = static_cast<UpdateBoundaryPolygonRequestNML&>(src);
                Message<UpdateBoundaryPolygonRequest > & tempDst = static_cast<Message<UpdateBoundaryPolygonRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UpdateBoundaryPolygonRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UpdateBoundaryPolygonResponse::ID:
            {
                UpdateBoundaryPolygonResponseNML & tempSrc = static_cast<UpdateBoundaryPolygonResponseNML&>(src);
                Message<UpdateBoundaryPolygonResponse > & tempDst = static_cast<Message<UpdateBoundaryPolygonResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UpdateBoundaryPolygonResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UpdateBoundaryPolygon::ID:
            {
                UpdateBoundaryPolygonNML & tempSrc = static_cast<UpdateBoundaryPolygonNML&>(src);
                Message<UpdateBoundaryPolygon > & tempDst = static_cast<Message<UpdateBoundaryPolygon>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UpdateBoundaryPolygon::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case ExploreTaskAction::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskAction at %p\n",buffer);
                ExploreTaskActionNML * p = static_cast<ExploreTaskActionNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskActionFeedback at %p\n",buffer);
                ExploreTaskActionFeedbackNML * p = static_cast<ExploreTaskActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskActionGoal at %p\n",buffer);
                ExploreTaskActionGoalNML * p = static_cast<ExploreTaskActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskActionResult at %p\n",buffer);
                ExploreTaskActionResultNML * p = static_cast<ExploreTaskActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskFeedback at %p\n",buffer);
                ExploreTaskFeedbackNML * p = static_cast<ExploreTaskFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskGoal::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskGoal at %p\n",buffer);
                ExploreTaskGoalNML * p = static_cast<ExploreTaskGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskResult::ID:
        {
            // only need to construct if data type is not flat
            if (ExploreTaskResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ExploreTaskResult at %p\n",buffer);
                ExploreTaskResultNML * p = static_cast<ExploreTaskResultNML*>(buffer);
                // construct the type at pointer p
                new (p) ExploreTaskResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ExploreTaskResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Frontier::ID:
        {
            // only need to construct if data type is not flat
            if (Frontier::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Frontier at %p\n",buffer);
                FrontierNML * p = static_cast<FrontierNML*>(buffer);
                // construct the type at pointer p
                new (p) FrontierNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Frontier at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetNextFrontierRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetNextFrontierRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetNextFrontierRequest at %p\n",buffer);
                GetNextFrontierRequestNML * p = static_cast<GetNextFrontierRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetNextFrontierRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetNextFrontierRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetNextFrontierResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetNextFrontierResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetNextFrontierResponse at %p\n",buffer);
                GetNextFrontierResponseNML * p = static_cast<GetNextFrontierResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetNextFrontierResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetNextFrontierResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetNextFrontier::ID:
        {
            // only need to construct if data type is not flat
            if (GetNextFrontier::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetNextFrontier at %p\n",buffer);
                GetNextFrontierNML * p = static_cast<GetNextFrontierNML*>(buffer);
                // construct the type at pointer p
                new (p) GetNextFrontierNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetNextFrontier at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UpdateBoundaryPolygonRequest::ID:
        {
            // only need to construct if data type is not flat
            if (UpdateBoundaryPolygonRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UpdateBoundaryPolygonRequest at %p\n",buffer);
                UpdateBoundaryPolygonRequestNML * p = static_cast<UpdateBoundaryPolygonRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) UpdateBoundaryPolygonRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UpdateBoundaryPolygonRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UpdateBoundaryPolygonResponse::ID:
        {
            // only need to construct if data type is not flat
            if (UpdateBoundaryPolygonResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UpdateBoundaryPolygonResponse at %p\n",buffer);
                UpdateBoundaryPolygonResponseNML * p = static_cast<UpdateBoundaryPolygonResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) UpdateBoundaryPolygonResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UpdateBoundaryPolygonResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UpdateBoundaryPolygon::ID:
        {
            // only need to construct if data type is not flat
            if (UpdateBoundaryPolygon::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UpdateBoundaryPolygon at %p\n",buffer);
                UpdateBoundaryPolygonNML * p = static_cast<UpdateBoundaryPolygonNML*>(buffer);
                // construct the type at pointer p
                new (p) UpdateBoundaryPolygonNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UpdateBoundaryPolygon at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int frontier_exploration_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case ExploreTaskAction::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskAction at %p\n",buffer);
                ExploreTaskActionNML * p = static_cast<ExploreTaskActionNML*>(buffer);
                p->~ExploreTaskActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskActionFeedback at %p\n",buffer);
                ExploreTaskActionFeedbackNML * p = static_cast<ExploreTaskActionFeedbackNML*>(buffer);
                p->~ExploreTaskActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskActionGoal at %p\n",buffer);
                ExploreTaskActionGoalNML * p = static_cast<ExploreTaskActionGoalNML*>(buffer);
                p->~ExploreTaskActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskActionResult at %p\n",buffer);
                ExploreTaskActionResultNML * p = static_cast<ExploreTaskActionResultNML*>(buffer);
                p->~ExploreTaskActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskFeedback at %p\n",buffer);
                ExploreTaskFeedbackNML * p = static_cast<ExploreTaskFeedbackNML*>(buffer);
                p->~ExploreTaskFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskGoal at %p\n",buffer);
                ExploreTaskGoalNML * p = static_cast<ExploreTaskGoalNML*>(buffer);
                p->~ExploreTaskGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case ExploreTaskResult::ID:
        {
            // only need to destruct if data type is not flat
            if (ExploreTaskResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ExploreTaskResult at %p\n",buffer);
                ExploreTaskResultNML * p = static_cast<ExploreTaskResultNML*>(buffer);
                p->~ExploreTaskResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ExploreTaskResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case Frontier::ID:
        {
            // only need to destruct if data type is not flat
            if (Frontier::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Frontier at %p\n",buffer);
                FrontierNML * p = static_cast<FrontierNML*>(buffer);
                p->~FrontierNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Frontier at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetNextFrontierRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetNextFrontierRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetNextFrontierRequest at %p\n",buffer);
                GetNextFrontierRequestNML * p = static_cast<GetNextFrontierRequestNML*>(buffer);
                p->~GetNextFrontierRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetNextFrontierRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetNextFrontierResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetNextFrontierResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetNextFrontierResponse at %p\n",buffer);
                GetNextFrontierResponseNML * p = static_cast<GetNextFrontierResponseNML*>(buffer);
                p->~GetNextFrontierResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetNextFrontierResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetNextFrontier::ID:
        {
            // only need to destruct if data type is not flat
            if (GetNextFrontier::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetNextFrontier at %p\n",buffer);
                GetNextFrontierNML * p = static_cast<GetNextFrontierNML*>(buffer);
                p->~GetNextFrontierNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetNextFrontier at %p, is flat\n",buffer);
            }
            break;
        } 
        case UpdateBoundaryPolygonRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (UpdateBoundaryPolygonRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UpdateBoundaryPolygonRequest at %p\n",buffer);
                UpdateBoundaryPolygonRequestNML * p = static_cast<UpdateBoundaryPolygonRequestNML*>(buffer);
                p->~UpdateBoundaryPolygonRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UpdateBoundaryPolygonRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case UpdateBoundaryPolygonResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (UpdateBoundaryPolygonResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UpdateBoundaryPolygonResponse at %p\n",buffer);
                UpdateBoundaryPolygonResponseNML * p = static_cast<UpdateBoundaryPolygonResponseNML*>(buffer);
                p->~UpdateBoundaryPolygonResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UpdateBoundaryPolygonResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case UpdateBoundaryPolygon::ID:
        {
            // only need to destruct if data type is not flat
            if (UpdateBoundaryPolygon::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UpdateBoundaryPolygon at %p\n",buffer);
                UpdateBoundaryPolygonNML * p = static_cast<UpdateBoundaryPolygonNML*>(buffer);
                p->~UpdateBoundaryPolygonNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UpdateBoundaryPolygon at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

ExploreTaskActionNML::ExploreTaskActionNML() : NMLmsg((NMLTYPE)ExploreTaskAction::ID,sizeof(ExploreTaskActionNML)), nmlVersion(ExploreTaskAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskAction()*/)
{
};

ExploreTaskActionNML::~ExploreTaskActionNML()
{
};

ExploreTaskActionNML & ExploreTaskActionNML::operator=(const ExploreTaskActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskActionNML & ExploreTaskActionNML::operator=(const ExploreTaskAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskAction> temp(new ExploreTaskAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskAction Message version mismatch, expected " << ExploreTaskAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskAction Message version mismatch, expected " << ExploreTaskAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

ExploreTaskActionFeedbackNML::ExploreTaskActionFeedbackNML() : NMLmsg((NMLTYPE)ExploreTaskActionFeedback::ID,sizeof(ExploreTaskActionFeedbackNML)), nmlVersion(ExploreTaskActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskActionFeedback()*/)
{
};

ExploreTaskActionFeedbackNML::~ExploreTaskActionFeedbackNML()
{
};

ExploreTaskActionFeedbackNML & ExploreTaskActionFeedbackNML::operator=(const ExploreTaskActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskActionFeedbackNML & ExploreTaskActionFeedbackNML::operator=(const ExploreTaskActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskActionFeedback> temp(new ExploreTaskActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskActionFeedback Message version mismatch, expected " << ExploreTaskActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskActionFeedback Message version mismatch, expected " << ExploreTaskActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

ExploreTaskActionGoalNML::ExploreTaskActionGoalNML() : NMLmsg((NMLTYPE)ExploreTaskActionGoal::ID,sizeof(ExploreTaskActionGoalNML)), nmlVersion(ExploreTaskActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskActionGoal()*/)
{
};

ExploreTaskActionGoalNML::~ExploreTaskActionGoalNML()
{
};

ExploreTaskActionGoalNML & ExploreTaskActionGoalNML::operator=(const ExploreTaskActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskActionGoalNML & ExploreTaskActionGoalNML::operator=(const ExploreTaskActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskActionGoal> temp(new ExploreTaskActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskActionGoal Message version mismatch, expected " << ExploreTaskActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskActionGoal Message version mismatch, expected " << ExploreTaskActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

ExploreTaskActionResultNML::ExploreTaskActionResultNML() : NMLmsg((NMLTYPE)ExploreTaskActionResult::ID,sizeof(ExploreTaskActionResultNML)), nmlVersion(ExploreTaskActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskActionResult()*/)
{
};

ExploreTaskActionResultNML::~ExploreTaskActionResultNML()
{
};

ExploreTaskActionResultNML & ExploreTaskActionResultNML::operator=(const ExploreTaskActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskActionResultNML & ExploreTaskActionResultNML::operator=(const ExploreTaskActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskActionResult> temp(new ExploreTaskActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskActionResult Message version mismatch, expected " << ExploreTaskActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskActionResult Message version mismatch, expected " << ExploreTaskActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.next_frontier);
        nmlupdate(cms,inobj.base_position);

    }  
 }

ExploreTaskFeedbackNML::ExploreTaskFeedbackNML() : NMLmsg((NMLTYPE)ExploreTaskFeedback::ID,sizeof(ExploreTaskFeedbackNML)), nmlVersion(ExploreTaskFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskFeedback()*/)
{
};

ExploreTaskFeedbackNML::~ExploreTaskFeedbackNML()
{
};

ExploreTaskFeedbackNML & ExploreTaskFeedbackNML::operator=(const ExploreTaskFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskFeedbackNML & ExploreTaskFeedbackNML::operator=(const ExploreTaskFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskFeedback> temp(new ExploreTaskFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskFeedback Message version mismatch, expected " << ExploreTaskFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskFeedback Message version mismatch, expected " << ExploreTaskFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.explore_boundary);
        nmlupdate(cms,inobj.explore_center);

    }  
 }

ExploreTaskGoalNML::ExploreTaskGoalNML() : NMLmsg((NMLTYPE)ExploreTaskGoal::ID,sizeof(ExploreTaskGoalNML)), nmlVersion(ExploreTaskGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskGoal()*/)
{
};

ExploreTaskGoalNML::~ExploreTaskGoalNML()
{
};

ExploreTaskGoalNML & ExploreTaskGoalNML::operator=(const ExploreTaskGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskGoalNML & ExploreTaskGoalNML::operator=(const ExploreTaskGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskGoal> temp(new ExploreTaskGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskGoal Message version mismatch, expected " << ExploreTaskGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskGoal Message version mismatch, expected " << ExploreTaskGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, ExploreTaskResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ExploreTaskResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

ExploreTaskResultNML::ExploreTaskResultNML() : NMLmsg((NMLTYPE)ExploreTaskResult::ID,sizeof(ExploreTaskResultNML)), nmlVersion(ExploreTaskResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ExploreTaskResult()*/)
{
};

ExploreTaskResultNML::~ExploreTaskResultNML()
{
};

ExploreTaskResultNML & ExploreTaskResultNML::operator=(const ExploreTaskResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ExploreTaskResultNML & ExploreTaskResultNML::operator=(const ExploreTaskResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ExploreTaskResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ExploreTaskResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ExploreTaskResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ExploreTaskResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ExploreTaskResult> temp(new ExploreTaskResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ExploreTaskResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ExploreTaskResult Message version mismatch, expected " << ExploreTaskResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ExploreTaskResult Message version mismatch, expected " << ExploreTaskResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, Frontier & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Frontier, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.size);
        cms->update(inobj.min_distance);
        nmlupdate(cms,inobj.initial);
        nmlupdate(cms,inobj.centroid);
        nmlupdate(cms,inobj.middle);

    }  
 }

FrontierNML::FrontierNML() : NMLmsg((NMLTYPE)Frontier::ID,sizeof(FrontierNML)), nmlVersion(Frontier::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Frontier()*/)
{
};

FrontierNML::~FrontierNML()
{
};

FrontierNML & FrontierNML::operator=(const FrontierNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrontierNML & FrontierNML::operator=(const Frontier & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Frontier);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrontierNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Frontier&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrontierNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Frontier> temp(new Frontier());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Frontier::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Frontier Message version mismatch, expected " << Frontier::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Frontier Message version mismatch, expected " << Frontier::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, GetNextFrontierRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetNextFrontierRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.start_pose);

    }  
 }

GetNextFrontierRequestNML::GetNextFrontierRequestNML() : NMLmsg((NMLTYPE)GetNextFrontierRequest::ID,sizeof(GetNextFrontierRequestNML)), nmlVersion(GetNextFrontierRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetNextFrontierRequest()*/)
{
};

GetNextFrontierRequestNML::~GetNextFrontierRequestNML()
{
};

GetNextFrontierRequestNML & GetNextFrontierRequestNML::operator=(const GetNextFrontierRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetNextFrontierRequestNML & GetNextFrontierRequestNML::operator=(const GetNextFrontierRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetNextFrontierRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetNextFrontierRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetNextFrontierRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetNextFrontierRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetNextFrontierRequest> temp(new GetNextFrontierRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetNextFrontierRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetNextFrontierRequest Message version mismatch, expected " << GetNextFrontierRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetNextFrontierRequest Message version mismatch, expected " << GetNextFrontierRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, GetNextFrontierResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetNextFrontierResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.next_frontier);

    }  
 }

GetNextFrontierResponseNML::GetNextFrontierResponseNML() : NMLmsg((NMLTYPE)GetNextFrontierResponse::ID,sizeof(GetNextFrontierResponseNML)), nmlVersion(GetNextFrontierResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetNextFrontierResponse()*/)
{
};

GetNextFrontierResponseNML::~GetNextFrontierResponseNML()
{
};

GetNextFrontierResponseNML & GetNextFrontierResponseNML::operator=(const GetNextFrontierResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetNextFrontierResponseNML & GetNextFrontierResponseNML::operator=(const GetNextFrontierResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetNextFrontierResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetNextFrontierResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetNextFrontierResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetNextFrontierResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetNextFrontierResponse> temp(new GetNextFrontierResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetNextFrontierResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetNextFrontierResponse Message version mismatch, expected " << GetNextFrontierResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetNextFrontierResponse Message version mismatch, expected " << GetNextFrontierResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, GetNextFrontier & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetNextFrontier, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetNextFrontierNML::GetNextFrontierNML() : NMLmsg((NMLTYPE)GetNextFrontier::ID,sizeof(GetNextFrontierNML)), nmlVersion(GetNextFrontier::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetNextFrontier()*/)
{
};

GetNextFrontierNML::~GetNextFrontierNML()
{
};

GetNextFrontierNML & GetNextFrontierNML::operator=(const GetNextFrontierNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetNextFrontierNML & GetNextFrontierNML::operator=(const GetNextFrontier & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetNextFrontier);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetNextFrontierNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetNextFrontier&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetNextFrontierNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetNextFrontier> temp(new GetNextFrontier());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetNextFrontier::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetNextFrontier Message version mismatch, expected " << GetNextFrontier::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetNextFrontier Message version mismatch, expected " << GetNextFrontier::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, UpdateBoundaryPolygonRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UpdateBoundaryPolygonRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.explore_boundary);

    }  
 }

UpdateBoundaryPolygonRequestNML::UpdateBoundaryPolygonRequestNML() : NMLmsg((NMLTYPE)UpdateBoundaryPolygonRequest::ID,sizeof(UpdateBoundaryPolygonRequestNML)), nmlVersion(UpdateBoundaryPolygonRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UpdateBoundaryPolygonRequest()*/)
{
};

UpdateBoundaryPolygonRequestNML::~UpdateBoundaryPolygonRequestNML()
{
};

UpdateBoundaryPolygonRequestNML & UpdateBoundaryPolygonRequestNML::operator=(const UpdateBoundaryPolygonRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UpdateBoundaryPolygonRequestNML & UpdateBoundaryPolygonRequestNML::operator=(const UpdateBoundaryPolygonRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UpdateBoundaryPolygonRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UpdateBoundaryPolygonRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UpdateBoundaryPolygonRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UpdateBoundaryPolygonRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UpdateBoundaryPolygonRequest> temp(new UpdateBoundaryPolygonRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UpdateBoundaryPolygonRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UpdateBoundaryPolygonRequest Message version mismatch, expected " << UpdateBoundaryPolygonRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UpdateBoundaryPolygonRequest Message version mismatch, expected " << UpdateBoundaryPolygonRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, UpdateBoundaryPolygonResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UpdateBoundaryPolygonResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

UpdateBoundaryPolygonResponseNML::UpdateBoundaryPolygonResponseNML() : NMLmsg((NMLTYPE)UpdateBoundaryPolygonResponse::ID,sizeof(UpdateBoundaryPolygonResponseNML)), nmlVersion(UpdateBoundaryPolygonResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UpdateBoundaryPolygonResponse()*/)
{
};

UpdateBoundaryPolygonResponseNML::~UpdateBoundaryPolygonResponseNML()
{
};

UpdateBoundaryPolygonResponseNML & UpdateBoundaryPolygonResponseNML::operator=(const UpdateBoundaryPolygonResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UpdateBoundaryPolygonResponseNML & UpdateBoundaryPolygonResponseNML::operator=(const UpdateBoundaryPolygonResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UpdateBoundaryPolygonResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UpdateBoundaryPolygonResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UpdateBoundaryPolygonResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UpdateBoundaryPolygonResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UpdateBoundaryPolygonResponse> temp(new UpdateBoundaryPolygonResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UpdateBoundaryPolygonResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UpdateBoundaryPolygonResponse Message version mismatch, expected " << UpdateBoundaryPolygonResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UpdateBoundaryPolygonResponse Message version mismatch, expected " << UpdateBoundaryPolygonResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void frontier_exploration::nmlupdate(CMS * cms, UpdateBoundaryPolygon & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UpdateBoundaryPolygon, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

UpdateBoundaryPolygonNML::UpdateBoundaryPolygonNML() : NMLmsg((NMLTYPE)UpdateBoundaryPolygon::ID,sizeof(UpdateBoundaryPolygonNML)), nmlVersion(UpdateBoundaryPolygon::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UpdateBoundaryPolygon()*/)
{
};

UpdateBoundaryPolygonNML::~UpdateBoundaryPolygonNML()
{
};

UpdateBoundaryPolygonNML & UpdateBoundaryPolygonNML::operator=(const UpdateBoundaryPolygonNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UpdateBoundaryPolygonNML & UpdateBoundaryPolygonNML::operator=(const UpdateBoundaryPolygon & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UpdateBoundaryPolygon);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UpdateBoundaryPolygonNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UpdateBoundaryPolygon&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UpdateBoundaryPolygonNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UpdateBoundaryPolygon> temp(new UpdateBoundaryPolygon());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: frontier_exploration_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UpdateBoundaryPolygon::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UpdateBoundaryPolygon Message version mismatch, expected " << UpdateBoundaryPolygon::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UpdateBoundaryPolygon Message version mismatch, expected " << UpdateBoundaryPolygon::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int frontier_exploration::frontier_exploration_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("frontier_exploration_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case ExploreTaskAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskAction, id " << ExploreTaskAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ExploreTaskActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskActionFeedback, id " << ExploreTaskActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ExploreTaskActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskActionGoal, id " << ExploreTaskActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ExploreTaskActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskActionResult, id " << ExploreTaskActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ExploreTaskFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskFeedback, id " << ExploreTaskFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ExploreTaskGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskGoal, id " << ExploreTaskGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ExploreTaskResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ExploreTaskResult, id " << ExploreTaskResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ExploreTaskResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Frontier::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Frontier, id " << Frontier::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrontierNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetNextFrontierRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetNextFrontierRequest, id " << GetNextFrontierRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetNextFrontierRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetNextFrontierResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetNextFrontierResponse, id " << GetNextFrontierResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetNextFrontierResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetNextFrontier::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetNextFrontier, id " << GetNextFrontier::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetNextFrontierNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UpdateBoundaryPolygonRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UpdateBoundaryPolygonRequest, id " << UpdateBoundaryPolygonRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UpdateBoundaryPolygonRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UpdateBoundaryPolygonResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UpdateBoundaryPolygonResponse, id " << UpdateBoundaryPolygonResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UpdateBoundaryPolygonResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UpdateBoundaryPolygon::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UpdateBoundaryPolygon, id " << UpdateBoundaryPolygon::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_frontier_exploration_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"frontier_exploration_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UpdateBoundaryPolygonNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

