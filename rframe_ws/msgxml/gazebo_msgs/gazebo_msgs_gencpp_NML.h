// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:05 -0500
//  From Template/Script: data_templates/NMLHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_GAZEBO_MSGS_GENCPPNML_H_
#define _CODEGEN_GAZEBO_MSGS_GENCPPNML_H_

#include <messaging/nml/NMLMessageFactory.h>
//#include <DataTypeInfo.h>
#include <messaging/Message.h>

#include "gazebo_msgs_gencpp_NMLSupport.h"

namespace rframe { class DataTypeInfo; };

#include "ContactState.h"
#include "ContactsState.h"
#include "LinkState.h"
#include "LinkStates.h"
#include "ModelState.h"
#include "ModelStates.h"
#include "ODEJointProperties.h"
#include "ODEPhysics.h"
#include "WorldState.h"
#include "ApplyBodyWrenchRequest.h"
#include "ApplyBodyWrenchResponse.h"
#include "ApplyBodyWrench.h"
#include "ApplyJointEffortRequest.h"
#include "ApplyJointEffortResponse.h"
#include "ApplyJointEffort.h"
#include "BodyRequestRequest.h"
#include "BodyRequestResponse.h"
#include "BodyRequest.h"
#include "DeleteModelRequest.h"
#include "DeleteModelResponse.h"
#include "DeleteModel.h"
#include "GetJointPropertiesRequest.h"
#include "GetJointPropertiesResponse.h"
#include "GetJointProperties.h"
#include "GetLinkPropertiesRequest.h"
#include "GetLinkPropertiesResponse.h"
#include "GetLinkProperties.h"
#include "GetLinkStateRequest.h"
#include "GetLinkStateResponse.h"
#include "GetLinkState.h"
#include "GetModelPropertiesRequest.h"
#include "GetModelPropertiesResponse.h"
#include "GetModelProperties.h"
#include "GetModelStateRequest.h"
#include "GetModelStateResponse.h"
#include "GetModelState.h"
#include "GetPhysicsPropertiesRequest.h"
#include "GetPhysicsPropertiesResponse.h"
#include "GetPhysicsProperties.h"
#include "GetWorldPropertiesRequest.h"
#include "GetWorldPropertiesResponse.h"
#include "GetWorldProperties.h"
#include "JointRequestRequest.h"
#include "JointRequestResponse.h"
#include "JointRequest.h"
#include "SetJointPropertiesRequest.h"
#include "SetJointPropertiesResponse.h"
#include "SetJointProperties.h"
#include "SetJointTrajectoryRequest.h"
#include "SetJointTrajectoryResponse.h"
#include "SetJointTrajectory.h"
#include "SetLinkPropertiesRequest.h"
#include "SetLinkPropertiesResponse.h"
#include "SetLinkProperties.h"
#include "SetLinkStateRequest.h"
#include "SetLinkStateResponse.h"
#include "SetLinkState.h"
#include "SetModelConfigurationRequest.h"
#include "SetModelConfigurationResponse.h"
#include "SetModelConfiguration.h"
#include "SetModelStateRequest.h"
#include "SetModelStateResponse.h"
#include "SetModelState.h"
#include "SetPhysicsPropertiesRequest.h"
#include "SetPhysicsPropertiesResponse.h"
#include "SetPhysicsProperties.h"
#include "SpawnModelRequest.h"
#include "SpawnModelResponse.h"
#include "SpawnModel.h"

namespace gazebo_msgs {

    /** definition of message factory for gazebo_msgs_gencpp */
    class gazebo_msgs_gencppNMLMessageFactory : public NMLMessageFactory
    {
    public:
        /** constructor */
        gazebo_msgs_gencppNMLMessageFactory();
        /** destructor */
        virtual ~gazebo_msgs_gencppNMLMessageFactory();

        /** see  rframe::MessageFactoryInterface */
        virtual void dataTypes(std::vector<DataTypeInfo> & ids);
        /** see  rframe::MessageFactoryInterface */
        virtual int dataType(NMLmsg & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateTransport(NMLmsg * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateMessage(MessageBase * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int toTransport( MessageBase & src, NMLmsg & dst);
        /** see  rframe::MessageFactoryInterface */
        virtual int fromTransport( NMLmsg & src, MessageBase & dst);

        /** \return poitner to nml format function */
        virtual NML_FORMAT_PTR FormatPointer();
        /** run constructor for class of type id in the provided buffer */
        virtual int constructBuffer(rframe::ID_TYPE id, void * buffer);
        /** run destructor for class of type id in the buffer */
        virtual int destructBuffer(rframe::ID_TYPE id, void * buffer);
    };

    /** factory allocation function for use when not dynamically loading the factory library  */
    NMLMessageFactory * allocate_gazebo_msgs_gencpp();

    /** NML interface for ContactState 

    */
    class ContactStateNML : public NMLmsg
    {
    public:

        /** constructor */
        ContactStateNML();
        /** destructor */
        ~ContactStateNML();

        /** assignment operator */
        ContactStateNML & operator=(const ContactStateNML &inobj);
        /** assignment operator for base data class */
        ContactStateNML & operator=(const ContactState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ContactState nmlPayload;

        /** set payload */
        void payload(const ContactState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ContactState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ContactState * payload() { return & nmlPayload; };

    //     std::shared_ptr<ContactState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ContactsState 

    */
    class ContactsStateNML : public NMLmsg
    {
    public:

        /** constructor */
        ContactsStateNML();
        /** destructor */
        ~ContactsStateNML();

        /** assignment operator */
        ContactsStateNML & operator=(const ContactsStateNML &inobj);
        /** assignment operator for base data class */
        ContactsStateNML & operator=(const ContactsState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ContactsState nmlPayload;

        /** set payload */
        void payload(const ContactsState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ContactsState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ContactsState * payload() { return & nmlPayload; };

    //     std::shared_ptr<ContactsState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for LinkState 

    */
    class LinkStateNML : public NMLmsg
    {
    public:

        /** constructor */
        LinkStateNML();
        /** destructor */
        ~LinkStateNML();

        /** assignment operator */
        LinkStateNML & operator=(const LinkStateNML &inobj);
        /** assignment operator for base data class */
        LinkStateNML & operator=(const LinkState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        LinkState nmlPayload;

        /** set payload */
        void payload(const LinkState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<LinkState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        LinkState * payload() { return & nmlPayload; };

    //     std::shared_ptr<LinkState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for LinkStates 

    */
    class LinkStatesNML : public NMLmsg
    {
    public:

        /** constructor */
        LinkStatesNML();
        /** destructor */
        ~LinkStatesNML();

        /** assignment operator */
        LinkStatesNML & operator=(const LinkStatesNML &inobj);
        /** assignment operator for base data class */
        LinkStatesNML & operator=(const LinkStates &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        LinkStates nmlPayload;

        /** set payload */
        void payload(const LinkStates &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<LinkStates> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        LinkStates * payload() { return & nmlPayload; };

    //     std::shared_ptr<LinkStates> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ModelState 

    */
    class ModelStateNML : public NMLmsg
    {
    public:

        /** constructor */
        ModelStateNML();
        /** destructor */
        ~ModelStateNML();

        /** assignment operator */
        ModelStateNML & operator=(const ModelStateNML &inobj);
        /** assignment operator for base data class */
        ModelStateNML & operator=(const ModelState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ModelState nmlPayload;

        /** set payload */
        void payload(const ModelState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ModelState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ModelState * payload() { return & nmlPayload; };

    //     std::shared_ptr<ModelState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ModelStates 

    */
    class ModelStatesNML : public NMLmsg
    {
    public:

        /** constructor */
        ModelStatesNML();
        /** destructor */
        ~ModelStatesNML();

        /** assignment operator */
        ModelStatesNML & operator=(const ModelStatesNML &inobj);
        /** assignment operator for base data class */
        ModelStatesNML & operator=(const ModelStates &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ModelStates nmlPayload;

        /** set payload */
        void payload(const ModelStates &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ModelStates> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ModelStates * payload() { return & nmlPayload; };

    //     std::shared_ptr<ModelStates> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ODEJointProperties 

    */
    class ODEJointPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        ODEJointPropertiesNML();
        /** destructor */
        ~ODEJointPropertiesNML();

        /** assignment operator */
        ODEJointPropertiesNML & operator=(const ODEJointPropertiesNML &inobj);
        /** assignment operator for base data class */
        ODEJointPropertiesNML & operator=(const ODEJointProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ODEJointProperties nmlPayload;

        /** set payload */
        void payload(const ODEJointProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ODEJointProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ODEJointProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<ODEJointProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ODEPhysics 

    */
    class ODEPhysicsNML : public NMLmsg
    {
    public:

        /** constructor */
        ODEPhysicsNML();
        /** destructor */
        ~ODEPhysicsNML();

        /** assignment operator */
        ODEPhysicsNML & operator=(const ODEPhysicsNML &inobj);
        /** assignment operator for base data class */
        ODEPhysicsNML & operator=(const ODEPhysics &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ODEPhysics nmlPayload;

        /** set payload */
        void payload(const ODEPhysics &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ODEPhysics> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ODEPhysics * payload() { return & nmlPayload; };

    //     std::shared_ptr<ODEPhysics> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for WorldState 

    */
    class WorldStateNML : public NMLmsg
    {
    public:

        /** constructor */
        WorldStateNML();
        /** destructor */
        ~WorldStateNML();

        /** assignment operator */
        WorldStateNML & operator=(const WorldStateNML &inobj);
        /** assignment operator for base data class */
        WorldStateNML & operator=(const WorldState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        WorldState nmlPayload;

        /** set payload */
        void payload(const WorldState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<WorldState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        WorldState * payload() { return & nmlPayload; };

    //     std::shared_ptr<WorldState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ApplyBodyWrenchRequest 

    */
    class ApplyBodyWrenchRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        ApplyBodyWrenchRequestNML();
        /** destructor */
        ~ApplyBodyWrenchRequestNML();

        /** assignment operator */
        ApplyBodyWrenchRequestNML & operator=(const ApplyBodyWrenchRequestNML &inobj);
        /** assignment operator for base data class */
        ApplyBodyWrenchRequestNML & operator=(const ApplyBodyWrenchRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ApplyBodyWrenchRequest nmlPayload;

        /** set payload */
        void payload(const ApplyBodyWrenchRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ApplyBodyWrenchRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ApplyBodyWrenchRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<ApplyBodyWrenchRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ApplyBodyWrenchResponse 

    */
    class ApplyBodyWrenchResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        ApplyBodyWrenchResponseNML();
        /** destructor */
        ~ApplyBodyWrenchResponseNML();

        /** assignment operator */
        ApplyBodyWrenchResponseNML & operator=(const ApplyBodyWrenchResponseNML &inobj);
        /** assignment operator for base data class */
        ApplyBodyWrenchResponseNML & operator=(const ApplyBodyWrenchResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ApplyBodyWrenchResponse nmlPayload;

        /** set payload */
        void payload(const ApplyBodyWrenchResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ApplyBodyWrenchResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ApplyBodyWrenchResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<ApplyBodyWrenchResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ApplyBodyWrench 

    */
    class ApplyBodyWrenchNML : public NMLmsg
    {
    public:

        /** constructor */
        ApplyBodyWrenchNML();
        /** destructor */
        ~ApplyBodyWrenchNML();

        /** assignment operator */
        ApplyBodyWrenchNML & operator=(const ApplyBodyWrenchNML &inobj);
        /** assignment operator for base data class */
        ApplyBodyWrenchNML & operator=(const ApplyBodyWrench &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ApplyBodyWrench nmlPayload;

        /** set payload */
        void payload(const ApplyBodyWrench &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ApplyBodyWrench> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ApplyBodyWrench * payload() { return & nmlPayload; };

    //     std::shared_ptr<ApplyBodyWrench> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ApplyJointEffortRequest 

    */
    class ApplyJointEffortRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        ApplyJointEffortRequestNML();
        /** destructor */
        ~ApplyJointEffortRequestNML();

        /** assignment operator */
        ApplyJointEffortRequestNML & operator=(const ApplyJointEffortRequestNML &inobj);
        /** assignment operator for base data class */
        ApplyJointEffortRequestNML & operator=(const ApplyJointEffortRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ApplyJointEffortRequest nmlPayload;

        /** set payload */
        void payload(const ApplyJointEffortRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ApplyJointEffortRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ApplyJointEffortRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<ApplyJointEffortRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ApplyJointEffortResponse 

    */
    class ApplyJointEffortResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        ApplyJointEffortResponseNML();
        /** destructor */
        ~ApplyJointEffortResponseNML();

        /** assignment operator */
        ApplyJointEffortResponseNML & operator=(const ApplyJointEffortResponseNML &inobj);
        /** assignment operator for base data class */
        ApplyJointEffortResponseNML & operator=(const ApplyJointEffortResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ApplyJointEffortResponse nmlPayload;

        /** set payload */
        void payload(const ApplyJointEffortResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ApplyJointEffortResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ApplyJointEffortResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<ApplyJointEffortResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for ApplyJointEffort 

    */
    class ApplyJointEffortNML : public NMLmsg
    {
    public:

        /** constructor */
        ApplyJointEffortNML();
        /** destructor */
        ~ApplyJointEffortNML();

        /** assignment operator */
        ApplyJointEffortNML & operator=(const ApplyJointEffortNML &inobj);
        /** assignment operator for base data class */
        ApplyJointEffortNML & operator=(const ApplyJointEffort &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        ApplyJointEffort nmlPayload;

        /** set payload */
        void payload(const ApplyJointEffort &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<ApplyJointEffort> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        ApplyJointEffort * payload() { return & nmlPayload; };

    //     std::shared_ptr<ApplyJointEffort> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for BodyRequestRequest 

    */
    class BodyRequestRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        BodyRequestRequestNML();
        /** destructor */
        ~BodyRequestRequestNML();

        /** assignment operator */
        BodyRequestRequestNML & operator=(const BodyRequestRequestNML &inobj);
        /** assignment operator for base data class */
        BodyRequestRequestNML & operator=(const BodyRequestRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        BodyRequestRequest nmlPayload;

        /** set payload */
        void payload(const BodyRequestRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<BodyRequestRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        BodyRequestRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<BodyRequestRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for BodyRequestResponse 

    */
    class BodyRequestResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        BodyRequestResponseNML();
        /** destructor */
        ~BodyRequestResponseNML();

        /** assignment operator */
        BodyRequestResponseNML & operator=(const BodyRequestResponseNML &inobj);
        /** assignment operator for base data class */
        BodyRequestResponseNML & operator=(const BodyRequestResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        BodyRequestResponse nmlPayload;

        /** set payload */
        void payload(const BodyRequestResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<BodyRequestResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        BodyRequestResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<BodyRequestResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for BodyRequest 

    */
    class BodyRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        BodyRequestNML();
        /** destructor */
        ~BodyRequestNML();

        /** assignment operator */
        BodyRequestNML & operator=(const BodyRequestNML &inobj);
        /** assignment operator for base data class */
        BodyRequestNML & operator=(const BodyRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        BodyRequest nmlPayload;

        /** set payload */
        void payload(const BodyRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<BodyRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        BodyRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<BodyRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DeleteModelRequest 

    */
    class DeleteModelRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        DeleteModelRequestNML();
        /** destructor */
        ~DeleteModelRequestNML();

        /** assignment operator */
        DeleteModelRequestNML & operator=(const DeleteModelRequestNML &inobj);
        /** assignment operator for base data class */
        DeleteModelRequestNML & operator=(const DeleteModelRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DeleteModelRequest nmlPayload;

        /** set payload */
        void payload(const DeleteModelRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DeleteModelRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DeleteModelRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<DeleteModelRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DeleteModelResponse 

    */
    class DeleteModelResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        DeleteModelResponseNML();
        /** destructor */
        ~DeleteModelResponseNML();

        /** assignment operator */
        DeleteModelResponseNML & operator=(const DeleteModelResponseNML &inobj);
        /** assignment operator for base data class */
        DeleteModelResponseNML & operator=(const DeleteModelResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DeleteModelResponse nmlPayload;

        /** set payload */
        void payload(const DeleteModelResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DeleteModelResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DeleteModelResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<DeleteModelResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for DeleteModel 

    */
    class DeleteModelNML : public NMLmsg
    {
    public:

        /** constructor */
        DeleteModelNML();
        /** destructor */
        ~DeleteModelNML();

        /** assignment operator */
        DeleteModelNML & operator=(const DeleteModelNML &inobj);
        /** assignment operator for base data class */
        DeleteModelNML & operator=(const DeleteModel &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        DeleteModel nmlPayload;

        /** set payload */
        void payload(const DeleteModel &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<DeleteModel> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        DeleteModel * payload() { return & nmlPayload; };

    //     std::shared_ptr<DeleteModel> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetJointPropertiesRequest 

    */
    class GetJointPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetJointPropertiesRequestNML();
        /** destructor */
        ~GetJointPropertiesRequestNML();

        /** assignment operator */
        GetJointPropertiesRequestNML & operator=(const GetJointPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        GetJointPropertiesRequestNML & operator=(const GetJointPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetJointPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const GetJointPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetJointPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetJointPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetJointPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetJointPropertiesResponse 

    */
    class GetJointPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetJointPropertiesResponseNML();
        /** destructor */
        ~GetJointPropertiesResponseNML();

        /** assignment operator */
        GetJointPropertiesResponseNML & operator=(const GetJointPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        GetJointPropertiesResponseNML & operator=(const GetJointPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetJointPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const GetJointPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetJointPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetJointPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetJointPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetJointProperties 

    */
    class GetJointPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        GetJointPropertiesNML();
        /** destructor */
        ~GetJointPropertiesNML();

        /** assignment operator */
        GetJointPropertiesNML & operator=(const GetJointPropertiesNML &inobj);
        /** assignment operator for base data class */
        GetJointPropertiesNML & operator=(const GetJointProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetJointProperties nmlPayload;

        /** set payload */
        void payload(const GetJointProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetJointProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetJointProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetJointProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetLinkPropertiesRequest 

    */
    class GetLinkPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetLinkPropertiesRequestNML();
        /** destructor */
        ~GetLinkPropertiesRequestNML();

        /** assignment operator */
        GetLinkPropertiesRequestNML & operator=(const GetLinkPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        GetLinkPropertiesRequestNML & operator=(const GetLinkPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetLinkPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const GetLinkPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetLinkPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetLinkPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetLinkPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetLinkPropertiesResponse 

    */
    class GetLinkPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetLinkPropertiesResponseNML();
        /** destructor */
        ~GetLinkPropertiesResponseNML();

        /** assignment operator */
        GetLinkPropertiesResponseNML & operator=(const GetLinkPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        GetLinkPropertiesResponseNML & operator=(const GetLinkPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetLinkPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const GetLinkPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetLinkPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetLinkPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetLinkPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetLinkProperties 

    */
    class GetLinkPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        GetLinkPropertiesNML();
        /** destructor */
        ~GetLinkPropertiesNML();

        /** assignment operator */
        GetLinkPropertiesNML & operator=(const GetLinkPropertiesNML &inobj);
        /** assignment operator for base data class */
        GetLinkPropertiesNML & operator=(const GetLinkProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetLinkProperties nmlPayload;

        /** set payload */
        void payload(const GetLinkProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetLinkProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetLinkProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetLinkProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetLinkStateRequest 

    */
    class GetLinkStateRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetLinkStateRequestNML();
        /** destructor */
        ~GetLinkStateRequestNML();

        /** assignment operator */
        GetLinkStateRequestNML & operator=(const GetLinkStateRequestNML &inobj);
        /** assignment operator for base data class */
        GetLinkStateRequestNML & operator=(const GetLinkStateRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetLinkStateRequest nmlPayload;

        /** set payload */
        void payload(const GetLinkStateRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetLinkStateRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetLinkStateRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetLinkStateRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetLinkStateResponse 

    */
    class GetLinkStateResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetLinkStateResponseNML();
        /** destructor */
        ~GetLinkStateResponseNML();

        /** assignment operator */
        GetLinkStateResponseNML & operator=(const GetLinkStateResponseNML &inobj);
        /** assignment operator for base data class */
        GetLinkStateResponseNML & operator=(const GetLinkStateResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetLinkStateResponse nmlPayload;

        /** set payload */
        void payload(const GetLinkStateResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetLinkStateResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetLinkStateResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetLinkStateResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetLinkState 

    */
    class GetLinkStateNML : public NMLmsg
    {
    public:

        /** constructor */
        GetLinkStateNML();
        /** destructor */
        ~GetLinkStateNML();

        /** assignment operator */
        GetLinkStateNML & operator=(const GetLinkStateNML &inobj);
        /** assignment operator for base data class */
        GetLinkStateNML & operator=(const GetLinkState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetLinkState nmlPayload;

        /** set payload */
        void payload(const GetLinkState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetLinkState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetLinkState * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetLinkState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetModelPropertiesRequest 

    */
    class GetModelPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetModelPropertiesRequestNML();
        /** destructor */
        ~GetModelPropertiesRequestNML();

        /** assignment operator */
        GetModelPropertiesRequestNML & operator=(const GetModelPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        GetModelPropertiesRequestNML & operator=(const GetModelPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetModelPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const GetModelPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetModelPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetModelPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetModelPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetModelPropertiesResponse 

    */
    class GetModelPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetModelPropertiesResponseNML();
        /** destructor */
        ~GetModelPropertiesResponseNML();

        /** assignment operator */
        GetModelPropertiesResponseNML & operator=(const GetModelPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        GetModelPropertiesResponseNML & operator=(const GetModelPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetModelPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const GetModelPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetModelPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetModelPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetModelPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetModelProperties 

    */
    class GetModelPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        GetModelPropertiesNML();
        /** destructor */
        ~GetModelPropertiesNML();

        /** assignment operator */
        GetModelPropertiesNML & operator=(const GetModelPropertiesNML &inobj);
        /** assignment operator for base data class */
        GetModelPropertiesNML & operator=(const GetModelProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetModelProperties nmlPayload;

        /** set payload */
        void payload(const GetModelProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetModelProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetModelProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetModelProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetModelStateRequest 

    */
    class GetModelStateRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetModelStateRequestNML();
        /** destructor */
        ~GetModelStateRequestNML();

        /** assignment operator */
        GetModelStateRequestNML & operator=(const GetModelStateRequestNML &inobj);
        /** assignment operator for base data class */
        GetModelStateRequestNML & operator=(const GetModelStateRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetModelStateRequest nmlPayload;

        /** set payload */
        void payload(const GetModelStateRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetModelStateRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetModelStateRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetModelStateRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetModelStateResponse 

    */
    class GetModelStateResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetModelStateResponseNML();
        /** destructor */
        ~GetModelStateResponseNML();

        /** assignment operator */
        GetModelStateResponseNML & operator=(const GetModelStateResponseNML &inobj);
        /** assignment operator for base data class */
        GetModelStateResponseNML & operator=(const GetModelStateResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetModelStateResponse nmlPayload;

        /** set payload */
        void payload(const GetModelStateResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetModelStateResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetModelStateResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetModelStateResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetModelState 

    */
    class GetModelStateNML : public NMLmsg
    {
    public:

        /** constructor */
        GetModelStateNML();
        /** destructor */
        ~GetModelStateNML();

        /** assignment operator */
        GetModelStateNML & operator=(const GetModelStateNML &inobj);
        /** assignment operator for base data class */
        GetModelStateNML & operator=(const GetModelState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetModelState nmlPayload;

        /** set payload */
        void payload(const GetModelState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetModelState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetModelState * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetModelState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetPhysicsPropertiesRequest 

    */
    class GetPhysicsPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetPhysicsPropertiesRequestNML();
        /** destructor */
        ~GetPhysicsPropertiesRequestNML();

        /** assignment operator */
        GetPhysicsPropertiesRequestNML & operator=(const GetPhysicsPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        GetPhysicsPropertiesRequestNML & operator=(const GetPhysicsPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetPhysicsPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const GetPhysicsPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetPhysicsPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetPhysicsPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetPhysicsPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetPhysicsPropertiesResponse 

    */
    class GetPhysicsPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetPhysicsPropertiesResponseNML();
        /** destructor */
        ~GetPhysicsPropertiesResponseNML();

        /** assignment operator */
        GetPhysicsPropertiesResponseNML & operator=(const GetPhysicsPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        GetPhysicsPropertiesResponseNML & operator=(const GetPhysicsPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetPhysicsPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const GetPhysicsPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetPhysicsPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetPhysicsPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetPhysicsPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetPhysicsProperties 

    */
    class GetPhysicsPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        GetPhysicsPropertiesNML();
        /** destructor */
        ~GetPhysicsPropertiesNML();

        /** assignment operator */
        GetPhysicsPropertiesNML & operator=(const GetPhysicsPropertiesNML &inobj);
        /** assignment operator for base data class */
        GetPhysicsPropertiesNML & operator=(const GetPhysicsProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetPhysicsProperties nmlPayload;

        /** set payload */
        void payload(const GetPhysicsProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetPhysicsProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetPhysicsProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetPhysicsProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetWorldPropertiesRequest 

    */
    class GetWorldPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        GetWorldPropertiesRequestNML();
        /** destructor */
        ~GetWorldPropertiesRequestNML();

        /** assignment operator */
        GetWorldPropertiesRequestNML & operator=(const GetWorldPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        GetWorldPropertiesRequestNML & operator=(const GetWorldPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetWorldPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const GetWorldPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetWorldPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetWorldPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetWorldPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetWorldPropertiesResponse 

    */
    class GetWorldPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        GetWorldPropertiesResponseNML();
        /** destructor */
        ~GetWorldPropertiesResponseNML();

        /** assignment operator */
        GetWorldPropertiesResponseNML & operator=(const GetWorldPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        GetWorldPropertiesResponseNML & operator=(const GetWorldPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetWorldPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const GetWorldPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetWorldPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetWorldPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetWorldPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GetWorldProperties 

    */
    class GetWorldPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        GetWorldPropertiesNML();
        /** destructor */
        ~GetWorldPropertiesNML();

        /** assignment operator */
        GetWorldPropertiesNML & operator=(const GetWorldPropertiesNML &inobj);
        /** assignment operator for base data class */
        GetWorldPropertiesNML & operator=(const GetWorldProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GetWorldProperties nmlPayload;

        /** set payload */
        void payload(const GetWorldProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GetWorldProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GetWorldProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<GetWorldProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointRequestRequest 

    */
    class JointRequestRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        JointRequestRequestNML();
        /** destructor */
        ~JointRequestRequestNML();

        /** assignment operator */
        JointRequestRequestNML & operator=(const JointRequestRequestNML &inobj);
        /** assignment operator for base data class */
        JointRequestRequestNML & operator=(const JointRequestRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointRequestRequest nmlPayload;

        /** set payload */
        void payload(const JointRequestRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointRequestRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointRequestRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointRequestRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointRequestResponse 

    */
    class JointRequestResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        JointRequestResponseNML();
        /** destructor */
        ~JointRequestResponseNML();

        /** assignment operator */
        JointRequestResponseNML & operator=(const JointRequestResponseNML &inobj);
        /** assignment operator for base data class */
        JointRequestResponseNML & operator=(const JointRequestResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointRequestResponse nmlPayload;

        /** set payload */
        void payload(const JointRequestResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointRequestResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointRequestResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointRequestResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointRequest 

    */
    class JointRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        JointRequestNML();
        /** destructor */
        ~JointRequestNML();

        /** assignment operator */
        JointRequestNML & operator=(const JointRequestNML &inobj);
        /** assignment operator for base data class */
        JointRequestNML & operator=(const JointRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointRequest nmlPayload;

        /** set payload */
        void payload(const JointRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetJointPropertiesRequest 

    */
    class SetJointPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetJointPropertiesRequestNML();
        /** destructor */
        ~SetJointPropertiesRequestNML();

        /** assignment operator */
        SetJointPropertiesRequestNML & operator=(const SetJointPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        SetJointPropertiesRequestNML & operator=(const SetJointPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetJointPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const SetJointPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetJointPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetJointPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetJointPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetJointPropertiesResponse 

    */
    class SetJointPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetJointPropertiesResponseNML();
        /** destructor */
        ~SetJointPropertiesResponseNML();

        /** assignment operator */
        SetJointPropertiesResponseNML & operator=(const SetJointPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        SetJointPropertiesResponseNML & operator=(const SetJointPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetJointPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const SetJointPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetJointPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetJointPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetJointPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetJointProperties 

    */
    class SetJointPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        SetJointPropertiesNML();
        /** destructor */
        ~SetJointPropertiesNML();

        /** assignment operator */
        SetJointPropertiesNML & operator=(const SetJointPropertiesNML &inobj);
        /** assignment operator for base data class */
        SetJointPropertiesNML & operator=(const SetJointProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetJointProperties nmlPayload;

        /** set payload */
        void payload(const SetJointProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetJointProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetJointProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetJointProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetJointTrajectoryRequest 

    */
    class SetJointTrajectoryRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetJointTrajectoryRequestNML();
        /** destructor */
        ~SetJointTrajectoryRequestNML();

        /** assignment operator */
        SetJointTrajectoryRequestNML & operator=(const SetJointTrajectoryRequestNML &inobj);
        /** assignment operator for base data class */
        SetJointTrajectoryRequestNML & operator=(const SetJointTrajectoryRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetJointTrajectoryRequest nmlPayload;

        /** set payload */
        void payload(const SetJointTrajectoryRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetJointTrajectoryRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetJointTrajectoryRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetJointTrajectoryRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetJointTrajectoryResponse 

    */
    class SetJointTrajectoryResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetJointTrajectoryResponseNML();
        /** destructor */
        ~SetJointTrajectoryResponseNML();

        /** assignment operator */
        SetJointTrajectoryResponseNML & operator=(const SetJointTrajectoryResponseNML &inobj);
        /** assignment operator for base data class */
        SetJointTrajectoryResponseNML & operator=(const SetJointTrajectoryResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetJointTrajectoryResponse nmlPayload;

        /** set payload */
        void payload(const SetJointTrajectoryResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetJointTrajectoryResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetJointTrajectoryResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetJointTrajectoryResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetJointTrajectory 

    */
    class SetJointTrajectoryNML : public NMLmsg
    {
    public:

        /** constructor */
        SetJointTrajectoryNML();
        /** destructor */
        ~SetJointTrajectoryNML();

        /** assignment operator */
        SetJointTrajectoryNML & operator=(const SetJointTrajectoryNML &inobj);
        /** assignment operator for base data class */
        SetJointTrajectoryNML & operator=(const SetJointTrajectory &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetJointTrajectory nmlPayload;

        /** set payload */
        void payload(const SetJointTrajectory &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetJointTrajectory> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetJointTrajectory * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetJointTrajectory> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetLinkPropertiesRequest 

    */
    class SetLinkPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetLinkPropertiesRequestNML();
        /** destructor */
        ~SetLinkPropertiesRequestNML();

        /** assignment operator */
        SetLinkPropertiesRequestNML & operator=(const SetLinkPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        SetLinkPropertiesRequestNML & operator=(const SetLinkPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetLinkPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const SetLinkPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetLinkPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetLinkPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetLinkPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetLinkPropertiesResponse 

    */
    class SetLinkPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetLinkPropertiesResponseNML();
        /** destructor */
        ~SetLinkPropertiesResponseNML();

        /** assignment operator */
        SetLinkPropertiesResponseNML & operator=(const SetLinkPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        SetLinkPropertiesResponseNML & operator=(const SetLinkPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetLinkPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const SetLinkPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetLinkPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetLinkPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetLinkPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetLinkProperties 

    */
    class SetLinkPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        SetLinkPropertiesNML();
        /** destructor */
        ~SetLinkPropertiesNML();

        /** assignment operator */
        SetLinkPropertiesNML & operator=(const SetLinkPropertiesNML &inobj);
        /** assignment operator for base data class */
        SetLinkPropertiesNML & operator=(const SetLinkProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetLinkProperties nmlPayload;

        /** set payload */
        void payload(const SetLinkProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetLinkProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetLinkProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetLinkProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetLinkStateRequest 

    */
    class SetLinkStateRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetLinkStateRequestNML();
        /** destructor */
        ~SetLinkStateRequestNML();

        /** assignment operator */
        SetLinkStateRequestNML & operator=(const SetLinkStateRequestNML &inobj);
        /** assignment operator for base data class */
        SetLinkStateRequestNML & operator=(const SetLinkStateRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetLinkStateRequest nmlPayload;

        /** set payload */
        void payload(const SetLinkStateRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetLinkStateRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetLinkStateRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetLinkStateRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetLinkStateResponse 

    */
    class SetLinkStateResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetLinkStateResponseNML();
        /** destructor */
        ~SetLinkStateResponseNML();

        /** assignment operator */
        SetLinkStateResponseNML & operator=(const SetLinkStateResponseNML &inobj);
        /** assignment operator for base data class */
        SetLinkStateResponseNML & operator=(const SetLinkStateResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetLinkStateResponse nmlPayload;

        /** set payload */
        void payload(const SetLinkStateResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetLinkStateResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetLinkStateResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetLinkStateResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetLinkState 

    */
    class SetLinkStateNML : public NMLmsg
    {
    public:

        /** constructor */
        SetLinkStateNML();
        /** destructor */
        ~SetLinkStateNML();

        /** assignment operator */
        SetLinkStateNML & operator=(const SetLinkStateNML &inobj);
        /** assignment operator for base data class */
        SetLinkStateNML & operator=(const SetLinkState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetLinkState nmlPayload;

        /** set payload */
        void payload(const SetLinkState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetLinkState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetLinkState * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetLinkState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetModelConfigurationRequest 

    */
    class SetModelConfigurationRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetModelConfigurationRequestNML();
        /** destructor */
        ~SetModelConfigurationRequestNML();

        /** assignment operator */
        SetModelConfigurationRequestNML & operator=(const SetModelConfigurationRequestNML &inobj);
        /** assignment operator for base data class */
        SetModelConfigurationRequestNML & operator=(const SetModelConfigurationRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetModelConfigurationRequest nmlPayload;

        /** set payload */
        void payload(const SetModelConfigurationRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetModelConfigurationRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetModelConfigurationRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetModelConfigurationRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetModelConfigurationResponse 

    */
    class SetModelConfigurationResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetModelConfigurationResponseNML();
        /** destructor */
        ~SetModelConfigurationResponseNML();

        /** assignment operator */
        SetModelConfigurationResponseNML & operator=(const SetModelConfigurationResponseNML &inobj);
        /** assignment operator for base data class */
        SetModelConfigurationResponseNML & operator=(const SetModelConfigurationResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetModelConfigurationResponse nmlPayload;

        /** set payload */
        void payload(const SetModelConfigurationResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetModelConfigurationResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetModelConfigurationResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetModelConfigurationResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetModelConfiguration 

    */
    class SetModelConfigurationNML : public NMLmsg
    {
    public:

        /** constructor */
        SetModelConfigurationNML();
        /** destructor */
        ~SetModelConfigurationNML();

        /** assignment operator */
        SetModelConfigurationNML & operator=(const SetModelConfigurationNML &inobj);
        /** assignment operator for base data class */
        SetModelConfigurationNML & operator=(const SetModelConfiguration &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetModelConfiguration nmlPayload;

        /** set payload */
        void payload(const SetModelConfiguration &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetModelConfiguration> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetModelConfiguration * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetModelConfiguration> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetModelStateRequest 

    */
    class SetModelStateRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetModelStateRequestNML();
        /** destructor */
        ~SetModelStateRequestNML();

        /** assignment operator */
        SetModelStateRequestNML & operator=(const SetModelStateRequestNML &inobj);
        /** assignment operator for base data class */
        SetModelStateRequestNML & operator=(const SetModelStateRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetModelStateRequest nmlPayload;

        /** set payload */
        void payload(const SetModelStateRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetModelStateRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetModelStateRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetModelStateRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetModelStateResponse 

    */
    class SetModelStateResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetModelStateResponseNML();
        /** destructor */
        ~SetModelStateResponseNML();

        /** assignment operator */
        SetModelStateResponseNML & operator=(const SetModelStateResponseNML &inobj);
        /** assignment operator for base data class */
        SetModelStateResponseNML & operator=(const SetModelStateResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetModelStateResponse nmlPayload;

        /** set payload */
        void payload(const SetModelStateResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetModelStateResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetModelStateResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetModelStateResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetModelState 

    */
    class SetModelStateNML : public NMLmsg
    {
    public:

        /** constructor */
        SetModelStateNML();
        /** destructor */
        ~SetModelStateNML();

        /** assignment operator */
        SetModelStateNML & operator=(const SetModelStateNML &inobj);
        /** assignment operator for base data class */
        SetModelStateNML & operator=(const SetModelState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetModelState nmlPayload;

        /** set payload */
        void payload(const SetModelState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetModelState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetModelState * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetModelState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetPhysicsPropertiesRequest 

    */
    class SetPhysicsPropertiesRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SetPhysicsPropertiesRequestNML();
        /** destructor */
        ~SetPhysicsPropertiesRequestNML();

        /** assignment operator */
        SetPhysicsPropertiesRequestNML & operator=(const SetPhysicsPropertiesRequestNML &inobj);
        /** assignment operator for base data class */
        SetPhysicsPropertiesRequestNML & operator=(const SetPhysicsPropertiesRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetPhysicsPropertiesRequest nmlPayload;

        /** set payload */
        void payload(const SetPhysicsPropertiesRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetPhysicsPropertiesRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetPhysicsPropertiesRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetPhysicsPropertiesRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetPhysicsPropertiesResponse 

    */
    class SetPhysicsPropertiesResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SetPhysicsPropertiesResponseNML();
        /** destructor */
        ~SetPhysicsPropertiesResponseNML();

        /** assignment operator */
        SetPhysicsPropertiesResponseNML & operator=(const SetPhysicsPropertiesResponseNML &inobj);
        /** assignment operator for base data class */
        SetPhysicsPropertiesResponseNML & operator=(const SetPhysicsPropertiesResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetPhysicsPropertiesResponse nmlPayload;

        /** set payload */
        void payload(const SetPhysicsPropertiesResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetPhysicsPropertiesResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetPhysicsPropertiesResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetPhysicsPropertiesResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SetPhysicsProperties 

    */
    class SetPhysicsPropertiesNML : public NMLmsg
    {
    public:

        /** constructor */
        SetPhysicsPropertiesNML();
        /** destructor */
        ~SetPhysicsPropertiesNML();

        /** assignment operator */
        SetPhysicsPropertiesNML & operator=(const SetPhysicsPropertiesNML &inobj);
        /** assignment operator for base data class */
        SetPhysicsPropertiesNML & operator=(const SetPhysicsProperties &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SetPhysicsProperties nmlPayload;

        /** set payload */
        void payload(const SetPhysicsProperties &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SetPhysicsProperties> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SetPhysicsProperties * payload() { return & nmlPayload; };

    //     std::shared_ptr<SetPhysicsProperties> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SpawnModelRequest 

    */
    class SpawnModelRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        SpawnModelRequestNML();
        /** destructor */
        ~SpawnModelRequestNML();

        /** assignment operator */
        SpawnModelRequestNML & operator=(const SpawnModelRequestNML &inobj);
        /** assignment operator for base data class */
        SpawnModelRequestNML & operator=(const SpawnModelRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SpawnModelRequest nmlPayload;

        /** set payload */
        void payload(const SpawnModelRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SpawnModelRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SpawnModelRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<SpawnModelRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SpawnModelResponse 

    */
    class SpawnModelResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        SpawnModelResponseNML();
        /** destructor */
        ~SpawnModelResponseNML();

        /** assignment operator */
        SpawnModelResponseNML & operator=(const SpawnModelResponseNML &inobj);
        /** assignment operator for base data class */
        SpawnModelResponseNML & operator=(const SpawnModelResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SpawnModelResponse nmlPayload;

        /** set payload */
        void payload(const SpawnModelResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SpawnModelResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SpawnModelResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<SpawnModelResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SpawnModel 

    */
    class SpawnModelNML : public NMLmsg
    {
    public:

        /** constructor */
        SpawnModelNML();
        /** destructor */
        ~SpawnModelNML();

        /** assignment operator */
        SpawnModelNML & operator=(const SpawnModelNML &inobj);
        /** assignment operator for base data class */
        SpawnModelNML & operator=(const SpawnModel &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SpawnModel nmlPayload;

        /** set payload */
        void payload(const SpawnModel &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SpawnModel> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SpawnModel * payload() { return & nmlPayload; };

    //     std::shared_ptr<SpawnModel> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    // predeclaration of nmlupdate functions (necessary due to namespaces )

    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ContactState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ContactsState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::LinkState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::LinkStates & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ModelState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ModelStates & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ODEJointProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ODEPhysics & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::WorldState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ApplyBodyWrenchRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ApplyBodyWrenchResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ApplyBodyWrench & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ApplyJointEffortRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ApplyJointEffortResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::ApplyJointEffort & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::BodyRequestRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::BodyRequestResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::BodyRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::DeleteModelRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::DeleteModelResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::DeleteModel & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetJointPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetJointPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetJointProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetLinkPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetLinkPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetLinkProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetLinkStateRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetLinkStateResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetLinkState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetModelPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetModelPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetModelProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetModelStateRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetModelStateResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetModelState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetPhysicsPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetPhysicsPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetPhysicsProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetWorldPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetWorldPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::GetWorldProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::JointRequestRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::JointRequestResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::JointRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetJointPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetJointPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetJointProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetJointTrajectoryRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetJointTrajectoryResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetJointTrajectory & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetLinkPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetLinkPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetLinkProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetLinkStateRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetLinkStateResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetLinkState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetModelConfigurationRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetModelConfigurationResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetModelConfiguration & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetModelStateRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetModelStateResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetModelState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetPhysicsPropertiesRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetPhysicsPropertiesResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SetPhysicsProperties & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SpawnModelRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SpawnModelResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, gazebo_msgs::SpawnModel & inobj);

    /** nml format function */
    int gazebo_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms);

}; // end namespace gazebo_msgs

#endif // _GAZEBO_MSGS_GENCPPNML_H_
