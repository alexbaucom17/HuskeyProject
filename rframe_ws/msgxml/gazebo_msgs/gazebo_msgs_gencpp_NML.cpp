// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:05 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "gazebo_msgs_gencpp_NML.h"
#include "gazebo_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <ContactState.h>
#include <ContactsState.h>
#include <LinkState.h>
#include <LinkStates.h>
#include <ModelState.h>
#include <ModelStates.h>
#include <ODEJointProperties.h>
#include <ODEPhysics.h>
#include <WorldState.h>
#include <ApplyBodyWrenchRequest.h>
#include <ApplyBodyWrenchResponse.h>
#include <ApplyBodyWrench.h>
#include <ApplyJointEffortRequest.h>
#include <ApplyJointEffortResponse.h>
#include <ApplyJointEffort.h>
#include <BodyRequestRequest.h>
#include <BodyRequestResponse.h>
#include <BodyRequest.h>
#include <DeleteModelRequest.h>
#include <DeleteModelResponse.h>
#include <DeleteModel.h>
#include <GetJointPropertiesRequest.h>
#include <GetJointPropertiesResponse.h>
#include <GetJointProperties.h>
#include <GetLinkPropertiesRequest.h>
#include <GetLinkPropertiesResponse.h>
#include <GetLinkProperties.h>
#include <GetLinkStateRequest.h>
#include <GetLinkStateResponse.h>
#include <GetLinkState.h>
#include <GetModelPropertiesRequest.h>
#include <GetModelPropertiesResponse.h>
#include <GetModelProperties.h>
#include <GetModelStateRequest.h>
#include <GetModelStateResponse.h>
#include <GetModelState.h>
#include <GetPhysicsPropertiesRequest.h>
#include <GetPhysicsPropertiesResponse.h>
#include <GetPhysicsProperties.h>
#include <GetWorldPropertiesRequest.h>
#include <GetWorldPropertiesResponse.h>
#include <GetWorldProperties.h>
#include <JointRequestRequest.h>
#include <JointRequestResponse.h>
#include <JointRequest.h>
#include <SetJointPropertiesRequest.h>
#include <SetJointPropertiesResponse.h>
#include <SetJointProperties.h>
#include <SetJointTrajectoryRequest.h>
#include <SetJointTrajectoryResponse.h>
#include <SetJointTrajectory.h>
#include <SetLinkPropertiesRequest.h>
#include <SetLinkPropertiesResponse.h>
#include <SetLinkProperties.h>
#include <SetLinkStateRequest.h>
#include <SetLinkStateResponse.h>
#include <SetLinkState.h>
#include <SetModelConfigurationRequest.h>
#include <SetModelConfigurationResponse.h>
#include <SetModelConfiguration.h>
#include <SetModelStateRequest.h>
#include <SetModelStateResponse.h>
#include <SetModelState.h>
#include <SetPhysicsPropertiesRequest.h>
#include <SetPhysicsPropertiesResponse.h>
#include <SetPhysicsProperties.h>
#include <SpawnModelRequest.h>
#include <SpawnModelResponse.h>
#include <SpawnModel.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace gazebo_msgs;

rframe::NMLMessageFactory * NML_gazebo_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_gazebo_msgs_gencppfactory = new gazebo_msgs_gencppNMLMessageFactory();
        return NML_gazebo_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * gazebo_msgs::allocate_gazebo_msgs_gencpp()
{
    NML_gazebo_msgs_gencppfactory = new gazebo_msgs_gencppNMLMessageFactory();
    return NML_gazebo_msgs_gencppfactory;
};

gazebo_msgs_gencppNMLMessageFactory::gazebo_msgs_gencppNMLMessageFactory()
{
    name("gazebo_msgs_gencpp");
    // use constructor to register data types
    gazebo_msgs::registerLibrary();
}

gazebo_msgs_gencppNMLMessageFactory::~gazebo_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR gazebo_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return gazebo_msgs_gencpp_format;
}

int gazebo_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void gazebo_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(ContactState::ID);
    info.name(ContactState::DATA_TYPE_FULL_NAME);
    info.hashKey(ContactState::DATA_VERSION);
    info.md5Key(ContactState::VERSION_MD5);
    info.xmlSource(ContactState::XML_SOURCE);
    info.flat(ContactState::dataTypeFlat());
    ids.push_back(info);

    info.id(ContactsState::ID);
    info.name(ContactsState::DATA_TYPE_FULL_NAME);
    info.hashKey(ContactsState::DATA_VERSION);
    info.md5Key(ContactsState::VERSION_MD5);
    info.xmlSource(ContactsState::XML_SOURCE);
    info.flat(ContactsState::dataTypeFlat());
    ids.push_back(info);

    info.id(LinkState::ID);
    info.name(LinkState::DATA_TYPE_FULL_NAME);
    info.hashKey(LinkState::DATA_VERSION);
    info.md5Key(LinkState::VERSION_MD5);
    info.xmlSource(LinkState::XML_SOURCE);
    info.flat(LinkState::dataTypeFlat());
    ids.push_back(info);

    info.id(LinkStates::ID);
    info.name(LinkStates::DATA_TYPE_FULL_NAME);
    info.hashKey(LinkStates::DATA_VERSION);
    info.md5Key(LinkStates::VERSION_MD5);
    info.xmlSource(LinkStates::XML_SOURCE);
    info.flat(LinkStates::dataTypeFlat());
    ids.push_back(info);

    info.id(ModelState::ID);
    info.name(ModelState::DATA_TYPE_FULL_NAME);
    info.hashKey(ModelState::DATA_VERSION);
    info.md5Key(ModelState::VERSION_MD5);
    info.xmlSource(ModelState::XML_SOURCE);
    info.flat(ModelState::dataTypeFlat());
    ids.push_back(info);

    info.id(ModelStates::ID);
    info.name(ModelStates::DATA_TYPE_FULL_NAME);
    info.hashKey(ModelStates::DATA_VERSION);
    info.md5Key(ModelStates::VERSION_MD5);
    info.xmlSource(ModelStates::XML_SOURCE);
    info.flat(ModelStates::dataTypeFlat());
    ids.push_back(info);

    info.id(ODEJointProperties::ID);
    info.name(ODEJointProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(ODEJointProperties::DATA_VERSION);
    info.md5Key(ODEJointProperties::VERSION_MD5);
    info.xmlSource(ODEJointProperties::XML_SOURCE);
    info.flat(ODEJointProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(ODEPhysics::ID);
    info.name(ODEPhysics::DATA_TYPE_FULL_NAME);
    info.hashKey(ODEPhysics::DATA_VERSION);
    info.md5Key(ODEPhysics::VERSION_MD5);
    info.xmlSource(ODEPhysics::XML_SOURCE);
    info.flat(ODEPhysics::dataTypeFlat());
    ids.push_back(info);

    info.id(WorldState::ID);
    info.name(WorldState::DATA_TYPE_FULL_NAME);
    info.hashKey(WorldState::DATA_VERSION);
    info.md5Key(WorldState::VERSION_MD5);
    info.xmlSource(WorldState::XML_SOURCE);
    info.flat(WorldState::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyBodyWrenchRequest::ID);
    info.name(ApplyBodyWrenchRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyBodyWrenchRequest::DATA_VERSION);
    info.md5Key(ApplyBodyWrenchRequest::VERSION_MD5);
    info.xmlSource(ApplyBodyWrenchRequest::XML_SOURCE);
    info.flat(ApplyBodyWrenchRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyBodyWrenchResponse::ID);
    info.name(ApplyBodyWrenchResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyBodyWrenchResponse::DATA_VERSION);
    info.md5Key(ApplyBodyWrenchResponse::VERSION_MD5);
    info.xmlSource(ApplyBodyWrenchResponse::XML_SOURCE);
    info.flat(ApplyBodyWrenchResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyBodyWrench::ID);
    info.name(ApplyBodyWrench::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyBodyWrench::DATA_VERSION);
    info.md5Key(ApplyBodyWrench::VERSION_MD5);
    info.xmlSource(ApplyBodyWrench::XML_SOURCE);
    info.flat(ApplyBodyWrench::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyJointEffortRequest::ID);
    info.name(ApplyJointEffortRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyJointEffortRequest::DATA_VERSION);
    info.md5Key(ApplyJointEffortRequest::VERSION_MD5);
    info.xmlSource(ApplyJointEffortRequest::XML_SOURCE);
    info.flat(ApplyJointEffortRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyJointEffortResponse::ID);
    info.name(ApplyJointEffortResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyJointEffortResponse::DATA_VERSION);
    info.md5Key(ApplyJointEffortResponse::VERSION_MD5);
    info.xmlSource(ApplyJointEffortResponse::XML_SOURCE);
    info.flat(ApplyJointEffortResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyJointEffort::ID);
    info.name(ApplyJointEffort::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyJointEffort::DATA_VERSION);
    info.md5Key(ApplyJointEffort::VERSION_MD5);
    info.xmlSource(ApplyJointEffort::XML_SOURCE);
    info.flat(ApplyJointEffort::dataTypeFlat());
    ids.push_back(info);

    info.id(BodyRequestRequest::ID);
    info.name(BodyRequestRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(BodyRequestRequest::DATA_VERSION);
    info.md5Key(BodyRequestRequest::VERSION_MD5);
    info.xmlSource(BodyRequestRequest::XML_SOURCE);
    info.flat(BodyRequestRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(BodyRequestResponse::ID);
    info.name(BodyRequestResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(BodyRequestResponse::DATA_VERSION);
    info.md5Key(BodyRequestResponse::VERSION_MD5);
    info.xmlSource(BodyRequestResponse::XML_SOURCE);
    info.flat(BodyRequestResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(BodyRequest::ID);
    info.name(BodyRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(BodyRequest::DATA_VERSION);
    info.md5Key(BodyRequest::VERSION_MD5);
    info.xmlSource(BodyRequest::XML_SOURCE);
    info.flat(BodyRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DeleteModelRequest::ID);
    info.name(DeleteModelRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DeleteModelRequest::DATA_VERSION);
    info.md5Key(DeleteModelRequest::VERSION_MD5);
    info.xmlSource(DeleteModelRequest::XML_SOURCE);
    info.flat(DeleteModelRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DeleteModelResponse::ID);
    info.name(DeleteModelResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DeleteModelResponse::DATA_VERSION);
    info.md5Key(DeleteModelResponse::VERSION_MD5);
    info.xmlSource(DeleteModelResponse::XML_SOURCE);
    info.flat(DeleteModelResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DeleteModel::ID);
    info.name(DeleteModel::DATA_TYPE_FULL_NAME);
    info.hashKey(DeleteModel::DATA_VERSION);
    info.md5Key(DeleteModel::VERSION_MD5);
    info.xmlSource(DeleteModel::XML_SOURCE);
    info.flat(DeleteModel::dataTypeFlat());
    ids.push_back(info);

    info.id(GetJointPropertiesRequest::ID);
    info.name(GetJointPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetJointPropertiesRequest::DATA_VERSION);
    info.md5Key(GetJointPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetJointPropertiesRequest::XML_SOURCE);
    info.flat(GetJointPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetJointPropertiesResponse::ID);
    info.name(GetJointPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetJointPropertiesResponse::DATA_VERSION);
    info.md5Key(GetJointPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetJointPropertiesResponse::XML_SOURCE);
    info.flat(GetJointPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetJointProperties::ID);
    info.name(GetJointProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetJointProperties::DATA_VERSION);
    info.md5Key(GetJointProperties::VERSION_MD5);
    info.xmlSource(GetJointProperties::XML_SOURCE);
    info.flat(GetJointProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkPropertiesRequest::ID);
    info.name(GetLinkPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkPropertiesRequest::DATA_VERSION);
    info.md5Key(GetLinkPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetLinkPropertiesRequest::XML_SOURCE);
    info.flat(GetLinkPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkPropertiesResponse::ID);
    info.name(GetLinkPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkPropertiesResponse::DATA_VERSION);
    info.md5Key(GetLinkPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetLinkPropertiesResponse::XML_SOURCE);
    info.flat(GetLinkPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkProperties::ID);
    info.name(GetLinkProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkProperties::DATA_VERSION);
    info.md5Key(GetLinkProperties::VERSION_MD5);
    info.xmlSource(GetLinkProperties::XML_SOURCE);
    info.flat(GetLinkProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkStateRequest::ID);
    info.name(GetLinkStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkStateRequest::DATA_VERSION);
    info.md5Key(GetLinkStateRequest::VERSION_MD5);
    info.xmlSource(GetLinkStateRequest::XML_SOURCE);
    info.flat(GetLinkStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkStateResponse::ID);
    info.name(GetLinkStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkStateResponse::DATA_VERSION);
    info.md5Key(GetLinkStateResponse::VERSION_MD5);
    info.xmlSource(GetLinkStateResponse::XML_SOURCE);
    info.flat(GetLinkStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkState::ID);
    info.name(GetLinkState::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkState::DATA_VERSION);
    info.md5Key(GetLinkState::VERSION_MD5);
    info.xmlSource(GetLinkState::XML_SOURCE);
    info.flat(GetLinkState::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelPropertiesRequest::ID);
    info.name(GetModelPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelPropertiesRequest::DATA_VERSION);
    info.md5Key(GetModelPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetModelPropertiesRequest::XML_SOURCE);
    info.flat(GetModelPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelPropertiesResponse::ID);
    info.name(GetModelPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelPropertiesResponse::DATA_VERSION);
    info.md5Key(GetModelPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetModelPropertiesResponse::XML_SOURCE);
    info.flat(GetModelPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelProperties::ID);
    info.name(GetModelProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelProperties::DATA_VERSION);
    info.md5Key(GetModelProperties::VERSION_MD5);
    info.xmlSource(GetModelProperties::XML_SOURCE);
    info.flat(GetModelProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelStateRequest::ID);
    info.name(GetModelStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelStateRequest::DATA_VERSION);
    info.md5Key(GetModelStateRequest::VERSION_MD5);
    info.xmlSource(GetModelStateRequest::XML_SOURCE);
    info.flat(GetModelStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelStateResponse::ID);
    info.name(GetModelStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelStateResponse::DATA_VERSION);
    info.md5Key(GetModelStateResponse::VERSION_MD5);
    info.xmlSource(GetModelStateResponse::XML_SOURCE);
    info.flat(GetModelStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelState::ID);
    info.name(GetModelState::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelState::DATA_VERSION);
    info.md5Key(GetModelState::VERSION_MD5);
    info.xmlSource(GetModelState::XML_SOURCE);
    info.flat(GetModelState::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPhysicsPropertiesRequest::ID);
    info.name(GetPhysicsPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPhysicsPropertiesRequest::DATA_VERSION);
    info.md5Key(GetPhysicsPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetPhysicsPropertiesRequest::XML_SOURCE);
    info.flat(GetPhysicsPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPhysicsPropertiesResponse::ID);
    info.name(GetPhysicsPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPhysicsPropertiesResponse::DATA_VERSION);
    info.md5Key(GetPhysicsPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetPhysicsPropertiesResponse::XML_SOURCE);
    info.flat(GetPhysicsPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPhysicsProperties::ID);
    info.name(GetPhysicsProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPhysicsProperties::DATA_VERSION);
    info.md5Key(GetPhysicsProperties::VERSION_MD5);
    info.xmlSource(GetPhysicsProperties::XML_SOURCE);
    info.flat(GetPhysicsProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetWorldPropertiesRequest::ID);
    info.name(GetWorldPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetWorldPropertiesRequest::DATA_VERSION);
    info.md5Key(GetWorldPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetWorldPropertiesRequest::XML_SOURCE);
    info.flat(GetWorldPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetWorldPropertiesResponse::ID);
    info.name(GetWorldPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetWorldPropertiesResponse::DATA_VERSION);
    info.md5Key(GetWorldPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetWorldPropertiesResponse::XML_SOURCE);
    info.flat(GetWorldPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetWorldProperties::ID);
    info.name(GetWorldProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetWorldProperties::DATA_VERSION);
    info.md5Key(GetWorldProperties::VERSION_MD5);
    info.xmlSource(GetWorldProperties::XML_SOURCE);
    info.flat(GetWorldProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(JointRequestRequest::ID);
    info.name(JointRequestRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(JointRequestRequest::DATA_VERSION);
    info.md5Key(JointRequestRequest::VERSION_MD5);
    info.xmlSource(JointRequestRequest::XML_SOURCE);
    info.flat(JointRequestRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(JointRequestResponse::ID);
    info.name(JointRequestResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(JointRequestResponse::DATA_VERSION);
    info.md5Key(JointRequestResponse::VERSION_MD5);
    info.xmlSource(JointRequestResponse::XML_SOURCE);
    info.flat(JointRequestResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(JointRequest::ID);
    info.name(JointRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(JointRequest::DATA_VERSION);
    info.md5Key(JointRequest::VERSION_MD5);
    info.xmlSource(JointRequest::XML_SOURCE);
    info.flat(JointRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointPropertiesRequest::ID);
    info.name(SetJointPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointPropertiesRequest::DATA_VERSION);
    info.md5Key(SetJointPropertiesRequest::VERSION_MD5);
    info.xmlSource(SetJointPropertiesRequest::XML_SOURCE);
    info.flat(SetJointPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointPropertiesResponse::ID);
    info.name(SetJointPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointPropertiesResponse::DATA_VERSION);
    info.md5Key(SetJointPropertiesResponse::VERSION_MD5);
    info.xmlSource(SetJointPropertiesResponse::XML_SOURCE);
    info.flat(SetJointPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointProperties::ID);
    info.name(SetJointProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointProperties::DATA_VERSION);
    info.md5Key(SetJointProperties::VERSION_MD5);
    info.xmlSource(SetJointProperties::XML_SOURCE);
    info.flat(SetJointProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointTrajectoryRequest::ID);
    info.name(SetJointTrajectoryRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointTrajectoryRequest::DATA_VERSION);
    info.md5Key(SetJointTrajectoryRequest::VERSION_MD5);
    info.xmlSource(SetJointTrajectoryRequest::XML_SOURCE);
    info.flat(SetJointTrajectoryRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointTrajectoryResponse::ID);
    info.name(SetJointTrajectoryResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointTrajectoryResponse::DATA_VERSION);
    info.md5Key(SetJointTrajectoryResponse::VERSION_MD5);
    info.xmlSource(SetJointTrajectoryResponse::XML_SOURCE);
    info.flat(SetJointTrajectoryResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointTrajectory::ID);
    info.name(SetJointTrajectory::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointTrajectory::DATA_VERSION);
    info.md5Key(SetJointTrajectory::VERSION_MD5);
    info.xmlSource(SetJointTrajectory::XML_SOURCE);
    info.flat(SetJointTrajectory::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkPropertiesRequest::ID);
    info.name(SetLinkPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkPropertiesRequest::DATA_VERSION);
    info.md5Key(SetLinkPropertiesRequest::VERSION_MD5);
    info.xmlSource(SetLinkPropertiesRequest::XML_SOURCE);
    info.flat(SetLinkPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkPropertiesResponse::ID);
    info.name(SetLinkPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkPropertiesResponse::DATA_VERSION);
    info.md5Key(SetLinkPropertiesResponse::VERSION_MD5);
    info.xmlSource(SetLinkPropertiesResponse::XML_SOURCE);
    info.flat(SetLinkPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkProperties::ID);
    info.name(SetLinkProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkProperties::DATA_VERSION);
    info.md5Key(SetLinkProperties::VERSION_MD5);
    info.xmlSource(SetLinkProperties::XML_SOURCE);
    info.flat(SetLinkProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkStateRequest::ID);
    info.name(SetLinkStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkStateRequest::DATA_VERSION);
    info.md5Key(SetLinkStateRequest::VERSION_MD5);
    info.xmlSource(SetLinkStateRequest::XML_SOURCE);
    info.flat(SetLinkStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkStateResponse::ID);
    info.name(SetLinkStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkStateResponse::DATA_VERSION);
    info.md5Key(SetLinkStateResponse::VERSION_MD5);
    info.xmlSource(SetLinkStateResponse::XML_SOURCE);
    info.flat(SetLinkStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkState::ID);
    info.name(SetLinkState::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkState::DATA_VERSION);
    info.md5Key(SetLinkState::VERSION_MD5);
    info.xmlSource(SetLinkState::XML_SOURCE);
    info.flat(SetLinkState::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelConfigurationRequest::ID);
    info.name(SetModelConfigurationRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelConfigurationRequest::DATA_VERSION);
    info.md5Key(SetModelConfigurationRequest::VERSION_MD5);
    info.xmlSource(SetModelConfigurationRequest::XML_SOURCE);
    info.flat(SetModelConfigurationRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelConfigurationResponse::ID);
    info.name(SetModelConfigurationResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelConfigurationResponse::DATA_VERSION);
    info.md5Key(SetModelConfigurationResponse::VERSION_MD5);
    info.xmlSource(SetModelConfigurationResponse::XML_SOURCE);
    info.flat(SetModelConfigurationResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelConfiguration::ID);
    info.name(SetModelConfiguration::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelConfiguration::DATA_VERSION);
    info.md5Key(SetModelConfiguration::VERSION_MD5);
    info.xmlSource(SetModelConfiguration::XML_SOURCE);
    info.flat(SetModelConfiguration::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelStateRequest::ID);
    info.name(SetModelStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelStateRequest::DATA_VERSION);
    info.md5Key(SetModelStateRequest::VERSION_MD5);
    info.xmlSource(SetModelStateRequest::XML_SOURCE);
    info.flat(SetModelStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelStateResponse::ID);
    info.name(SetModelStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelStateResponse::DATA_VERSION);
    info.md5Key(SetModelStateResponse::VERSION_MD5);
    info.xmlSource(SetModelStateResponse::XML_SOURCE);
    info.flat(SetModelStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelState::ID);
    info.name(SetModelState::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelState::DATA_VERSION);
    info.md5Key(SetModelState::VERSION_MD5);
    info.xmlSource(SetModelState::XML_SOURCE);
    info.flat(SetModelState::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPhysicsPropertiesRequest::ID);
    info.name(SetPhysicsPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPhysicsPropertiesRequest::DATA_VERSION);
    info.md5Key(SetPhysicsPropertiesRequest::VERSION_MD5);
    info.xmlSource(SetPhysicsPropertiesRequest::XML_SOURCE);
    info.flat(SetPhysicsPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPhysicsPropertiesResponse::ID);
    info.name(SetPhysicsPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPhysicsPropertiesResponse::DATA_VERSION);
    info.md5Key(SetPhysicsPropertiesResponse::VERSION_MD5);
    info.xmlSource(SetPhysicsPropertiesResponse::XML_SOURCE);
    info.flat(SetPhysicsPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPhysicsProperties::ID);
    info.name(SetPhysicsProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPhysicsProperties::DATA_VERSION);
    info.md5Key(SetPhysicsProperties::VERSION_MD5);
    info.xmlSource(SetPhysicsProperties::XML_SOURCE);
    info.flat(SetPhysicsProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnModelRequest::ID);
    info.name(SpawnModelRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnModelRequest::DATA_VERSION);
    info.md5Key(SpawnModelRequest::VERSION_MD5);
    info.xmlSource(SpawnModelRequest::XML_SOURCE);
    info.flat(SpawnModelRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnModelResponse::ID);
    info.name(SpawnModelResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnModelResponse::DATA_VERSION);
    info.md5Key(SpawnModelResponse::VERSION_MD5);
    info.xmlSource(SpawnModelResponse::XML_SOURCE);
    info.flat(SpawnModelResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnModel::ID);
    info.name(SpawnModel::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnModel::DATA_VERSION);
    info.md5Key(SpawnModel::VERSION_MD5);
    info.xmlSource(SpawnModel::XML_SOURCE);
    info.flat(SpawnModel::dataTypeFlat());
    ids.push_back(info);

}

int gazebo_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case ContactState::ID:
        {
            //ContactStateNML * newmsg = new ContactStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ContactStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ContactsState::ID:
        {
            //ContactsStateNML * newmsg = new ContactsStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ContactsStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LinkState::ID:
        {
            //LinkStateNML * newmsg = new LinkStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LinkStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LinkStates::ID:
        {
            //LinkStatesNML * newmsg = new LinkStatesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LinkStatesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ModelState::ID:
        {
            //ModelStateNML * newmsg = new ModelStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ModelStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ModelStates::ID:
        {
            //ModelStatesNML * newmsg = new ModelStatesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ModelStatesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ODEJointProperties::ID:
        {
            //ODEJointPropertiesNML * newmsg = new ODEJointPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ODEJointPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ODEPhysics::ID:
        {
            //ODEPhysicsNML * newmsg = new ODEPhysicsNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ODEPhysicsNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case WorldState::ID:
        {
            //WorldStateNML * newmsg = new WorldStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new WorldStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ApplyBodyWrenchRequest::ID:
        {
            //ApplyBodyWrenchRequestNML * newmsg = new ApplyBodyWrenchRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ApplyBodyWrenchRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ApplyBodyWrenchResponse::ID:
        {
            //ApplyBodyWrenchResponseNML * newmsg = new ApplyBodyWrenchResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ApplyBodyWrenchResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ApplyBodyWrench::ID:
        {
            //ApplyBodyWrenchNML * newmsg = new ApplyBodyWrenchNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ApplyBodyWrenchNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ApplyJointEffortRequest::ID:
        {
            //ApplyJointEffortRequestNML * newmsg = new ApplyJointEffortRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ApplyJointEffortRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ApplyJointEffortResponse::ID:
        {
            //ApplyJointEffortResponseNML * newmsg = new ApplyJointEffortResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ApplyJointEffortResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ApplyJointEffort::ID:
        {
            //ApplyJointEffortNML * newmsg = new ApplyJointEffortNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ApplyJointEffortNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case BodyRequestRequest::ID:
        {
            //BodyRequestRequestNML * newmsg = new BodyRequestRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new BodyRequestRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case BodyRequestResponse::ID:
        {
            //BodyRequestResponseNML * newmsg = new BodyRequestResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new BodyRequestResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case BodyRequest::ID:
        {
            //BodyRequestNML * newmsg = new BodyRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new BodyRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DeleteModelRequest::ID:
        {
            //DeleteModelRequestNML * newmsg = new DeleteModelRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DeleteModelRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DeleteModelResponse::ID:
        {
            //DeleteModelResponseNML * newmsg = new DeleteModelResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DeleteModelResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DeleteModel::ID:
        {
            //DeleteModelNML * newmsg = new DeleteModelNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DeleteModelNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetJointPropertiesRequest::ID:
        {
            //GetJointPropertiesRequestNML * newmsg = new GetJointPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetJointPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetJointPropertiesResponse::ID:
        {
            //GetJointPropertiesResponseNML * newmsg = new GetJointPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetJointPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetJointProperties::ID:
        {
            //GetJointPropertiesNML * newmsg = new GetJointPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetJointPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetLinkPropertiesRequest::ID:
        {
            //GetLinkPropertiesRequestNML * newmsg = new GetLinkPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetLinkPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetLinkPropertiesResponse::ID:
        {
            //GetLinkPropertiesResponseNML * newmsg = new GetLinkPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetLinkPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetLinkProperties::ID:
        {
            //GetLinkPropertiesNML * newmsg = new GetLinkPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetLinkPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetLinkStateRequest::ID:
        {
            //GetLinkStateRequestNML * newmsg = new GetLinkStateRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetLinkStateRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetLinkStateResponse::ID:
        {
            //GetLinkStateResponseNML * newmsg = new GetLinkStateResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetLinkStateResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetLinkState::ID:
        {
            //GetLinkStateNML * newmsg = new GetLinkStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetLinkStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetModelPropertiesRequest::ID:
        {
            //GetModelPropertiesRequestNML * newmsg = new GetModelPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetModelPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetModelPropertiesResponse::ID:
        {
            //GetModelPropertiesResponseNML * newmsg = new GetModelPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetModelPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetModelProperties::ID:
        {
            //GetModelPropertiesNML * newmsg = new GetModelPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetModelPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetModelStateRequest::ID:
        {
            //GetModelStateRequestNML * newmsg = new GetModelStateRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetModelStateRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetModelStateResponse::ID:
        {
            //GetModelStateResponseNML * newmsg = new GetModelStateResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetModelStateResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetModelState::ID:
        {
            //GetModelStateNML * newmsg = new GetModelStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetModelStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPhysicsPropertiesRequest::ID:
        {
            //GetPhysicsPropertiesRequestNML * newmsg = new GetPhysicsPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPhysicsPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPhysicsPropertiesResponse::ID:
        {
            //GetPhysicsPropertiesResponseNML * newmsg = new GetPhysicsPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPhysicsPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetPhysicsProperties::ID:
        {
            //GetPhysicsPropertiesNML * newmsg = new GetPhysicsPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetPhysicsPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetWorldPropertiesRequest::ID:
        {
            //GetWorldPropertiesRequestNML * newmsg = new GetWorldPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetWorldPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetWorldPropertiesResponse::ID:
        {
            //GetWorldPropertiesResponseNML * newmsg = new GetWorldPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetWorldPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GetWorldProperties::ID:
        {
            //GetWorldPropertiesNML * newmsg = new GetWorldPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GetWorldPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointRequestRequest::ID:
        {
            //JointRequestRequestNML * newmsg = new JointRequestRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointRequestRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointRequestResponse::ID:
        {
            //JointRequestResponseNML * newmsg = new JointRequestResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointRequestResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointRequest::ID:
        {
            //JointRequestNML * newmsg = new JointRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetJointPropertiesRequest::ID:
        {
            //SetJointPropertiesRequestNML * newmsg = new SetJointPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetJointPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetJointPropertiesResponse::ID:
        {
            //SetJointPropertiesResponseNML * newmsg = new SetJointPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetJointPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetJointProperties::ID:
        {
            //SetJointPropertiesNML * newmsg = new SetJointPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetJointPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetJointTrajectoryRequest::ID:
        {
            //SetJointTrajectoryRequestNML * newmsg = new SetJointTrajectoryRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetJointTrajectoryRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetJointTrajectoryResponse::ID:
        {
            //SetJointTrajectoryResponseNML * newmsg = new SetJointTrajectoryResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetJointTrajectoryResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetJointTrajectory::ID:
        {
            //SetJointTrajectoryNML * newmsg = new SetJointTrajectoryNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetJointTrajectoryNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetLinkPropertiesRequest::ID:
        {
            //SetLinkPropertiesRequestNML * newmsg = new SetLinkPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetLinkPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetLinkPropertiesResponse::ID:
        {
            //SetLinkPropertiesResponseNML * newmsg = new SetLinkPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetLinkPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetLinkProperties::ID:
        {
            //SetLinkPropertiesNML * newmsg = new SetLinkPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetLinkPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetLinkStateRequest::ID:
        {
            //SetLinkStateRequestNML * newmsg = new SetLinkStateRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetLinkStateRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetLinkStateResponse::ID:
        {
            //SetLinkStateResponseNML * newmsg = new SetLinkStateResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetLinkStateResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetLinkState::ID:
        {
            //SetLinkStateNML * newmsg = new SetLinkStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetLinkStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetModelConfigurationRequest::ID:
        {
            //SetModelConfigurationRequestNML * newmsg = new SetModelConfigurationRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetModelConfigurationRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetModelConfigurationResponse::ID:
        {
            //SetModelConfigurationResponseNML * newmsg = new SetModelConfigurationResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetModelConfigurationResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetModelConfiguration::ID:
        {
            //SetModelConfigurationNML * newmsg = new SetModelConfigurationNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetModelConfigurationNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetModelStateRequest::ID:
        {
            //SetModelStateRequestNML * newmsg = new SetModelStateRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetModelStateRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetModelStateResponse::ID:
        {
            //SetModelStateResponseNML * newmsg = new SetModelStateResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetModelStateResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetModelState::ID:
        {
            //SetModelStateNML * newmsg = new SetModelStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetModelStateNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetPhysicsPropertiesRequest::ID:
        {
            //SetPhysicsPropertiesRequestNML * newmsg = new SetPhysicsPropertiesRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetPhysicsPropertiesRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetPhysicsPropertiesResponse::ID:
        {
            //SetPhysicsPropertiesResponseNML * newmsg = new SetPhysicsPropertiesResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetPhysicsPropertiesResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SetPhysicsProperties::ID:
        {
            //SetPhysicsPropertiesNML * newmsg = new SetPhysicsPropertiesNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SetPhysicsPropertiesNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SpawnModelRequest::ID:
        {
            //SpawnModelRequestNML * newmsg = new SpawnModelRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SpawnModelRequestNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SpawnModelResponse::ID:
        {
            //SpawnModelResponseNML * newmsg = new SpawnModelResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SpawnModelResponseNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SpawnModel::ID:
        {
            //SpawnModelNML * newmsg = new SpawnModelNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SpawnModelNML(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case ContactState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ContactState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ContactsState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ContactsState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LinkState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LinkState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LinkStates::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LinkStates>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ModelState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ModelState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ModelStates::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ModelStates>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ODEJointProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ODEJointProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ODEPhysics::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ODEPhysics>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case WorldState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<WorldState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyBodyWrenchRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrenchRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyBodyWrenchResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrenchResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyBodyWrench::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrench>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyJointEffortRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffortRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyJointEffortResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffortResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyJointEffort::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffort>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case BodyRequestRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequestRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case BodyRequestResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequestResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case BodyRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DeleteModelRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModelRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DeleteModelResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModelResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DeleteModel::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModel>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetJointPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetJointPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetJointPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetJointPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetJointProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetJointProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkStateRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkStateResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelStateRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelStateResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPhysicsPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPhysicsPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPhysicsProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetWorldPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetWorldPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetWorldProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointRequestRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointRequestRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointRequestResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointRequestResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointTrajectoryRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectoryRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointTrajectoryResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectoryResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointTrajectory::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectory>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkStateRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkStateResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelConfigurationRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfigurationRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelConfigurationResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfigurationResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelConfiguration::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfiguration>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelStateRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelStateResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelState>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPhysicsPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsPropertiesRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPhysicsPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsPropertiesResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPhysicsProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsProperties>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnModelRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModelRequest>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnModelResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModelResponse>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnModel::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModel>(),std::bind(&gazebo_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case ContactState::ID:
            {
                ContactStateNML * tempmsg = static_cast<ContactStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ContactsState::ID:
            {
                ContactsStateNML * tempmsg = static_cast<ContactsStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LinkState::ID:
            {
                LinkStateNML * tempmsg = static_cast<LinkStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LinkStates::ID:
            {
                LinkStatesNML * tempmsg = static_cast<LinkStatesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ModelState::ID:
            {
                ModelStateNML * tempmsg = static_cast<ModelStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ModelStates::ID:
            {
                ModelStatesNML * tempmsg = static_cast<ModelStatesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ODEJointProperties::ID:
            {
                ODEJointPropertiesNML * tempmsg = static_cast<ODEJointPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ODEPhysics::ID:
            {
                ODEPhysicsNML * tempmsg = static_cast<ODEPhysicsNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case WorldState::ID:
            {
                WorldStateNML * tempmsg = static_cast<WorldStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ApplyBodyWrenchRequest::ID:
            {
                ApplyBodyWrenchRequestNML * tempmsg = static_cast<ApplyBodyWrenchRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ApplyBodyWrenchResponse::ID:
            {
                ApplyBodyWrenchResponseNML * tempmsg = static_cast<ApplyBodyWrenchResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ApplyBodyWrench::ID:
            {
                ApplyBodyWrenchNML * tempmsg = static_cast<ApplyBodyWrenchNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ApplyJointEffortRequest::ID:
            {
                ApplyJointEffortRequestNML * tempmsg = static_cast<ApplyJointEffortRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ApplyJointEffortResponse::ID:
            {
                ApplyJointEffortResponseNML * tempmsg = static_cast<ApplyJointEffortResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ApplyJointEffort::ID:
            {
                ApplyJointEffortNML * tempmsg = static_cast<ApplyJointEffortNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case BodyRequestRequest::ID:
            {
                BodyRequestRequestNML * tempmsg = static_cast<BodyRequestRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case BodyRequestResponse::ID:
            {
                BodyRequestResponseNML * tempmsg = static_cast<BodyRequestResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case BodyRequest::ID:
            {
                BodyRequestNML * tempmsg = static_cast<BodyRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DeleteModelRequest::ID:
            {
                DeleteModelRequestNML * tempmsg = static_cast<DeleteModelRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DeleteModelResponse::ID:
            {
                DeleteModelResponseNML * tempmsg = static_cast<DeleteModelResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DeleteModel::ID:
            {
                DeleteModelNML * tempmsg = static_cast<DeleteModelNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetJointPropertiesRequest::ID:
            {
                GetJointPropertiesRequestNML * tempmsg = static_cast<GetJointPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetJointPropertiesResponse::ID:
            {
                GetJointPropertiesResponseNML * tempmsg = static_cast<GetJointPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetJointProperties::ID:
            {
                GetJointPropertiesNML * tempmsg = static_cast<GetJointPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetLinkPropertiesRequest::ID:
            {
                GetLinkPropertiesRequestNML * tempmsg = static_cast<GetLinkPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetLinkPropertiesResponse::ID:
            {
                GetLinkPropertiesResponseNML * tempmsg = static_cast<GetLinkPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetLinkProperties::ID:
            {
                GetLinkPropertiesNML * tempmsg = static_cast<GetLinkPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetLinkStateRequest::ID:
            {
                GetLinkStateRequestNML * tempmsg = static_cast<GetLinkStateRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetLinkStateResponse::ID:
            {
                GetLinkStateResponseNML * tempmsg = static_cast<GetLinkStateResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetLinkState::ID:
            {
                GetLinkStateNML * tempmsg = static_cast<GetLinkStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetModelPropertiesRequest::ID:
            {
                GetModelPropertiesRequestNML * tempmsg = static_cast<GetModelPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetModelPropertiesResponse::ID:
            {
                GetModelPropertiesResponseNML * tempmsg = static_cast<GetModelPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetModelProperties::ID:
            {
                GetModelPropertiesNML * tempmsg = static_cast<GetModelPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetModelStateRequest::ID:
            {
                GetModelStateRequestNML * tempmsg = static_cast<GetModelStateRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetModelStateResponse::ID:
            {
                GetModelStateResponseNML * tempmsg = static_cast<GetModelStateResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetModelState::ID:
            {
                GetModelStateNML * tempmsg = static_cast<GetModelStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPhysicsPropertiesRequest::ID:
            {
                GetPhysicsPropertiesRequestNML * tempmsg = static_cast<GetPhysicsPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPhysicsPropertiesResponse::ID:
            {
                GetPhysicsPropertiesResponseNML * tempmsg = static_cast<GetPhysicsPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetPhysicsProperties::ID:
            {
                GetPhysicsPropertiesNML * tempmsg = static_cast<GetPhysicsPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetWorldPropertiesRequest::ID:
            {
                GetWorldPropertiesRequestNML * tempmsg = static_cast<GetWorldPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetWorldPropertiesResponse::ID:
            {
                GetWorldPropertiesResponseNML * tempmsg = static_cast<GetWorldPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GetWorldProperties::ID:
            {
                GetWorldPropertiesNML * tempmsg = static_cast<GetWorldPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointRequestRequest::ID:
            {
                JointRequestRequestNML * tempmsg = static_cast<JointRequestRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointRequestResponse::ID:
            {
                JointRequestResponseNML * tempmsg = static_cast<JointRequestResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointRequest::ID:
            {
                JointRequestNML * tempmsg = static_cast<JointRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetJointPropertiesRequest::ID:
            {
                SetJointPropertiesRequestNML * tempmsg = static_cast<SetJointPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetJointPropertiesResponse::ID:
            {
                SetJointPropertiesResponseNML * tempmsg = static_cast<SetJointPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetJointProperties::ID:
            {
                SetJointPropertiesNML * tempmsg = static_cast<SetJointPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetJointTrajectoryRequest::ID:
            {
                SetJointTrajectoryRequestNML * tempmsg = static_cast<SetJointTrajectoryRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetJointTrajectoryResponse::ID:
            {
                SetJointTrajectoryResponseNML * tempmsg = static_cast<SetJointTrajectoryResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetJointTrajectory::ID:
            {
                SetJointTrajectoryNML * tempmsg = static_cast<SetJointTrajectoryNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetLinkPropertiesRequest::ID:
            {
                SetLinkPropertiesRequestNML * tempmsg = static_cast<SetLinkPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetLinkPropertiesResponse::ID:
            {
                SetLinkPropertiesResponseNML * tempmsg = static_cast<SetLinkPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetLinkProperties::ID:
            {
                SetLinkPropertiesNML * tempmsg = static_cast<SetLinkPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetLinkStateRequest::ID:
            {
                SetLinkStateRequestNML * tempmsg = static_cast<SetLinkStateRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetLinkStateResponse::ID:
            {
                SetLinkStateResponseNML * tempmsg = static_cast<SetLinkStateResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetLinkState::ID:
            {
                SetLinkStateNML * tempmsg = static_cast<SetLinkStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetModelConfigurationRequest::ID:
            {
                SetModelConfigurationRequestNML * tempmsg = static_cast<SetModelConfigurationRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetModelConfigurationResponse::ID:
            {
                SetModelConfigurationResponseNML * tempmsg = static_cast<SetModelConfigurationResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetModelConfiguration::ID:
            {
                SetModelConfigurationNML * tempmsg = static_cast<SetModelConfigurationNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetModelStateRequest::ID:
            {
                SetModelStateRequestNML * tempmsg = static_cast<SetModelStateRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetModelStateResponse::ID:
            {
                SetModelStateResponseNML * tempmsg = static_cast<SetModelStateResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetModelState::ID:
            {
                SetModelStateNML * tempmsg = static_cast<SetModelStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetPhysicsPropertiesRequest::ID:
            {
                SetPhysicsPropertiesRequestNML * tempmsg = static_cast<SetPhysicsPropertiesRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetPhysicsPropertiesResponse::ID:
            {
                SetPhysicsPropertiesResponseNML * tempmsg = static_cast<SetPhysicsPropertiesResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SetPhysicsProperties::ID:
            {
                SetPhysicsPropertiesNML * tempmsg = static_cast<SetPhysicsPropertiesNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SpawnModelRequest::ID:
            {
                SpawnModelRequestNML * tempmsg = static_cast<SpawnModelRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SpawnModelResponse::ID:
            {
                SpawnModelResponseNML * tempmsg = static_cast<SpawnModelResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SpawnModel::ID:
            {
                SpawnModelNML * tempmsg = static_cast<SpawnModelNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case ContactState::ID:
            {
                ContactStateNML & tempDst = static_cast<ContactStateNML&>(dst);
                Message<ContactState > & tempSrc = static_cast<Message<ContactState>&>(src);

                if (tempSrc.version() != ContactState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ContactState: " << __FILE__ << " expected: " 
                             << ContactState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ContactState: " << __FILE__ << " expected: " 
                         << ContactState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ContactsState::ID:
            {
                ContactsStateNML & tempDst = static_cast<ContactsStateNML&>(dst);
                Message<ContactsState > & tempSrc = static_cast<Message<ContactsState>&>(src);

                if (tempSrc.version() != ContactsState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ContactsState: " << __FILE__ << " expected: " 
                             << ContactsState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ContactsState: " << __FILE__ << " expected: " 
                         << ContactsState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LinkState::ID:
            {
                LinkStateNML & tempDst = static_cast<LinkStateNML&>(dst);
                Message<LinkState > & tempSrc = static_cast<Message<LinkState>&>(src);

                if (tempSrc.version() != LinkState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LinkState: " << __FILE__ << " expected: " 
                             << LinkState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LinkState: " << __FILE__ << " expected: " 
                         << LinkState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LinkStates::ID:
            {
                LinkStatesNML & tempDst = static_cast<LinkStatesNML&>(dst);
                Message<LinkStates > & tempSrc = static_cast<Message<LinkStates>&>(src);

                if (tempSrc.version() != LinkStates::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LinkStates: " << __FILE__ << " expected: " 
                             << LinkStates::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LinkStates: " << __FILE__ << " expected: " 
                         << LinkStates::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ModelState::ID:
            {
                ModelStateNML & tempDst = static_cast<ModelStateNML&>(dst);
                Message<ModelState > & tempSrc = static_cast<Message<ModelState>&>(src);

                if (tempSrc.version() != ModelState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ModelState: " << __FILE__ << " expected: " 
                             << ModelState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ModelState: " << __FILE__ << " expected: " 
                         << ModelState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ModelStates::ID:
            {
                ModelStatesNML & tempDst = static_cast<ModelStatesNML&>(dst);
                Message<ModelStates > & tempSrc = static_cast<Message<ModelStates>&>(src);

                if (tempSrc.version() != ModelStates::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ModelStates: " << __FILE__ << " expected: " 
                             << ModelStates::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ModelStates: " << __FILE__ << " expected: " 
                         << ModelStates::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ODEJointProperties::ID:
            {
                ODEJointPropertiesNML & tempDst = static_cast<ODEJointPropertiesNML&>(dst);
                Message<ODEJointProperties > & tempSrc = static_cast<Message<ODEJointProperties>&>(src);

                if (tempSrc.version() != ODEJointProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ODEJointProperties: " << __FILE__ << " expected: " 
                             << ODEJointProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ODEJointProperties: " << __FILE__ << " expected: " 
                         << ODEJointProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ODEPhysics::ID:
            {
                ODEPhysicsNML & tempDst = static_cast<ODEPhysicsNML&>(dst);
                Message<ODEPhysics > & tempSrc = static_cast<Message<ODEPhysics>&>(src);

                if (tempSrc.version() != ODEPhysics::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ODEPhysics: " << __FILE__ << " expected: " 
                             << ODEPhysics::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ODEPhysics: " << __FILE__ << " expected: " 
                         << ODEPhysics::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case WorldState::ID:
            {
                WorldStateNML & tempDst = static_cast<WorldStateNML&>(dst);
                Message<WorldState > & tempSrc = static_cast<Message<WorldState>&>(src);

                if (tempSrc.version() != WorldState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of WorldState: " << __FILE__ << " expected: " 
                             << WorldState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of WorldState: " << __FILE__ << " expected: " 
                         << WorldState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ApplyBodyWrenchRequest::ID:
            {
                ApplyBodyWrenchRequestNML & tempDst = static_cast<ApplyBodyWrenchRequestNML&>(dst);
                Message<ApplyBodyWrenchRequest > & tempSrc = static_cast<Message<ApplyBodyWrenchRequest>&>(src);

                if (tempSrc.version() != ApplyBodyWrenchRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ApplyBodyWrenchRequest: " << __FILE__ << " expected: " 
                             << ApplyBodyWrenchRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ApplyBodyWrenchRequest: " << __FILE__ << " expected: " 
                         << ApplyBodyWrenchRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ApplyBodyWrenchResponse::ID:
            {
                ApplyBodyWrenchResponseNML & tempDst = static_cast<ApplyBodyWrenchResponseNML&>(dst);
                Message<ApplyBodyWrenchResponse > & tempSrc = static_cast<Message<ApplyBodyWrenchResponse>&>(src);

                if (tempSrc.version() != ApplyBodyWrenchResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ApplyBodyWrenchResponse: " << __FILE__ << " expected: " 
                             << ApplyBodyWrenchResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ApplyBodyWrenchResponse: " << __FILE__ << " expected: " 
                         << ApplyBodyWrenchResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ApplyBodyWrench::ID:
            {
                ApplyBodyWrenchNML & tempDst = static_cast<ApplyBodyWrenchNML&>(dst);
                Message<ApplyBodyWrench > & tempSrc = static_cast<Message<ApplyBodyWrench>&>(src);

                if (tempSrc.version() != ApplyBodyWrench::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ApplyBodyWrench: " << __FILE__ << " expected: " 
                             << ApplyBodyWrench::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ApplyBodyWrench: " << __FILE__ << " expected: " 
                         << ApplyBodyWrench::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ApplyJointEffortRequest::ID:
            {
                ApplyJointEffortRequestNML & tempDst = static_cast<ApplyJointEffortRequestNML&>(dst);
                Message<ApplyJointEffortRequest > & tempSrc = static_cast<Message<ApplyJointEffortRequest>&>(src);

                if (tempSrc.version() != ApplyJointEffortRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ApplyJointEffortRequest: " << __FILE__ << " expected: " 
                             << ApplyJointEffortRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ApplyJointEffortRequest: " << __FILE__ << " expected: " 
                         << ApplyJointEffortRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ApplyJointEffortResponse::ID:
            {
                ApplyJointEffortResponseNML & tempDst = static_cast<ApplyJointEffortResponseNML&>(dst);
                Message<ApplyJointEffortResponse > & tempSrc = static_cast<Message<ApplyJointEffortResponse>&>(src);

                if (tempSrc.version() != ApplyJointEffortResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ApplyJointEffortResponse: " << __FILE__ << " expected: " 
                             << ApplyJointEffortResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ApplyJointEffortResponse: " << __FILE__ << " expected: " 
                         << ApplyJointEffortResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ApplyJointEffort::ID:
            {
                ApplyJointEffortNML & tempDst = static_cast<ApplyJointEffortNML&>(dst);
                Message<ApplyJointEffort > & tempSrc = static_cast<Message<ApplyJointEffort>&>(src);

                if (tempSrc.version() != ApplyJointEffort::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ApplyJointEffort: " << __FILE__ << " expected: " 
                             << ApplyJointEffort::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ApplyJointEffort: " << __FILE__ << " expected: " 
                         << ApplyJointEffort::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case BodyRequestRequest::ID:
            {
                BodyRequestRequestNML & tempDst = static_cast<BodyRequestRequestNML&>(dst);
                Message<BodyRequestRequest > & tempSrc = static_cast<Message<BodyRequestRequest>&>(src);

                if (tempSrc.version() != BodyRequestRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of BodyRequestRequest: " << __FILE__ << " expected: " 
                             << BodyRequestRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of BodyRequestRequest: " << __FILE__ << " expected: " 
                         << BodyRequestRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case BodyRequestResponse::ID:
            {
                BodyRequestResponseNML & tempDst = static_cast<BodyRequestResponseNML&>(dst);
                Message<BodyRequestResponse > & tempSrc = static_cast<Message<BodyRequestResponse>&>(src);

                if (tempSrc.version() != BodyRequestResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of BodyRequestResponse: " << __FILE__ << " expected: " 
                             << BodyRequestResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of BodyRequestResponse: " << __FILE__ << " expected: " 
                         << BodyRequestResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case BodyRequest::ID:
            {
                BodyRequestNML & tempDst = static_cast<BodyRequestNML&>(dst);
                Message<BodyRequest > & tempSrc = static_cast<Message<BodyRequest>&>(src);

                if (tempSrc.version() != BodyRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of BodyRequest: " << __FILE__ << " expected: " 
                             << BodyRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of BodyRequest: " << __FILE__ << " expected: " 
                         << BodyRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DeleteModelRequest::ID:
            {
                DeleteModelRequestNML & tempDst = static_cast<DeleteModelRequestNML&>(dst);
                Message<DeleteModelRequest > & tempSrc = static_cast<Message<DeleteModelRequest>&>(src);

                if (tempSrc.version() != DeleteModelRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DeleteModelRequest: " << __FILE__ << " expected: " 
                             << DeleteModelRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DeleteModelRequest: " << __FILE__ << " expected: " 
                         << DeleteModelRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DeleteModelResponse::ID:
            {
                DeleteModelResponseNML & tempDst = static_cast<DeleteModelResponseNML&>(dst);
                Message<DeleteModelResponse > & tempSrc = static_cast<Message<DeleteModelResponse>&>(src);

                if (tempSrc.version() != DeleteModelResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DeleteModelResponse: " << __FILE__ << " expected: " 
                             << DeleteModelResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DeleteModelResponse: " << __FILE__ << " expected: " 
                         << DeleteModelResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DeleteModel::ID:
            {
                DeleteModelNML & tempDst = static_cast<DeleteModelNML&>(dst);
                Message<DeleteModel > & tempSrc = static_cast<Message<DeleteModel>&>(src);

                if (tempSrc.version() != DeleteModel::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DeleteModel: " << __FILE__ << " expected: " 
                             << DeleteModel::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DeleteModel: " << __FILE__ << " expected: " 
                         << DeleteModel::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetJointPropertiesRequest::ID:
            {
                GetJointPropertiesRequestNML & tempDst = static_cast<GetJointPropertiesRequestNML&>(dst);
                Message<GetJointPropertiesRequest > & tempSrc = static_cast<Message<GetJointPropertiesRequest>&>(src);

                if (tempSrc.version() != GetJointPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetJointPropertiesRequest: " << __FILE__ << " expected: " 
                             << GetJointPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetJointPropertiesRequest: " << __FILE__ << " expected: " 
                         << GetJointPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetJointPropertiesResponse::ID:
            {
                GetJointPropertiesResponseNML & tempDst = static_cast<GetJointPropertiesResponseNML&>(dst);
                Message<GetJointPropertiesResponse > & tempSrc = static_cast<Message<GetJointPropertiesResponse>&>(src);

                if (tempSrc.version() != GetJointPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetJointPropertiesResponse: " << __FILE__ << " expected: " 
                             << GetJointPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetJointPropertiesResponse: " << __FILE__ << " expected: " 
                         << GetJointPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetJointProperties::ID:
            {
                GetJointPropertiesNML & tempDst = static_cast<GetJointPropertiesNML&>(dst);
                Message<GetJointProperties > & tempSrc = static_cast<Message<GetJointProperties>&>(src);

                if (tempSrc.version() != GetJointProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetJointProperties: " << __FILE__ << " expected: " 
                             << GetJointProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetJointProperties: " << __FILE__ << " expected: " 
                         << GetJointProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetLinkPropertiesRequest::ID:
            {
                GetLinkPropertiesRequestNML & tempDst = static_cast<GetLinkPropertiesRequestNML&>(dst);
                Message<GetLinkPropertiesRequest > & tempSrc = static_cast<Message<GetLinkPropertiesRequest>&>(src);

                if (tempSrc.version() != GetLinkPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetLinkPropertiesRequest: " << __FILE__ << " expected: " 
                             << GetLinkPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetLinkPropertiesRequest: " << __FILE__ << " expected: " 
                         << GetLinkPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetLinkPropertiesResponse::ID:
            {
                GetLinkPropertiesResponseNML & tempDst = static_cast<GetLinkPropertiesResponseNML&>(dst);
                Message<GetLinkPropertiesResponse > & tempSrc = static_cast<Message<GetLinkPropertiesResponse>&>(src);

                if (tempSrc.version() != GetLinkPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetLinkPropertiesResponse: " << __FILE__ << " expected: " 
                             << GetLinkPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetLinkPropertiesResponse: " << __FILE__ << " expected: " 
                         << GetLinkPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetLinkProperties::ID:
            {
                GetLinkPropertiesNML & tempDst = static_cast<GetLinkPropertiesNML&>(dst);
                Message<GetLinkProperties > & tempSrc = static_cast<Message<GetLinkProperties>&>(src);

                if (tempSrc.version() != GetLinkProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetLinkProperties: " << __FILE__ << " expected: " 
                             << GetLinkProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetLinkProperties: " << __FILE__ << " expected: " 
                         << GetLinkProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetLinkStateRequest::ID:
            {
                GetLinkStateRequestNML & tempDst = static_cast<GetLinkStateRequestNML&>(dst);
                Message<GetLinkStateRequest > & tempSrc = static_cast<Message<GetLinkStateRequest>&>(src);

                if (tempSrc.version() != GetLinkStateRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetLinkStateRequest: " << __FILE__ << " expected: " 
                             << GetLinkStateRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetLinkStateRequest: " << __FILE__ << " expected: " 
                         << GetLinkStateRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetLinkStateResponse::ID:
            {
                GetLinkStateResponseNML & tempDst = static_cast<GetLinkStateResponseNML&>(dst);
                Message<GetLinkStateResponse > & tempSrc = static_cast<Message<GetLinkStateResponse>&>(src);

                if (tempSrc.version() != GetLinkStateResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetLinkStateResponse: " << __FILE__ << " expected: " 
                             << GetLinkStateResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetLinkStateResponse: " << __FILE__ << " expected: " 
                         << GetLinkStateResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetLinkState::ID:
            {
                GetLinkStateNML & tempDst = static_cast<GetLinkStateNML&>(dst);
                Message<GetLinkState > & tempSrc = static_cast<Message<GetLinkState>&>(src);

                if (tempSrc.version() != GetLinkState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetLinkState: " << __FILE__ << " expected: " 
                             << GetLinkState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetLinkState: " << __FILE__ << " expected: " 
                         << GetLinkState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetModelPropertiesRequest::ID:
            {
                GetModelPropertiesRequestNML & tempDst = static_cast<GetModelPropertiesRequestNML&>(dst);
                Message<GetModelPropertiesRequest > & tempSrc = static_cast<Message<GetModelPropertiesRequest>&>(src);

                if (tempSrc.version() != GetModelPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetModelPropertiesRequest: " << __FILE__ << " expected: " 
                             << GetModelPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetModelPropertiesRequest: " << __FILE__ << " expected: " 
                         << GetModelPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetModelPropertiesResponse::ID:
            {
                GetModelPropertiesResponseNML & tempDst = static_cast<GetModelPropertiesResponseNML&>(dst);
                Message<GetModelPropertiesResponse > & tempSrc = static_cast<Message<GetModelPropertiesResponse>&>(src);

                if (tempSrc.version() != GetModelPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetModelPropertiesResponse: " << __FILE__ << " expected: " 
                             << GetModelPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetModelPropertiesResponse: " << __FILE__ << " expected: " 
                         << GetModelPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetModelProperties::ID:
            {
                GetModelPropertiesNML & tempDst = static_cast<GetModelPropertiesNML&>(dst);
                Message<GetModelProperties > & tempSrc = static_cast<Message<GetModelProperties>&>(src);

                if (tempSrc.version() != GetModelProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetModelProperties: " << __FILE__ << " expected: " 
                             << GetModelProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetModelProperties: " << __FILE__ << " expected: " 
                         << GetModelProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetModelStateRequest::ID:
            {
                GetModelStateRequestNML & tempDst = static_cast<GetModelStateRequestNML&>(dst);
                Message<GetModelStateRequest > & tempSrc = static_cast<Message<GetModelStateRequest>&>(src);

                if (tempSrc.version() != GetModelStateRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetModelStateRequest: " << __FILE__ << " expected: " 
                             << GetModelStateRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetModelStateRequest: " << __FILE__ << " expected: " 
                         << GetModelStateRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetModelStateResponse::ID:
            {
                GetModelStateResponseNML & tempDst = static_cast<GetModelStateResponseNML&>(dst);
                Message<GetModelStateResponse > & tempSrc = static_cast<Message<GetModelStateResponse>&>(src);

                if (tempSrc.version() != GetModelStateResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetModelStateResponse: " << __FILE__ << " expected: " 
                             << GetModelStateResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetModelStateResponse: " << __FILE__ << " expected: " 
                         << GetModelStateResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetModelState::ID:
            {
                GetModelStateNML & tempDst = static_cast<GetModelStateNML&>(dst);
                Message<GetModelState > & tempSrc = static_cast<Message<GetModelState>&>(src);

                if (tempSrc.version() != GetModelState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetModelState: " << __FILE__ << " expected: " 
                             << GetModelState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetModelState: " << __FILE__ << " expected: " 
                         << GetModelState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPhysicsPropertiesRequest::ID:
            {
                GetPhysicsPropertiesRequestNML & tempDst = static_cast<GetPhysicsPropertiesRequestNML&>(dst);
                Message<GetPhysicsPropertiesRequest > & tempSrc = static_cast<Message<GetPhysicsPropertiesRequest>&>(src);

                if (tempSrc.version() != GetPhysicsPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPhysicsPropertiesRequest: " << __FILE__ << " expected: " 
                             << GetPhysicsPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPhysicsPropertiesRequest: " << __FILE__ << " expected: " 
                         << GetPhysicsPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPhysicsPropertiesResponse::ID:
            {
                GetPhysicsPropertiesResponseNML & tempDst = static_cast<GetPhysicsPropertiesResponseNML&>(dst);
                Message<GetPhysicsPropertiesResponse > & tempSrc = static_cast<Message<GetPhysicsPropertiesResponse>&>(src);

                if (tempSrc.version() != GetPhysicsPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPhysicsPropertiesResponse: " << __FILE__ << " expected: " 
                             << GetPhysicsPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPhysicsPropertiesResponse: " << __FILE__ << " expected: " 
                         << GetPhysicsPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetPhysicsProperties::ID:
            {
                GetPhysicsPropertiesNML & tempDst = static_cast<GetPhysicsPropertiesNML&>(dst);
                Message<GetPhysicsProperties > & tempSrc = static_cast<Message<GetPhysicsProperties>&>(src);

                if (tempSrc.version() != GetPhysicsProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetPhysicsProperties: " << __FILE__ << " expected: " 
                             << GetPhysicsProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetPhysicsProperties: " << __FILE__ << " expected: " 
                         << GetPhysicsProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetWorldPropertiesRequest::ID:
            {
                GetWorldPropertiesRequestNML & tempDst = static_cast<GetWorldPropertiesRequestNML&>(dst);
                Message<GetWorldPropertiesRequest > & tempSrc = static_cast<Message<GetWorldPropertiesRequest>&>(src);

                if (tempSrc.version() != GetWorldPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetWorldPropertiesRequest: " << __FILE__ << " expected: " 
                             << GetWorldPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetWorldPropertiesRequest: " << __FILE__ << " expected: " 
                         << GetWorldPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetWorldPropertiesResponse::ID:
            {
                GetWorldPropertiesResponseNML & tempDst = static_cast<GetWorldPropertiesResponseNML&>(dst);
                Message<GetWorldPropertiesResponse > & tempSrc = static_cast<Message<GetWorldPropertiesResponse>&>(src);

                if (tempSrc.version() != GetWorldPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetWorldPropertiesResponse: " << __FILE__ << " expected: " 
                             << GetWorldPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetWorldPropertiesResponse: " << __FILE__ << " expected: " 
                         << GetWorldPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GetWorldProperties::ID:
            {
                GetWorldPropertiesNML & tempDst = static_cast<GetWorldPropertiesNML&>(dst);
                Message<GetWorldProperties > & tempSrc = static_cast<Message<GetWorldProperties>&>(src);

                if (tempSrc.version() != GetWorldProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GetWorldProperties: " << __FILE__ << " expected: " 
                             << GetWorldProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GetWorldProperties: " << __FILE__ << " expected: " 
                         << GetWorldProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointRequestRequest::ID:
            {
                JointRequestRequestNML & tempDst = static_cast<JointRequestRequestNML&>(dst);
                Message<JointRequestRequest > & tempSrc = static_cast<Message<JointRequestRequest>&>(src);

                if (tempSrc.version() != JointRequestRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointRequestRequest: " << __FILE__ << " expected: " 
                             << JointRequestRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointRequestRequest: " << __FILE__ << " expected: " 
                         << JointRequestRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointRequestResponse::ID:
            {
                JointRequestResponseNML & tempDst = static_cast<JointRequestResponseNML&>(dst);
                Message<JointRequestResponse > & tempSrc = static_cast<Message<JointRequestResponse>&>(src);

                if (tempSrc.version() != JointRequestResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointRequestResponse: " << __FILE__ << " expected: " 
                             << JointRequestResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointRequestResponse: " << __FILE__ << " expected: " 
                         << JointRequestResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointRequest::ID:
            {
                JointRequestNML & tempDst = static_cast<JointRequestNML&>(dst);
                Message<JointRequest > & tempSrc = static_cast<Message<JointRequest>&>(src);

                if (tempSrc.version() != JointRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointRequest: " << __FILE__ << " expected: " 
                             << JointRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointRequest: " << __FILE__ << " expected: " 
                         << JointRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetJointPropertiesRequest::ID:
            {
                SetJointPropertiesRequestNML & tempDst = static_cast<SetJointPropertiesRequestNML&>(dst);
                Message<SetJointPropertiesRequest > & tempSrc = static_cast<Message<SetJointPropertiesRequest>&>(src);

                if (tempSrc.version() != SetJointPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetJointPropertiesRequest: " << __FILE__ << " expected: " 
                             << SetJointPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetJointPropertiesRequest: " << __FILE__ << " expected: " 
                         << SetJointPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetJointPropertiesResponse::ID:
            {
                SetJointPropertiesResponseNML & tempDst = static_cast<SetJointPropertiesResponseNML&>(dst);
                Message<SetJointPropertiesResponse > & tempSrc = static_cast<Message<SetJointPropertiesResponse>&>(src);

                if (tempSrc.version() != SetJointPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetJointPropertiesResponse: " << __FILE__ << " expected: " 
                             << SetJointPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetJointPropertiesResponse: " << __FILE__ << " expected: " 
                         << SetJointPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetJointProperties::ID:
            {
                SetJointPropertiesNML & tempDst = static_cast<SetJointPropertiesNML&>(dst);
                Message<SetJointProperties > & tempSrc = static_cast<Message<SetJointProperties>&>(src);

                if (tempSrc.version() != SetJointProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetJointProperties: " << __FILE__ << " expected: " 
                             << SetJointProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetJointProperties: " << __FILE__ << " expected: " 
                         << SetJointProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetJointTrajectoryRequest::ID:
            {
                SetJointTrajectoryRequestNML & tempDst = static_cast<SetJointTrajectoryRequestNML&>(dst);
                Message<SetJointTrajectoryRequest > & tempSrc = static_cast<Message<SetJointTrajectoryRequest>&>(src);

                if (tempSrc.version() != SetJointTrajectoryRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetJointTrajectoryRequest: " << __FILE__ << " expected: " 
                             << SetJointTrajectoryRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetJointTrajectoryRequest: " << __FILE__ << " expected: " 
                         << SetJointTrajectoryRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetJointTrajectoryResponse::ID:
            {
                SetJointTrajectoryResponseNML & tempDst = static_cast<SetJointTrajectoryResponseNML&>(dst);
                Message<SetJointTrajectoryResponse > & tempSrc = static_cast<Message<SetJointTrajectoryResponse>&>(src);

                if (tempSrc.version() != SetJointTrajectoryResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetJointTrajectoryResponse: " << __FILE__ << " expected: " 
                             << SetJointTrajectoryResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetJointTrajectoryResponse: " << __FILE__ << " expected: " 
                         << SetJointTrajectoryResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetJointTrajectory::ID:
            {
                SetJointTrajectoryNML & tempDst = static_cast<SetJointTrajectoryNML&>(dst);
                Message<SetJointTrajectory > & tempSrc = static_cast<Message<SetJointTrajectory>&>(src);

                if (tempSrc.version() != SetJointTrajectory::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetJointTrajectory: " << __FILE__ << " expected: " 
                             << SetJointTrajectory::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetJointTrajectory: " << __FILE__ << " expected: " 
                         << SetJointTrajectory::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetLinkPropertiesRequest::ID:
            {
                SetLinkPropertiesRequestNML & tempDst = static_cast<SetLinkPropertiesRequestNML&>(dst);
                Message<SetLinkPropertiesRequest > & tempSrc = static_cast<Message<SetLinkPropertiesRequest>&>(src);

                if (tempSrc.version() != SetLinkPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetLinkPropertiesRequest: " << __FILE__ << " expected: " 
                             << SetLinkPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetLinkPropertiesRequest: " << __FILE__ << " expected: " 
                         << SetLinkPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetLinkPropertiesResponse::ID:
            {
                SetLinkPropertiesResponseNML & tempDst = static_cast<SetLinkPropertiesResponseNML&>(dst);
                Message<SetLinkPropertiesResponse > & tempSrc = static_cast<Message<SetLinkPropertiesResponse>&>(src);

                if (tempSrc.version() != SetLinkPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetLinkPropertiesResponse: " << __FILE__ << " expected: " 
                             << SetLinkPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetLinkPropertiesResponse: " << __FILE__ << " expected: " 
                         << SetLinkPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetLinkProperties::ID:
            {
                SetLinkPropertiesNML & tempDst = static_cast<SetLinkPropertiesNML&>(dst);
                Message<SetLinkProperties > & tempSrc = static_cast<Message<SetLinkProperties>&>(src);

                if (tempSrc.version() != SetLinkProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetLinkProperties: " << __FILE__ << " expected: " 
                             << SetLinkProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetLinkProperties: " << __FILE__ << " expected: " 
                         << SetLinkProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetLinkStateRequest::ID:
            {
                SetLinkStateRequestNML & tempDst = static_cast<SetLinkStateRequestNML&>(dst);
                Message<SetLinkStateRequest > & tempSrc = static_cast<Message<SetLinkStateRequest>&>(src);

                if (tempSrc.version() != SetLinkStateRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetLinkStateRequest: " << __FILE__ << " expected: " 
                             << SetLinkStateRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetLinkStateRequest: " << __FILE__ << " expected: " 
                         << SetLinkStateRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetLinkStateResponse::ID:
            {
                SetLinkStateResponseNML & tempDst = static_cast<SetLinkStateResponseNML&>(dst);
                Message<SetLinkStateResponse > & tempSrc = static_cast<Message<SetLinkStateResponse>&>(src);

                if (tempSrc.version() != SetLinkStateResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetLinkStateResponse: " << __FILE__ << " expected: " 
                             << SetLinkStateResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetLinkStateResponse: " << __FILE__ << " expected: " 
                         << SetLinkStateResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetLinkState::ID:
            {
                SetLinkStateNML & tempDst = static_cast<SetLinkStateNML&>(dst);
                Message<SetLinkState > & tempSrc = static_cast<Message<SetLinkState>&>(src);

                if (tempSrc.version() != SetLinkState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetLinkState: " << __FILE__ << " expected: " 
                             << SetLinkState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetLinkState: " << __FILE__ << " expected: " 
                         << SetLinkState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetModelConfigurationRequest::ID:
            {
                SetModelConfigurationRequestNML & tempDst = static_cast<SetModelConfigurationRequestNML&>(dst);
                Message<SetModelConfigurationRequest > & tempSrc = static_cast<Message<SetModelConfigurationRequest>&>(src);

                if (tempSrc.version() != SetModelConfigurationRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetModelConfigurationRequest: " << __FILE__ << " expected: " 
                             << SetModelConfigurationRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetModelConfigurationRequest: " << __FILE__ << " expected: " 
                         << SetModelConfigurationRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetModelConfigurationResponse::ID:
            {
                SetModelConfigurationResponseNML & tempDst = static_cast<SetModelConfigurationResponseNML&>(dst);
                Message<SetModelConfigurationResponse > & tempSrc = static_cast<Message<SetModelConfigurationResponse>&>(src);

                if (tempSrc.version() != SetModelConfigurationResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetModelConfigurationResponse: " << __FILE__ << " expected: " 
                             << SetModelConfigurationResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetModelConfigurationResponse: " << __FILE__ << " expected: " 
                         << SetModelConfigurationResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetModelConfiguration::ID:
            {
                SetModelConfigurationNML & tempDst = static_cast<SetModelConfigurationNML&>(dst);
                Message<SetModelConfiguration > & tempSrc = static_cast<Message<SetModelConfiguration>&>(src);

                if (tempSrc.version() != SetModelConfiguration::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetModelConfiguration: " << __FILE__ << " expected: " 
                             << SetModelConfiguration::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetModelConfiguration: " << __FILE__ << " expected: " 
                         << SetModelConfiguration::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetModelStateRequest::ID:
            {
                SetModelStateRequestNML & tempDst = static_cast<SetModelStateRequestNML&>(dst);
                Message<SetModelStateRequest > & tempSrc = static_cast<Message<SetModelStateRequest>&>(src);

                if (tempSrc.version() != SetModelStateRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetModelStateRequest: " << __FILE__ << " expected: " 
                             << SetModelStateRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetModelStateRequest: " << __FILE__ << " expected: " 
                         << SetModelStateRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetModelStateResponse::ID:
            {
                SetModelStateResponseNML & tempDst = static_cast<SetModelStateResponseNML&>(dst);
                Message<SetModelStateResponse > & tempSrc = static_cast<Message<SetModelStateResponse>&>(src);

                if (tempSrc.version() != SetModelStateResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetModelStateResponse: " << __FILE__ << " expected: " 
                             << SetModelStateResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetModelStateResponse: " << __FILE__ << " expected: " 
                         << SetModelStateResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetModelState::ID:
            {
                SetModelStateNML & tempDst = static_cast<SetModelStateNML&>(dst);
                Message<SetModelState > & tempSrc = static_cast<Message<SetModelState>&>(src);

                if (tempSrc.version() != SetModelState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetModelState: " << __FILE__ << " expected: " 
                             << SetModelState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetModelState: " << __FILE__ << " expected: " 
                         << SetModelState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetPhysicsPropertiesRequest::ID:
            {
                SetPhysicsPropertiesRequestNML & tempDst = static_cast<SetPhysicsPropertiesRequestNML&>(dst);
                Message<SetPhysicsPropertiesRequest > & tempSrc = static_cast<Message<SetPhysicsPropertiesRequest>&>(src);

                if (tempSrc.version() != SetPhysicsPropertiesRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetPhysicsPropertiesRequest: " << __FILE__ << " expected: " 
                             << SetPhysicsPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetPhysicsPropertiesRequest: " << __FILE__ << " expected: " 
                         << SetPhysicsPropertiesRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetPhysicsPropertiesResponse::ID:
            {
                SetPhysicsPropertiesResponseNML & tempDst = static_cast<SetPhysicsPropertiesResponseNML&>(dst);
                Message<SetPhysicsPropertiesResponse > & tempSrc = static_cast<Message<SetPhysicsPropertiesResponse>&>(src);

                if (tempSrc.version() != SetPhysicsPropertiesResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetPhysicsPropertiesResponse: " << __FILE__ << " expected: " 
                             << SetPhysicsPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetPhysicsPropertiesResponse: " << __FILE__ << " expected: " 
                         << SetPhysicsPropertiesResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SetPhysicsProperties::ID:
            {
                SetPhysicsPropertiesNML & tempDst = static_cast<SetPhysicsPropertiesNML&>(dst);
                Message<SetPhysicsProperties > & tempSrc = static_cast<Message<SetPhysicsProperties>&>(src);

                if (tempSrc.version() != SetPhysicsProperties::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SetPhysicsProperties: " << __FILE__ << " expected: " 
                             << SetPhysicsProperties::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SetPhysicsProperties: " << __FILE__ << " expected: " 
                         << SetPhysicsProperties::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SpawnModelRequest::ID:
            {
                SpawnModelRequestNML & tempDst = static_cast<SpawnModelRequestNML&>(dst);
                Message<SpawnModelRequest > & tempSrc = static_cast<Message<SpawnModelRequest>&>(src);

                if (tempSrc.version() != SpawnModelRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SpawnModelRequest: " << __FILE__ << " expected: " 
                             << SpawnModelRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SpawnModelRequest: " << __FILE__ << " expected: " 
                         << SpawnModelRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SpawnModelResponse::ID:
            {
                SpawnModelResponseNML & tempDst = static_cast<SpawnModelResponseNML&>(dst);
                Message<SpawnModelResponse > & tempSrc = static_cast<Message<SpawnModelResponse>&>(src);

                if (tempSrc.version() != SpawnModelResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SpawnModelResponse: " << __FILE__ << " expected: " 
                             << SpawnModelResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SpawnModelResponse: " << __FILE__ << " expected: " 
                         << SpawnModelResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SpawnModel::ID:
            {
                SpawnModelNML & tempDst = static_cast<SpawnModelNML&>(dst);
                Message<SpawnModel > & tempSrc = static_cast<Message<SpawnModel>&>(src);

                if (tempSrc.version() != SpawnModel::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SpawnModel: " << __FILE__ << " expected: " 
                             << SpawnModel::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SpawnModel: " << __FILE__ << " expected: " 
                         << SpawnModel::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case ContactState::ID:
            {
                ContactStateNML & tempSrc = static_cast<ContactStateNML&>(src);
                Message<ContactState > & tempDst = static_cast<Message<ContactState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ContactState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ContactsState::ID:
            {
                ContactsStateNML & tempSrc = static_cast<ContactsStateNML&>(src);
                Message<ContactsState > & tempDst = static_cast<Message<ContactsState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ContactsState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LinkState::ID:
            {
                LinkStateNML & tempSrc = static_cast<LinkStateNML&>(src);
                Message<LinkState > & tempDst = static_cast<Message<LinkState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LinkState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LinkStates::ID:
            {
                LinkStatesNML & tempSrc = static_cast<LinkStatesNML&>(src);
                Message<LinkStates > & tempDst = static_cast<Message<LinkStates>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LinkStates::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ModelState::ID:
            {
                ModelStateNML & tempSrc = static_cast<ModelStateNML&>(src);
                Message<ModelState > & tempDst = static_cast<Message<ModelState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ModelState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ModelStates::ID:
            {
                ModelStatesNML & tempSrc = static_cast<ModelStatesNML&>(src);
                Message<ModelStates > & tempDst = static_cast<Message<ModelStates>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ModelStates::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ODEJointProperties::ID:
            {
                ODEJointPropertiesNML & tempSrc = static_cast<ODEJointPropertiesNML&>(src);
                Message<ODEJointProperties > & tempDst = static_cast<Message<ODEJointProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ODEJointProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ODEPhysics::ID:
            {
                ODEPhysicsNML & tempSrc = static_cast<ODEPhysicsNML&>(src);
                Message<ODEPhysics > & tempDst = static_cast<Message<ODEPhysics>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ODEPhysics::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case WorldState::ID:
            {
                WorldStateNML & tempSrc = static_cast<WorldStateNML&>(src);
                Message<WorldState > & tempDst = static_cast<Message<WorldState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (WorldState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ApplyBodyWrenchRequest::ID:
            {
                ApplyBodyWrenchRequestNML & tempSrc = static_cast<ApplyBodyWrenchRequestNML&>(src);
                Message<ApplyBodyWrenchRequest > & tempDst = static_cast<Message<ApplyBodyWrenchRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ApplyBodyWrenchRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ApplyBodyWrenchResponse::ID:
            {
                ApplyBodyWrenchResponseNML & tempSrc = static_cast<ApplyBodyWrenchResponseNML&>(src);
                Message<ApplyBodyWrenchResponse > & tempDst = static_cast<Message<ApplyBodyWrenchResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ApplyBodyWrenchResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ApplyBodyWrench::ID:
            {
                ApplyBodyWrenchNML & tempSrc = static_cast<ApplyBodyWrenchNML&>(src);
                Message<ApplyBodyWrench > & tempDst = static_cast<Message<ApplyBodyWrench>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ApplyBodyWrench::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ApplyJointEffortRequest::ID:
            {
                ApplyJointEffortRequestNML & tempSrc = static_cast<ApplyJointEffortRequestNML&>(src);
                Message<ApplyJointEffortRequest > & tempDst = static_cast<Message<ApplyJointEffortRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ApplyJointEffortRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ApplyJointEffortResponse::ID:
            {
                ApplyJointEffortResponseNML & tempSrc = static_cast<ApplyJointEffortResponseNML&>(src);
                Message<ApplyJointEffortResponse > & tempDst = static_cast<Message<ApplyJointEffortResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ApplyJointEffortResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ApplyJointEffort::ID:
            {
                ApplyJointEffortNML & tempSrc = static_cast<ApplyJointEffortNML&>(src);
                Message<ApplyJointEffort > & tempDst = static_cast<Message<ApplyJointEffort>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ApplyJointEffort::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case BodyRequestRequest::ID:
            {
                BodyRequestRequestNML & tempSrc = static_cast<BodyRequestRequestNML&>(src);
                Message<BodyRequestRequest > & tempDst = static_cast<Message<BodyRequestRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (BodyRequestRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case BodyRequestResponse::ID:
            {
                BodyRequestResponseNML & tempSrc = static_cast<BodyRequestResponseNML&>(src);
                Message<BodyRequestResponse > & tempDst = static_cast<Message<BodyRequestResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (BodyRequestResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case BodyRequest::ID:
            {
                BodyRequestNML & tempSrc = static_cast<BodyRequestNML&>(src);
                Message<BodyRequest > & tempDst = static_cast<Message<BodyRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (BodyRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DeleteModelRequest::ID:
            {
                DeleteModelRequestNML & tempSrc = static_cast<DeleteModelRequestNML&>(src);
                Message<DeleteModelRequest > & tempDst = static_cast<Message<DeleteModelRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DeleteModelRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DeleteModelResponse::ID:
            {
                DeleteModelResponseNML & tempSrc = static_cast<DeleteModelResponseNML&>(src);
                Message<DeleteModelResponse > & tempDst = static_cast<Message<DeleteModelResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DeleteModelResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DeleteModel::ID:
            {
                DeleteModelNML & tempSrc = static_cast<DeleteModelNML&>(src);
                Message<DeleteModel > & tempDst = static_cast<Message<DeleteModel>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DeleteModel::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetJointPropertiesRequest::ID:
            {
                GetJointPropertiesRequestNML & tempSrc = static_cast<GetJointPropertiesRequestNML&>(src);
                Message<GetJointPropertiesRequest > & tempDst = static_cast<Message<GetJointPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetJointPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetJointPropertiesResponse::ID:
            {
                GetJointPropertiesResponseNML & tempSrc = static_cast<GetJointPropertiesResponseNML&>(src);
                Message<GetJointPropertiesResponse > & tempDst = static_cast<Message<GetJointPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetJointPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetJointProperties::ID:
            {
                GetJointPropertiesNML & tempSrc = static_cast<GetJointPropertiesNML&>(src);
                Message<GetJointProperties > & tempDst = static_cast<Message<GetJointProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetJointProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetLinkPropertiesRequest::ID:
            {
                GetLinkPropertiesRequestNML & tempSrc = static_cast<GetLinkPropertiesRequestNML&>(src);
                Message<GetLinkPropertiesRequest > & tempDst = static_cast<Message<GetLinkPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetLinkPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetLinkPropertiesResponse::ID:
            {
                GetLinkPropertiesResponseNML & tempSrc = static_cast<GetLinkPropertiesResponseNML&>(src);
                Message<GetLinkPropertiesResponse > & tempDst = static_cast<Message<GetLinkPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetLinkPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetLinkProperties::ID:
            {
                GetLinkPropertiesNML & tempSrc = static_cast<GetLinkPropertiesNML&>(src);
                Message<GetLinkProperties > & tempDst = static_cast<Message<GetLinkProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetLinkProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetLinkStateRequest::ID:
            {
                GetLinkStateRequestNML & tempSrc = static_cast<GetLinkStateRequestNML&>(src);
                Message<GetLinkStateRequest > & tempDst = static_cast<Message<GetLinkStateRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetLinkStateRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetLinkStateResponse::ID:
            {
                GetLinkStateResponseNML & tempSrc = static_cast<GetLinkStateResponseNML&>(src);
                Message<GetLinkStateResponse > & tempDst = static_cast<Message<GetLinkStateResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetLinkStateResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetLinkState::ID:
            {
                GetLinkStateNML & tempSrc = static_cast<GetLinkStateNML&>(src);
                Message<GetLinkState > & tempDst = static_cast<Message<GetLinkState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetLinkState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetModelPropertiesRequest::ID:
            {
                GetModelPropertiesRequestNML & tempSrc = static_cast<GetModelPropertiesRequestNML&>(src);
                Message<GetModelPropertiesRequest > & tempDst = static_cast<Message<GetModelPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetModelPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetModelPropertiesResponse::ID:
            {
                GetModelPropertiesResponseNML & tempSrc = static_cast<GetModelPropertiesResponseNML&>(src);
                Message<GetModelPropertiesResponse > & tempDst = static_cast<Message<GetModelPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetModelPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetModelProperties::ID:
            {
                GetModelPropertiesNML & tempSrc = static_cast<GetModelPropertiesNML&>(src);
                Message<GetModelProperties > & tempDst = static_cast<Message<GetModelProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetModelProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetModelStateRequest::ID:
            {
                GetModelStateRequestNML & tempSrc = static_cast<GetModelStateRequestNML&>(src);
                Message<GetModelStateRequest > & tempDst = static_cast<Message<GetModelStateRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetModelStateRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetModelStateResponse::ID:
            {
                GetModelStateResponseNML & tempSrc = static_cast<GetModelStateResponseNML&>(src);
                Message<GetModelStateResponse > & tempDst = static_cast<Message<GetModelStateResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetModelStateResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetModelState::ID:
            {
                GetModelStateNML & tempSrc = static_cast<GetModelStateNML&>(src);
                Message<GetModelState > & tempDst = static_cast<Message<GetModelState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetModelState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPhysicsPropertiesRequest::ID:
            {
                GetPhysicsPropertiesRequestNML & tempSrc = static_cast<GetPhysicsPropertiesRequestNML&>(src);
                Message<GetPhysicsPropertiesRequest > & tempDst = static_cast<Message<GetPhysicsPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPhysicsPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPhysicsPropertiesResponse::ID:
            {
                GetPhysicsPropertiesResponseNML & tempSrc = static_cast<GetPhysicsPropertiesResponseNML&>(src);
                Message<GetPhysicsPropertiesResponse > & tempDst = static_cast<Message<GetPhysicsPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPhysicsPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetPhysicsProperties::ID:
            {
                GetPhysicsPropertiesNML & tempSrc = static_cast<GetPhysicsPropertiesNML&>(src);
                Message<GetPhysicsProperties > & tempDst = static_cast<Message<GetPhysicsProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetPhysicsProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetWorldPropertiesRequest::ID:
            {
                GetWorldPropertiesRequestNML & tempSrc = static_cast<GetWorldPropertiesRequestNML&>(src);
                Message<GetWorldPropertiesRequest > & tempDst = static_cast<Message<GetWorldPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetWorldPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetWorldPropertiesResponse::ID:
            {
                GetWorldPropertiesResponseNML & tempSrc = static_cast<GetWorldPropertiesResponseNML&>(src);
                Message<GetWorldPropertiesResponse > & tempDst = static_cast<Message<GetWorldPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetWorldPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GetWorldProperties::ID:
            {
                GetWorldPropertiesNML & tempSrc = static_cast<GetWorldPropertiesNML&>(src);
                Message<GetWorldProperties > & tempDst = static_cast<Message<GetWorldProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GetWorldProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointRequestRequest::ID:
            {
                JointRequestRequestNML & tempSrc = static_cast<JointRequestRequestNML&>(src);
                Message<JointRequestRequest > & tempDst = static_cast<Message<JointRequestRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointRequestRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointRequestResponse::ID:
            {
                JointRequestResponseNML & tempSrc = static_cast<JointRequestResponseNML&>(src);
                Message<JointRequestResponse > & tempDst = static_cast<Message<JointRequestResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointRequestResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointRequest::ID:
            {
                JointRequestNML & tempSrc = static_cast<JointRequestNML&>(src);
                Message<JointRequest > & tempDst = static_cast<Message<JointRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetJointPropertiesRequest::ID:
            {
                SetJointPropertiesRequestNML & tempSrc = static_cast<SetJointPropertiesRequestNML&>(src);
                Message<SetJointPropertiesRequest > & tempDst = static_cast<Message<SetJointPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetJointPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetJointPropertiesResponse::ID:
            {
                SetJointPropertiesResponseNML & tempSrc = static_cast<SetJointPropertiesResponseNML&>(src);
                Message<SetJointPropertiesResponse > & tempDst = static_cast<Message<SetJointPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetJointPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetJointProperties::ID:
            {
                SetJointPropertiesNML & tempSrc = static_cast<SetJointPropertiesNML&>(src);
                Message<SetJointProperties > & tempDst = static_cast<Message<SetJointProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetJointProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetJointTrajectoryRequest::ID:
            {
                SetJointTrajectoryRequestNML & tempSrc = static_cast<SetJointTrajectoryRequestNML&>(src);
                Message<SetJointTrajectoryRequest > & tempDst = static_cast<Message<SetJointTrajectoryRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetJointTrajectoryRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetJointTrajectoryResponse::ID:
            {
                SetJointTrajectoryResponseNML & tempSrc = static_cast<SetJointTrajectoryResponseNML&>(src);
                Message<SetJointTrajectoryResponse > & tempDst = static_cast<Message<SetJointTrajectoryResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetJointTrajectoryResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetJointTrajectory::ID:
            {
                SetJointTrajectoryNML & tempSrc = static_cast<SetJointTrajectoryNML&>(src);
                Message<SetJointTrajectory > & tempDst = static_cast<Message<SetJointTrajectory>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetJointTrajectory::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetLinkPropertiesRequest::ID:
            {
                SetLinkPropertiesRequestNML & tempSrc = static_cast<SetLinkPropertiesRequestNML&>(src);
                Message<SetLinkPropertiesRequest > & tempDst = static_cast<Message<SetLinkPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetLinkPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetLinkPropertiesResponse::ID:
            {
                SetLinkPropertiesResponseNML & tempSrc = static_cast<SetLinkPropertiesResponseNML&>(src);
                Message<SetLinkPropertiesResponse > & tempDst = static_cast<Message<SetLinkPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetLinkPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetLinkProperties::ID:
            {
                SetLinkPropertiesNML & tempSrc = static_cast<SetLinkPropertiesNML&>(src);
                Message<SetLinkProperties > & tempDst = static_cast<Message<SetLinkProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetLinkProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetLinkStateRequest::ID:
            {
                SetLinkStateRequestNML & tempSrc = static_cast<SetLinkStateRequestNML&>(src);
                Message<SetLinkStateRequest > & tempDst = static_cast<Message<SetLinkStateRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetLinkStateRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetLinkStateResponse::ID:
            {
                SetLinkStateResponseNML & tempSrc = static_cast<SetLinkStateResponseNML&>(src);
                Message<SetLinkStateResponse > & tempDst = static_cast<Message<SetLinkStateResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetLinkStateResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetLinkState::ID:
            {
                SetLinkStateNML & tempSrc = static_cast<SetLinkStateNML&>(src);
                Message<SetLinkState > & tempDst = static_cast<Message<SetLinkState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetLinkState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetModelConfigurationRequest::ID:
            {
                SetModelConfigurationRequestNML & tempSrc = static_cast<SetModelConfigurationRequestNML&>(src);
                Message<SetModelConfigurationRequest > & tempDst = static_cast<Message<SetModelConfigurationRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetModelConfigurationRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetModelConfigurationResponse::ID:
            {
                SetModelConfigurationResponseNML & tempSrc = static_cast<SetModelConfigurationResponseNML&>(src);
                Message<SetModelConfigurationResponse > & tempDst = static_cast<Message<SetModelConfigurationResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetModelConfigurationResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetModelConfiguration::ID:
            {
                SetModelConfigurationNML & tempSrc = static_cast<SetModelConfigurationNML&>(src);
                Message<SetModelConfiguration > & tempDst = static_cast<Message<SetModelConfiguration>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetModelConfiguration::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetModelStateRequest::ID:
            {
                SetModelStateRequestNML & tempSrc = static_cast<SetModelStateRequestNML&>(src);
                Message<SetModelStateRequest > & tempDst = static_cast<Message<SetModelStateRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetModelStateRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetModelStateResponse::ID:
            {
                SetModelStateResponseNML & tempSrc = static_cast<SetModelStateResponseNML&>(src);
                Message<SetModelStateResponse > & tempDst = static_cast<Message<SetModelStateResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetModelStateResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetModelState::ID:
            {
                SetModelStateNML & tempSrc = static_cast<SetModelStateNML&>(src);
                Message<SetModelState > & tempDst = static_cast<Message<SetModelState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetModelState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetPhysicsPropertiesRequest::ID:
            {
                SetPhysicsPropertiesRequestNML & tempSrc = static_cast<SetPhysicsPropertiesRequestNML&>(src);
                Message<SetPhysicsPropertiesRequest > & tempDst = static_cast<Message<SetPhysicsPropertiesRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetPhysicsPropertiesRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetPhysicsPropertiesResponse::ID:
            {
                SetPhysicsPropertiesResponseNML & tempSrc = static_cast<SetPhysicsPropertiesResponseNML&>(src);
                Message<SetPhysicsPropertiesResponse > & tempDst = static_cast<Message<SetPhysicsPropertiesResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetPhysicsPropertiesResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SetPhysicsProperties::ID:
            {
                SetPhysicsPropertiesNML & tempSrc = static_cast<SetPhysicsPropertiesNML&>(src);
                Message<SetPhysicsProperties > & tempDst = static_cast<Message<SetPhysicsProperties>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SetPhysicsProperties::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SpawnModelRequest::ID:
            {
                SpawnModelRequestNML & tempSrc = static_cast<SpawnModelRequestNML&>(src);
                Message<SpawnModelRequest > & tempDst = static_cast<Message<SpawnModelRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SpawnModelRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SpawnModelResponse::ID:
            {
                SpawnModelResponseNML & tempSrc = static_cast<SpawnModelResponseNML&>(src);
                Message<SpawnModelResponse > & tempDst = static_cast<Message<SpawnModelResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SpawnModelResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SpawnModel::ID:
            {
                SpawnModelNML & tempSrc = static_cast<SpawnModelNML&>(src);
                Message<SpawnModel > & tempDst = static_cast<Message<SpawnModel>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SpawnModel::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case ContactState::ID:
        {
            // only need to construct if data type is not flat
            if (ContactState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ContactState at %p\n",buffer);
                ContactStateNML * p = static_cast<ContactStateNML*>(buffer);
                // construct the type at pointer p
                new (p) ContactStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ContactState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ContactsState::ID:
        {
            // only need to construct if data type is not flat
            if (ContactsState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ContactsState at %p\n",buffer);
                ContactsStateNML * p = static_cast<ContactsStateNML*>(buffer);
                // construct the type at pointer p
                new (p) ContactsStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ContactsState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LinkState::ID:
        {
            // only need to construct if data type is not flat
            if (LinkState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LinkState at %p\n",buffer);
                LinkStateNML * p = static_cast<LinkStateNML*>(buffer);
                // construct the type at pointer p
                new (p) LinkStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LinkState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LinkStates::ID:
        {
            // only need to construct if data type is not flat
            if (LinkStates::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LinkStates at %p\n",buffer);
                LinkStatesNML * p = static_cast<LinkStatesNML*>(buffer);
                // construct the type at pointer p
                new (p) LinkStatesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LinkStates at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ModelState::ID:
        {
            // only need to construct if data type is not flat
            if (ModelState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ModelState at %p\n",buffer);
                ModelStateNML * p = static_cast<ModelStateNML*>(buffer);
                // construct the type at pointer p
                new (p) ModelStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ModelState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ModelStates::ID:
        {
            // only need to construct if data type is not flat
            if (ModelStates::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ModelStates at %p\n",buffer);
                ModelStatesNML * p = static_cast<ModelStatesNML*>(buffer);
                // construct the type at pointer p
                new (p) ModelStatesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ModelStates at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ODEJointProperties::ID:
        {
            // only need to construct if data type is not flat
            if (ODEJointProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ODEJointProperties at %p\n",buffer);
                ODEJointPropertiesNML * p = static_cast<ODEJointPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) ODEJointPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ODEJointProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ODEPhysics::ID:
        {
            // only need to construct if data type is not flat
            if (ODEPhysics::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ODEPhysics at %p\n",buffer);
                ODEPhysicsNML * p = static_cast<ODEPhysicsNML*>(buffer);
                // construct the type at pointer p
                new (p) ODEPhysicsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ODEPhysics at %p,, is flat\n",buffer);
            }
            break;
        } 
        case WorldState::ID:
        {
            // only need to construct if data type is not flat
            if (WorldState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing WorldState at %p\n",buffer);
                WorldStateNML * p = static_cast<WorldStateNML*>(buffer);
                // construct the type at pointer p
                new (p) WorldStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing WorldState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ApplyBodyWrenchRequest::ID:
        {
            // only need to construct if data type is not flat
            if (ApplyBodyWrenchRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ApplyBodyWrenchRequest at %p\n",buffer);
                ApplyBodyWrenchRequestNML * p = static_cast<ApplyBodyWrenchRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) ApplyBodyWrenchRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ApplyBodyWrenchRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ApplyBodyWrenchResponse::ID:
        {
            // only need to construct if data type is not flat
            if (ApplyBodyWrenchResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ApplyBodyWrenchResponse at %p\n",buffer);
                ApplyBodyWrenchResponseNML * p = static_cast<ApplyBodyWrenchResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) ApplyBodyWrenchResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ApplyBodyWrenchResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ApplyBodyWrench::ID:
        {
            // only need to construct if data type is not flat
            if (ApplyBodyWrench::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ApplyBodyWrench at %p\n",buffer);
                ApplyBodyWrenchNML * p = static_cast<ApplyBodyWrenchNML*>(buffer);
                // construct the type at pointer p
                new (p) ApplyBodyWrenchNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ApplyBodyWrench at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ApplyJointEffortRequest::ID:
        {
            // only need to construct if data type is not flat
            if (ApplyJointEffortRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ApplyJointEffortRequest at %p\n",buffer);
                ApplyJointEffortRequestNML * p = static_cast<ApplyJointEffortRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) ApplyJointEffortRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ApplyJointEffortRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ApplyJointEffortResponse::ID:
        {
            // only need to construct if data type is not flat
            if (ApplyJointEffortResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ApplyJointEffortResponse at %p\n",buffer);
                ApplyJointEffortResponseNML * p = static_cast<ApplyJointEffortResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) ApplyJointEffortResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ApplyJointEffortResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ApplyJointEffort::ID:
        {
            // only need to construct if data type is not flat
            if (ApplyJointEffort::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ApplyJointEffort at %p\n",buffer);
                ApplyJointEffortNML * p = static_cast<ApplyJointEffortNML*>(buffer);
                // construct the type at pointer p
                new (p) ApplyJointEffortNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ApplyJointEffort at %p,, is flat\n",buffer);
            }
            break;
        } 
        case BodyRequestRequest::ID:
        {
            // only need to construct if data type is not flat
            if (BodyRequestRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing BodyRequestRequest at %p\n",buffer);
                BodyRequestRequestNML * p = static_cast<BodyRequestRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) BodyRequestRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing BodyRequestRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case BodyRequestResponse::ID:
        {
            // only need to construct if data type is not flat
            if (BodyRequestResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing BodyRequestResponse at %p\n",buffer);
                BodyRequestResponseNML * p = static_cast<BodyRequestResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) BodyRequestResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing BodyRequestResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case BodyRequest::ID:
        {
            // only need to construct if data type is not flat
            if (BodyRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing BodyRequest at %p\n",buffer);
                BodyRequestNML * p = static_cast<BodyRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) BodyRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing BodyRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DeleteModelRequest::ID:
        {
            // only need to construct if data type is not flat
            if (DeleteModelRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DeleteModelRequest at %p\n",buffer);
                DeleteModelRequestNML * p = static_cast<DeleteModelRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) DeleteModelRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DeleteModelRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DeleteModelResponse::ID:
        {
            // only need to construct if data type is not flat
            if (DeleteModelResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DeleteModelResponse at %p\n",buffer);
                DeleteModelResponseNML * p = static_cast<DeleteModelResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) DeleteModelResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DeleteModelResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DeleteModel::ID:
        {
            // only need to construct if data type is not flat
            if (DeleteModel::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DeleteModel at %p\n",buffer);
                DeleteModelNML * p = static_cast<DeleteModelNML*>(buffer);
                // construct the type at pointer p
                new (p) DeleteModelNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DeleteModel at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetJointPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetJointPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetJointPropertiesRequest at %p\n",buffer);
                GetJointPropertiesRequestNML * p = static_cast<GetJointPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetJointPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetJointPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetJointPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetJointPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetJointPropertiesResponse at %p\n",buffer);
                GetJointPropertiesResponseNML * p = static_cast<GetJointPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetJointPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetJointPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetJointProperties::ID:
        {
            // only need to construct if data type is not flat
            if (GetJointProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetJointProperties at %p\n",buffer);
                GetJointPropertiesNML * p = static_cast<GetJointPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) GetJointPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetJointProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetLinkPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetLinkPropertiesRequest at %p\n",buffer);
                GetLinkPropertiesRequestNML * p = static_cast<GetLinkPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetLinkPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetLinkPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetLinkPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetLinkPropertiesResponse at %p\n",buffer);
                GetLinkPropertiesResponseNML * p = static_cast<GetLinkPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetLinkPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetLinkPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkProperties::ID:
        {
            // only need to construct if data type is not flat
            if (GetLinkProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetLinkProperties at %p\n",buffer);
                GetLinkPropertiesNML * p = static_cast<GetLinkPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) GetLinkPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetLinkProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkStateRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetLinkStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetLinkStateRequest at %p\n",buffer);
                GetLinkStateRequestNML * p = static_cast<GetLinkStateRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetLinkStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetLinkStateRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkStateResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetLinkStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetLinkStateResponse at %p\n",buffer);
                GetLinkStateResponseNML * p = static_cast<GetLinkStateResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetLinkStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetLinkStateResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkState::ID:
        {
            // only need to construct if data type is not flat
            if (GetLinkState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetLinkState at %p\n",buffer);
                GetLinkStateNML * p = static_cast<GetLinkStateNML*>(buffer);
                // construct the type at pointer p
                new (p) GetLinkStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetLinkState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetModelPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetModelPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetModelPropertiesRequest at %p\n",buffer);
                GetModelPropertiesRequestNML * p = static_cast<GetModelPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetModelPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetModelPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetModelPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetModelPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetModelPropertiesResponse at %p\n",buffer);
                GetModelPropertiesResponseNML * p = static_cast<GetModelPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetModelPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetModelPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetModelProperties::ID:
        {
            // only need to construct if data type is not flat
            if (GetModelProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetModelProperties at %p\n",buffer);
                GetModelPropertiesNML * p = static_cast<GetModelPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) GetModelPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetModelProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetModelStateRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetModelStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetModelStateRequest at %p\n",buffer);
                GetModelStateRequestNML * p = static_cast<GetModelStateRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetModelStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetModelStateRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetModelStateResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetModelStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetModelStateResponse at %p\n",buffer);
                GetModelStateResponseNML * p = static_cast<GetModelStateResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetModelStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetModelStateResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetModelState::ID:
        {
            // only need to construct if data type is not flat
            if (GetModelState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetModelState at %p\n",buffer);
                GetModelStateNML * p = static_cast<GetModelStateNML*>(buffer);
                // construct the type at pointer p
                new (p) GetModelStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetModelState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPhysicsPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetPhysicsPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPhysicsPropertiesRequest at %p\n",buffer);
                GetPhysicsPropertiesRequestNML * p = static_cast<GetPhysicsPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPhysicsPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPhysicsPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPhysicsPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetPhysicsPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPhysicsPropertiesResponse at %p\n",buffer);
                GetPhysicsPropertiesResponseNML * p = static_cast<GetPhysicsPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPhysicsPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPhysicsPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetPhysicsProperties::ID:
        {
            // only need to construct if data type is not flat
            if (GetPhysicsProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetPhysicsProperties at %p\n",buffer);
                GetPhysicsPropertiesNML * p = static_cast<GetPhysicsPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) GetPhysicsPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetPhysicsProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetWorldPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (GetWorldPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetWorldPropertiesRequest at %p\n",buffer);
                GetWorldPropertiesRequestNML * p = static_cast<GetWorldPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) GetWorldPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetWorldPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetWorldPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (GetWorldPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetWorldPropertiesResponse at %p\n",buffer);
                GetWorldPropertiesResponseNML * p = static_cast<GetWorldPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) GetWorldPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetWorldPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GetWorldProperties::ID:
        {
            // only need to construct if data type is not flat
            if (GetWorldProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GetWorldProperties at %p\n",buffer);
                GetWorldPropertiesNML * p = static_cast<GetWorldPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) GetWorldPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GetWorldProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointRequestRequest::ID:
        {
            // only need to construct if data type is not flat
            if (JointRequestRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointRequestRequest at %p\n",buffer);
                JointRequestRequestNML * p = static_cast<JointRequestRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) JointRequestRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointRequestRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointRequestResponse::ID:
        {
            // only need to construct if data type is not flat
            if (JointRequestResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointRequestResponse at %p\n",buffer);
                JointRequestResponseNML * p = static_cast<JointRequestResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) JointRequestResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointRequestResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointRequest::ID:
        {
            // only need to construct if data type is not flat
            if (JointRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointRequest at %p\n",buffer);
                JointRequestNML * p = static_cast<JointRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) JointRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetJointPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetJointPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetJointPropertiesRequest at %p\n",buffer);
                SetJointPropertiesRequestNML * p = static_cast<SetJointPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetJointPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetJointPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetJointPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetJointPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetJointPropertiesResponse at %p\n",buffer);
                SetJointPropertiesResponseNML * p = static_cast<SetJointPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetJointPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetJointPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetJointProperties::ID:
        {
            // only need to construct if data type is not flat
            if (SetJointProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetJointProperties at %p\n",buffer);
                SetJointPropertiesNML * p = static_cast<SetJointPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) SetJointPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetJointProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetJointTrajectoryRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetJointTrajectoryRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetJointTrajectoryRequest at %p\n",buffer);
                SetJointTrajectoryRequestNML * p = static_cast<SetJointTrajectoryRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetJointTrajectoryRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetJointTrajectoryRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetJointTrajectoryResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetJointTrajectoryResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetJointTrajectoryResponse at %p\n",buffer);
                SetJointTrajectoryResponseNML * p = static_cast<SetJointTrajectoryResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetJointTrajectoryResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetJointTrajectoryResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetJointTrajectory::ID:
        {
            // only need to construct if data type is not flat
            if (SetJointTrajectory::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetJointTrajectory at %p\n",buffer);
                SetJointTrajectoryNML * p = static_cast<SetJointTrajectoryNML*>(buffer);
                // construct the type at pointer p
                new (p) SetJointTrajectoryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetJointTrajectory at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetLinkPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetLinkPropertiesRequest at %p\n",buffer);
                SetLinkPropertiesRequestNML * p = static_cast<SetLinkPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetLinkPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetLinkPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetLinkPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetLinkPropertiesResponse at %p\n",buffer);
                SetLinkPropertiesResponseNML * p = static_cast<SetLinkPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetLinkPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetLinkPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkProperties::ID:
        {
            // only need to construct if data type is not flat
            if (SetLinkProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetLinkProperties at %p\n",buffer);
                SetLinkPropertiesNML * p = static_cast<SetLinkPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) SetLinkPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetLinkProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkStateRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetLinkStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetLinkStateRequest at %p\n",buffer);
                SetLinkStateRequestNML * p = static_cast<SetLinkStateRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetLinkStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetLinkStateRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkStateResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetLinkStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetLinkStateResponse at %p\n",buffer);
                SetLinkStateResponseNML * p = static_cast<SetLinkStateResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetLinkStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetLinkStateResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkState::ID:
        {
            // only need to construct if data type is not flat
            if (SetLinkState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetLinkState at %p\n",buffer);
                SetLinkStateNML * p = static_cast<SetLinkStateNML*>(buffer);
                // construct the type at pointer p
                new (p) SetLinkStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetLinkState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetModelConfigurationRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetModelConfigurationRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetModelConfigurationRequest at %p\n",buffer);
                SetModelConfigurationRequestNML * p = static_cast<SetModelConfigurationRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetModelConfigurationRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetModelConfigurationRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetModelConfigurationResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetModelConfigurationResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetModelConfigurationResponse at %p\n",buffer);
                SetModelConfigurationResponseNML * p = static_cast<SetModelConfigurationResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetModelConfigurationResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetModelConfigurationResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetModelConfiguration::ID:
        {
            // only need to construct if data type is not flat
            if (SetModelConfiguration::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetModelConfiguration at %p\n",buffer);
                SetModelConfigurationNML * p = static_cast<SetModelConfigurationNML*>(buffer);
                // construct the type at pointer p
                new (p) SetModelConfigurationNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetModelConfiguration at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetModelStateRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetModelStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetModelStateRequest at %p\n",buffer);
                SetModelStateRequestNML * p = static_cast<SetModelStateRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetModelStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetModelStateRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetModelStateResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetModelStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetModelStateResponse at %p\n",buffer);
                SetModelStateResponseNML * p = static_cast<SetModelStateResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetModelStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetModelStateResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetModelState::ID:
        {
            // only need to construct if data type is not flat
            if (SetModelState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetModelState at %p\n",buffer);
                SetModelStateNML * p = static_cast<SetModelStateNML*>(buffer);
                // construct the type at pointer p
                new (p) SetModelStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetModelState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetPhysicsPropertiesRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SetPhysicsPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetPhysicsPropertiesRequest at %p\n",buffer);
                SetPhysicsPropertiesRequestNML * p = static_cast<SetPhysicsPropertiesRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SetPhysicsPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetPhysicsPropertiesRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetPhysicsPropertiesResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SetPhysicsPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetPhysicsPropertiesResponse at %p\n",buffer);
                SetPhysicsPropertiesResponseNML * p = static_cast<SetPhysicsPropertiesResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SetPhysicsPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetPhysicsPropertiesResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SetPhysicsProperties::ID:
        {
            // only need to construct if data type is not flat
            if (SetPhysicsProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SetPhysicsProperties at %p\n",buffer);
                SetPhysicsPropertiesNML * p = static_cast<SetPhysicsPropertiesNML*>(buffer);
                // construct the type at pointer p
                new (p) SetPhysicsPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SetPhysicsProperties at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SpawnModelRequest::ID:
        {
            // only need to construct if data type is not flat
            if (SpawnModelRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SpawnModelRequest at %p\n",buffer);
                SpawnModelRequestNML * p = static_cast<SpawnModelRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) SpawnModelRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SpawnModelRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SpawnModelResponse::ID:
        {
            // only need to construct if data type is not flat
            if (SpawnModelResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SpawnModelResponse at %p\n",buffer);
                SpawnModelResponseNML * p = static_cast<SpawnModelResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) SpawnModelResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SpawnModelResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SpawnModel::ID:
        {
            // only need to construct if data type is not flat
            if (SpawnModel::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SpawnModel at %p\n",buffer);
                SpawnModelNML * p = static_cast<SpawnModelNML*>(buffer);
                // construct the type at pointer p
                new (p) SpawnModelNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SpawnModel at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int gazebo_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case ContactState::ID:
        {
            // only need to destruct if data type is not flat
            if (ContactState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ContactState at %p\n",buffer);
                ContactStateNML * p = static_cast<ContactStateNML*>(buffer);
                p->~ContactStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ContactState at %p, is flat\n",buffer);
            }
            break;
        } 
        case ContactsState::ID:
        {
            // only need to destruct if data type is not flat
            if (ContactsState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ContactsState at %p\n",buffer);
                ContactsStateNML * p = static_cast<ContactsStateNML*>(buffer);
                p->~ContactsStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ContactsState at %p, is flat\n",buffer);
            }
            break;
        } 
        case LinkState::ID:
        {
            // only need to destruct if data type is not flat
            if (LinkState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LinkState at %p\n",buffer);
                LinkStateNML * p = static_cast<LinkStateNML*>(buffer);
                p->~LinkStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LinkState at %p, is flat\n",buffer);
            }
            break;
        } 
        case LinkStates::ID:
        {
            // only need to destruct if data type is not flat
            if (LinkStates::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LinkStates at %p\n",buffer);
                LinkStatesNML * p = static_cast<LinkStatesNML*>(buffer);
                p->~LinkStatesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LinkStates at %p, is flat\n",buffer);
            }
            break;
        } 
        case ModelState::ID:
        {
            // only need to destruct if data type is not flat
            if (ModelState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ModelState at %p\n",buffer);
                ModelStateNML * p = static_cast<ModelStateNML*>(buffer);
                p->~ModelStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ModelState at %p, is flat\n",buffer);
            }
            break;
        } 
        case ModelStates::ID:
        {
            // only need to destruct if data type is not flat
            if (ModelStates::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ModelStates at %p\n",buffer);
                ModelStatesNML * p = static_cast<ModelStatesNML*>(buffer);
                p->~ModelStatesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ModelStates at %p, is flat\n",buffer);
            }
            break;
        } 
        case ODEJointProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (ODEJointProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ODEJointProperties at %p\n",buffer);
                ODEJointPropertiesNML * p = static_cast<ODEJointPropertiesNML*>(buffer);
                p->~ODEJointPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ODEJointProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case ODEPhysics::ID:
        {
            // only need to destruct if data type is not flat
            if (ODEPhysics::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ODEPhysics at %p\n",buffer);
                ODEPhysicsNML * p = static_cast<ODEPhysicsNML*>(buffer);
                p->~ODEPhysicsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ODEPhysics at %p, is flat\n",buffer);
            }
            break;
        } 
        case WorldState::ID:
        {
            // only need to destruct if data type is not flat
            if (WorldState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing WorldState at %p\n",buffer);
                WorldStateNML * p = static_cast<WorldStateNML*>(buffer);
                p->~WorldStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction WorldState at %p, is flat\n",buffer);
            }
            break;
        } 
        case ApplyBodyWrenchRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (ApplyBodyWrenchRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ApplyBodyWrenchRequest at %p\n",buffer);
                ApplyBodyWrenchRequestNML * p = static_cast<ApplyBodyWrenchRequestNML*>(buffer);
                p->~ApplyBodyWrenchRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ApplyBodyWrenchRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case ApplyBodyWrenchResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (ApplyBodyWrenchResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ApplyBodyWrenchResponse at %p\n",buffer);
                ApplyBodyWrenchResponseNML * p = static_cast<ApplyBodyWrenchResponseNML*>(buffer);
                p->~ApplyBodyWrenchResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ApplyBodyWrenchResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case ApplyBodyWrench::ID:
        {
            // only need to destruct if data type is not flat
            if (ApplyBodyWrench::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ApplyBodyWrench at %p\n",buffer);
                ApplyBodyWrenchNML * p = static_cast<ApplyBodyWrenchNML*>(buffer);
                p->~ApplyBodyWrenchNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ApplyBodyWrench at %p, is flat\n",buffer);
            }
            break;
        } 
        case ApplyJointEffortRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (ApplyJointEffortRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ApplyJointEffortRequest at %p\n",buffer);
                ApplyJointEffortRequestNML * p = static_cast<ApplyJointEffortRequestNML*>(buffer);
                p->~ApplyJointEffortRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ApplyJointEffortRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case ApplyJointEffortResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (ApplyJointEffortResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ApplyJointEffortResponse at %p\n",buffer);
                ApplyJointEffortResponseNML * p = static_cast<ApplyJointEffortResponseNML*>(buffer);
                p->~ApplyJointEffortResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ApplyJointEffortResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case ApplyJointEffort::ID:
        {
            // only need to destruct if data type is not flat
            if (ApplyJointEffort::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ApplyJointEffort at %p\n",buffer);
                ApplyJointEffortNML * p = static_cast<ApplyJointEffortNML*>(buffer);
                p->~ApplyJointEffortNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ApplyJointEffort at %p, is flat\n",buffer);
            }
            break;
        } 
        case BodyRequestRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (BodyRequestRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing BodyRequestRequest at %p\n",buffer);
                BodyRequestRequestNML * p = static_cast<BodyRequestRequestNML*>(buffer);
                p->~BodyRequestRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction BodyRequestRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case BodyRequestResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (BodyRequestResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing BodyRequestResponse at %p\n",buffer);
                BodyRequestResponseNML * p = static_cast<BodyRequestResponseNML*>(buffer);
                p->~BodyRequestResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction BodyRequestResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case BodyRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (BodyRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing BodyRequest at %p\n",buffer);
                BodyRequestNML * p = static_cast<BodyRequestNML*>(buffer);
                p->~BodyRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction BodyRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case DeleteModelRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (DeleteModelRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DeleteModelRequest at %p\n",buffer);
                DeleteModelRequestNML * p = static_cast<DeleteModelRequestNML*>(buffer);
                p->~DeleteModelRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DeleteModelRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case DeleteModelResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (DeleteModelResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DeleteModelResponse at %p\n",buffer);
                DeleteModelResponseNML * p = static_cast<DeleteModelResponseNML*>(buffer);
                p->~DeleteModelResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DeleteModelResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case DeleteModel::ID:
        {
            // only need to destruct if data type is not flat
            if (DeleteModel::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DeleteModel at %p\n",buffer);
                DeleteModelNML * p = static_cast<DeleteModelNML*>(buffer);
                p->~DeleteModelNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DeleteModel at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetJointPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetJointPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetJointPropertiesRequest at %p\n",buffer);
                GetJointPropertiesRequestNML * p = static_cast<GetJointPropertiesRequestNML*>(buffer);
                p->~GetJointPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetJointPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetJointPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetJointPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetJointPropertiesResponse at %p\n",buffer);
                GetJointPropertiesResponseNML * p = static_cast<GetJointPropertiesResponseNML*>(buffer);
                p->~GetJointPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetJointPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetJointProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (GetJointProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetJointProperties at %p\n",buffer);
                GetJointPropertiesNML * p = static_cast<GetJointPropertiesNML*>(buffer);
                p->~GetJointPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetJointProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetLinkPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetLinkPropertiesRequest at %p\n",buffer);
                GetLinkPropertiesRequestNML * p = static_cast<GetLinkPropertiesRequestNML*>(buffer);
                p->~GetLinkPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetLinkPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetLinkPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetLinkPropertiesResponse at %p\n",buffer);
                GetLinkPropertiesResponseNML * p = static_cast<GetLinkPropertiesResponseNML*>(buffer);
                p->~GetLinkPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetLinkPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (GetLinkProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetLinkProperties at %p\n",buffer);
                GetLinkPropertiesNML * p = static_cast<GetLinkPropertiesNML*>(buffer);
                p->~GetLinkPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetLinkProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkStateRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetLinkStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetLinkStateRequest at %p\n",buffer);
                GetLinkStateRequestNML * p = static_cast<GetLinkStateRequestNML*>(buffer);
                p->~GetLinkStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetLinkStateRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkStateResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetLinkStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetLinkStateResponse at %p\n",buffer);
                GetLinkStateResponseNML * p = static_cast<GetLinkStateResponseNML*>(buffer);
                p->~GetLinkStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetLinkStateResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetLinkState::ID:
        {
            // only need to destruct if data type is not flat
            if (GetLinkState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetLinkState at %p\n",buffer);
                GetLinkStateNML * p = static_cast<GetLinkStateNML*>(buffer);
                p->~GetLinkStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetLinkState at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetModelPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetModelPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetModelPropertiesRequest at %p\n",buffer);
                GetModelPropertiesRequestNML * p = static_cast<GetModelPropertiesRequestNML*>(buffer);
                p->~GetModelPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetModelPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetModelPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetModelPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetModelPropertiesResponse at %p\n",buffer);
                GetModelPropertiesResponseNML * p = static_cast<GetModelPropertiesResponseNML*>(buffer);
                p->~GetModelPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetModelPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetModelProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (GetModelProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetModelProperties at %p\n",buffer);
                GetModelPropertiesNML * p = static_cast<GetModelPropertiesNML*>(buffer);
                p->~GetModelPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetModelProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetModelStateRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetModelStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetModelStateRequest at %p\n",buffer);
                GetModelStateRequestNML * p = static_cast<GetModelStateRequestNML*>(buffer);
                p->~GetModelStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetModelStateRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetModelStateResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetModelStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetModelStateResponse at %p\n",buffer);
                GetModelStateResponseNML * p = static_cast<GetModelStateResponseNML*>(buffer);
                p->~GetModelStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetModelStateResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetModelState::ID:
        {
            // only need to destruct if data type is not flat
            if (GetModelState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetModelState at %p\n",buffer);
                GetModelStateNML * p = static_cast<GetModelStateNML*>(buffer);
                p->~GetModelStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetModelState at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPhysicsPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPhysicsPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPhysicsPropertiesRequest at %p\n",buffer);
                GetPhysicsPropertiesRequestNML * p = static_cast<GetPhysicsPropertiesRequestNML*>(buffer);
                p->~GetPhysicsPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPhysicsPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPhysicsPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPhysicsPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPhysicsPropertiesResponse at %p\n",buffer);
                GetPhysicsPropertiesResponseNML * p = static_cast<GetPhysicsPropertiesResponseNML*>(buffer);
                p->~GetPhysicsPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPhysicsPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetPhysicsProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (GetPhysicsProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetPhysicsProperties at %p\n",buffer);
                GetPhysicsPropertiesNML * p = static_cast<GetPhysicsPropertiesNML*>(buffer);
                p->~GetPhysicsPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetPhysicsProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetWorldPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (GetWorldPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetWorldPropertiesRequest at %p\n",buffer);
                GetWorldPropertiesRequestNML * p = static_cast<GetWorldPropertiesRequestNML*>(buffer);
                p->~GetWorldPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetWorldPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetWorldPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (GetWorldPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetWorldPropertiesResponse at %p\n",buffer);
                GetWorldPropertiesResponseNML * p = static_cast<GetWorldPropertiesResponseNML*>(buffer);
                p->~GetWorldPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetWorldPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case GetWorldProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (GetWorldProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GetWorldProperties at %p\n",buffer);
                GetWorldPropertiesNML * p = static_cast<GetWorldPropertiesNML*>(buffer);
                p->~GetWorldPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GetWorldProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointRequestRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (JointRequestRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointRequestRequest at %p\n",buffer);
                JointRequestRequestNML * p = static_cast<JointRequestRequestNML*>(buffer);
                p->~JointRequestRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointRequestRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointRequestResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (JointRequestResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointRequestResponse at %p\n",buffer);
                JointRequestResponseNML * p = static_cast<JointRequestResponseNML*>(buffer);
                p->~JointRequestResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointRequestResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (JointRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointRequest at %p\n",buffer);
                JointRequestNML * p = static_cast<JointRequestNML*>(buffer);
                p->~JointRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetJointPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetJointPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetJointPropertiesRequest at %p\n",buffer);
                SetJointPropertiesRequestNML * p = static_cast<SetJointPropertiesRequestNML*>(buffer);
                p->~SetJointPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetJointPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetJointPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetJointPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetJointPropertiesResponse at %p\n",buffer);
                SetJointPropertiesResponseNML * p = static_cast<SetJointPropertiesResponseNML*>(buffer);
                p->~SetJointPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetJointPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetJointProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (SetJointProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetJointProperties at %p\n",buffer);
                SetJointPropertiesNML * p = static_cast<SetJointPropertiesNML*>(buffer);
                p->~SetJointPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetJointProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetJointTrajectoryRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetJointTrajectoryRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetJointTrajectoryRequest at %p\n",buffer);
                SetJointTrajectoryRequestNML * p = static_cast<SetJointTrajectoryRequestNML*>(buffer);
                p->~SetJointTrajectoryRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetJointTrajectoryRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetJointTrajectoryResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetJointTrajectoryResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetJointTrajectoryResponse at %p\n",buffer);
                SetJointTrajectoryResponseNML * p = static_cast<SetJointTrajectoryResponseNML*>(buffer);
                p->~SetJointTrajectoryResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetJointTrajectoryResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetJointTrajectory::ID:
        {
            // only need to destruct if data type is not flat
            if (SetJointTrajectory::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetJointTrajectory at %p\n",buffer);
                SetJointTrajectoryNML * p = static_cast<SetJointTrajectoryNML*>(buffer);
                p->~SetJointTrajectoryNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetJointTrajectory at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetLinkPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetLinkPropertiesRequest at %p\n",buffer);
                SetLinkPropertiesRequestNML * p = static_cast<SetLinkPropertiesRequestNML*>(buffer);
                p->~SetLinkPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetLinkPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetLinkPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetLinkPropertiesResponse at %p\n",buffer);
                SetLinkPropertiesResponseNML * p = static_cast<SetLinkPropertiesResponseNML*>(buffer);
                p->~SetLinkPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetLinkPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (SetLinkProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetLinkProperties at %p\n",buffer);
                SetLinkPropertiesNML * p = static_cast<SetLinkPropertiesNML*>(buffer);
                p->~SetLinkPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetLinkProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkStateRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetLinkStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetLinkStateRequest at %p\n",buffer);
                SetLinkStateRequestNML * p = static_cast<SetLinkStateRequestNML*>(buffer);
                p->~SetLinkStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetLinkStateRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkStateResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetLinkStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetLinkStateResponse at %p\n",buffer);
                SetLinkStateResponseNML * p = static_cast<SetLinkStateResponseNML*>(buffer);
                p->~SetLinkStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetLinkStateResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetLinkState::ID:
        {
            // only need to destruct if data type is not flat
            if (SetLinkState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetLinkState at %p\n",buffer);
                SetLinkStateNML * p = static_cast<SetLinkStateNML*>(buffer);
                p->~SetLinkStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetLinkState at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetModelConfigurationRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetModelConfigurationRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetModelConfigurationRequest at %p\n",buffer);
                SetModelConfigurationRequestNML * p = static_cast<SetModelConfigurationRequestNML*>(buffer);
                p->~SetModelConfigurationRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetModelConfigurationRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetModelConfigurationResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetModelConfigurationResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetModelConfigurationResponse at %p\n",buffer);
                SetModelConfigurationResponseNML * p = static_cast<SetModelConfigurationResponseNML*>(buffer);
                p->~SetModelConfigurationResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetModelConfigurationResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetModelConfiguration::ID:
        {
            // only need to destruct if data type is not flat
            if (SetModelConfiguration::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetModelConfiguration at %p\n",buffer);
                SetModelConfigurationNML * p = static_cast<SetModelConfigurationNML*>(buffer);
                p->~SetModelConfigurationNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetModelConfiguration at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetModelStateRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetModelStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetModelStateRequest at %p\n",buffer);
                SetModelStateRequestNML * p = static_cast<SetModelStateRequestNML*>(buffer);
                p->~SetModelStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetModelStateRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetModelStateResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetModelStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetModelStateResponse at %p\n",buffer);
                SetModelStateResponseNML * p = static_cast<SetModelStateResponseNML*>(buffer);
                p->~SetModelStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetModelStateResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetModelState::ID:
        {
            // only need to destruct if data type is not flat
            if (SetModelState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetModelState at %p\n",buffer);
                SetModelStateNML * p = static_cast<SetModelStateNML*>(buffer);
                p->~SetModelStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetModelState at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetPhysicsPropertiesRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SetPhysicsPropertiesRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetPhysicsPropertiesRequest at %p\n",buffer);
                SetPhysicsPropertiesRequestNML * p = static_cast<SetPhysicsPropertiesRequestNML*>(buffer);
                p->~SetPhysicsPropertiesRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetPhysicsPropertiesRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetPhysicsPropertiesResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SetPhysicsPropertiesResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetPhysicsPropertiesResponse at %p\n",buffer);
                SetPhysicsPropertiesResponseNML * p = static_cast<SetPhysicsPropertiesResponseNML*>(buffer);
                p->~SetPhysicsPropertiesResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetPhysicsPropertiesResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SetPhysicsProperties::ID:
        {
            // only need to destruct if data type is not flat
            if (SetPhysicsProperties::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SetPhysicsProperties at %p\n",buffer);
                SetPhysicsPropertiesNML * p = static_cast<SetPhysicsPropertiesNML*>(buffer);
                p->~SetPhysicsPropertiesNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SetPhysicsProperties at %p, is flat\n",buffer);
            }
            break;
        } 
        case SpawnModelRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (SpawnModelRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SpawnModelRequest at %p\n",buffer);
                SpawnModelRequestNML * p = static_cast<SpawnModelRequestNML*>(buffer);
                p->~SpawnModelRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SpawnModelRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case SpawnModelResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (SpawnModelResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SpawnModelResponse at %p\n",buffer);
                SpawnModelResponseNML * p = static_cast<SpawnModelResponseNML*>(buffer);
                p->~SpawnModelResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SpawnModelResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case SpawnModel::ID:
        {
            // only need to destruct if data type is not flat
            if (SpawnModel::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SpawnModel at %p\n",buffer);
                SpawnModelNML * p = static_cast<SpawnModelNML*>(buffer);
                p->~SpawnModelNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SpawnModel at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void gazebo_msgs::nmlupdate(CMS * cms, ContactState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ContactState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.info);
        nmlupdate(cms,inobj.collision1_name);
        nmlupdate(cms,inobj.collision2_name);
        nmlupdate(cms,inobj.wrenches);
        nmlupdate(cms,inobj.total_wrench);
        nmlupdate(cms,inobj.contact_positions);
        nmlupdate(cms,inobj.contact_normals);
        nmlupdate(cms,inobj.depths);

    }  
 }

ContactStateNML::ContactStateNML() : NMLmsg((NMLTYPE)ContactState::ID,sizeof(ContactStateNML)), nmlVersion(ContactState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ContactState()*/)
{
};

ContactStateNML::~ContactStateNML()
{
};

ContactStateNML & ContactStateNML::operator=(const ContactStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ContactStateNML & ContactStateNML::operator=(const ContactState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ContactState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ContactStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ContactState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ContactStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ContactState> temp(new ContactState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ContactState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ContactState Message version mismatch, expected " << ContactState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ContactState Message version mismatch, expected " << ContactState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ContactsState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ContactsState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.states);

    }  
 }

ContactsStateNML::ContactsStateNML() : NMLmsg((NMLTYPE)ContactsState::ID,sizeof(ContactsStateNML)), nmlVersion(ContactsState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ContactsState()*/)
{
};

ContactsStateNML::~ContactsStateNML()
{
};

ContactsStateNML & ContactsStateNML::operator=(const ContactsStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ContactsStateNML & ContactsStateNML::operator=(const ContactsState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ContactsState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ContactsStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ContactsState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ContactsStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ContactsState> temp(new ContactsState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ContactsState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ContactsState Message version mismatch, expected " << ContactsState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ContactsState Message version mismatch, expected " << ContactsState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, LinkState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LinkState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.link_name);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);
        nmlupdate(cms,inobj.reference_frame);

    }  
 }

LinkStateNML::LinkStateNML() : NMLmsg((NMLTYPE)LinkState::ID,sizeof(LinkStateNML)), nmlVersion(LinkState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LinkState()*/)
{
};

LinkStateNML::~LinkStateNML()
{
};

LinkStateNML & LinkStateNML::operator=(const LinkStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LinkStateNML & LinkStateNML::operator=(const LinkState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LinkState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LinkStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LinkState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LinkStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LinkState> temp(new LinkState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LinkState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LinkState Message version mismatch, expected " << LinkState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LinkState Message version mismatch, expected " << LinkState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, LinkStates & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LinkStates, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);

    }  
 }

LinkStatesNML::LinkStatesNML() : NMLmsg((NMLTYPE)LinkStates::ID,sizeof(LinkStatesNML)), nmlVersion(LinkStates::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LinkStates()*/)
{
};

LinkStatesNML::~LinkStatesNML()
{
};

LinkStatesNML & LinkStatesNML::operator=(const LinkStatesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LinkStatesNML & LinkStatesNML::operator=(const LinkStates & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LinkStates);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LinkStatesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LinkStates&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LinkStatesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LinkStates> temp(new LinkStates());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LinkStates::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LinkStates Message version mismatch, expected " << LinkStates::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LinkStates Message version mismatch, expected " << LinkStates::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ModelState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ModelState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);
        nmlupdate(cms,inobj.reference_frame);

    }  
 }

ModelStateNML::ModelStateNML() : NMLmsg((NMLTYPE)ModelState::ID,sizeof(ModelStateNML)), nmlVersion(ModelState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ModelState()*/)
{
};

ModelStateNML::~ModelStateNML()
{
};

ModelStateNML & ModelStateNML::operator=(const ModelStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ModelStateNML & ModelStateNML::operator=(const ModelState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ModelState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ModelStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ModelState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ModelStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ModelState> temp(new ModelState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ModelState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ModelState Message version mismatch, expected " << ModelState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ModelState Message version mismatch, expected " << ModelState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ModelStates & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ModelStates, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);

    }  
 }

ModelStatesNML::ModelStatesNML() : NMLmsg((NMLTYPE)ModelStates::ID,sizeof(ModelStatesNML)), nmlVersion(ModelStates::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ModelStates()*/)
{
};

ModelStatesNML::~ModelStatesNML()
{
};

ModelStatesNML & ModelStatesNML::operator=(const ModelStatesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ModelStatesNML & ModelStatesNML::operator=(const ModelStates & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ModelStates);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ModelStatesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ModelStates&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ModelStatesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ModelStates> temp(new ModelStates());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ModelStates::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ModelStates Message version mismatch, expected " << ModelStates::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ModelStates Message version mismatch, expected " << ModelStates::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ODEJointProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ODEJointProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.damping);
        nmlupdate(cms,inobj.hiStop);
        nmlupdate(cms,inobj.loStop);
        nmlupdate(cms,inobj.erp);
        nmlupdate(cms,inobj.cfm);
        nmlupdate(cms,inobj.stop_erp);
        nmlupdate(cms,inobj.stop_cfm);
        nmlupdate(cms,inobj.fudge_factor);
        nmlupdate(cms,inobj.fmax);
        nmlupdate(cms,inobj.vel);

    }  
 }

ODEJointPropertiesNML::ODEJointPropertiesNML() : NMLmsg((NMLTYPE)ODEJointProperties::ID,sizeof(ODEJointPropertiesNML)), nmlVersion(ODEJointProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ODEJointProperties()*/)
{
};

ODEJointPropertiesNML::~ODEJointPropertiesNML()
{
};

ODEJointPropertiesNML & ODEJointPropertiesNML::operator=(const ODEJointPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ODEJointPropertiesNML & ODEJointPropertiesNML::operator=(const ODEJointProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ODEJointProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ODEJointPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ODEJointProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ODEJointPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ODEJointProperties> temp(new ODEJointProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ODEJointProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ODEJointProperties Message version mismatch, expected " << ODEJointProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ODEJointProperties Message version mismatch, expected " << ODEJointProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ODEPhysics & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ODEPhysics, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.auto_disable_bodies);
        cms->update(inobj.sor_pgs_precon_iters);
        cms->update(inobj.sor_pgs_iters);
        cms->update(inobj.sor_pgs_w);
        cms->update(inobj.sor_pgs_rms_error_tol);
        cms->update(inobj.contact_surface_layer);
        cms->update(inobj.contact_max_correcting_vel);
        cms->update(inobj.cfm);
        cms->update(inobj.erp);
        cms->update(inobj.max_contacts);

    }  
 }

ODEPhysicsNML::ODEPhysicsNML() : NMLmsg((NMLTYPE)ODEPhysics::ID,sizeof(ODEPhysicsNML)), nmlVersion(ODEPhysics::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ODEPhysics()*/)
{
};

ODEPhysicsNML::~ODEPhysicsNML()
{
};

ODEPhysicsNML & ODEPhysicsNML::operator=(const ODEPhysicsNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ODEPhysicsNML & ODEPhysicsNML::operator=(const ODEPhysics & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ODEPhysics);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ODEPhysicsNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ODEPhysics&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ODEPhysicsNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ODEPhysics> temp(new ODEPhysics());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ODEPhysics::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ODEPhysics Message version mismatch, expected " << ODEPhysics::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ODEPhysics Message version mismatch, expected " << ODEPhysics::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, WorldState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate WorldState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);
        nmlupdate(cms,inobj.wrench);

    }  
 }

WorldStateNML::WorldStateNML() : NMLmsg((NMLTYPE)WorldState::ID,sizeof(WorldStateNML)), nmlVersion(WorldState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new WorldState()*/)
{
};

WorldStateNML::~WorldStateNML()
{
};

WorldStateNML & WorldStateNML::operator=(const WorldStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

WorldStateNML & WorldStateNML::operator=(const WorldState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(WorldState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void WorldStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<WorldState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: WorldStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<WorldState> temp(new WorldState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (WorldState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: WorldState Message version mismatch, expected " << WorldState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: WorldState Message version mismatch, expected " << WorldState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ApplyBodyWrenchRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ApplyBodyWrenchRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.body_name);
        nmlupdate(cms,inobj.reference_frame);
        nmlupdate(cms,inobj.reference_point);
        nmlupdate(cms,inobj.wrench);
        nmlupdate(cms,inobj.start_time);
        nmlupdate(cms,inobj.duration);

    }  
 }

ApplyBodyWrenchRequestNML::ApplyBodyWrenchRequestNML() : NMLmsg((NMLTYPE)ApplyBodyWrenchRequest::ID,sizeof(ApplyBodyWrenchRequestNML)), nmlVersion(ApplyBodyWrenchRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ApplyBodyWrenchRequest()*/)
{
};

ApplyBodyWrenchRequestNML::~ApplyBodyWrenchRequestNML()
{
};

ApplyBodyWrenchRequestNML & ApplyBodyWrenchRequestNML::operator=(const ApplyBodyWrenchRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ApplyBodyWrenchRequestNML & ApplyBodyWrenchRequestNML::operator=(const ApplyBodyWrenchRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ApplyBodyWrenchRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ApplyBodyWrenchRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ApplyBodyWrenchRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ApplyBodyWrenchRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ApplyBodyWrenchRequest> temp(new ApplyBodyWrenchRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ApplyBodyWrenchRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ApplyBodyWrenchRequest Message version mismatch, expected " << ApplyBodyWrenchRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ApplyBodyWrenchRequest Message version mismatch, expected " << ApplyBodyWrenchRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ApplyBodyWrenchResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ApplyBodyWrenchResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

ApplyBodyWrenchResponseNML::ApplyBodyWrenchResponseNML() : NMLmsg((NMLTYPE)ApplyBodyWrenchResponse::ID,sizeof(ApplyBodyWrenchResponseNML)), nmlVersion(ApplyBodyWrenchResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ApplyBodyWrenchResponse()*/)
{
};

ApplyBodyWrenchResponseNML::~ApplyBodyWrenchResponseNML()
{
};

ApplyBodyWrenchResponseNML & ApplyBodyWrenchResponseNML::operator=(const ApplyBodyWrenchResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ApplyBodyWrenchResponseNML & ApplyBodyWrenchResponseNML::operator=(const ApplyBodyWrenchResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ApplyBodyWrenchResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ApplyBodyWrenchResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ApplyBodyWrenchResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ApplyBodyWrenchResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ApplyBodyWrenchResponse> temp(new ApplyBodyWrenchResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ApplyBodyWrenchResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ApplyBodyWrenchResponse Message version mismatch, expected " << ApplyBodyWrenchResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ApplyBodyWrenchResponse Message version mismatch, expected " << ApplyBodyWrenchResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ApplyBodyWrench & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ApplyBodyWrench, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

ApplyBodyWrenchNML::ApplyBodyWrenchNML() : NMLmsg((NMLTYPE)ApplyBodyWrench::ID,sizeof(ApplyBodyWrenchNML)), nmlVersion(ApplyBodyWrench::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ApplyBodyWrench()*/)
{
};

ApplyBodyWrenchNML::~ApplyBodyWrenchNML()
{
};

ApplyBodyWrenchNML & ApplyBodyWrenchNML::operator=(const ApplyBodyWrenchNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ApplyBodyWrenchNML & ApplyBodyWrenchNML::operator=(const ApplyBodyWrench & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ApplyBodyWrench);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ApplyBodyWrenchNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ApplyBodyWrench&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ApplyBodyWrenchNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ApplyBodyWrench> temp(new ApplyBodyWrench());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ApplyBodyWrench::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ApplyBodyWrench Message version mismatch, expected " << ApplyBodyWrench::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ApplyBodyWrench Message version mismatch, expected " << ApplyBodyWrench::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ApplyJointEffortRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ApplyJointEffortRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.joint_name);
        cms->update(inobj.effort);
        nmlupdate(cms,inobj.start_time);
        nmlupdate(cms,inobj.duration);

    }  
 }

ApplyJointEffortRequestNML::ApplyJointEffortRequestNML() : NMLmsg((NMLTYPE)ApplyJointEffortRequest::ID,sizeof(ApplyJointEffortRequestNML)), nmlVersion(ApplyJointEffortRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ApplyJointEffortRequest()*/)
{
};

ApplyJointEffortRequestNML::~ApplyJointEffortRequestNML()
{
};

ApplyJointEffortRequestNML & ApplyJointEffortRequestNML::operator=(const ApplyJointEffortRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ApplyJointEffortRequestNML & ApplyJointEffortRequestNML::operator=(const ApplyJointEffortRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ApplyJointEffortRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ApplyJointEffortRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ApplyJointEffortRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ApplyJointEffortRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ApplyJointEffortRequest> temp(new ApplyJointEffortRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ApplyJointEffortRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ApplyJointEffortRequest Message version mismatch, expected " << ApplyJointEffortRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ApplyJointEffortRequest Message version mismatch, expected " << ApplyJointEffortRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ApplyJointEffortResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ApplyJointEffortResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

ApplyJointEffortResponseNML::ApplyJointEffortResponseNML() : NMLmsg((NMLTYPE)ApplyJointEffortResponse::ID,sizeof(ApplyJointEffortResponseNML)), nmlVersion(ApplyJointEffortResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ApplyJointEffortResponse()*/)
{
};

ApplyJointEffortResponseNML::~ApplyJointEffortResponseNML()
{
};

ApplyJointEffortResponseNML & ApplyJointEffortResponseNML::operator=(const ApplyJointEffortResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ApplyJointEffortResponseNML & ApplyJointEffortResponseNML::operator=(const ApplyJointEffortResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ApplyJointEffortResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ApplyJointEffortResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ApplyJointEffortResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ApplyJointEffortResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ApplyJointEffortResponse> temp(new ApplyJointEffortResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ApplyJointEffortResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ApplyJointEffortResponse Message version mismatch, expected " << ApplyJointEffortResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ApplyJointEffortResponse Message version mismatch, expected " << ApplyJointEffortResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, ApplyJointEffort & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ApplyJointEffort, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

ApplyJointEffortNML::ApplyJointEffortNML() : NMLmsg((NMLTYPE)ApplyJointEffort::ID,sizeof(ApplyJointEffortNML)), nmlVersion(ApplyJointEffort::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ApplyJointEffort()*/)
{
};

ApplyJointEffortNML::~ApplyJointEffortNML()
{
};

ApplyJointEffortNML & ApplyJointEffortNML::operator=(const ApplyJointEffortNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ApplyJointEffortNML & ApplyJointEffortNML::operator=(const ApplyJointEffort & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ApplyJointEffort);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ApplyJointEffortNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ApplyJointEffort&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ApplyJointEffortNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ApplyJointEffort> temp(new ApplyJointEffort());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ApplyJointEffort::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ApplyJointEffort Message version mismatch, expected " << ApplyJointEffort::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ApplyJointEffort Message version mismatch, expected " << ApplyJointEffort::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, BodyRequestRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate BodyRequestRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.body_name);

    }  
 }

BodyRequestRequestNML::BodyRequestRequestNML() : NMLmsg((NMLTYPE)BodyRequestRequest::ID,sizeof(BodyRequestRequestNML)), nmlVersion(BodyRequestRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new BodyRequestRequest()*/)
{
};

BodyRequestRequestNML::~BodyRequestRequestNML()
{
};

BodyRequestRequestNML & BodyRequestRequestNML::operator=(const BodyRequestRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

BodyRequestRequestNML & BodyRequestRequestNML::operator=(const BodyRequestRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(BodyRequestRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void BodyRequestRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<BodyRequestRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: BodyRequestRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<BodyRequestRequest> temp(new BodyRequestRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (BodyRequestRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: BodyRequestRequest Message version mismatch, expected " << BodyRequestRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: BodyRequestRequest Message version mismatch, expected " << BodyRequestRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, BodyRequestResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate BodyRequestResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

BodyRequestResponseNML::BodyRequestResponseNML() : NMLmsg((NMLTYPE)BodyRequestResponse::ID,sizeof(BodyRequestResponseNML)), nmlVersion(BodyRequestResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new BodyRequestResponse()*/)
{
};

BodyRequestResponseNML::~BodyRequestResponseNML()
{
};

BodyRequestResponseNML & BodyRequestResponseNML::operator=(const BodyRequestResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

BodyRequestResponseNML & BodyRequestResponseNML::operator=(const BodyRequestResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(BodyRequestResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void BodyRequestResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<BodyRequestResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: BodyRequestResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<BodyRequestResponse> temp(new BodyRequestResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (BodyRequestResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: BodyRequestResponse Message version mismatch, expected " << BodyRequestResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: BodyRequestResponse Message version mismatch, expected " << BodyRequestResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, BodyRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate BodyRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

BodyRequestNML::BodyRequestNML() : NMLmsg((NMLTYPE)BodyRequest::ID,sizeof(BodyRequestNML)), nmlVersion(BodyRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new BodyRequest()*/)
{
};

BodyRequestNML::~BodyRequestNML()
{
};

BodyRequestNML & BodyRequestNML::operator=(const BodyRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

BodyRequestNML & BodyRequestNML::operator=(const BodyRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(BodyRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void BodyRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<BodyRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: BodyRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<BodyRequest> temp(new BodyRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (BodyRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: BodyRequest Message version mismatch, expected " << BodyRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: BodyRequest Message version mismatch, expected " << BodyRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, DeleteModelRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DeleteModelRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);

    }  
 }

DeleteModelRequestNML::DeleteModelRequestNML() : NMLmsg((NMLTYPE)DeleteModelRequest::ID,sizeof(DeleteModelRequestNML)), nmlVersion(DeleteModelRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DeleteModelRequest()*/)
{
};

DeleteModelRequestNML::~DeleteModelRequestNML()
{
};

DeleteModelRequestNML & DeleteModelRequestNML::operator=(const DeleteModelRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DeleteModelRequestNML & DeleteModelRequestNML::operator=(const DeleteModelRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DeleteModelRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DeleteModelRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DeleteModelRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DeleteModelRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DeleteModelRequest> temp(new DeleteModelRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DeleteModelRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DeleteModelRequest Message version mismatch, expected " << DeleteModelRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DeleteModelRequest Message version mismatch, expected " << DeleteModelRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, DeleteModelResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DeleteModelResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

DeleteModelResponseNML::DeleteModelResponseNML() : NMLmsg((NMLTYPE)DeleteModelResponse::ID,sizeof(DeleteModelResponseNML)), nmlVersion(DeleteModelResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DeleteModelResponse()*/)
{
};

DeleteModelResponseNML::~DeleteModelResponseNML()
{
};

DeleteModelResponseNML & DeleteModelResponseNML::operator=(const DeleteModelResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DeleteModelResponseNML & DeleteModelResponseNML::operator=(const DeleteModelResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DeleteModelResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DeleteModelResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DeleteModelResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DeleteModelResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DeleteModelResponse> temp(new DeleteModelResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DeleteModelResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DeleteModelResponse Message version mismatch, expected " << DeleteModelResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DeleteModelResponse Message version mismatch, expected " << DeleteModelResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, DeleteModel & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DeleteModel, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

DeleteModelNML::DeleteModelNML() : NMLmsg((NMLTYPE)DeleteModel::ID,sizeof(DeleteModelNML)), nmlVersion(DeleteModel::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DeleteModel()*/)
{
};

DeleteModelNML::~DeleteModelNML()
{
};

DeleteModelNML & DeleteModelNML::operator=(const DeleteModelNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DeleteModelNML & DeleteModelNML::operator=(const DeleteModel & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DeleteModel);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DeleteModelNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DeleteModel&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DeleteModelNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DeleteModel> temp(new DeleteModel());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DeleteModel::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DeleteModel Message version mismatch, expected " << DeleteModel::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DeleteModel Message version mismatch, expected " << DeleteModel::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetJointPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetJointPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.joint_name);

    }  
 }

GetJointPropertiesRequestNML::GetJointPropertiesRequestNML() : NMLmsg((NMLTYPE)GetJointPropertiesRequest::ID,sizeof(GetJointPropertiesRequestNML)), nmlVersion(GetJointPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetJointPropertiesRequest()*/)
{
};

GetJointPropertiesRequestNML::~GetJointPropertiesRequestNML()
{
};

GetJointPropertiesRequestNML & GetJointPropertiesRequestNML::operator=(const GetJointPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetJointPropertiesRequestNML & GetJointPropertiesRequestNML::operator=(const GetJointPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetJointPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetJointPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetJointPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetJointPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetJointPropertiesRequest> temp(new GetJointPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetJointPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetJointPropertiesRequest Message version mismatch, expected " << GetJointPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetJointPropertiesRequest Message version mismatch, expected " << GetJointPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetJointPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetJointPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.type);
        nmlupdate(cms,inobj.damping);
        nmlupdate(cms,inobj.position);
        nmlupdate(cms,inobj.rate);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetJointPropertiesResponseNML::GetJointPropertiesResponseNML() : NMLmsg((NMLTYPE)GetJointPropertiesResponse::ID,sizeof(GetJointPropertiesResponseNML)), nmlVersion(GetJointPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetJointPropertiesResponse()*/)
{
};

GetJointPropertiesResponseNML::~GetJointPropertiesResponseNML()
{
};

GetJointPropertiesResponseNML & GetJointPropertiesResponseNML::operator=(const GetJointPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetJointPropertiesResponseNML & GetJointPropertiesResponseNML::operator=(const GetJointPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetJointPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetJointPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetJointPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetJointPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetJointPropertiesResponse> temp(new GetJointPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetJointPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetJointPropertiesResponse Message version mismatch, expected " << GetJointPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetJointPropertiesResponse Message version mismatch, expected " << GetJointPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetJointProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetJointProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetJointPropertiesNML::GetJointPropertiesNML() : NMLmsg((NMLTYPE)GetJointProperties::ID,sizeof(GetJointPropertiesNML)), nmlVersion(GetJointProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetJointProperties()*/)
{
};

GetJointPropertiesNML::~GetJointPropertiesNML()
{
};

GetJointPropertiesNML & GetJointPropertiesNML::operator=(const GetJointPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetJointPropertiesNML & GetJointPropertiesNML::operator=(const GetJointProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetJointProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetJointPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetJointProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetJointPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetJointProperties> temp(new GetJointProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetJointProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetJointProperties Message version mismatch, expected " << GetJointProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetJointProperties Message version mismatch, expected " << GetJointProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetLinkPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetLinkPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.link_name);

    }  
 }

GetLinkPropertiesRequestNML::GetLinkPropertiesRequestNML() : NMLmsg((NMLTYPE)GetLinkPropertiesRequest::ID,sizeof(GetLinkPropertiesRequestNML)), nmlVersion(GetLinkPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetLinkPropertiesRequest()*/)
{
};

GetLinkPropertiesRequestNML::~GetLinkPropertiesRequestNML()
{
};

GetLinkPropertiesRequestNML & GetLinkPropertiesRequestNML::operator=(const GetLinkPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetLinkPropertiesRequestNML & GetLinkPropertiesRequestNML::operator=(const GetLinkPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetLinkPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetLinkPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetLinkPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetLinkPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetLinkPropertiesRequest> temp(new GetLinkPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetLinkPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetLinkPropertiesRequest Message version mismatch, expected " << GetLinkPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetLinkPropertiesRequest Message version mismatch, expected " << GetLinkPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetLinkPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetLinkPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.com);
        cms->update(inobj.gravity_mode);
        cms->update(inobj.mass);
        cms->update(inobj.ixx);
        cms->update(inobj.ixy);
        cms->update(inobj.ixz);
        cms->update(inobj.iyy);
        cms->update(inobj.iyz);
        cms->update(inobj.izz);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetLinkPropertiesResponseNML::GetLinkPropertiesResponseNML() : NMLmsg((NMLTYPE)GetLinkPropertiesResponse::ID,sizeof(GetLinkPropertiesResponseNML)), nmlVersion(GetLinkPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetLinkPropertiesResponse()*/)
{
};

GetLinkPropertiesResponseNML::~GetLinkPropertiesResponseNML()
{
};

GetLinkPropertiesResponseNML & GetLinkPropertiesResponseNML::operator=(const GetLinkPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetLinkPropertiesResponseNML & GetLinkPropertiesResponseNML::operator=(const GetLinkPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetLinkPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetLinkPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetLinkPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetLinkPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetLinkPropertiesResponse> temp(new GetLinkPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetLinkPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetLinkPropertiesResponse Message version mismatch, expected " << GetLinkPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetLinkPropertiesResponse Message version mismatch, expected " << GetLinkPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetLinkProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetLinkProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetLinkPropertiesNML::GetLinkPropertiesNML() : NMLmsg((NMLTYPE)GetLinkProperties::ID,sizeof(GetLinkPropertiesNML)), nmlVersion(GetLinkProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetLinkProperties()*/)
{
};

GetLinkPropertiesNML::~GetLinkPropertiesNML()
{
};

GetLinkPropertiesNML & GetLinkPropertiesNML::operator=(const GetLinkPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetLinkPropertiesNML & GetLinkPropertiesNML::operator=(const GetLinkProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetLinkProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetLinkPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetLinkProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetLinkPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetLinkProperties> temp(new GetLinkProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetLinkProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetLinkProperties Message version mismatch, expected " << GetLinkProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetLinkProperties Message version mismatch, expected " << GetLinkProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetLinkStateRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetLinkStateRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.link_name);
        nmlupdate(cms,inobj.reference_frame);

    }  
 }

GetLinkStateRequestNML::GetLinkStateRequestNML() : NMLmsg((NMLTYPE)GetLinkStateRequest::ID,sizeof(GetLinkStateRequestNML)), nmlVersion(GetLinkStateRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetLinkStateRequest()*/)
{
};

GetLinkStateRequestNML::~GetLinkStateRequestNML()
{
};

GetLinkStateRequestNML & GetLinkStateRequestNML::operator=(const GetLinkStateRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetLinkStateRequestNML & GetLinkStateRequestNML::operator=(const GetLinkStateRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetLinkStateRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetLinkStateRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetLinkStateRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetLinkStateRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetLinkStateRequest> temp(new GetLinkStateRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetLinkStateRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetLinkStateRequest Message version mismatch, expected " << GetLinkStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetLinkStateRequest Message version mismatch, expected " << GetLinkStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetLinkStateResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetLinkStateResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.link_state);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetLinkStateResponseNML::GetLinkStateResponseNML() : NMLmsg((NMLTYPE)GetLinkStateResponse::ID,sizeof(GetLinkStateResponseNML)), nmlVersion(GetLinkStateResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetLinkStateResponse()*/)
{
};

GetLinkStateResponseNML::~GetLinkStateResponseNML()
{
};

GetLinkStateResponseNML & GetLinkStateResponseNML::operator=(const GetLinkStateResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetLinkStateResponseNML & GetLinkStateResponseNML::operator=(const GetLinkStateResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetLinkStateResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetLinkStateResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetLinkStateResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetLinkStateResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetLinkStateResponse> temp(new GetLinkStateResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetLinkStateResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetLinkStateResponse Message version mismatch, expected " << GetLinkStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetLinkStateResponse Message version mismatch, expected " << GetLinkStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetLinkState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetLinkState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetLinkStateNML::GetLinkStateNML() : NMLmsg((NMLTYPE)GetLinkState::ID,sizeof(GetLinkStateNML)), nmlVersion(GetLinkState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetLinkState()*/)
{
};

GetLinkStateNML::~GetLinkStateNML()
{
};

GetLinkStateNML & GetLinkStateNML::operator=(const GetLinkStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetLinkStateNML & GetLinkStateNML::operator=(const GetLinkState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetLinkState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetLinkStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetLinkState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetLinkStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetLinkState> temp(new GetLinkState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetLinkState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetLinkState Message version mismatch, expected " << GetLinkState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetLinkState Message version mismatch, expected " << GetLinkState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetModelPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetModelPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);

    }  
 }

GetModelPropertiesRequestNML::GetModelPropertiesRequestNML() : NMLmsg((NMLTYPE)GetModelPropertiesRequest::ID,sizeof(GetModelPropertiesRequestNML)), nmlVersion(GetModelPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetModelPropertiesRequest()*/)
{
};

GetModelPropertiesRequestNML::~GetModelPropertiesRequestNML()
{
};

GetModelPropertiesRequestNML & GetModelPropertiesRequestNML::operator=(const GetModelPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetModelPropertiesRequestNML & GetModelPropertiesRequestNML::operator=(const GetModelPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetModelPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetModelPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetModelPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetModelPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetModelPropertiesRequest> temp(new GetModelPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetModelPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetModelPropertiesRequest Message version mismatch, expected " << GetModelPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetModelPropertiesRequest Message version mismatch, expected " << GetModelPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetModelPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetModelPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.parent_model_name);
        nmlupdate(cms,inobj.canonical_body_name);
        nmlupdate(cms,inobj.body_names);
        nmlupdate(cms,inobj.geom_names);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.child_model_names);
        cms->update(inobj.is_static);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetModelPropertiesResponseNML::GetModelPropertiesResponseNML() : NMLmsg((NMLTYPE)GetModelPropertiesResponse::ID,sizeof(GetModelPropertiesResponseNML)), nmlVersion(GetModelPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetModelPropertiesResponse()*/)
{
};

GetModelPropertiesResponseNML::~GetModelPropertiesResponseNML()
{
};

GetModelPropertiesResponseNML & GetModelPropertiesResponseNML::operator=(const GetModelPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetModelPropertiesResponseNML & GetModelPropertiesResponseNML::operator=(const GetModelPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetModelPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetModelPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetModelPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetModelPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetModelPropertiesResponse> temp(new GetModelPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetModelPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetModelPropertiesResponse Message version mismatch, expected " << GetModelPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetModelPropertiesResponse Message version mismatch, expected " << GetModelPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetModelProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetModelProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetModelPropertiesNML::GetModelPropertiesNML() : NMLmsg((NMLTYPE)GetModelProperties::ID,sizeof(GetModelPropertiesNML)), nmlVersion(GetModelProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetModelProperties()*/)
{
};

GetModelPropertiesNML::~GetModelPropertiesNML()
{
};

GetModelPropertiesNML & GetModelPropertiesNML::operator=(const GetModelPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetModelPropertiesNML & GetModelPropertiesNML::operator=(const GetModelProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetModelProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetModelPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetModelProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetModelPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetModelProperties> temp(new GetModelProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetModelProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetModelProperties Message version mismatch, expected " << GetModelProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetModelProperties Message version mismatch, expected " << GetModelProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetModelStateRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetModelStateRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);
        nmlupdate(cms,inobj.relative_entity_name);

    }  
 }

GetModelStateRequestNML::GetModelStateRequestNML() : NMLmsg((NMLTYPE)GetModelStateRequest::ID,sizeof(GetModelStateRequestNML)), nmlVersion(GetModelStateRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetModelStateRequest()*/)
{
};

GetModelStateRequestNML::~GetModelStateRequestNML()
{
};

GetModelStateRequestNML & GetModelStateRequestNML::operator=(const GetModelStateRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetModelStateRequestNML & GetModelStateRequestNML::operator=(const GetModelStateRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetModelStateRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetModelStateRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetModelStateRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetModelStateRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetModelStateRequest> temp(new GetModelStateRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetModelStateRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetModelStateRequest Message version mismatch, expected " << GetModelStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetModelStateRequest Message version mismatch, expected " << GetModelStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetModelStateResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetModelStateResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.pose);
        nmlupdate(cms,inobj.twist);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetModelStateResponseNML::GetModelStateResponseNML() : NMLmsg((NMLTYPE)GetModelStateResponse::ID,sizeof(GetModelStateResponseNML)), nmlVersion(GetModelStateResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetModelStateResponse()*/)
{
};

GetModelStateResponseNML::~GetModelStateResponseNML()
{
};

GetModelStateResponseNML & GetModelStateResponseNML::operator=(const GetModelStateResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetModelStateResponseNML & GetModelStateResponseNML::operator=(const GetModelStateResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetModelStateResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetModelStateResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetModelStateResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetModelStateResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetModelStateResponse> temp(new GetModelStateResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetModelStateResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetModelStateResponse Message version mismatch, expected " << GetModelStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetModelStateResponse Message version mismatch, expected " << GetModelStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetModelState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetModelState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetModelStateNML::GetModelStateNML() : NMLmsg((NMLTYPE)GetModelState::ID,sizeof(GetModelStateNML)), nmlVersion(GetModelState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetModelState()*/)
{
};

GetModelStateNML::~GetModelStateNML()
{
};

GetModelStateNML & GetModelStateNML::operator=(const GetModelStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetModelStateNML & GetModelStateNML::operator=(const GetModelState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetModelState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetModelStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetModelState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetModelStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetModelState> temp(new GetModelState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetModelState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetModelState Message version mismatch, expected " << GetModelState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetModelState Message version mismatch, expected " << GetModelState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetPhysicsPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPhysicsPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

GetPhysicsPropertiesRequestNML::GetPhysicsPropertiesRequestNML() : NMLmsg((NMLTYPE)GetPhysicsPropertiesRequest::ID,sizeof(GetPhysicsPropertiesRequestNML)), nmlVersion(GetPhysicsPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPhysicsPropertiesRequest()*/)
{
};

GetPhysicsPropertiesRequestNML::~GetPhysicsPropertiesRequestNML()
{
};

GetPhysicsPropertiesRequestNML & GetPhysicsPropertiesRequestNML::operator=(const GetPhysicsPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPhysicsPropertiesRequestNML & GetPhysicsPropertiesRequestNML::operator=(const GetPhysicsPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPhysicsPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPhysicsPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPhysicsPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPhysicsPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPhysicsPropertiesRequest> temp(new GetPhysicsPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPhysicsPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPhysicsPropertiesRequest Message version mismatch, expected " << GetPhysicsPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPhysicsPropertiesRequest Message version mismatch, expected " << GetPhysicsPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetPhysicsPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPhysicsPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.time_step);
        cms->update(inobj.pause);
        cms->update(inobj.max_update_rate);
        nmlupdate(cms,inobj.gravity);
        nmlupdate(cms,inobj.ode_config);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetPhysicsPropertiesResponseNML::GetPhysicsPropertiesResponseNML() : NMLmsg((NMLTYPE)GetPhysicsPropertiesResponse::ID,sizeof(GetPhysicsPropertiesResponseNML)), nmlVersion(GetPhysicsPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPhysicsPropertiesResponse()*/)
{
};

GetPhysicsPropertiesResponseNML::~GetPhysicsPropertiesResponseNML()
{
};

GetPhysicsPropertiesResponseNML & GetPhysicsPropertiesResponseNML::operator=(const GetPhysicsPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPhysicsPropertiesResponseNML & GetPhysicsPropertiesResponseNML::operator=(const GetPhysicsPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPhysicsPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPhysicsPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPhysicsPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPhysicsPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPhysicsPropertiesResponse> temp(new GetPhysicsPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPhysicsPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPhysicsPropertiesResponse Message version mismatch, expected " << GetPhysicsPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPhysicsPropertiesResponse Message version mismatch, expected " << GetPhysicsPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetPhysicsProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetPhysicsProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetPhysicsPropertiesNML::GetPhysicsPropertiesNML() : NMLmsg((NMLTYPE)GetPhysicsProperties::ID,sizeof(GetPhysicsPropertiesNML)), nmlVersion(GetPhysicsProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetPhysicsProperties()*/)
{
};

GetPhysicsPropertiesNML::~GetPhysicsPropertiesNML()
{
};

GetPhysicsPropertiesNML & GetPhysicsPropertiesNML::operator=(const GetPhysicsPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetPhysicsPropertiesNML & GetPhysicsPropertiesNML::operator=(const GetPhysicsProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetPhysicsProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetPhysicsPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetPhysicsProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetPhysicsPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetPhysicsProperties> temp(new GetPhysicsProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetPhysicsProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetPhysicsProperties Message version mismatch, expected " << GetPhysicsProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetPhysicsProperties Message version mismatch, expected " << GetPhysicsProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetWorldPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetWorldPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

GetWorldPropertiesRequestNML::GetWorldPropertiesRequestNML() : NMLmsg((NMLTYPE)GetWorldPropertiesRequest::ID,sizeof(GetWorldPropertiesRequestNML)), nmlVersion(GetWorldPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetWorldPropertiesRequest()*/)
{
};

GetWorldPropertiesRequestNML::~GetWorldPropertiesRequestNML()
{
};

GetWorldPropertiesRequestNML & GetWorldPropertiesRequestNML::operator=(const GetWorldPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetWorldPropertiesRequestNML & GetWorldPropertiesRequestNML::operator=(const GetWorldPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetWorldPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetWorldPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetWorldPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetWorldPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetWorldPropertiesRequest> temp(new GetWorldPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetWorldPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetWorldPropertiesRequest Message version mismatch, expected " << GetWorldPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetWorldPropertiesRequest Message version mismatch, expected " << GetWorldPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetWorldPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetWorldPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.sim_time);
        nmlupdate(cms,inobj.model_names);
        cms->update(inobj.rendering_enabled);
        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

GetWorldPropertiesResponseNML::GetWorldPropertiesResponseNML() : NMLmsg((NMLTYPE)GetWorldPropertiesResponse::ID,sizeof(GetWorldPropertiesResponseNML)), nmlVersion(GetWorldPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetWorldPropertiesResponse()*/)
{
};

GetWorldPropertiesResponseNML::~GetWorldPropertiesResponseNML()
{
};

GetWorldPropertiesResponseNML & GetWorldPropertiesResponseNML::operator=(const GetWorldPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetWorldPropertiesResponseNML & GetWorldPropertiesResponseNML::operator=(const GetWorldPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetWorldPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetWorldPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetWorldPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetWorldPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetWorldPropertiesResponse> temp(new GetWorldPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetWorldPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetWorldPropertiesResponse Message version mismatch, expected " << GetWorldPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetWorldPropertiesResponse Message version mismatch, expected " << GetWorldPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, GetWorldProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GetWorldProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

GetWorldPropertiesNML::GetWorldPropertiesNML() : NMLmsg((NMLTYPE)GetWorldProperties::ID,sizeof(GetWorldPropertiesNML)), nmlVersion(GetWorldProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GetWorldProperties()*/)
{
};

GetWorldPropertiesNML::~GetWorldPropertiesNML()
{
};

GetWorldPropertiesNML & GetWorldPropertiesNML::operator=(const GetWorldPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GetWorldPropertiesNML & GetWorldPropertiesNML::operator=(const GetWorldProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GetWorldProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GetWorldPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GetWorldProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GetWorldPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GetWorldProperties> temp(new GetWorldProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GetWorldProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GetWorldProperties Message version mismatch, expected " << GetWorldProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GetWorldProperties Message version mismatch, expected " << GetWorldProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, JointRequestRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointRequestRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.joint_name);

    }  
 }

JointRequestRequestNML::JointRequestRequestNML() : NMLmsg((NMLTYPE)JointRequestRequest::ID,sizeof(JointRequestRequestNML)), nmlVersion(JointRequestRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointRequestRequest()*/)
{
};

JointRequestRequestNML::~JointRequestRequestNML()
{
};

JointRequestRequestNML & JointRequestRequestNML::operator=(const JointRequestRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointRequestRequestNML & JointRequestRequestNML::operator=(const JointRequestRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointRequestRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointRequestRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointRequestRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointRequestRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointRequestRequest> temp(new JointRequestRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointRequestRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointRequestRequest Message version mismatch, expected " << JointRequestRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointRequestRequest Message version mismatch, expected " << JointRequestRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, JointRequestResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointRequestResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

JointRequestResponseNML::JointRequestResponseNML() : NMLmsg((NMLTYPE)JointRequestResponse::ID,sizeof(JointRequestResponseNML)), nmlVersion(JointRequestResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointRequestResponse()*/)
{
};

JointRequestResponseNML::~JointRequestResponseNML()
{
};

JointRequestResponseNML & JointRequestResponseNML::operator=(const JointRequestResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointRequestResponseNML & JointRequestResponseNML::operator=(const JointRequestResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointRequestResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointRequestResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointRequestResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointRequestResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointRequestResponse> temp(new JointRequestResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointRequestResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointRequestResponse Message version mismatch, expected " << JointRequestResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointRequestResponse Message version mismatch, expected " << JointRequestResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, JointRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

JointRequestNML::JointRequestNML() : NMLmsg((NMLTYPE)JointRequest::ID,sizeof(JointRequestNML)), nmlVersion(JointRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointRequest()*/)
{
};

JointRequestNML::~JointRequestNML()
{
};

JointRequestNML & JointRequestNML::operator=(const JointRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointRequestNML & JointRequestNML::operator=(const JointRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointRequest> temp(new JointRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointRequest Message version mismatch, expected " << JointRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointRequest Message version mismatch, expected " << JointRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetJointPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetJointPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.joint_name);
        nmlupdate(cms,inobj.ode_joint_config);

    }  
 }

SetJointPropertiesRequestNML::SetJointPropertiesRequestNML() : NMLmsg((NMLTYPE)SetJointPropertiesRequest::ID,sizeof(SetJointPropertiesRequestNML)), nmlVersion(SetJointPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetJointPropertiesRequest()*/)
{
};

SetJointPropertiesRequestNML::~SetJointPropertiesRequestNML()
{
};

SetJointPropertiesRequestNML & SetJointPropertiesRequestNML::operator=(const SetJointPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetJointPropertiesRequestNML & SetJointPropertiesRequestNML::operator=(const SetJointPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetJointPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetJointPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetJointPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetJointPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetJointPropertiesRequest> temp(new SetJointPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetJointPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetJointPropertiesRequest Message version mismatch, expected " << SetJointPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetJointPropertiesRequest Message version mismatch, expected " << SetJointPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetJointPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetJointPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetJointPropertiesResponseNML::SetJointPropertiesResponseNML() : NMLmsg((NMLTYPE)SetJointPropertiesResponse::ID,sizeof(SetJointPropertiesResponseNML)), nmlVersion(SetJointPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetJointPropertiesResponse()*/)
{
};

SetJointPropertiesResponseNML::~SetJointPropertiesResponseNML()
{
};

SetJointPropertiesResponseNML & SetJointPropertiesResponseNML::operator=(const SetJointPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetJointPropertiesResponseNML & SetJointPropertiesResponseNML::operator=(const SetJointPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetJointPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetJointPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetJointPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetJointPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetJointPropertiesResponse> temp(new SetJointPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetJointPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetJointPropertiesResponse Message version mismatch, expected " << SetJointPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetJointPropertiesResponse Message version mismatch, expected " << SetJointPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetJointProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetJointProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetJointPropertiesNML::SetJointPropertiesNML() : NMLmsg((NMLTYPE)SetJointProperties::ID,sizeof(SetJointPropertiesNML)), nmlVersion(SetJointProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetJointProperties()*/)
{
};

SetJointPropertiesNML::~SetJointPropertiesNML()
{
};

SetJointPropertiesNML & SetJointPropertiesNML::operator=(const SetJointPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetJointPropertiesNML & SetJointPropertiesNML::operator=(const SetJointProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetJointProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetJointPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetJointProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetJointPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetJointProperties> temp(new SetJointProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetJointProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetJointProperties Message version mismatch, expected " << SetJointProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetJointProperties Message version mismatch, expected " << SetJointProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetJointTrajectoryRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetJointTrajectoryRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);
        nmlupdate(cms,inobj.joint_trajectory);
        nmlupdate(cms,inobj.model_pose);
        cms->update(inobj.set_model_pose);
        cms->update(inobj.disable_physics_updates);

    }  
 }

SetJointTrajectoryRequestNML::SetJointTrajectoryRequestNML() : NMLmsg((NMLTYPE)SetJointTrajectoryRequest::ID,sizeof(SetJointTrajectoryRequestNML)), nmlVersion(SetJointTrajectoryRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetJointTrajectoryRequest()*/)
{
};

SetJointTrajectoryRequestNML::~SetJointTrajectoryRequestNML()
{
};

SetJointTrajectoryRequestNML & SetJointTrajectoryRequestNML::operator=(const SetJointTrajectoryRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetJointTrajectoryRequestNML & SetJointTrajectoryRequestNML::operator=(const SetJointTrajectoryRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetJointTrajectoryRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetJointTrajectoryRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetJointTrajectoryRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetJointTrajectoryRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetJointTrajectoryRequest> temp(new SetJointTrajectoryRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetJointTrajectoryRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetJointTrajectoryRequest Message version mismatch, expected " << SetJointTrajectoryRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetJointTrajectoryRequest Message version mismatch, expected " << SetJointTrajectoryRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetJointTrajectoryResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetJointTrajectoryResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetJointTrajectoryResponseNML::SetJointTrajectoryResponseNML() : NMLmsg((NMLTYPE)SetJointTrajectoryResponse::ID,sizeof(SetJointTrajectoryResponseNML)), nmlVersion(SetJointTrajectoryResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetJointTrajectoryResponse()*/)
{
};

SetJointTrajectoryResponseNML::~SetJointTrajectoryResponseNML()
{
};

SetJointTrajectoryResponseNML & SetJointTrajectoryResponseNML::operator=(const SetJointTrajectoryResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetJointTrajectoryResponseNML & SetJointTrajectoryResponseNML::operator=(const SetJointTrajectoryResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetJointTrajectoryResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetJointTrajectoryResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetJointTrajectoryResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetJointTrajectoryResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetJointTrajectoryResponse> temp(new SetJointTrajectoryResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetJointTrajectoryResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetJointTrajectoryResponse Message version mismatch, expected " << SetJointTrajectoryResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetJointTrajectoryResponse Message version mismatch, expected " << SetJointTrajectoryResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetJointTrajectory & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetJointTrajectory, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetJointTrajectoryNML::SetJointTrajectoryNML() : NMLmsg((NMLTYPE)SetJointTrajectory::ID,sizeof(SetJointTrajectoryNML)), nmlVersion(SetJointTrajectory::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetJointTrajectory()*/)
{
};

SetJointTrajectoryNML::~SetJointTrajectoryNML()
{
};

SetJointTrajectoryNML & SetJointTrajectoryNML::operator=(const SetJointTrajectoryNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetJointTrajectoryNML & SetJointTrajectoryNML::operator=(const SetJointTrajectory & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetJointTrajectory);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetJointTrajectoryNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetJointTrajectory&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetJointTrajectoryNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetJointTrajectory> temp(new SetJointTrajectory());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetJointTrajectory::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetJointTrajectory Message version mismatch, expected " << SetJointTrajectory::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetJointTrajectory Message version mismatch, expected " << SetJointTrajectory::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetLinkPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetLinkPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.link_name);
        nmlupdate(cms,inobj.com);
        cms->update(inobj.gravity_mode);
        cms->update(inobj.mass);
        cms->update(inobj.ixx);
        cms->update(inobj.ixy);
        cms->update(inobj.ixz);
        cms->update(inobj.iyy);
        cms->update(inobj.iyz);
        cms->update(inobj.izz);

    }  
 }

SetLinkPropertiesRequestNML::SetLinkPropertiesRequestNML() : NMLmsg((NMLTYPE)SetLinkPropertiesRequest::ID,sizeof(SetLinkPropertiesRequestNML)), nmlVersion(SetLinkPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetLinkPropertiesRequest()*/)
{
};

SetLinkPropertiesRequestNML::~SetLinkPropertiesRequestNML()
{
};

SetLinkPropertiesRequestNML & SetLinkPropertiesRequestNML::operator=(const SetLinkPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetLinkPropertiesRequestNML & SetLinkPropertiesRequestNML::operator=(const SetLinkPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetLinkPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetLinkPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetLinkPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetLinkPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetLinkPropertiesRequest> temp(new SetLinkPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetLinkPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetLinkPropertiesRequest Message version mismatch, expected " << SetLinkPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetLinkPropertiesRequest Message version mismatch, expected " << SetLinkPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetLinkPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetLinkPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetLinkPropertiesResponseNML::SetLinkPropertiesResponseNML() : NMLmsg((NMLTYPE)SetLinkPropertiesResponse::ID,sizeof(SetLinkPropertiesResponseNML)), nmlVersion(SetLinkPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetLinkPropertiesResponse()*/)
{
};

SetLinkPropertiesResponseNML::~SetLinkPropertiesResponseNML()
{
};

SetLinkPropertiesResponseNML & SetLinkPropertiesResponseNML::operator=(const SetLinkPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetLinkPropertiesResponseNML & SetLinkPropertiesResponseNML::operator=(const SetLinkPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetLinkPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetLinkPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetLinkPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetLinkPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetLinkPropertiesResponse> temp(new SetLinkPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetLinkPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetLinkPropertiesResponse Message version mismatch, expected " << SetLinkPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetLinkPropertiesResponse Message version mismatch, expected " << SetLinkPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetLinkProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetLinkProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetLinkPropertiesNML::SetLinkPropertiesNML() : NMLmsg((NMLTYPE)SetLinkProperties::ID,sizeof(SetLinkPropertiesNML)), nmlVersion(SetLinkProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetLinkProperties()*/)
{
};

SetLinkPropertiesNML::~SetLinkPropertiesNML()
{
};

SetLinkPropertiesNML & SetLinkPropertiesNML::operator=(const SetLinkPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetLinkPropertiesNML & SetLinkPropertiesNML::operator=(const SetLinkProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetLinkProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetLinkPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetLinkProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetLinkPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetLinkProperties> temp(new SetLinkProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetLinkProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetLinkProperties Message version mismatch, expected " << SetLinkProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetLinkProperties Message version mismatch, expected " << SetLinkProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetLinkStateRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetLinkStateRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.link_state);

    }  
 }

SetLinkStateRequestNML::SetLinkStateRequestNML() : NMLmsg((NMLTYPE)SetLinkStateRequest::ID,sizeof(SetLinkStateRequestNML)), nmlVersion(SetLinkStateRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetLinkStateRequest()*/)
{
};

SetLinkStateRequestNML::~SetLinkStateRequestNML()
{
};

SetLinkStateRequestNML & SetLinkStateRequestNML::operator=(const SetLinkStateRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetLinkStateRequestNML & SetLinkStateRequestNML::operator=(const SetLinkStateRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetLinkStateRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetLinkStateRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetLinkStateRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetLinkStateRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetLinkStateRequest> temp(new SetLinkStateRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetLinkStateRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetLinkStateRequest Message version mismatch, expected " << SetLinkStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetLinkStateRequest Message version mismatch, expected " << SetLinkStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetLinkStateResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetLinkStateResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetLinkStateResponseNML::SetLinkStateResponseNML() : NMLmsg((NMLTYPE)SetLinkStateResponse::ID,sizeof(SetLinkStateResponseNML)), nmlVersion(SetLinkStateResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetLinkStateResponse()*/)
{
};

SetLinkStateResponseNML::~SetLinkStateResponseNML()
{
};

SetLinkStateResponseNML & SetLinkStateResponseNML::operator=(const SetLinkStateResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetLinkStateResponseNML & SetLinkStateResponseNML::operator=(const SetLinkStateResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetLinkStateResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetLinkStateResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetLinkStateResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetLinkStateResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetLinkStateResponse> temp(new SetLinkStateResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetLinkStateResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetLinkStateResponse Message version mismatch, expected " << SetLinkStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetLinkStateResponse Message version mismatch, expected " << SetLinkStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetLinkState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetLinkState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetLinkStateNML::SetLinkStateNML() : NMLmsg((NMLTYPE)SetLinkState::ID,sizeof(SetLinkStateNML)), nmlVersion(SetLinkState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetLinkState()*/)
{
};

SetLinkStateNML::~SetLinkStateNML()
{
};

SetLinkStateNML & SetLinkStateNML::operator=(const SetLinkStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetLinkStateNML & SetLinkStateNML::operator=(const SetLinkState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetLinkState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetLinkStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetLinkState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetLinkStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetLinkState> temp(new SetLinkState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetLinkState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetLinkState Message version mismatch, expected " << SetLinkState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetLinkState Message version mismatch, expected " << SetLinkState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetModelConfigurationRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetModelConfigurationRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);
        nmlupdate(cms,inobj.urdf_param_name);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.joint_positions);

    }  
 }

SetModelConfigurationRequestNML::SetModelConfigurationRequestNML() : NMLmsg((NMLTYPE)SetModelConfigurationRequest::ID,sizeof(SetModelConfigurationRequestNML)), nmlVersion(SetModelConfigurationRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetModelConfigurationRequest()*/)
{
};

SetModelConfigurationRequestNML::~SetModelConfigurationRequestNML()
{
};

SetModelConfigurationRequestNML & SetModelConfigurationRequestNML::operator=(const SetModelConfigurationRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetModelConfigurationRequestNML & SetModelConfigurationRequestNML::operator=(const SetModelConfigurationRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetModelConfigurationRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetModelConfigurationRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetModelConfigurationRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetModelConfigurationRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetModelConfigurationRequest> temp(new SetModelConfigurationRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetModelConfigurationRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetModelConfigurationRequest Message version mismatch, expected " << SetModelConfigurationRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetModelConfigurationRequest Message version mismatch, expected " << SetModelConfigurationRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetModelConfigurationResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetModelConfigurationResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetModelConfigurationResponseNML::SetModelConfigurationResponseNML() : NMLmsg((NMLTYPE)SetModelConfigurationResponse::ID,sizeof(SetModelConfigurationResponseNML)), nmlVersion(SetModelConfigurationResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetModelConfigurationResponse()*/)
{
};

SetModelConfigurationResponseNML::~SetModelConfigurationResponseNML()
{
};

SetModelConfigurationResponseNML & SetModelConfigurationResponseNML::operator=(const SetModelConfigurationResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetModelConfigurationResponseNML & SetModelConfigurationResponseNML::operator=(const SetModelConfigurationResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetModelConfigurationResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetModelConfigurationResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetModelConfigurationResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetModelConfigurationResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetModelConfigurationResponse> temp(new SetModelConfigurationResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetModelConfigurationResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetModelConfigurationResponse Message version mismatch, expected " << SetModelConfigurationResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetModelConfigurationResponse Message version mismatch, expected " << SetModelConfigurationResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetModelConfiguration & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetModelConfiguration, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetModelConfigurationNML::SetModelConfigurationNML() : NMLmsg((NMLTYPE)SetModelConfiguration::ID,sizeof(SetModelConfigurationNML)), nmlVersion(SetModelConfiguration::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetModelConfiguration()*/)
{
};

SetModelConfigurationNML::~SetModelConfigurationNML()
{
};

SetModelConfigurationNML & SetModelConfigurationNML::operator=(const SetModelConfigurationNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetModelConfigurationNML & SetModelConfigurationNML::operator=(const SetModelConfiguration & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetModelConfiguration);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetModelConfigurationNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetModelConfiguration&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetModelConfigurationNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetModelConfiguration> temp(new SetModelConfiguration());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetModelConfiguration::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetModelConfiguration Message version mismatch, expected " << SetModelConfiguration::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetModelConfiguration Message version mismatch, expected " << SetModelConfiguration::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetModelStateRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetModelStateRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_state);

    }  
 }

SetModelStateRequestNML::SetModelStateRequestNML() : NMLmsg((NMLTYPE)SetModelStateRequest::ID,sizeof(SetModelStateRequestNML)), nmlVersion(SetModelStateRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetModelStateRequest()*/)
{
};

SetModelStateRequestNML::~SetModelStateRequestNML()
{
};

SetModelStateRequestNML & SetModelStateRequestNML::operator=(const SetModelStateRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetModelStateRequestNML & SetModelStateRequestNML::operator=(const SetModelStateRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetModelStateRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetModelStateRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetModelStateRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetModelStateRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetModelStateRequest> temp(new SetModelStateRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetModelStateRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetModelStateRequest Message version mismatch, expected " << SetModelStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetModelStateRequest Message version mismatch, expected " << SetModelStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetModelStateResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetModelStateResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetModelStateResponseNML::SetModelStateResponseNML() : NMLmsg((NMLTYPE)SetModelStateResponse::ID,sizeof(SetModelStateResponseNML)), nmlVersion(SetModelStateResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetModelStateResponse()*/)
{
};

SetModelStateResponseNML::~SetModelStateResponseNML()
{
};

SetModelStateResponseNML & SetModelStateResponseNML::operator=(const SetModelStateResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetModelStateResponseNML & SetModelStateResponseNML::operator=(const SetModelStateResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetModelStateResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetModelStateResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetModelStateResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetModelStateResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetModelStateResponse> temp(new SetModelStateResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetModelStateResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetModelStateResponse Message version mismatch, expected " << SetModelStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetModelStateResponse Message version mismatch, expected " << SetModelStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetModelState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetModelState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetModelStateNML::SetModelStateNML() : NMLmsg((NMLTYPE)SetModelState::ID,sizeof(SetModelStateNML)), nmlVersion(SetModelState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetModelState()*/)
{
};

SetModelStateNML::~SetModelStateNML()
{
};

SetModelStateNML & SetModelStateNML::operator=(const SetModelStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetModelStateNML & SetModelStateNML::operator=(const SetModelState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetModelState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetModelStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetModelState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetModelStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetModelState> temp(new SetModelState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetModelState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetModelState Message version mismatch, expected " << SetModelState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetModelState Message version mismatch, expected " << SetModelState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetPhysicsPropertiesRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetPhysicsPropertiesRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.time_step);
        cms->update(inobj.max_update_rate);
        nmlupdate(cms,inobj.gravity);
        nmlupdate(cms,inobj.ode_config);

    }  
 }

SetPhysicsPropertiesRequestNML::SetPhysicsPropertiesRequestNML() : NMLmsg((NMLTYPE)SetPhysicsPropertiesRequest::ID,sizeof(SetPhysicsPropertiesRequestNML)), nmlVersion(SetPhysicsPropertiesRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetPhysicsPropertiesRequest()*/)
{
};

SetPhysicsPropertiesRequestNML::~SetPhysicsPropertiesRequestNML()
{
};

SetPhysicsPropertiesRequestNML & SetPhysicsPropertiesRequestNML::operator=(const SetPhysicsPropertiesRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetPhysicsPropertiesRequestNML & SetPhysicsPropertiesRequestNML::operator=(const SetPhysicsPropertiesRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetPhysicsPropertiesRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetPhysicsPropertiesRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetPhysicsPropertiesRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetPhysicsPropertiesRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetPhysicsPropertiesRequest> temp(new SetPhysicsPropertiesRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetPhysicsPropertiesRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetPhysicsPropertiesRequest Message version mismatch, expected " << SetPhysicsPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetPhysicsPropertiesRequest Message version mismatch, expected " << SetPhysicsPropertiesRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetPhysicsPropertiesResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetPhysicsPropertiesResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SetPhysicsPropertiesResponseNML::SetPhysicsPropertiesResponseNML() : NMLmsg((NMLTYPE)SetPhysicsPropertiesResponse::ID,sizeof(SetPhysicsPropertiesResponseNML)), nmlVersion(SetPhysicsPropertiesResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetPhysicsPropertiesResponse()*/)
{
};

SetPhysicsPropertiesResponseNML::~SetPhysicsPropertiesResponseNML()
{
};

SetPhysicsPropertiesResponseNML & SetPhysicsPropertiesResponseNML::operator=(const SetPhysicsPropertiesResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetPhysicsPropertiesResponseNML & SetPhysicsPropertiesResponseNML::operator=(const SetPhysicsPropertiesResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetPhysicsPropertiesResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetPhysicsPropertiesResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetPhysicsPropertiesResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetPhysicsPropertiesResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetPhysicsPropertiesResponse> temp(new SetPhysicsPropertiesResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetPhysicsPropertiesResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetPhysicsPropertiesResponse Message version mismatch, expected " << SetPhysicsPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetPhysicsPropertiesResponse Message version mismatch, expected " << SetPhysicsPropertiesResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SetPhysicsProperties & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SetPhysicsProperties, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SetPhysicsPropertiesNML::SetPhysicsPropertiesNML() : NMLmsg((NMLTYPE)SetPhysicsProperties::ID,sizeof(SetPhysicsPropertiesNML)), nmlVersion(SetPhysicsProperties::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SetPhysicsProperties()*/)
{
};

SetPhysicsPropertiesNML::~SetPhysicsPropertiesNML()
{
};

SetPhysicsPropertiesNML & SetPhysicsPropertiesNML::operator=(const SetPhysicsPropertiesNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SetPhysicsPropertiesNML & SetPhysicsPropertiesNML::operator=(const SetPhysicsProperties & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SetPhysicsProperties);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SetPhysicsPropertiesNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SetPhysicsProperties&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SetPhysicsPropertiesNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SetPhysicsProperties> temp(new SetPhysicsProperties());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SetPhysicsProperties::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SetPhysicsProperties Message version mismatch, expected " << SetPhysicsProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SetPhysicsProperties Message version mismatch, expected " << SetPhysicsProperties::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SpawnModelRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SpawnModelRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.model_name);
        nmlupdate(cms,inobj.model_xml);
        nmlupdate(cms,inobj.robot_namespace);
        nmlupdate(cms,inobj.initial_pose);
        nmlupdate(cms,inobj.reference_frame);

    }  
 }

SpawnModelRequestNML::SpawnModelRequestNML() : NMLmsg((NMLTYPE)SpawnModelRequest::ID,sizeof(SpawnModelRequestNML)), nmlVersion(SpawnModelRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SpawnModelRequest()*/)
{
};

SpawnModelRequestNML::~SpawnModelRequestNML()
{
};

SpawnModelRequestNML & SpawnModelRequestNML::operator=(const SpawnModelRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SpawnModelRequestNML & SpawnModelRequestNML::operator=(const SpawnModelRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SpawnModelRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SpawnModelRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SpawnModelRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SpawnModelRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SpawnModelRequest> temp(new SpawnModelRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SpawnModelRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SpawnModelRequest Message version mismatch, expected " << SpawnModelRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SpawnModelRequest Message version mismatch, expected " << SpawnModelRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SpawnModelResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SpawnModelResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.success);
        nmlupdate(cms,inobj.status_message);

    }  
 }

SpawnModelResponseNML::SpawnModelResponseNML() : NMLmsg((NMLTYPE)SpawnModelResponse::ID,sizeof(SpawnModelResponseNML)), nmlVersion(SpawnModelResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SpawnModelResponse()*/)
{
};

SpawnModelResponseNML::~SpawnModelResponseNML()
{
};

SpawnModelResponseNML & SpawnModelResponseNML::operator=(const SpawnModelResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SpawnModelResponseNML & SpawnModelResponseNML::operator=(const SpawnModelResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SpawnModelResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SpawnModelResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SpawnModelResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SpawnModelResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SpawnModelResponse> temp(new SpawnModelResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SpawnModelResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SpawnModelResponse Message version mismatch, expected " << SpawnModelResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SpawnModelResponse Message version mismatch, expected " << SpawnModelResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void gazebo_msgs::nmlupdate(CMS * cms, SpawnModel & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SpawnModel, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

SpawnModelNML::SpawnModelNML() : NMLmsg((NMLTYPE)SpawnModel::ID,sizeof(SpawnModelNML)), nmlVersion(SpawnModel::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SpawnModel()*/)
{
};

SpawnModelNML::~SpawnModelNML()
{
};

SpawnModelNML & SpawnModelNML::operator=(const SpawnModelNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SpawnModelNML & SpawnModelNML::operator=(const SpawnModel & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SpawnModel);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SpawnModelNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SpawnModel&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SpawnModelNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SpawnModel> temp(new SpawnModel());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: gazebo_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SpawnModel::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SpawnModel Message version mismatch, expected " << SpawnModel::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SpawnModel Message version mismatch, expected " << SpawnModel::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int gazebo_msgs::gazebo_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("gazebo_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case ContactState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ContactState, id " << ContactState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ContactStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ContactsState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ContactsState, id " << ContactsState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ContactsStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LinkState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LinkState, id " << LinkState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LinkStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LinkStates::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LinkStates, id " << LinkStates::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LinkStatesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ModelState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ModelState, id " << ModelState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ModelStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ModelStates::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ModelStates, id " << ModelStates::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ModelStatesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ODEJointProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ODEJointProperties, id " << ODEJointProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ODEJointPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ODEPhysics::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ODEPhysics, id " << ODEPhysics::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ODEPhysicsNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case WorldState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for WorldState, id " << WorldState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((WorldStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ApplyBodyWrenchRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ApplyBodyWrenchRequest, id " << ApplyBodyWrenchRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ApplyBodyWrenchRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ApplyBodyWrenchResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ApplyBodyWrenchResponse, id " << ApplyBodyWrenchResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ApplyBodyWrenchResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ApplyBodyWrench::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ApplyBodyWrench, id " << ApplyBodyWrench::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ApplyBodyWrenchNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ApplyJointEffortRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ApplyJointEffortRequest, id " << ApplyJointEffortRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ApplyJointEffortRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ApplyJointEffortResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ApplyJointEffortResponse, id " << ApplyJointEffortResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ApplyJointEffortResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ApplyJointEffort::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ApplyJointEffort, id " << ApplyJointEffort::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ApplyJointEffortNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case BodyRequestRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for BodyRequestRequest, id " << BodyRequestRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((BodyRequestRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case BodyRequestResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for BodyRequestResponse, id " << BodyRequestResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((BodyRequestResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case BodyRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for BodyRequest, id " << BodyRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((BodyRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DeleteModelRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DeleteModelRequest, id " << DeleteModelRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DeleteModelRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DeleteModelResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DeleteModelResponse, id " << DeleteModelResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DeleteModelResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DeleteModel::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DeleteModel, id " << DeleteModel::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DeleteModelNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetJointPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetJointPropertiesRequest, id " << GetJointPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetJointPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetJointPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetJointPropertiesResponse, id " << GetJointPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetJointPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetJointProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetJointProperties, id " << GetJointProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetJointPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetLinkPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetLinkPropertiesRequest, id " << GetLinkPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetLinkPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetLinkPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetLinkPropertiesResponse, id " << GetLinkPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetLinkPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetLinkProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetLinkProperties, id " << GetLinkProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetLinkPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetLinkStateRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetLinkStateRequest, id " << GetLinkStateRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetLinkStateRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetLinkStateResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetLinkStateResponse, id " << GetLinkStateResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetLinkStateResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetLinkState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetLinkState, id " << GetLinkState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetLinkStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetModelPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetModelPropertiesRequest, id " << GetModelPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetModelPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetModelPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetModelPropertiesResponse, id " << GetModelPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetModelPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetModelProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetModelProperties, id " << GetModelProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetModelPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetModelStateRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetModelStateRequest, id " << GetModelStateRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetModelStateRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetModelStateResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetModelStateResponse, id " << GetModelStateResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetModelStateResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetModelState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetModelState, id " << GetModelState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetModelStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPhysicsPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPhysicsPropertiesRequest, id " << GetPhysicsPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPhysicsPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPhysicsPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPhysicsPropertiesResponse, id " << GetPhysicsPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPhysicsPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetPhysicsProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetPhysicsProperties, id " << GetPhysicsProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetPhysicsPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetWorldPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetWorldPropertiesRequest, id " << GetWorldPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetWorldPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetWorldPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetWorldPropertiesResponse, id " << GetWorldPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetWorldPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GetWorldProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GetWorldProperties, id " << GetWorldProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GetWorldPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointRequestRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointRequestRequest, id " << JointRequestRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointRequestRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointRequestResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointRequestResponse, id " << JointRequestResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointRequestResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointRequest, id " << JointRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetJointPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetJointPropertiesRequest, id " << SetJointPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetJointPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetJointPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetJointPropertiesResponse, id " << SetJointPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetJointPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetJointProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetJointProperties, id " << SetJointProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetJointPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetJointTrajectoryRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetJointTrajectoryRequest, id " << SetJointTrajectoryRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetJointTrajectoryRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetJointTrajectoryResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetJointTrajectoryResponse, id " << SetJointTrajectoryResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetJointTrajectoryResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetJointTrajectory::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetJointTrajectory, id " << SetJointTrajectory::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetJointTrajectoryNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetLinkPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetLinkPropertiesRequest, id " << SetLinkPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetLinkPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetLinkPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetLinkPropertiesResponse, id " << SetLinkPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetLinkPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetLinkProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetLinkProperties, id " << SetLinkProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetLinkPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetLinkStateRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetLinkStateRequest, id " << SetLinkStateRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetLinkStateRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetLinkStateResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetLinkStateResponse, id " << SetLinkStateResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetLinkStateResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetLinkState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetLinkState, id " << SetLinkState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetLinkStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetModelConfigurationRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetModelConfigurationRequest, id " << SetModelConfigurationRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetModelConfigurationRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetModelConfigurationResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetModelConfigurationResponse, id " << SetModelConfigurationResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetModelConfigurationResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetModelConfiguration::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetModelConfiguration, id " << SetModelConfiguration::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetModelConfigurationNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetModelStateRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetModelStateRequest, id " << SetModelStateRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetModelStateRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetModelStateResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetModelStateResponse, id " << SetModelStateResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetModelStateResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetModelState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetModelState, id " << SetModelState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetModelStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetPhysicsPropertiesRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetPhysicsPropertiesRequest, id " << SetPhysicsPropertiesRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetPhysicsPropertiesRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetPhysicsPropertiesResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetPhysicsPropertiesResponse, id " << SetPhysicsPropertiesResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetPhysicsPropertiesResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SetPhysicsProperties::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SetPhysicsProperties, id " << SetPhysicsProperties::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SetPhysicsPropertiesNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SpawnModelRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SpawnModelRequest, id " << SpawnModelRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SpawnModelRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SpawnModelResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SpawnModelResponse, id " << SpawnModelResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SpawnModelResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SpawnModel::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SpawnModel, id " << SpawnModel::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_gazebo_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"gazebo_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SpawnModelNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

