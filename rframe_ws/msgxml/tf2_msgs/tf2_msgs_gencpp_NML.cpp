// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:08 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "tf2_msgs_gencpp_NML.h"
#include "tf2_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <LookupTransformAction.h>
#include <LookupTransformActionFeedback.h>
#include <LookupTransformActionGoal.h>
#include <LookupTransformActionResult.h>
#include <LookupTransformFeedback.h>
#include <LookupTransformGoal.h>
#include <LookupTransformResult.h>
#include <TF2Error.h>
#include <TFMessage.h>
#include <FrameGraphRequest.h>
#include <FrameGraphResponse.h>
#include <FrameGraph.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace tf2_msgs;

rframe::NMLMessageFactory * NML_tf2_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_tf2_msgs_gencppfactory = new tf2_msgs_gencppNMLMessageFactory();
        return NML_tf2_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * tf2_msgs::allocate_tf2_msgs_gencpp()
{
    NML_tf2_msgs_gencppfactory = new tf2_msgs_gencppNMLMessageFactory();
    return NML_tf2_msgs_gencppfactory;
};

tf2_msgs_gencppNMLMessageFactory::tf2_msgs_gencppNMLMessageFactory()
{
    name("tf2_msgs_gencpp");
    // use constructor to register data types
    tf2_msgs::registerLibrary();
}

tf2_msgs_gencppNMLMessageFactory::~tf2_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR tf2_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return tf2_msgs_gencpp_format;
}

int tf2_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void tf2_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(LookupTransformAction::ID);
    info.name(LookupTransformAction::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformAction::DATA_VERSION);
    info.md5Key(LookupTransformAction::VERSION_MD5);
    info.xmlSource(LookupTransformAction::XML_SOURCE);
    info.flat(LookupTransformAction::dataTypeFlat());
    ids.push_back(info);

    info.id(LookupTransformActionFeedback::ID);
    info.name(LookupTransformActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformActionFeedback::DATA_VERSION);
    info.md5Key(LookupTransformActionFeedback::VERSION_MD5);
    info.xmlSource(LookupTransformActionFeedback::XML_SOURCE);
    info.flat(LookupTransformActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(LookupTransformActionGoal::ID);
    info.name(LookupTransformActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformActionGoal::DATA_VERSION);
    info.md5Key(LookupTransformActionGoal::VERSION_MD5);
    info.xmlSource(LookupTransformActionGoal::XML_SOURCE);
    info.flat(LookupTransformActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(LookupTransformActionResult::ID);
    info.name(LookupTransformActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformActionResult::DATA_VERSION);
    info.md5Key(LookupTransformActionResult::VERSION_MD5);
    info.xmlSource(LookupTransformActionResult::XML_SOURCE);
    info.flat(LookupTransformActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(LookupTransformFeedback::ID);
    info.name(LookupTransformFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformFeedback::DATA_VERSION);
    info.md5Key(LookupTransformFeedback::VERSION_MD5);
    info.xmlSource(LookupTransformFeedback::XML_SOURCE);
    info.flat(LookupTransformFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(LookupTransformGoal::ID);
    info.name(LookupTransformGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformGoal::DATA_VERSION);
    info.md5Key(LookupTransformGoal::VERSION_MD5);
    info.xmlSource(LookupTransformGoal::XML_SOURCE);
    info.flat(LookupTransformGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(LookupTransformResult::ID);
    info.name(LookupTransformResult::DATA_TYPE_FULL_NAME);
    info.hashKey(LookupTransformResult::DATA_VERSION);
    info.md5Key(LookupTransformResult::VERSION_MD5);
    info.xmlSource(LookupTransformResult::XML_SOURCE);
    info.flat(LookupTransformResult::dataTypeFlat());
    ids.push_back(info);

    info.id(TF2Error::ID);
    info.name(TF2Error::DATA_TYPE_FULL_NAME);
    info.hashKey(TF2Error::DATA_VERSION);
    info.md5Key(TF2Error::VERSION_MD5);
    info.xmlSource(TF2Error::XML_SOURCE);
    info.flat(TF2Error::dataTypeFlat());
    ids.push_back(info);

    info.id(TFMessage::ID);
    info.name(TFMessage::DATA_TYPE_FULL_NAME);
    info.hashKey(TFMessage::DATA_VERSION);
    info.md5Key(TFMessage::VERSION_MD5);
    info.xmlSource(TFMessage::XML_SOURCE);
    info.flat(TFMessage::dataTypeFlat());
    ids.push_back(info);

    info.id(FrameGraphRequest::ID);
    info.name(FrameGraphRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(FrameGraphRequest::DATA_VERSION);
    info.md5Key(FrameGraphRequest::VERSION_MD5);
    info.xmlSource(FrameGraphRequest::XML_SOURCE);
    info.flat(FrameGraphRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(FrameGraphResponse::ID);
    info.name(FrameGraphResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(FrameGraphResponse::DATA_VERSION);
    info.md5Key(FrameGraphResponse::VERSION_MD5);
    info.xmlSource(FrameGraphResponse::XML_SOURCE);
    info.flat(FrameGraphResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(FrameGraph::ID);
    info.name(FrameGraph::DATA_TYPE_FULL_NAME);
    info.hashKey(FrameGraph::DATA_VERSION);
    info.md5Key(FrameGraph::VERSION_MD5);
    info.xmlSource(FrameGraph::XML_SOURCE);
    info.flat(FrameGraph::dataTypeFlat());
    ids.push_back(info);

}

int tf2_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case LookupTransformAction::ID:
        {
            //LookupTransformActionNML * newmsg = new LookupTransformActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformActionNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LookupTransformActionFeedback::ID:
        {
            //LookupTransformActionFeedbackNML * newmsg = new LookupTransformActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformActionFeedbackNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LookupTransformActionGoal::ID:
        {
            //LookupTransformActionGoalNML * newmsg = new LookupTransformActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformActionGoalNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LookupTransformActionResult::ID:
        {
            //LookupTransformActionResultNML * newmsg = new LookupTransformActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformActionResultNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LookupTransformFeedback::ID:
        {
            //LookupTransformFeedbackNML * newmsg = new LookupTransformFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformFeedbackNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LookupTransformGoal::ID:
        {
            //LookupTransformGoalNML * newmsg = new LookupTransformGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformGoalNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case LookupTransformResult::ID:
        {
            //LookupTransformResultNML * newmsg = new LookupTransformResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new LookupTransformResultNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TF2Error::ID:
        {
            //TF2ErrorNML * newmsg = new TF2ErrorNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TF2ErrorNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case TFMessage::ID:
        {
            //TFMessageNML * newmsg = new TFMessageNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TFMessageNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            //FrameGraphRequestNML * newmsg = new FrameGraphRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrameGraphRequestNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            //FrameGraphResponseNML * newmsg = new FrameGraphResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrameGraphResponseNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FrameGraph::ID:
        {
            //FrameGraphNML * newmsg = new FrameGraphNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FrameGraphNML(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case LookupTransformAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformAction>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LookupTransformActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformActionFeedback>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LookupTransformActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformActionGoal>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LookupTransformActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformActionResult>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LookupTransformFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformFeedback>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LookupTransformGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformGoal>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LookupTransformResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LookupTransformResult>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TF2Error::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TF2Error>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case TFMessage::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<TFMessage>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FrameGraphRequest>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FrameGraphResponse>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FrameGraph::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FrameGraph>(),std::bind(&tf2_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case LookupTransformAction::ID:
            {
                LookupTransformActionNML * tempmsg = static_cast<LookupTransformActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LookupTransformActionFeedback::ID:
            {
                LookupTransformActionFeedbackNML * tempmsg = static_cast<LookupTransformActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LookupTransformActionGoal::ID:
            {
                LookupTransformActionGoalNML * tempmsg = static_cast<LookupTransformActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LookupTransformActionResult::ID:
            {
                LookupTransformActionResultNML * tempmsg = static_cast<LookupTransformActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LookupTransformFeedback::ID:
            {
                LookupTransformFeedbackNML * tempmsg = static_cast<LookupTransformFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LookupTransformGoal::ID:
            {
                LookupTransformGoalNML * tempmsg = static_cast<LookupTransformGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case LookupTransformResult::ID:
            {
                LookupTransformResultNML * tempmsg = static_cast<LookupTransformResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TF2Error::ID:
            {
                TF2ErrorNML * tempmsg = static_cast<TF2ErrorNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case TFMessage::ID:
            {
                TFMessageNML * tempmsg = static_cast<TFMessageNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FrameGraphRequest::ID:
            {
                FrameGraphRequestNML * tempmsg = static_cast<FrameGraphRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FrameGraphResponse::ID:
            {
                FrameGraphResponseNML * tempmsg = static_cast<FrameGraphResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FrameGraph::ID:
            {
                FrameGraphNML * tempmsg = static_cast<FrameGraphNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case LookupTransformAction::ID:
            {
                LookupTransformActionNML & tempDst = static_cast<LookupTransformActionNML&>(dst);
                Message<LookupTransformAction > & tempSrc = static_cast<Message<LookupTransformAction>&>(src);

                if (tempSrc.version() != LookupTransformAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformAction: " << __FILE__ << " expected: " 
                             << LookupTransformAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformAction: " << __FILE__ << " expected: " 
                         << LookupTransformAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LookupTransformActionFeedback::ID:
            {
                LookupTransformActionFeedbackNML & tempDst = static_cast<LookupTransformActionFeedbackNML&>(dst);
                Message<LookupTransformActionFeedback > & tempSrc = static_cast<Message<LookupTransformActionFeedback>&>(src);

                if (tempSrc.version() != LookupTransformActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformActionFeedback: " << __FILE__ << " expected: " 
                             << LookupTransformActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformActionFeedback: " << __FILE__ << " expected: " 
                         << LookupTransformActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LookupTransformActionGoal::ID:
            {
                LookupTransformActionGoalNML & tempDst = static_cast<LookupTransformActionGoalNML&>(dst);
                Message<LookupTransformActionGoal > & tempSrc = static_cast<Message<LookupTransformActionGoal>&>(src);

                if (tempSrc.version() != LookupTransformActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformActionGoal: " << __FILE__ << " expected: " 
                             << LookupTransformActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformActionGoal: " << __FILE__ << " expected: " 
                         << LookupTransformActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LookupTransformActionResult::ID:
            {
                LookupTransformActionResultNML & tempDst = static_cast<LookupTransformActionResultNML&>(dst);
                Message<LookupTransformActionResult > & tempSrc = static_cast<Message<LookupTransformActionResult>&>(src);

                if (tempSrc.version() != LookupTransformActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformActionResult: " << __FILE__ << " expected: " 
                             << LookupTransformActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformActionResult: " << __FILE__ << " expected: " 
                         << LookupTransformActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LookupTransformFeedback::ID:
            {
                LookupTransformFeedbackNML & tempDst = static_cast<LookupTransformFeedbackNML&>(dst);
                Message<LookupTransformFeedback > & tempSrc = static_cast<Message<LookupTransformFeedback>&>(src);

                if (tempSrc.version() != LookupTransformFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformFeedback: " << __FILE__ << " expected: " 
                             << LookupTransformFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformFeedback: " << __FILE__ << " expected: " 
                         << LookupTransformFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LookupTransformGoal::ID:
            {
                LookupTransformGoalNML & tempDst = static_cast<LookupTransformGoalNML&>(dst);
                Message<LookupTransformGoal > & tempSrc = static_cast<Message<LookupTransformGoal>&>(src);

                if (tempSrc.version() != LookupTransformGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformGoal: " << __FILE__ << " expected: " 
                             << LookupTransformGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformGoal: " << __FILE__ << " expected: " 
                         << LookupTransformGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case LookupTransformResult::ID:
            {
                LookupTransformResultNML & tempDst = static_cast<LookupTransformResultNML&>(dst);
                Message<LookupTransformResult > & tempSrc = static_cast<Message<LookupTransformResult>&>(src);

                if (tempSrc.version() != LookupTransformResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of LookupTransformResult: " << __FILE__ << " expected: " 
                             << LookupTransformResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of LookupTransformResult: " << __FILE__ << " expected: " 
                         << LookupTransformResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TF2Error::ID:
            {
                TF2ErrorNML & tempDst = static_cast<TF2ErrorNML&>(dst);
                Message<TF2Error > & tempSrc = static_cast<Message<TF2Error>&>(src);

                if (tempSrc.version() != TF2Error::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TF2Error: " << __FILE__ << " expected: " 
                             << TF2Error::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TF2Error: " << __FILE__ << " expected: " 
                         << TF2Error::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case TFMessage::ID:
            {
                TFMessageNML & tempDst = static_cast<TFMessageNML&>(dst);
                Message<TFMessage > & tempSrc = static_cast<Message<TFMessage>&>(src);

                if (tempSrc.version() != TFMessage::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of TFMessage: " << __FILE__ << " expected: " 
                             << TFMessage::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of TFMessage: " << __FILE__ << " expected: " 
                         << TFMessage::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FrameGraphRequest::ID:
            {
                FrameGraphRequestNML & tempDst = static_cast<FrameGraphRequestNML&>(dst);
                Message<FrameGraphRequest > & tempSrc = static_cast<Message<FrameGraphRequest>&>(src);

                if (tempSrc.version() != FrameGraphRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FrameGraphRequest: " << __FILE__ << " expected: " 
                             << FrameGraphRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FrameGraphRequest: " << __FILE__ << " expected: " 
                         << FrameGraphRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FrameGraphResponse::ID:
            {
                FrameGraphResponseNML & tempDst = static_cast<FrameGraphResponseNML&>(dst);
                Message<FrameGraphResponse > & tempSrc = static_cast<Message<FrameGraphResponse>&>(src);

                if (tempSrc.version() != FrameGraphResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FrameGraphResponse: " << __FILE__ << " expected: " 
                             << FrameGraphResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FrameGraphResponse: " << __FILE__ << " expected: " 
                         << FrameGraphResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FrameGraph::ID:
            {
                FrameGraphNML & tempDst = static_cast<FrameGraphNML&>(dst);
                Message<FrameGraph > & tempSrc = static_cast<Message<FrameGraph>&>(src);

                if (tempSrc.version() != FrameGraph::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FrameGraph: " << __FILE__ << " expected: " 
                             << FrameGraph::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FrameGraph: " << __FILE__ << " expected: " 
                         << FrameGraph::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case LookupTransformAction::ID:
            {
                LookupTransformActionNML & tempSrc = static_cast<LookupTransformActionNML&>(src);
                Message<LookupTransformAction > & tempDst = static_cast<Message<LookupTransformAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LookupTransformActionFeedback::ID:
            {
                LookupTransformActionFeedbackNML & tempSrc = static_cast<LookupTransformActionFeedbackNML&>(src);
                Message<LookupTransformActionFeedback > & tempDst = static_cast<Message<LookupTransformActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LookupTransformActionGoal::ID:
            {
                LookupTransformActionGoalNML & tempSrc = static_cast<LookupTransformActionGoalNML&>(src);
                Message<LookupTransformActionGoal > & tempDst = static_cast<Message<LookupTransformActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LookupTransformActionResult::ID:
            {
                LookupTransformActionResultNML & tempSrc = static_cast<LookupTransformActionResultNML&>(src);
                Message<LookupTransformActionResult > & tempDst = static_cast<Message<LookupTransformActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LookupTransformFeedback::ID:
            {
                LookupTransformFeedbackNML & tempSrc = static_cast<LookupTransformFeedbackNML&>(src);
                Message<LookupTransformFeedback > & tempDst = static_cast<Message<LookupTransformFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LookupTransformGoal::ID:
            {
                LookupTransformGoalNML & tempSrc = static_cast<LookupTransformGoalNML&>(src);
                Message<LookupTransformGoal > & tempDst = static_cast<Message<LookupTransformGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case LookupTransformResult::ID:
            {
                LookupTransformResultNML & tempSrc = static_cast<LookupTransformResultNML&>(src);
                Message<LookupTransformResult > & tempDst = static_cast<Message<LookupTransformResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (LookupTransformResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TF2Error::ID:
            {
                TF2ErrorNML & tempSrc = static_cast<TF2ErrorNML&>(src);
                Message<TF2Error > & tempDst = static_cast<Message<TF2Error>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TF2Error::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case TFMessage::ID:
            {
                TFMessageNML & tempSrc = static_cast<TFMessageNML&>(src);
                Message<TFMessage > & tempDst = static_cast<Message<TFMessage>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (TFMessage::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FrameGraphRequest::ID:
            {
                FrameGraphRequestNML & tempSrc = static_cast<FrameGraphRequestNML&>(src);
                Message<FrameGraphRequest > & tempDst = static_cast<Message<FrameGraphRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FrameGraphRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FrameGraphResponse::ID:
            {
                FrameGraphResponseNML & tempSrc = static_cast<FrameGraphResponseNML&>(src);
                Message<FrameGraphResponse > & tempDst = static_cast<Message<FrameGraphResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FrameGraphResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FrameGraph::ID:
            {
                FrameGraphNML & tempSrc = static_cast<FrameGraphNML&>(src);
                Message<FrameGraph > & tempDst = static_cast<Message<FrameGraph>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FrameGraph::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case LookupTransformAction::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformAction at %p\n",buffer);
                LookupTransformActionNML * p = static_cast<LookupTransformActionNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformActionFeedback at %p\n",buffer);
                LookupTransformActionFeedbackNML * p = static_cast<LookupTransformActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformActionGoal at %p\n",buffer);
                LookupTransformActionGoalNML * p = static_cast<LookupTransformActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformActionResult at %p\n",buffer);
                LookupTransformActionResultNML * p = static_cast<LookupTransformActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformFeedback at %p\n",buffer);
                LookupTransformFeedbackNML * p = static_cast<LookupTransformFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformGoal::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformGoal at %p\n",buffer);
                LookupTransformGoalNML * p = static_cast<LookupTransformGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformResult::ID:
        {
            // only need to construct if data type is not flat
            if (LookupTransformResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing LookupTransformResult at %p\n",buffer);
                LookupTransformResultNML * p = static_cast<LookupTransformResultNML*>(buffer);
                // construct the type at pointer p
                new (p) LookupTransformResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing LookupTransformResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TF2Error::ID:
        {
            // only need to construct if data type is not flat
            if (TF2Error::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TF2Error at %p\n",buffer);
                TF2ErrorNML * p = static_cast<TF2ErrorNML*>(buffer);
                // construct the type at pointer p
                new (p) TF2ErrorNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TF2Error at %p,, is flat\n",buffer);
            }
            break;
        } 
        case TFMessage::ID:
        {
            // only need to construct if data type is not flat
            if (TFMessage::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing TFMessage at %p\n",buffer);
                TFMessageNML * p = static_cast<TFMessageNML*>(buffer);
                // construct the type at pointer p
                new (p) TFMessageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing TFMessage at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            // only need to construct if data type is not flat
            if (FrameGraphRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FrameGraphRequest at %p\n",buffer);
                FrameGraphRequestNML * p = static_cast<FrameGraphRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) FrameGraphRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FrameGraphRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            // only need to construct if data type is not flat
            if (FrameGraphResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FrameGraphResponse at %p\n",buffer);
                FrameGraphResponseNML * p = static_cast<FrameGraphResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) FrameGraphResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FrameGraphResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraph::ID:
        {
            // only need to construct if data type is not flat
            if (FrameGraph::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FrameGraph at %p\n",buffer);
                FrameGraphNML * p = static_cast<FrameGraphNML*>(buffer);
                // construct the type at pointer p
                new (p) FrameGraphNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FrameGraph at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int tf2_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case LookupTransformAction::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformAction at %p\n",buffer);
                LookupTransformActionNML * p = static_cast<LookupTransformActionNML*>(buffer);
                p->~LookupTransformActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformActionFeedback at %p\n",buffer);
                LookupTransformActionFeedbackNML * p = static_cast<LookupTransformActionFeedbackNML*>(buffer);
                p->~LookupTransformActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformActionGoal at %p\n",buffer);
                LookupTransformActionGoalNML * p = static_cast<LookupTransformActionGoalNML*>(buffer);
                p->~LookupTransformActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformActionResult at %p\n",buffer);
                LookupTransformActionResultNML * p = static_cast<LookupTransformActionResultNML*>(buffer);
                p->~LookupTransformActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformFeedback at %p\n",buffer);
                LookupTransformFeedbackNML * p = static_cast<LookupTransformFeedbackNML*>(buffer);
                p->~LookupTransformFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformGoal at %p\n",buffer);
                LookupTransformGoalNML * p = static_cast<LookupTransformGoalNML*>(buffer);
                p->~LookupTransformGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case LookupTransformResult::ID:
        {
            // only need to destruct if data type is not flat
            if (LookupTransformResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing LookupTransformResult at %p\n",buffer);
                LookupTransformResultNML * p = static_cast<LookupTransformResultNML*>(buffer);
                p->~LookupTransformResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction LookupTransformResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case TF2Error::ID:
        {
            // only need to destruct if data type is not flat
            if (TF2Error::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TF2Error at %p\n",buffer);
                TF2ErrorNML * p = static_cast<TF2ErrorNML*>(buffer);
                p->~TF2ErrorNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TF2Error at %p, is flat\n",buffer);
            }
            break;
        } 
        case TFMessage::ID:
        {
            // only need to destruct if data type is not flat
            if (TFMessage::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing TFMessage at %p\n",buffer);
                TFMessageNML * p = static_cast<TFMessageNML*>(buffer);
                p->~TFMessageNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction TFMessage at %p, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (FrameGraphRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FrameGraphRequest at %p\n",buffer);
                FrameGraphRequestNML * p = static_cast<FrameGraphRequestNML*>(buffer);
                p->~FrameGraphRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FrameGraphRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraphResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (FrameGraphResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FrameGraphResponse at %p\n",buffer);
                FrameGraphResponseNML * p = static_cast<FrameGraphResponseNML*>(buffer);
                p->~FrameGraphResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FrameGraphResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case FrameGraph::ID:
        {
            // only need to destruct if data type is not flat
            if (FrameGraph::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FrameGraph at %p\n",buffer);
                FrameGraphNML * p = static_cast<FrameGraphNML*>(buffer);
                p->~FrameGraphNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FrameGraph at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

LookupTransformActionNML::LookupTransformActionNML() : NMLmsg((NMLTYPE)LookupTransformAction::ID,sizeof(LookupTransformActionNML)), nmlVersion(LookupTransformAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformAction()*/)
{
};

LookupTransformActionNML::~LookupTransformActionNML()
{
};

LookupTransformActionNML & LookupTransformActionNML::operator=(const LookupTransformActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformActionNML & LookupTransformActionNML::operator=(const LookupTransformAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformAction> temp(new LookupTransformAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformAction Message version mismatch, expected " << LookupTransformAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformAction Message version mismatch, expected " << LookupTransformAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

LookupTransformActionFeedbackNML::LookupTransformActionFeedbackNML() : NMLmsg((NMLTYPE)LookupTransformActionFeedback::ID,sizeof(LookupTransformActionFeedbackNML)), nmlVersion(LookupTransformActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformActionFeedback()*/)
{
};

LookupTransformActionFeedbackNML::~LookupTransformActionFeedbackNML()
{
};

LookupTransformActionFeedbackNML & LookupTransformActionFeedbackNML::operator=(const LookupTransformActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformActionFeedbackNML & LookupTransformActionFeedbackNML::operator=(const LookupTransformActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformActionFeedback> temp(new LookupTransformActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformActionFeedback Message version mismatch, expected " << LookupTransformActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformActionFeedback Message version mismatch, expected " << LookupTransformActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

LookupTransformActionGoalNML::LookupTransformActionGoalNML() : NMLmsg((NMLTYPE)LookupTransformActionGoal::ID,sizeof(LookupTransformActionGoalNML)), nmlVersion(LookupTransformActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformActionGoal()*/)
{
};

LookupTransformActionGoalNML::~LookupTransformActionGoalNML()
{
};

LookupTransformActionGoalNML & LookupTransformActionGoalNML::operator=(const LookupTransformActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformActionGoalNML & LookupTransformActionGoalNML::operator=(const LookupTransformActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformActionGoal> temp(new LookupTransformActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformActionGoal Message version mismatch, expected " << LookupTransformActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformActionGoal Message version mismatch, expected " << LookupTransformActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

LookupTransformActionResultNML::LookupTransformActionResultNML() : NMLmsg((NMLTYPE)LookupTransformActionResult::ID,sizeof(LookupTransformActionResultNML)), nmlVersion(LookupTransformActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformActionResult()*/)
{
};

LookupTransformActionResultNML::~LookupTransformActionResultNML()
{
};

LookupTransformActionResultNML & LookupTransformActionResultNML::operator=(const LookupTransformActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformActionResultNML & LookupTransformActionResultNML::operator=(const LookupTransformActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformActionResult> temp(new LookupTransformActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformActionResult Message version mismatch, expected " << LookupTransformActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformActionResult Message version mismatch, expected " << LookupTransformActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

LookupTransformFeedbackNML::LookupTransformFeedbackNML() : NMLmsg((NMLTYPE)LookupTransformFeedback::ID,sizeof(LookupTransformFeedbackNML)), nmlVersion(LookupTransformFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformFeedback()*/)
{
};

LookupTransformFeedbackNML::~LookupTransformFeedbackNML()
{
};

LookupTransformFeedbackNML & LookupTransformFeedbackNML::operator=(const LookupTransformFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformFeedbackNML & LookupTransformFeedbackNML::operator=(const LookupTransformFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformFeedback> temp(new LookupTransformFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformFeedback Message version mismatch, expected " << LookupTransformFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformFeedback Message version mismatch, expected " << LookupTransformFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.target_frame);
        nmlupdate(cms,inobj.source_frame);
        nmlupdate(cms,inobj.source_time);
        nmlupdate(cms,inobj.timeout);
        nmlupdate(cms,inobj.target_time);
        nmlupdate(cms,inobj.fixed_frame);
        cms->update(inobj.advanced);

    }  
 }

LookupTransformGoalNML::LookupTransformGoalNML() : NMLmsg((NMLTYPE)LookupTransformGoal::ID,sizeof(LookupTransformGoalNML)), nmlVersion(LookupTransformGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformGoal()*/)
{
};

LookupTransformGoalNML::~LookupTransformGoalNML()
{
};

LookupTransformGoalNML & LookupTransformGoalNML::operator=(const LookupTransformGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformGoalNML & LookupTransformGoalNML::operator=(const LookupTransformGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformGoal> temp(new LookupTransformGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformGoal Message version mismatch, expected " << LookupTransformGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformGoal Message version mismatch, expected " << LookupTransformGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, LookupTransformResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate LookupTransformResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.transform);
        nmlupdate(cms,inobj.error);

    }  
 }

LookupTransformResultNML::LookupTransformResultNML() : NMLmsg((NMLTYPE)LookupTransformResult::ID,sizeof(LookupTransformResultNML)), nmlVersion(LookupTransformResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new LookupTransformResult()*/)
{
};

LookupTransformResultNML::~LookupTransformResultNML()
{
};

LookupTransformResultNML & LookupTransformResultNML::operator=(const LookupTransformResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

LookupTransformResultNML & LookupTransformResultNML::operator=(const LookupTransformResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(LookupTransformResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void LookupTransformResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<LookupTransformResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: LookupTransformResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<LookupTransformResult> temp(new LookupTransformResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (LookupTransformResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: LookupTransformResult Message version mismatch, expected " << LookupTransformResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: LookupTransformResult Message version mismatch, expected " << LookupTransformResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, TF2Error & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TF2Error, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.error);
        nmlupdate(cms,inobj.error_string);

    }  
 }

TF2ErrorNML::TF2ErrorNML() : NMLmsg((NMLTYPE)TF2Error::ID,sizeof(TF2ErrorNML)), nmlVersion(TF2Error::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TF2Error()*/)
{
};

TF2ErrorNML::~TF2ErrorNML()
{
};

TF2ErrorNML & TF2ErrorNML::operator=(const TF2ErrorNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TF2ErrorNML & TF2ErrorNML::operator=(const TF2Error & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TF2Error);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TF2ErrorNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TF2Error&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TF2ErrorNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TF2Error> temp(new TF2Error());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TF2Error::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TF2Error Message version mismatch, expected " << TF2Error::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TF2Error Message version mismatch, expected " << TF2Error::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, TFMessage & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate TFMessage, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.transforms);

    }  
 }

TFMessageNML::TFMessageNML() : NMLmsg((NMLTYPE)TFMessage::ID,sizeof(TFMessageNML)), nmlVersion(TFMessage::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new TFMessage()*/)
{
};

TFMessageNML::~TFMessageNML()
{
};

TFMessageNML & TFMessageNML::operator=(const TFMessageNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TFMessageNML & TFMessageNML::operator=(const TFMessage & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(TFMessage);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TFMessageNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<TFMessage&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TFMessageNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<TFMessage> temp(new TFMessage());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (TFMessage::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: TFMessage Message version mismatch, expected " << TFMessage::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: TFMessage Message version mismatch, expected " << TFMessage::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, FrameGraphRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FrameGraphRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

FrameGraphRequestNML::FrameGraphRequestNML() : NMLmsg((NMLTYPE)FrameGraphRequest::ID,sizeof(FrameGraphRequestNML)), nmlVersion(FrameGraphRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FrameGraphRequest()*/)
{
};

FrameGraphRequestNML::~FrameGraphRequestNML()
{
};

FrameGraphRequestNML & FrameGraphRequestNML::operator=(const FrameGraphRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrameGraphRequestNML & FrameGraphRequestNML::operator=(const FrameGraphRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FrameGraphRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrameGraphRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FrameGraphRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrameGraphRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FrameGraphRequest> temp(new FrameGraphRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FrameGraphRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FrameGraphRequest Message version mismatch, expected " << FrameGraphRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FrameGraphRequest Message version mismatch, expected " << FrameGraphRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, FrameGraphResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FrameGraphResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.frame_yaml);

    }  
 }

FrameGraphResponseNML::FrameGraphResponseNML() : NMLmsg((NMLTYPE)FrameGraphResponse::ID,sizeof(FrameGraphResponseNML)), nmlVersion(FrameGraphResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FrameGraphResponse()*/)
{
};

FrameGraphResponseNML::~FrameGraphResponseNML()
{
};

FrameGraphResponseNML & FrameGraphResponseNML::operator=(const FrameGraphResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrameGraphResponseNML & FrameGraphResponseNML::operator=(const FrameGraphResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FrameGraphResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrameGraphResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FrameGraphResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrameGraphResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FrameGraphResponse> temp(new FrameGraphResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FrameGraphResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FrameGraphResponse Message version mismatch, expected " << FrameGraphResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FrameGraphResponse Message version mismatch, expected " << FrameGraphResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void tf2_msgs::nmlupdate(CMS * cms, FrameGraph & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FrameGraph, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

FrameGraphNML::FrameGraphNML() : NMLmsg((NMLTYPE)FrameGraph::ID,sizeof(FrameGraphNML)), nmlVersion(FrameGraph::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FrameGraph()*/)
{
};

FrameGraphNML::~FrameGraphNML()
{
};

FrameGraphNML & FrameGraphNML::operator=(const FrameGraphNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FrameGraphNML & FrameGraphNML::operator=(const FrameGraph & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FrameGraph);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FrameGraphNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FrameGraph&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FrameGraphNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FrameGraph> temp(new FrameGraph());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: tf2_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FrameGraph::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FrameGraph Message version mismatch, expected " << FrameGraph::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FrameGraph Message version mismatch, expected " << FrameGraph::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int tf2_msgs::tf2_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("tf2_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case LookupTransformAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformAction, id " << LookupTransformAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LookupTransformActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformActionFeedback, id " << LookupTransformActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LookupTransformActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformActionGoal, id " << LookupTransformActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LookupTransformActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformActionResult, id " << LookupTransformActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LookupTransformFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformFeedback, id " << LookupTransformFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LookupTransformGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformGoal, id " << LookupTransformGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case LookupTransformResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for LookupTransformResult, id " << LookupTransformResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((LookupTransformResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TF2Error::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TF2Error, id " << TF2Error::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TF2ErrorNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case TFMessage::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for TFMessage, id " << TFMessage::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TFMessageNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FrameGraphRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FrameGraphRequest, id " << FrameGraphRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrameGraphRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FrameGraphResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FrameGraphResponse, id " << FrameGraphResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrameGraphResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FrameGraph::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FrameGraph, id " << FrameGraph::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_tf2_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"tf2_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FrameGraphNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

