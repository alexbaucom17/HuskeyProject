// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:48 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "dynamic_reconfigure_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace dynamic_reconfigure;

rframe::ROSMessageFactory * ROS_dynamic_reconfigure_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_dynamic_reconfigure_gencppfactory = new dynamic_reconfigure_gencppROSMessageFactory();

        return ROS_dynamic_reconfigure_gencppfactory;
    };
}

rframe::ROSMessageFactory * dynamic_reconfigure::allocate_dynamic_reconfigure_gencpp()
{
    ROS_dynamic_reconfigure_gencppfactory = new dynamic_reconfigure_gencppROSMessageFactory();
    return ROS_dynamic_reconfigure_gencppfactory;
};

dynamic_reconfigure_gencppROSMessageFactory::dynamic_reconfigure_gencppROSMessageFactory()
{
    name("dynamic_reconfigure_gencpp");
    // use constructor to register data types
    dynamic_reconfigure::registerLibrary();
}

dynamic_reconfigure_gencppROSMessageFactory::~dynamic_reconfigure_gencppROSMessageFactory()
{
}

int dynamic_reconfigure_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void dynamic_reconfigure_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(BoolParameter::ID);
    info.name(BoolParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(BoolParameter::DATA_VERSION);
    info.md5Key(BoolParameter::VERSION_MD5);
    info.xmlSource(BoolParameter::XML_SOURCE);
    info.flat(BoolParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(Config::ID);
    info.name(Config::DATA_TYPE_FULL_NAME);
    info.hashKey(Config::DATA_VERSION);
    info.md5Key(Config::VERSION_MD5);
    info.xmlSource(Config::XML_SOURCE);
    info.flat(Config::dataTypeFlat());
    ids.push_back(info);

    info.id(ConfigDescription::ID);
    info.name(ConfigDescription::DATA_TYPE_FULL_NAME);
    info.hashKey(ConfigDescription::DATA_VERSION);
    info.md5Key(ConfigDescription::VERSION_MD5);
    info.xmlSource(ConfigDescription::XML_SOURCE);
    info.flat(ConfigDescription::dataTypeFlat());
    ids.push_back(info);

    info.id(DoubleParameter::ID);
    info.name(DoubleParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(DoubleParameter::DATA_VERSION);
    info.md5Key(DoubleParameter::VERSION_MD5);
    info.xmlSource(DoubleParameter::XML_SOURCE);
    info.flat(DoubleParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(Group::ID);
    info.name(Group::DATA_TYPE_FULL_NAME);
    info.hashKey(Group::DATA_VERSION);
    info.md5Key(Group::VERSION_MD5);
    info.xmlSource(Group::XML_SOURCE);
    info.flat(Group::dataTypeFlat());
    ids.push_back(info);

    info.id(GroupState::ID);
    info.name(GroupState::DATA_TYPE_FULL_NAME);
    info.hashKey(GroupState::DATA_VERSION);
    info.md5Key(GroupState::VERSION_MD5);
    info.xmlSource(GroupState::XML_SOURCE);
    info.flat(GroupState::dataTypeFlat());
    ids.push_back(info);

    info.id(IntParameter::ID);
    info.name(IntParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(IntParameter::DATA_VERSION);
    info.md5Key(IntParameter::VERSION_MD5);
    info.xmlSource(IntParameter::XML_SOURCE);
    info.flat(IntParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(ParamDescription::ID);
    info.name(ParamDescription::DATA_TYPE_FULL_NAME);
    info.hashKey(ParamDescription::DATA_VERSION);
    info.md5Key(ParamDescription::VERSION_MD5);
    info.xmlSource(ParamDescription::XML_SOURCE);
    info.flat(ParamDescription::dataTypeFlat());
    ids.push_back(info);

    info.id(SensorLevels::ID);
    info.name(SensorLevels::DATA_TYPE_FULL_NAME);
    info.hashKey(SensorLevels::DATA_VERSION);
    info.md5Key(SensorLevels::VERSION_MD5);
    info.xmlSource(SensorLevels::XML_SOURCE);
    info.flat(SensorLevels::dataTypeFlat());
    ids.push_back(info);

    info.id(StrParameter::ID);
    info.name(StrParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(StrParameter::DATA_VERSION);
    info.md5Key(StrParameter::VERSION_MD5);
    info.xmlSource(StrParameter::XML_SOURCE);
    info.flat(StrParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(ReconfigureRequest::ID);
    info.name(ReconfigureRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(ReconfigureRequest::DATA_VERSION);
    info.md5Key(ReconfigureRequest::VERSION_MD5);
    info.xmlSource(ReconfigureRequest::XML_SOURCE);
    info.flat(ReconfigureRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(ReconfigureResponse::ID);
    info.name(ReconfigureResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(ReconfigureResponse::DATA_VERSION);
    info.md5Key(ReconfigureResponse::VERSION_MD5);
    info.xmlSource(ReconfigureResponse::XML_SOURCE);
    info.flat(ReconfigureResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(Reconfigure::ID);
    info.name(Reconfigure::DATA_TYPE_FULL_NAME);
    info.hashKey(Reconfigure::DATA_VERSION);
    info.md5Key(Reconfigure::VERSION_MD5);
    info.xmlSource(Reconfigure::XML_SOURCE);
    info.flat(Reconfigure::dataTypeFlat());
    ids.push_back(info);

}

int dynamic_reconfigure_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case BoolParameter::ID:
        {
            str = "dynamic_reconfigure/BoolParameter";
            break;
        }
        case Config::ID:
        {
            str = "dynamic_reconfigure/Config";
            break;
        }
        case ConfigDescription::ID:
        {
            str = "dynamic_reconfigure/ConfigDescription";
            break;
        }
        case DoubleParameter::ID:
        {
            str = "dynamic_reconfigure/DoubleParameter";
            break;
        }
        case Group::ID:
        {
            str = "dynamic_reconfigure/Group";
            break;
        }
        case GroupState::ID:
        {
            str = "dynamic_reconfigure/GroupState";
            break;
        }
        case IntParameter::ID:
        {
            str = "dynamic_reconfigure/IntParameter";
            break;
        }
        case ParamDescription::ID:
        {
            str = "dynamic_reconfigure/ParamDescription";
            break;
        }
        case SensorLevels::ID:
        {
            str = "dynamic_reconfigure/SensorLevels";
            break;
        }
        case StrParameter::ID:
        {
            str = "dynamic_reconfigure/StrParameter";
            break;
        }
        case ReconfigureRequest::ID:
        {
            str = "dynamic_reconfigure/ReconfigureRequest";
            break;
        }
        case ReconfigureResponse::ID:
        {
            str = "dynamic_reconfigure/ReconfigureResponse";
            break;
        }
        case Reconfigure::ID:
        {
            str = "dynamic_reconfigure/Reconfigure";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case BoolParameter::ID:
        {
            str = "string name\nbool value\n";
            break;
        }
        case Config::ID:
        {
            str = "BoolParameter[] bools\nIntParameter[] ints\nStrParameter[] strs\nDoubleParameter[] doubles\nGroupState[] groups\n\n================================================================================\nMSG: dynamic_reconfigure/BoolParameter\nstring name\nbool value\n\n================================================================================\nMSG: dynamic_reconfigure/IntParameter\nstring name\nint32 value\n\n================================================================================\nMSG: dynamic_reconfigure/StrParameter\nstring name\nstring value\n\n================================================================================\nMSG: dynamic_reconfigure/DoubleParameter\nstring name\nfloat64 value\n\n================================================================================\nMSG: dynamic_reconfigure/GroupState\nstring name\nbool state\nint32 id\nint32 parent\n";
            break;
        }
        case ConfigDescription::ID:
        {
            str = "Group[] groups\nConfig max\nConfig min\nConfig dflt\n\n================================================================================\nMSG: dynamic_reconfigure/Group\nstring name\nstring type\nParamDescription[] parameters\nint32 parent \nint32 id\n\n================================================================================\nMSG: dynamic_reconfigure/ParamDescription\nstring name\nstring type\nuint32 level\nstring description\nstring edit_method\n\n================================================================================\nMSG: dynamic_reconfigure/Config\nBoolParameter[] bools\nIntParameter[] ints\nStrParameter[] strs\nDoubleParameter[] doubles\nGroupState[] groups\n\n================================================================================\nMSG: dynamic_reconfigure/BoolParameter\nstring name\nbool value\n\n================================================================================\nMSG: dynamic_reconfigure/IntParameter\nstring name\nint32 value\n\n================================================================================\nMSG: dynamic_reconfigure/StrParameter\nstring name\nstring value\n\n================================================================================\nMSG: dynamic_reconfigure/DoubleParameter\nstring name\nfloat64 value\n\n================================================================================\nMSG: dynamic_reconfigure/GroupState\nstring name\nbool state\nint32 id\nint32 parent\n";
            break;
        }
        case DoubleParameter::ID:
        {
            str = "string name\nfloat64 value\n";
            break;
        }
        case Group::ID:
        {
            str = "string name\nstring type\nParamDescription[] parameters\nint32 parent \nint32 id\n\n================================================================================\nMSG: dynamic_reconfigure/ParamDescription\nstring name\nstring type\nuint32 level\nstring description\nstring edit_method\n";
            break;
        }
        case GroupState::ID:
        {
            str = "string name\nbool state\nint32 id\nint32 parent\n";
            break;
        }
        case IntParameter::ID:
        {
            str = "string name\nint32 value\n";
            break;
        }
        case ParamDescription::ID:
        {
            str = "string name\nstring type\nuint32 level\nstring description\nstring edit_method\n";
            break;
        }
        case SensorLevels::ID:
        {
            str = "# This message is deprecated, please use driver_base/SensorLevels instead.\n\nbyte RECONFIGURE_CLOSE = 3  # Parameters that need a sensor to be stopped completely when changed\nbyte RECONFIGURE_STOP = 1  # Parameters that need a sensor to stop streaming when changed\nbyte RECONFIGURE_RUNNING = 0 # Parameters that can be changed while a sensor is streaming\n";
            break;
        }
        case StrParameter::ID:
        {
            str = "string name\nstring value\n";
            break;
        }
        case ReconfigureRequest::ID:
        {
            str = ReconfigureRequest::XML_SOURCE;
            break;
        }
        case ReconfigureResponse::ID:
        {
            str = ReconfigureResponse::XML_SOURCE;
            break;
        }
        case Reconfigure::ID:
        {
            str = Reconfigure::XML_SOURCE;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case BoolParameter::ID:
        {
            str = "23f05028c1a699fb83e22401228c3a9e";
            break;
        }
        case Config::ID:
        {
            str = "958f16a05573709014982821e6822580";
            break;
        }
        case ConfigDescription::ID:
        {
            str = "757ce9d44ba8ddd801bb30bc456f946f";
            break;
        }
        case DoubleParameter::ID:
        {
            str = "d8512f27253c0f65f928a67c329cd658";
            break;
        }
        case Group::ID:
        {
            str = "9e8cd9e9423c94823db3614dd8b1cf7a";
            break;
        }
        case GroupState::ID:
        {
            str = "a2d87f51dc22930325041a2f8b1571f8";
            break;
        }
        case IntParameter::ID:
        {
            str = "65fedc7a0cbfb8db035e46194a350bf1";
            break;
        }
        case ParamDescription::ID:
        {
            str = "7434fcb9348c13054e0c3b267c8cb34d";
            break;
        }
        case SensorLevels::ID:
        {
            str = "6322637bee96d5489db6e2127c47602c";
            break;
        }
        case StrParameter::ID:
        {
            str = "bc6ccc4a57f61779c8eaae61e9f422e0";
            break;
        }
        case ReconfigureRequest::ID:
        {
            str = "ac41a77620a4a0348b7001641796a8a1";
            break;
        }
        case ReconfigureResponse::ID:
        {
            str = "ac41a77620a4a0348b7001641796a8a1";
            break;
        }
        case Reconfigure::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case BoolParameter::ID:
        {   
		    highOrder = 0x23f05028c1a699fbULL;
            lowOrder = 0x83e22401228c3a9eULL;
            break;
        }
        case Config::ID:
        {   
		    highOrder = 0x958f16a055737090ULL;
            lowOrder = 0x14982821e6822580ULL;
            break;
        }
        case ConfigDescription::ID:
        {   
		    highOrder = 0x757ce9d44ba8ddd8ULL;
            lowOrder = 0x01bb30bc456f946fULL;
            break;
        }
        case DoubleParameter::ID:
        {   
		    highOrder = 0xd8512f27253c0f65ULL;
            lowOrder = 0xf928a67c329cd658ULL;
            break;
        }
        case Group::ID:
        {   
		    highOrder = 0x9e8cd9e9423c9482ULL;
            lowOrder = 0x3db3614dd8b1cf7aULL;
            break;
        }
        case GroupState::ID:
        {   
		    highOrder = 0xa2d87f51dc229303ULL;
            lowOrder = 0x25041a2f8b1571f8ULL;
            break;
        }
        case IntParameter::ID:
        {   
		    highOrder = 0x65fedc7a0cbfb8dbULL;
            lowOrder = 0x035e46194a350bf1ULL;
            break;
        }
        case ParamDescription::ID:
        {   
		    highOrder = 0x7434fcb9348c1305ULL;
            lowOrder = 0x4e0c3b267c8cb34dULL;
            break;
        }
        case SensorLevels::ID:
        {   
		    highOrder = 0x6322637bee96d548ULL;
            lowOrder = 0x9db6e2127c47602cULL;
            break;
        }
        case StrParameter::ID:
        {   
		    highOrder = 0xbc6ccc4a57f61779ULL;
            lowOrder = 0xc8eaae61e9f422e0ULL;
            break;
        }
        case ReconfigureRequest::ID:
        {   
		    highOrder = 0xac41a77620a4a034ULL;
            lowOrder = 0x8b7001641796a8a1ULL;
            break;
        }
        case ReconfigureResponse::ID:
        {   
		    highOrder = 0xac41a77620a4a034ULL;
            lowOrder = 0x8b7001641796a8a1ULL;
            break;
        }
        case Reconfigure::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case BoolParameter::ID:
        case Config::ID:
        case ConfigDescription::ID:
        case DoubleParameter::ID:
        case Group::ID:
        case GroupState::ID:
        case IntParameter::ID:
        case ParamDescription::ID:
        case SensorLevels::ID:
        case StrParameter::ID:
        case ReconfigureRequest::ID:
        case ReconfigureResponse::ID:
        case Reconfigure::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case BoolParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BoolParameter>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Config::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Config>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ConfigDescription::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ConfigDescription>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DoubleParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DoubleParameter>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Group::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Group>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GroupState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GroupState>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case IntParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<IntParameter>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ParamDescription::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ParamDescription>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SensorLevels::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SensorLevels>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case StrParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<StrParameter>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ReconfigureRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ReconfigureRequest>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ReconfigureResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ReconfigureResponse>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Reconfigure::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Reconfigure>(),std::bind(&dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case BoolParameter::ID:
            {
                Message<BoolParameter > & tempSrc = static_cast<Message<BoolParameter>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::BoolParameter buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Config::ID:
            {
                Message<Config > & tempSrc = static_cast<Message<Config>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::Config buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ConfigDescription::ID:
            {
                Message<ConfigDescription > & tempSrc = static_cast<Message<ConfigDescription>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::ConfigDescription buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DoubleParameter::ID:
            {
                Message<DoubleParameter > & tempSrc = static_cast<Message<DoubleParameter>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::DoubleParameter buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Group::ID:
            {
                Message<Group > & tempSrc = static_cast<Message<Group>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::Group buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GroupState::ID:
            {
                Message<GroupState > & tempSrc = static_cast<Message<GroupState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::GroupState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case IntParameter::ID:
            {
                Message<IntParameter > & tempSrc = static_cast<Message<IntParameter>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::IntParameter buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ParamDescription::ID:
            {
                Message<ParamDescription > & tempSrc = static_cast<Message<ParamDescription>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::ParamDescription buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SensorLevels::ID:
            {
                Message<SensorLevels > & tempSrc = static_cast<Message<SensorLevels>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::SensorLevels buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case StrParameter::ID:
            {
                Message<StrParameter > & tempSrc = static_cast<Message<StrParameter>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::StrParameter buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ReconfigureRequest::ID:
            {
                Message<ReconfigureRequest > & tempSrc = static_cast<Message<ReconfigureRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::ReconfigureRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ReconfigureResponse::ID:
            {
                Message<ReconfigureResponse > & tempSrc = static_cast<Message<ReconfigureResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::ReconfigureResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Reconfigure::ID:
            {
                Message<Reconfigure > & tempSrc = static_cast<Message<Reconfigure>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: dynamic_reconfigure_gencpp::Reconfigure buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case BoolParameter::ID:
            {
                Message<BoolParameter > & tempDst = static_cast<Message<BoolParameter>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Config::ID:
            {
                Message<Config > & tempDst = static_cast<Message<Config>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ConfigDescription::ID:
            {
                Message<ConfigDescription > & tempDst = static_cast<Message<ConfigDescription>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DoubleParameter::ID:
            {
                Message<DoubleParameter > & tempDst = static_cast<Message<DoubleParameter>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Group::ID:
            {
                Message<Group > & tempDst = static_cast<Message<Group>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GroupState::ID:
            {
                Message<GroupState > & tempDst = static_cast<Message<GroupState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case IntParameter::ID:
            {
                Message<IntParameter > & tempDst = static_cast<Message<IntParameter>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ParamDescription::ID:
            {
                Message<ParamDescription > & tempDst = static_cast<Message<ParamDescription>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SensorLevels::ID:
            {
                Message<SensorLevels > & tempDst = static_cast<Message<SensorLevels>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case StrParameter::ID:
            {
                Message<StrParameter > & tempDst = static_cast<Message<StrParameter>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ReconfigureRequest::ID:
            {
                Message<ReconfigureRequest > & tempDst = static_cast<Message<ReconfigureRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ReconfigureResponse::ID:
            {
                Message<ReconfigureResponse > & tempDst = static_cast<Message<ReconfigureResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Reconfigure::ID:
            {
                Message<Reconfigure > & tempDst = static_cast<Message<Reconfigure>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // BoolParameter does not have a Header as its first member 
        // Config does not have a Header as its first member 
        // ConfigDescription does not have a Header as its first member 
        // DoubleParameter does not have a Header as its first member 
        // Group does not have a Header as its first member 
        // GroupState does not have a Header as its first member 
        // IntParameter does not have a Header as its first member 
        // ParamDescription does not have a Header as its first member 
        // StrParameter does not have a Header as its first member 
        // ReconfigureRequest does not have a Header as its first member 
        // ReconfigureResponse does not have a Header as its first member 
        // Reconfigure does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
