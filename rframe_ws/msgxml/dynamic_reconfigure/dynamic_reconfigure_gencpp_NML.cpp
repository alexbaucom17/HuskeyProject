// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:04 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "dynamic_reconfigure_gencpp_NML.h"
#include "dynamic_reconfigure_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <BoolParameter.h>
#include <Config.h>
#include <ConfigDescription.h>
#include <DoubleParameter.h>
#include <Group.h>
#include <GroupState.h>
#include <IntParameter.h>
#include <ParamDescription.h>
#include <SensorLevels.h>
#include <StrParameter.h>
#include <ReconfigureRequest.h>
#include <ReconfigureResponse.h>
#include <Reconfigure.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace dynamic_reconfigure;

rframe::NMLMessageFactory * NML_dynamic_reconfigure_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_dynamic_reconfigure_gencppfactory = new dynamic_reconfigure_gencppNMLMessageFactory();
        return NML_dynamic_reconfigure_gencppfactory;
    };
}

rframe::NMLMessageFactory * dynamic_reconfigure::allocate_dynamic_reconfigure_gencpp()
{
    NML_dynamic_reconfigure_gencppfactory = new dynamic_reconfigure_gencppNMLMessageFactory();
    return NML_dynamic_reconfigure_gencppfactory;
};

dynamic_reconfigure_gencppNMLMessageFactory::dynamic_reconfigure_gencppNMLMessageFactory()
{
    name("dynamic_reconfigure_gencpp");
    // use constructor to register data types
    dynamic_reconfigure::registerLibrary();
}

dynamic_reconfigure_gencppNMLMessageFactory::~dynamic_reconfigure_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR dynamic_reconfigure_gencppNMLMessageFactory::FormatPointer()
{
    return dynamic_reconfigure_gencpp_format;
}

int dynamic_reconfigure_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void dynamic_reconfigure_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(BoolParameter::ID);
    info.name(BoolParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(BoolParameter::DATA_VERSION);
    info.md5Key(BoolParameter::VERSION_MD5);
    info.xmlSource(BoolParameter::XML_SOURCE);
    info.flat(BoolParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(Config::ID);
    info.name(Config::DATA_TYPE_FULL_NAME);
    info.hashKey(Config::DATA_VERSION);
    info.md5Key(Config::VERSION_MD5);
    info.xmlSource(Config::XML_SOURCE);
    info.flat(Config::dataTypeFlat());
    ids.push_back(info);

    info.id(ConfigDescription::ID);
    info.name(ConfigDescription::DATA_TYPE_FULL_NAME);
    info.hashKey(ConfigDescription::DATA_VERSION);
    info.md5Key(ConfigDescription::VERSION_MD5);
    info.xmlSource(ConfigDescription::XML_SOURCE);
    info.flat(ConfigDescription::dataTypeFlat());
    ids.push_back(info);

    info.id(DoubleParameter::ID);
    info.name(DoubleParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(DoubleParameter::DATA_VERSION);
    info.md5Key(DoubleParameter::VERSION_MD5);
    info.xmlSource(DoubleParameter::XML_SOURCE);
    info.flat(DoubleParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(Group::ID);
    info.name(Group::DATA_TYPE_FULL_NAME);
    info.hashKey(Group::DATA_VERSION);
    info.md5Key(Group::VERSION_MD5);
    info.xmlSource(Group::XML_SOURCE);
    info.flat(Group::dataTypeFlat());
    ids.push_back(info);

    info.id(GroupState::ID);
    info.name(GroupState::DATA_TYPE_FULL_NAME);
    info.hashKey(GroupState::DATA_VERSION);
    info.md5Key(GroupState::VERSION_MD5);
    info.xmlSource(GroupState::XML_SOURCE);
    info.flat(GroupState::dataTypeFlat());
    ids.push_back(info);

    info.id(IntParameter::ID);
    info.name(IntParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(IntParameter::DATA_VERSION);
    info.md5Key(IntParameter::VERSION_MD5);
    info.xmlSource(IntParameter::XML_SOURCE);
    info.flat(IntParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(ParamDescription::ID);
    info.name(ParamDescription::DATA_TYPE_FULL_NAME);
    info.hashKey(ParamDescription::DATA_VERSION);
    info.md5Key(ParamDescription::VERSION_MD5);
    info.xmlSource(ParamDescription::XML_SOURCE);
    info.flat(ParamDescription::dataTypeFlat());
    ids.push_back(info);

    info.id(SensorLevels::ID);
    info.name(SensorLevels::DATA_TYPE_FULL_NAME);
    info.hashKey(SensorLevels::DATA_VERSION);
    info.md5Key(SensorLevels::VERSION_MD5);
    info.xmlSource(SensorLevels::XML_SOURCE);
    info.flat(SensorLevels::dataTypeFlat());
    ids.push_back(info);

    info.id(StrParameter::ID);
    info.name(StrParameter::DATA_TYPE_FULL_NAME);
    info.hashKey(StrParameter::DATA_VERSION);
    info.md5Key(StrParameter::VERSION_MD5);
    info.xmlSource(StrParameter::XML_SOURCE);
    info.flat(StrParameter::dataTypeFlat());
    ids.push_back(info);

    info.id(ReconfigureRequest::ID);
    info.name(ReconfigureRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(ReconfigureRequest::DATA_VERSION);
    info.md5Key(ReconfigureRequest::VERSION_MD5);
    info.xmlSource(ReconfigureRequest::XML_SOURCE);
    info.flat(ReconfigureRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(ReconfigureResponse::ID);
    info.name(ReconfigureResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(ReconfigureResponse::DATA_VERSION);
    info.md5Key(ReconfigureResponse::VERSION_MD5);
    info.xmlSource(ReconfigureResponse::XML_SOURCE);
    info.flat(ReconfigureResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(Reconfigure::ID);
    info.name(Reconfigure::DATA_TYPE_FULL_NAME);
    info.hashKey(Reconfigure::DATA_VERSION);
    info.md5Key(Reconfigure::VERSION_MD5);
    info.xmlSource(Reconfigure::XML_SOURCE);
    info.flat(Reconfigure::dataTypeFlat());
    ids.push_back(info);

}

int dynamic_reconfigure_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case BoolParameter::ID:
        {
            //BoolParameterNML * newmsg = new BoolParameterNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new BoolParameterNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Config::ID:
        {
            //ConfigNML * newmsg = new ConfigNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ConfigNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ConfigDescription::ID:
        {
            //ConfigDescriptionNML * newmsg = new ConfigDescriptionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ConfigDescriptionNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case DoubleParameter::ID:
        {
            //DoubleParameterNML * newmsg = new DoubleParameterNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DoubleParameterNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Group::ID:
        {
            //GroupNML * newmsg = new GroupNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GroupNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GroupState::ID:
        {
            //GroupStateNML * newmsg = new GroupStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GroupStateNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case IntParameter::ID:
        {
            //IntParameterNML * newmsg = new IntParameterNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new IntParameterNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ParamDescription::ID:
        {
            //ParamDescriptionNML * newmsg = new ParamDescriptionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ParamDescriptionNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SensorLevels::ID:
        {
            //SensorLevelsNML * newmsg = new SensorLevelsNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SensorLevelsNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case StrParameter::ID:
        {
            //StrParameterNML * newmsg = new StrParameterNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new StrParameterNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ReconfigureRequest::ID:
        {
            //ReconfigureRequestNML * newmsg = new ReconfigureRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ReconfigureRequestNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ReconfigureResponse::ID:
        {
            //ReconfigureResponseNML * newmsg = new ReconfigureResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ReconfigureResponseNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Reconfigure::ID:
        {
            //ReconfigureNML * newmsg = new ReconfigureNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ReconfigureNML(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case BoolParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BoolParameter>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Config::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Config>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ConfigDescription::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ConfigDescription>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DoubleParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DoubleParameter>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Group::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Group>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GroupState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GroupState>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case IntParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<IntParameter>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ParamDescription::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ParamDescription>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SensorLevels::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SensorLevels>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case StrParameter::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<StrParameter>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ReconfigureRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ReconfigureRequest>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ReconfigureResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ReconfigureResponse>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Reconfigure::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Reconfigure>(),std::bind(&dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case BoolParameter::ID:
            {
                BoolParameterNML * tempmsg = static_cast<BoolParameterNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Config::ID:
            {
                ConfigNML * tempmsg = static_cast<ConfigNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ConfigDescription::ID:
            {
                ConfigDescriptionNML * tempmsg = static_cast<ConfigDescriptionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case DoubleParameter::ID:
            {
                DoubleParameterNML * tempmsg = static_cast<DoubleParameterNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Group::ID:
            {
                GroupNML * tempmsg = static_cast<GroupNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GroupState::ID:
            {
                GroupStateNML * tempmsg = static_cast<GroupStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case IntParameter::ID:
            {
                IntParameterNML * tempmsg = static_cast<IntParameterNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ParamDescription::ID:
            {
                ParamDescriptionNML * tempmsg = static_cast<ParamDescriptionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SensorLevels::ID:
            {
                SensorLevelsNML * tempmsg = static_cast<SensorLevelsNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case StrParameter::ID:
            {
                StrParameterNML * tempmsg = static_cast<StrParameterNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ReconfigureRequest::ID:
            {
                ReconfigureRequestNML * tempmsg = static_cast<ReconfigureRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ReconfigureResponse::ID:
            {
                ReconfigureResponseNML * tempmsg = static_cast<ReconfigureResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Reconfigure::ID:
            {
                ReconfigureNML * tempmsg = static_cast<ReconfigureNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case BoolParameter::ID:
            {
                BoolParameterNML & tempDst = static_cast<BoolParameterNML&>(dst);
                Message<BoolParameter > & tempSrc = static_cast<Message<BoolParameter>&>(src);

                if (tempSrc.version() != BoolParameter::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of BoolParameter: " << __FILE__ << " expected: " 
                             << BoolParameter::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of BoolParameter: " << __FILE__ << " expected: " 
                         << BoolParameter::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Config::ID:
            {
                ConfigNML & tempDst = static_cast<ConfigNML&>(dst);
                Message<Config > & tempSrc = static_cast<Message<Config>&>(src);

                if (tempSrc.version() != Config::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Config: " << __FILE__ << " expected: " 
                             << Config::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Config: " << __FILE__ << " expected: " 
                         << Config::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ConfigDescription::ID:
            {
                ConfigDescriptionNML & tempDst = static_cast<ConfigDescriptionNML&>(dst);
                Message<ConfigDescription > & tempSrc = static_cast<Message<ConfigDescription>&>(src);

                if (tempSrc.version() != ConfigDescription::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ConfigDescription: " << __FILE__ << " expected: " 
                             << ConfigDescription::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ConfigDescription: " << __FILE__ << " expected: " 
                         << ConfigDescription::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case DoubleParameter::ID:
            {
                DoubleParameterNML & tempDst = static_cast<DoubleParameterNML&>(dst);
                Message<DoubleParameter > & tempSrc = static_cast<Message<DoubleParameter>&>(src);

                if (tempSrc.version() != DoubleParameter::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of DoubleParameter: " << __FILE__ << " expected: " 
                             << DoubleParameter::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of DoubleParameter: " << __FILE__ << " expected: " 
                         << DoubleParameter::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Group::ID:
            {
                GroupNML & tempDst = static_cast<GroupNML&>(dst);
                Message<Group > & tempSrc = static_cast<Message<Group>&>(src);

                if (tempSrc.version() != Group::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Group: " << __FILE__ << " expected: " 
                             << Group::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Group: " << __FILE__ << " expected: " 
                         << Group::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GroupState::ID:
            {
                GroupStateNML & tempDst = static_cast<GroupStateNML&>(dst);
                Message<GroupState > & tempSrc = static_cast<Message<GroupState>&>(src);

                if (tempSrc.version() != GroupState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GroupState: " << __FILE__ << " expected: " 
                             << GroupState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GroupState: " << __FILE__ << " expected: " 
                         << GroupState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case IntParameter::ID:
            {
                IntParameterNML & tempDst = static_cast<IntParameterNML&>(dst);
                Message<IntParameter > & tempSrc = static_cast<Message<IntParameter>&>(src);

                if (tempSrc.version() != IntParameter::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of IntParameter: " << __FILE__ << " expected: " 
                             << IntParameter::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of IntParameter: " << __FILE__ << " expected: " 
                         << IntParameter::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ParamDescription::ID:
            {
                ParamDescriptionNML & tempDst = static_cast<ParamDescriptionNML&>(dst);
                Message<ParamDescription > & tempSrc = static_cast<Message<ParamDescription>&>(src);

                if (tempSrc.version() != ParamDescription::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ParamDescription: " << __FILE__ << " expected: " 
                             << ParamDescription::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ParamDescription: " << __FILE__ << " expected: " 
                         << ParamDescription::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SensorLevels::ID:
            {
                SensorLevelsNML & tempDst = static_cast<SensorLevelsNML&>(dst);
                Message<SensorLevels > & tempSrc = static_cast<Message<SensorLevels>&>(src);

                if (tempSrc.version() != SensorLevels::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SensorLevels: " << __FILE__ << " expected: " 
                             << SensorLevels::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SensorLevels: " << __FILE__ << " expected: " 
                         << SensorLevels::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case StrParameter::ID:
            {
                StrParameterNML & tempDst = static_cast<StrParameterNML&>(dst);
                Message<StrParameter > & tempSrc = static_cast<Message<StrParameter>&>(src);

                if (tempSrc.version() != StrParameter::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of StrParameter: " << __FILE__ << " expected: " 
                             << StrParameter::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of StrParameter: " << __FILE__ << " expected: " 
                         << StrParameter::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ReconfigureRequest::ID:
            {
                ReconfigureRequestNML & tempDst = static_cast<ReconfigureRequestNML&>(dst);
                Message<ReconfigureRequest > & tempSrc = static_cast<Message<ReconfigureRequest>&>(src);

                if (tempSrc.version() != ReconfigureRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ReconfigureRequest: " << __FILE__ << " expected: " 
                             << ReconfigureRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ReconfigureRequest: " << __FILE__ << " expected: " 
                         << ReconfigureRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ReconfigureResponse::ID:
            {
                ReconfigureResponseNML & tempDst = static_cast<ReconfigureResponseNML&>(dst);
                Message<ReconfigureResponse > & tempSrc = static_cast<Message<ReconfigureResponse>&>(src);

                if (tempSrc.version() != ReconfigureResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ReconfigureResponse: " << __FILE__ << " expected: " 
                             << ReconfigureResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ReconfigureResponse: " << __FILE__ << " expected: " 
                         << ReconfigureResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Reconfigure::ID:
            {
                ReconfigureNML & tempDst = static_cast<ReconfigureNML&>(dst);
                Message<Reconfigure > & tempSrc = static_cast<Message<Reconfigure>&>(src);

                if (tempSrc.version() != Reconfigure::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Reconfigure: " << __FILE__ << " expected: " 
                             << Reconfigure::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Reconfigure: " << __FILE__ << " expected: " 
                         << Reconfigure::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case BoolParameter::ID:
            {
                BoolParameterNML & tempSrc = static_cast<BoolParameterNML&>(src);
                Message<BoolParameter > & tempDst = static_cast<Message<BoolParameter>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (BoolParameter::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Config::ID:
            {
                ConfigNML & tempSrc = static_cast<ConfigNML&>(src);
                Message<Config > & tempDst = static_cast<Message<Config>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Config::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ConfigDescription::ID:
            {
                ConfigDescriptionNML & tempSrc = static_cast<ConfigDescriptionNML&>(src);
                Message<ConfigDescription > & tempDst = static_cast<Message<ConfigDescription>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ConfigDescription::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case DoubleParameter::ID:
            {
                DoubleParameterNML & tempSrc = static_cast<DoubleParameterNML&>(src);
                Message<DoubleParameter > & tempDst = static_cast<Message<DoubleParameter>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (DoubleParameter::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Group::ID:
            {
                GroupNML & tempSrc = static_cast<GroupNML&>(src);
                Message<Group > & tempDst = static_cast<Message<Group>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Group::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GroupState::ID:
            {
                GroupStateNML & tempSrc = static_cast<GroupStateNML&>(src);
                Message<GroupState > & tempDst = static_cast<Message<GroupState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GroupState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case IntParameter::ID:
            {
                IntParameterNML & tempSrc = static_cast<IntParameterNML&>(src);
                Message<IntParameter > & tempDst = static_cast<Message<IntParameter>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (IntParameter::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ParamDescription::ID:
            {
                ParamDescriptionNML & tempSrc = static_cast<ParamDescriptionNML&>(src);
                Message<ParamDescription > & tempDst = static_cast<Message<ParamDescription>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ParamDescription::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SensorLevels::ID:
            {
                SensorLevelsNML & tempSrc = static_cast<SensorLevelsNML&>(src);
                Message<SensorLevels > & tempDst = static_cast<Message<SensorLevels>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SensorLevels::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case StrParameter::ID:
            {
                StrParameterNML & tempSrc = static_cast<StrParameterNML&>(src);
                Message<StrParameter > & tempDst = static_cast<Message<StrParameter>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (StrParameter::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ReconfigureRequest::ID:
            {
                ReconfigureRequestNML & tempSrc = static_cast<ReconfigureRequestNML&>(src);
                Message<ReconfigureRequest > & tempDst = static_cast<Message<ReconfigureRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ReconfigureRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ReconfigureResponse::ID:
            {
                ReconfigureResponseNML & tempSrc = static_cast<ReconfigureResponseNML&>(src);
                Message<ReconfigureResponse > & tempDst = static_cast<Message<ReconfigureResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ReconfigureResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Reconfigure::ID:
            {
                ReconfigureNML & tempSrc = static_cast<ReconfigureNML&>(src);
                Message<Reconfigure > & tempDst = static_cast<Message<Reconfigure>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Reconfigure::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case BoolParameter::ID:
        {
            // only need to construct if data type is not flat
            if (BoolParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing BoolParameter at %p\n",buffer);
                BoolParameterNML * p = static_cast<BoolParameterNML*>(buffer);
                // construct the type at pointer p
                new (p) BoolParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing BoolParameter at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Config::ID:
        {
            // only need to construct if data type is not flat
            if (Config::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Config at %p\n",buffer);
                ConfigNML * p = static_cast<ConfigNML*>(buffer);
                // construct the type at pointer p
                new (p) ConfigNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Config at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ConfigDescription::ID:
        {
            // only need to construct if data type is not flat
            if (ConfigDescription::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ConfigDescription at %p\n",buffer);
                ConfigDescriptionNML * p = static_cast<ConfigDescriptionNML*>(buffer);
                // construct the type at pointer p
                new (p) ConfigDescriptionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ConfigDescription at %p,, is flat\n",buffer);
            }
            break;
        } 
        case DoubleParameter::ID:
        {
            // only need to construct if data type is not flat
            if (DoubleParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing DoubleParameter at %p\n",buffer);
                DoubleParameterNML * p = static_cast<DoubleParameterNML*>(buffer);
                // construct the type at pointer p
                new (p) DoubleParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing DoubleParameter at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Group::ID:
        {
            // only need to construct if data type is not flat
            if (Group::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Group at %p\n",buffer);
                GroupNML * p = static_cast<GroupNML*>(buffer);
                // construct the type at pointer p
                new (p) GroupNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Group at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GroupState::ID:
        {
            // only need to construct if data type is not flat
            if (GroupState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GroupState at %p\n",buffer);
                GroupStateNML * p = static_cast<GroupStateNML*>(buffer);
                // construct the type at pointer p
                new (p) GroupStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GroupState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case IntParameter::ID:
        {
            // only need to construct if data type is not flat
            if (IntParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing IntParameter at %p\n",buffer);
                IntParameterNML * p = static_cast<IntParameterNML*>(buffer);
                // construct the type at pointer p
                new (p) IntParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing IntParameter at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ParamDescription::ID:
        {
            // only need to construct if data type is not flat
            if (ParamDescription::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ParamDescription at %p\n",buffer);
                ParamDescriptionNML * p = static_cast<ParamDescriptionNML*>(buffer);
                // construct the type at pointer p
                new (p) ParamDescriptionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ParamDescription at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SensorLevels::ID:
        {
            // only need to construct if data type is not flat
            if (SensorLevels::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SensorLevels at %p\n",buffer);
                SensorLevelsNML * p = static_cast<SensorLevelsNML*>(buffer);
                // construct the type at pointer p
                new (p) SensorLevelsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SensorLevels at %p,, is flat\n",buffer);
            }
            break;
        } 
        case StrParameter::ID:
        {
            // only need to construct if data type is not flat
            if (StrParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing StrParameter at %p\n",buffer);
                StrParameterNML * p = static_cast<StrParameterNML*>(buffer);
                // construct the type at pointer p
                new (p) StrParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing StrParameter at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ReconfigureRequest::ID:
        {
            // only need to construct if data type is not flat
            if (ReconfigureRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ReconfigureRequest at %p\n",buffer);
                ReconfigureRequestNML * p = static_cast<ReconfigureRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) ReconfigureRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ReconfigureRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ReconfigureResponse::ID:
        {
            // only need to construct if data type is not flat
            if (ReconfigureResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ReconfigureResponse at %p\n",buffer);
                ReconfigureResponseNML * p = static_cast<ReconfigureResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) ReconfigureResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ReconfigureResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Reconfigure::ID:
        {
            // only need to construct if data type is not flat
            if (Reconfigure::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Reconfigure at %p\n",buffer);
                ReconfigureNML * p = static_cast<ReconfigureNML*>(buffer);
                // construct the type at pointer p
                new (p) ReconfigureNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Reconfigure at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int dynamic_reconfigure_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case BoolParameter::ID:
        {
            // only need to destruct if data type is not flat
            if (BoolParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing BoolParameter at %p\n",buffer);
                BoolParameterNML * p = static_cast<BoolParameterNML*>(buffer);
                p->~BoolParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction BoolParameter at %p, is flat\n",buffer);
            }
            break;
        } 
        case Config::ID:
        {
            // only need to destruct if data type is not flat
            if (Config::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Config at %p\n",buffer);
                ConfigNML * p = static_cast<ConfigNML*>(buffer);
                p->~ConfigNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Config at %p, is flat\n",buffer);
            }
            break;
        } 
        case ConfigDescription::ID:
        {
            // only need to destruct if data type is not flat
            if (ConfigDescription::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ConfigDescription at %p\n",buffer);
                ConfigDescriptionNML * p = static_cast<ConfigDescriptionNML*>(buffer);
                p->~ConfigDescriptionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ConfigDescription at %p, is flat\n",buffer);
            }
            break;
        } 
        case DoubleParameter::ID:
        {
            // only need to destruct if data type is not flat
            if (DoubleParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing DoubleParameter at %p\n",buffer);
                DoubleParameterNML * p = static_cast<DoubleParameterNML*>(buffer);
                p->~DoubleParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction DoubleParameter at %p, is flat\n",buffer);
            }
            break;
        } 
        case Group::ID:
        {
            // only need to destruct if data type is not flat
            if (Group::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Group at %p\n",buffer);
                GroupNML * p = static_cast<GroupNML*>(buffer);
                p->~GroupNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Group at %p, is flat\n",buffer);
            }
            break;
        } 
        case GroupState::ID:
        {
            // only need to destruct if data type is not flat
            if (GroupState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GroupState at %p\n",buffer);
                GroupStateNML * p = static_cast<GroupStateNML*>(buffer);
                p->~GroupStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GroupState at %p, is flat\n",buffer);
            }
            break;
        } 
        case IntParameter::ID:
        {
            // only need to destruct if data type is not flat
            if (IntParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing IntParameter at %p\n",buffer);
                IntParameterNML * p = static_cast<IntParameterNML*>(buffer);
                p->~IntParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction IntParameter at %p, is flat\n",buffer);
            }
            break;
        } 
        case ParamDescription::ID:
        {
            // only need to destruct if data type is not flat
            if (ParamDescription::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ParamDescription at %p\n",buffer);
                ParamDescriptionNML * p = static_cast<ParamDescriptionNML*>(buffer);
                p->~ParamDescriptionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ParamDescription at %p, is flat\n",buffer);
            }
            break;
        } 
        case SensorLevels::ID:
        {
            // only need to destruct if data type is not flat
            if (SensorLevels::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SensorLevels at %p\n",buffer);
                SensorLevelsNML * p = static_cast<SensorLevelsNML*>(buffer);
                p->~SensorLevelsNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SensorLevels at %p, is flat\n",buffer);
            }
            break;
        } 
        case StrParameter::ID:
        {
            // only need to destruct if data type is not flat
            if (StrParameter::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing StrParameter at %p\n",buffer);
                StrParameterNML * p = static_cast<StrParameterNML*>(buffer);
                p->~StrParameterNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction StrParameter at %p, is flat\n",buffer);
            }
            break;
        } 
        case ReconfigureRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (ReconfigureRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ReconfigureRequest at %p\n",buffer);
                ReconfigureRequestNML * p = static_cast<ReconfigureRequestNML*>(buffer);
                p->~ReconfigureRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ReconfigureRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case ReconfigureResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (ReconfigureResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ReconfigureResponse at %p\n",buffer);
                ReconfigureResponseNML * p = static_cast<ReconfigureResponseNML*>(buffer);
                p->~ReconfigureResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ReconfigureResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case Reconfigure::ID:
        {
            // only need to destruct if data type is not flat
            if (Reconfigure::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Reconfigure at %p\n",buffer);
                ReconfigureNML * p = static_cast<ReconfigureNML*>(buffer);
                p->~ReconfigureNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Reconfigure at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void dynamic_reconfigure::nmlupdate(CMS * cms, BoolParameter & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate BoolParameter, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        cms->update(inobj.value);

    }  
 }

BoolParameterNML::BoolParameterNML() : NMLmsg((NMLTYPE)BoolParameter::ID,sizeof(BoolParameterNML)), nmlVersion(BoolParameter::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new BoolParameter()*/)
{
};

BoolParameterNML::~BoolParameterNML()
{
};

BoolParameterNML & BoolParameterNML::operator=(const BoolParameterNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

BoolParameterNML & BoolParameterNML::operator=(const BoolParameter & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(BoolParameter);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void BoolParameterNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<BoolParameter&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: BoolParameterNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<BoolParameter> temp(new BoolParameter());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (BoolParameter::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: BoolParameter Message version mismatch, expected " << BoolParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: BoolParameter Message version mismatch, expected " << BoolParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, Config & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Config, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.bools);
        nmlupdate(cms,inobj.ints);
        nmlupdate(cms,inobj.strs);
        nmlupdate(cms,inobj.doubles);
        nmlupdate(cms,inobj.groups);

    }  
 }

ConfigNML::ConfigNML() : NMLmsg((NMLTYPE)Config::ID,sizeof(ConfigNML)), nmlVersion(Config::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Config()*/)
{
};

ConfigNML::~ConfigNML()
{
};

ConfigNML & ConfigNML::operator=(const ConfigNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ConfigNML & ConfigNML::operator=(const Config & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Config);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ConfigNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Config&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ConfigNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Config> temp(new Config());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Config::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Config Message version mismatch, expected " << Config::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Config Message version mismatch, expected " << Config::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, ConfigDescription & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ConfigDescription, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.groups);
        nmlupdate(cms,inobj.max);
        nmlupdate(cms,inobj.min);
        nmlupdate(cms,inobj.dflt);

    }  
 }

ConfigDescriptionNML::ConfigDescriptionNML() : NMLmsg((NMLTYPE)ConfigDescription::ID,sizeof(ConfigDescriptionNML)), nmlVersion(ConfigDescription::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ConfigDescription()*/)
{
};

ConfigDescriptionNML::~ConfigDescriptionNML()
{
};

ConfigDescriptionNML & ConfigDescriptionNML::operator=(const ConfigDescriptionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ConfigDescriptionNML & ConfigDescriptionNML::operator=(const ConfigDescription & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ConfigDescription);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ConfigDescriptionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ConfigDescription&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ConfigDescriptionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ConfigDescription> temp(new ConfigDescription());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ConfigDescription::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ConfigDescription Message version mismatch, expected " << ConfigDescription::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ConfigDescription Message version mismatch, expected " << ConfigDescription::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, DoubleParameter & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate DoubleParameter, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        cms->update(inobj.value);

    }  
 }

DoubleParameterNML::DoubleParameterNML() : NMLmsg((NMLTYPE)DoubleParameter::ID,sizeof(DoubleParameterNML)), nmlVersion(DoubleParameter::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new DoubleParameter()*/)
{
};

DoubleParameterNML::~DoubleParameterNML()
{
};

DoubleParameterNML & DoubleParameterNML::operator=(const DoubleParameterNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DoubleParameterNML & DoubleParameterNML::operator=(const DoubleParameter & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(DoubleParameter);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DoubleParameterNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<DoubleParameter&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DoubleParameterNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<DoubleParameter> temp(new DoubleParameter());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (DoubleParameter::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: DoubleParameter Message version mismatch, expected " << DoubleParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: DoubleParameter Message version mismatch, expected " << DoubleParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, Group & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Group, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.type);
        nmlupdate(cms,inobj.parameters);
        cms->update(inobj.parent);
        cms->update(inobj.id);

    }  
 }

GroupNML::GroupNML() : NMLmsg((NMLTYPE)Group::ID,sizeof(GroupNML)), nmlVersion(Group::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Group()*/)
{
};

GroupNML::~GroupNML()
{
};

GroupNML & GroupNML::operator=(const GroupNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GroupNML & GroupNML::operator=(const Group & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Group);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GroupNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Group&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GroupNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Group> temp(new Group());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Group::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Group Message version mismatch, expected " << Group::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Group Message version mismatch, expected " << Group::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, GroupState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GroupState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        cms->update(inobj.state);
        cms->update(inobj.id);
        cms->update(inobj.parent);

    }  
 }

GroupStateNML::GroupStateNML() : NMLmsg((NMLTYPE)GroupState::ID,sizeof(GroupStateNML)), nmlVersion(GroupState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GroupState()*/)
{
};

GroupStateNML::~GroupStateNML()
{
};

GroupStateNML & GroupStateNML::operator=(const GroupStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GroupStateNML & GroupStateNML::operator=(const GroupState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GroupState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GroupStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GroupState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GroupStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GroupState> temp(new GroupState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GroupState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GroupState Message version mismatch, expected " << GroupState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GroupState Message version mismatch, expected " << GroupState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, IntParameter & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate IntParameter, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        cms->update(inobj.value);

    }  
 }

IntParameterNML::IntParameterNML() : NMLmsg((NMLTYPE)IntParameter::ID,sizeof(IntParameterNML)), nmlVersion(IntParameter::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new IntParameter()*/)
{
};

IntParameterNML::~IntParameterNML()
{
};

IntParameterNML & IntParameterNML::operator=(const IntParameterNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

IntParameterNML & IntParameterNML::operator=(const IntParameter & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(IntParameter);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void IntParameterNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<IntParameter&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: IntParameterNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<IntParameter> temp(new IntParameter());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (IntParameter::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: IntParameter Message version mismatch, expected " << IntParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: IntParameter Message version mismatch, expected " << IntParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, ParamDescription & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ParamDescription, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.type);
        cms->update(inobj.level);
        nmlupdate(cms,inobj.description);
        nmlupdate(cms,inobj.edit_method);

    }  
 }

ParamDescriptionNML::ParamDescriptionNML() : NMLmsg((NMLTYPE)ParamDescription::ID,sizeof(ParamDescriptionNML)), nmlVersion(ParamDescription::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ParamDescription()*/)
{
};

ParamDescriptionNML::~ParamDescriptionNML()
{
};

ParamDescriptionNML & ParamDescriptionNML::operator=(const ParamDescriptionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ParamDescriptionNML & ParamDescriptionNML::operator=(const ParamDescription & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ParamDescription);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ParamDescriptionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ParamDescription&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ParamDescriptionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ParamDescription> temp(new ParamDescription());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ParamDescription::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ParamDescription Message version mismatch, expected " << ParamDescription::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ParamDescription Message version mismatch, expected " << ParamDescription::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, SensorLevels & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SensorLevels, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

SensorLevelsNML::SensorLevelsNML() : NMLmsg((NMLTYPE)SensorLevels::ID,sizeof(SensorLevelsNML)), nmlVersion(SensorLevels::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SensorLevels()*/)
{
};

SensorLevelsNML::~SensorLevelsNML()
{
};

SensorLevelsNML & SensorLevelsNML::operator=(const SensorLevelsNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SensorLevelsNML & SensorLevelsNML::operator=(const SensorLevels & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SensorLevels);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SensorLevelsNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SensorLevels&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SensorLevelsNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SensorLevels> temp(new SensorLevels());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SensorLevels::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SensorLevels Message version mismatch, expected " << SensorLevels::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SensorLevels Message version mismatch, expected " << SensorLevels::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, StrParameter & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate StrParameter, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.value);

    }  
 }

StrParameterNML::StrParameterNML() : NMLmsg((NMLTYPE)StrParameter::ID,sizeof(StrParameterNML)), nmlVersion(StrParameter::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new StrParameter()*/)
{
};

StrParameterNML::~StrParameterNML()
{
};

StrParameterNML & StrParameterNML::operator=(const StrParameterNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

StrParameterNML & StrParameterNML::operator=(const StrParameter & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(StrParameter);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void StrParameterNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<StrParameter&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: StrParameterNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<StrParameter> temp(new StrParameter());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (StrParameter::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: StrParameter Message version mismatch, expected " << StrParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: StrParameter Message version mismatch, expected " << StrParameter::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, ReconfigureRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ReconfigureRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.config);

    }  
 }

ReconfigureRequestNML::ReconfigureRequestNML() : NMLmsg((NMLTYPE)ReconfigureRequest::ID,sizeof(ReconfigureRequestNML)), nmlVersion(ReconfigureRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ReconfigureRequest()*/)
{
};

ReconfigureRequestNML::~ReconfigureRequestNML()
{
};

ReconfigureRequestNML & ReconfigureRequestNML::operator=(const ReconfigureRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ReconfigureRequestNML & ReconfigureRequestNML::operator=(const ReconfigureRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ReconfigureRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ReconfigureRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ReconfigureRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ReconfigureRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ReconfigureRequest> temp(new ReconfigureRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ReconfigureRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ReconfigureRequest Message version mismatch, expected " << ReconfigureRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ReconfigureRequest Message version mismatch, expected " << ReconfigureRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, ReconfigureResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ReconfigureResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.config);

    }  
 }

ReconfigureResponseNML::ReconfigureResponseNML() : NMLmsg((NMLTYPE)ReconfigureResponse::ID,sizeof(ReconfigureResponseNML)), nmlVersion(ReconfigureResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ReconfigureResponse()*/)
{
};

ReconfigureResponseNML::~ReconfigureResponseNML()
{
};

ReconfigureResponseNML & ReconfigureResponseNML::operator=(const ReconfigureResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ReconfigureResponseNML & ReconfigureResponseNML::operator=(const ReconfigureResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ReconfigureResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ReconfigureResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ReconfigureResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ReconfigureResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ReconfigureResponse> temp(new ReconfigureResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ReconfigureResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ReconfigureResponse Message version mismatch, expected " << ReconfigureResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ReconfigureResponse Message version mismatch, expected " << ReconfigureResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void dynamic_reconfigure::nmlupdate(CMS * cms, Reconfigure & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Reconfigure, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

ReconfigureNML::ReconfigureNML() : NMLmsg((NMLTYPE)Reconfigure::ID,sizeof(ReconfigureNML)), nmlVersion(Reconfigure::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Reconfigure()*/)
{
};

ReconfigureNML::~ReconfigureNML()
{
};

ReconfigureNML & ReconfigureNML::operator=(const ReconfigureNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ReconfigureNML & ReconfigureNML::operator=(const Reconfigure & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Reconfigure);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ReconfigureNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Reconfigure&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ReconfigureNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Reconfigure> temp(new Reconfigure());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: dynamic_reconfigure_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Reconfigure::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Reconfigure Message version mismatch, expected " << Reconfigure::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Reconfigure Message version mismatch, expected " << Reconfigure::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int dynamic_reconfigure::dynamic_reconfigure_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("dynamic_reconfigure_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case BoolParameter::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for BoolParameter, id " << BoolParameter::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((BoolParameterNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Config::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Config, id " << Config::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ConfigNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ConfigDescription::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ConfigDescription, id " << ConfigDescription::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ConfigDescriptionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case DoubleParameter::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for DoubleParameter, id " << DoubleParameter::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DoubleParameterNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Group::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Group, id " << Group::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GroupNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GroupState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GroupState, id " << GroupState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GroupStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case IntParameter::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for IntParameter, id " << IntParameter::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((IntParameterNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ParamDescription::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ParamDescription, id " << ParamDescription::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ParamDescriptionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SensorLevels::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SensorLevels, id " << SensorLevels::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SensorLevelsNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case StrParameter::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for StrParameter, id " << StrParameter::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((StrParameterNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ReconfigureRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ReconfigureRequest, id " << ReconfigureRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ReconfigureRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ReconfigureResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ReconfigureResponse, id " << ReconfigureResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ReconfigureResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Reconfigure::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Reconfigure, id " << Reconfigure::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_dynamic_reconfigure_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"dynamic_reconfigure_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ReconfigureNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

