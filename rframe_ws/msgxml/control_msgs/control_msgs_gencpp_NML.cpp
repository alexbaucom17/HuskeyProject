// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:04 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "control_msgs_gencpp_NML.h"
#include "control_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <FollowJointTrajectoryAction.h>
#include <FollowJointTrajectoryActionFeedback.h>
#include <FollowJointTrajectoryActionGoal.h>
#include <FollowJointTrajectoryActionResult.h>
#include <FollowJointTrajectoryFeedback.h>
#include <FollowJointTrajectoryGoal.h>
#include <FollowJointTrajectoryResult.h>
#include <GripperCommand.h>
#include <GripperCommandAction.h>
#include <GripperCommandActionFeedback.h>
#include <GripperCommandActionGoal.h>
#include <GripperCommandActionResult.h>
#include <GripperCommandFeedback.h>
#include <GripperCommandGoal.h>
#include <GripperCommandResult.h>
#include <JointControllerState.h>
#include <JointTolerance.h>
#include <JointTrajectoryAction.h>
#include <JointTrajectoryActionFeedback.h>
#include <JointTrajectoryActionGoal.h>
#include <JointTrajectoryActionResult.h>
#include <JointTrajectoryControllerState.h>
#include <JointTrajectoryFeedback.h>
#include <JointTrajectoryGoal.h>
#include <JointTrajectoryResult.h>
#include <PointHeadAction.h>
#include <PointHeadActionFeedback.h>
#include <PointHeadActionGoal.h>
#include <PointHeadActionResult.h>
#include <PointHeadFeedback.h>
#include <PointHeadGoal.h>
#include <PointHeadResult.h>
#include <SingleJointPositionAction.h>
#include <SingleJointPositionActionFeedback.h>
#include <SingleJointPositionActionGoal.h>
#include <SingleJointPositionActionResult.h>
#include <SingleJointPositionFeedback.h>
#include <SingleJointPositionGoal.h>
#include <SingleJointPositionResult.h>
#include <QueryCalibrationStateRequest.h>
#include <QueryCalibrationStateResponse.h>
#include <QueryCalibrationState.h>
#include <QueryTrajectoryStateRequest.h>
#include <QueryTrajectoryStateResponse.h>
#include <QueryTrajectoryState.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace control_msgs;

rframe::NMLMessageFactory * NML_control_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_control_msgs_gencppfactory = new control_msgs_gencppNMLMessageFactory();
        return NML_control_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * control_msgs::allocate_control_msgs_gencpp()
{
    NML_control_msgs_gencppfactory = new control_msgs_gencppNMLMessageFactory();
    return NML_control_msgs_gencppfactory;
};

control_msgs_gencppNMLMessageFactory::control_msgs_gencppNMLMessageFactory()
{
    name("control_msgs_gencpp");
    // use constructor to register data types
    control_msgs::registerLibrary();
}

control_msgs_gencppNMLMessageFactory::~control_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR control_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return control_msgs_gencpp_format;
}

int control_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void control_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(FollowJointTrajectoryAction::ID);
    info.name(FollowJointTrajectoryAction::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryAction::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryAction::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryAction::XML_SOURCE);
    info.flat(FollowJointTrajectoryAction::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryActionFeedback::ID);
    info.name(FollowJointTrajectoryActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryActionFeedback::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryActionFeedback::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryActionFeedback::XML_SOURCE);
    info.flat(FollowJointTrajectoryActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryActionGoal::ID);
    info.name(FollowJointTrajectoryActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryActionGoal::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryActionGoal::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryActionGoal::XML_SOURCE);
    info.flat(FollowJointTrajectoryActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryActionResult::ID);
    info.name(FollowJointTrajectoryActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryActionResult::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryActionResult::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryActionResult::XML_SOURCE);
    info.flat(FollowJointTrajectoryActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryFeedback::ID);
    info.name(FollowJointTrajectoryFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryFeedback::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryFeedback::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryFeedback::XML_SOURCE);
    info.flat(FollowJointTrajectoryFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryGoal::ID);
    info.name(FollowJointTrajectoryGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryGoal::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryGoal::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryGoal::XML_SOURCE);
    info.flat(FollowJointTrajectoryGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryResult::ID);
    info.name(FollowJointTrajectoryResult::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryResult::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryResult::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryResult::XML_SOURCE);
    info.flat(FollowJointTrajectoryResult::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommand::ID);
    info.name(GripperCommand::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommand::DATA_VERSION);
    info.md5Key(GripperCommand::VERSION_MD5);
    info.xmlSource(GripperCommand::XML_SOURCE);
    info.flat(GripperCommand::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandAction::ID);
    info.name(GripperCommandAction::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandAction::DATA_VERSION);
    info.md5Key(GripperCommandAction::VERSION_MD5);
    info.xmlSource(GripperCommandAction::XML_SOURCE);
    info.flat(GripperCommandAction::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandActionFeedback::ID);
    info.name(GripperCommandActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandActionFeedback::DATA_VERSION);
    info.md5Key(GripperCommandActionFeedback::VERSION_MD5);
    info.xmlSource(GripperCommandActionFeedback::XML_SOURCE);
    info.flat(GripperCommandActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandActionGoal::ID);
    info.name(GripperCommandActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandActionGoal::DATA_VERSION);
    info.md5Key(GripperCommandActionGoal::VERSION_MD5);
    info.xmlSource(GripperCommandActionGoal::XML_SOURCE);
    info.flat(GripperCommandActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandActionResult::ID);
    info.name(GripperCommandActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandActionResult::DATA_VERSION);
    info.md5Key(GripperCommandActionResult::VERSION_MD5);
    info.xmlSource(GripperCommandActionResult::XML_SOURCE);
    info.flat(GripperCommandActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandFeedback::ID);
    info.name(GripperCommandFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandFeedback::DATA_VERSION);
    info.md5Key(GripperCommandFeedback::VERSION_MD5);
    info.xmlSource(GripperCommandFeedback::XML_SOURCE);
    info.flat(GripperCommandFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandGoal::ID);
    info.name(GripperCommandGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandGoal::DATA_VERSION);
    info.md5Key(GripperCommandGoal::VERSION_MD5);
    info.xmlSource(GripperCommandGoal::XML_SOURCE);
    info.flat(GripperCommandGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandResult::ID);
    info.name(GripperCommandResult::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandResult::DATA_VERSION);
    info.md5Key(GripperCommandResult::VERSION_MD5);
    info.xmlSource(GripperCommandResult::XML_SOURCE);
    info.flat(GripperCommandResult::dataTypeFlat());
    ids.push_back(info);

    info.id(JointControllerState::ID);
    info.name(JointControllerState::DATA_TYPE_FULL_NAME);
    info.hashKey(JointControllerState::DATA_VERSION);
    info.md5Key(JointControllerState::VERSION_MD5);
    info.xmlSource(JointControllerState::XML_SOURCE);
    info.flat(JointControllerState::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTolerance::ID);
    info.name(JointTolerance::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTolerance::DATA_VERSION);
    info.md5Key(JointTolerance::VERSION_MD5);
    info.xmlSource(JointTolerance::XML_SOURCE);
    info.flat(JointTolerance::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryAction::ID);
    info.name(JointTrajectoryAction::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryAction::DATA_VERSION);
    info.md5Key(JointTrajectoryAction::VERSION_MD5);
    info.xmlSource(JointTrajectoryAction::XML_SOURCE);
    info.flat(JointTrajectoryAction::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryActionFeedback::ID);
    info.name(JointTrajectoryActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryActionFeedback::DATA_VERSION);
    info.md5Key(JointTrajectoryActionFeedback::VERSION_MD5);
    info.xmlSource(JointTrajectoryActionFeedback::XML_SOURCE);
    info.flat(JointTrajectoryActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryActionGoal::ID);
    info.name(JointTrajectoryActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryActionGoal::DATA_VERSION);
    info.md5Key(JointTrajectoryActionGoal::VERSION_MD5);
    info.xmlSource(JointTrajectoryActionGoal::XML_SOURCE);
    info.flat(JointTrajectoryActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryActionResult::ID);
    info.name(JointTrajectoryActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryActionResult::DATA_VERSION);
    info.md5Key(JointTrajectoryActionResult::VERSION_MD5);
    info.xmlSource(JointTrajectoryActionResult::XML_SOURCE);
    info.flat(JointTrajectoryActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryControllerState::ID);
    info.name(JointTrajectoryControllerState::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryControllerState::DATA_VERSION);
    info.md5Key(JointTrajectoryControllerState::VERSION_MD5);
    info.xmlSource(JointTrajectoryControllerState::XML_SOURCE);
    info.flat(JointTrajectoryControllerState::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryFeedback::ID);
    info.name(JointTrajectoryFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryFeedback::DATA_VERSION);
    info.md5Key(JointTrajectoryFeedback::VERSION_MD5);
    info.xmlSource(JointTrajectoryFeedback::XML_SOURCE);
    info.flat(JointTrajectoryFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryGoal::ID);
    info.name(JointTrajectoryGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryGoal::DATA_VERSION);
    info.md5Key(JointTrajectoryGoal::VERSION_MD5);
    info.xmlSource(JointTrajectoryGoal::XML_SOURCE);
    info.flat(JointTrajectoryGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryResult::ID);
    info.name(JointTrajectoryResult::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryResult::DATA_VERSION);
    info.md5Key(JointTrajectoryResult::VERSION_MD5);
    info.xmlSource(JointTrajectoryResult::XML_SOURCE);
    info.flat(JointTrajectoryResult::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadAction::ID);
    info.name(PointHeadAction::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadAction::DATA_VERSION);
    info.md5Key(PointHeadAction::VERSION_MD5);
    info.xmlSource(PointHeadAction::XML_SOURCE);
    info.flat(PointHeadAction::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadActionFeedback::ID);
    info.name(PointHeadActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadActionFeedback::DATA_VERSION);
    info.md5Key(PointHeadActionFeedback::VERSION_MD5);
    info.xmlSource(PointHeadActionFeedback::XML_SOURCE);
    info.flat(PointHeadActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadActionGoal::ID);
    info.name(PointHeadActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadActionGoal::DATA_VERSION);
    info.md5Key(PointHeadActionGoal::VERSION_MD5);
    info.xmlSource(PointHeadActionGoal::XML_SOURCE);
    info.flat(PointHeadActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadActionResult::ID);
    info.name(PointHeadActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadActionResult::DATA_VERSION);
    info.md5Key(PointHeadActionResult::VERSION_MD5);
    info.xmlSource(PointHeadActionResult::XML_SOURCE);
    info.flat(PointHeadActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadFeedback::ID);
    info.name(PointHeadFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadFeedback::DATA_VERSION);
    info.md5Key(PointHeadFeedback::VERSION_MD5);
    info.xmlSource(PointHeadFeedback::XML_SOURCE);
    info.flat(PointHeadFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadGoal::ID);
    info.name(PointHeadGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadGoal::DATA_VERSION);
    info.md5Key(PointHeadGoal::VERSION_MD5);
    info.xmlSource(PointHeadGoal::XML_SOURCE);
    info.flat(PointHeadGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadResult::ID);
    info.name(PointHeadResult::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadResult::DATA_VERSION);
    info.md5Key(PointHeadResult::VERSION_MD5);
    info.xmlSource(PointHeadResult::XML_SOURCE);
    info.flat(PointHeadResult::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionAction::ID);
    info.name(SingleJointPositionAction::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionAction::DATA_VERSION);
    info.md5Key(SingleJointPositionAction::VERSION_MD5);
    info.xmlSource(SingleJointPositionAction::XML_SOURCE);
    info.flat(SingleJointPositionAction::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionActionFeedback::ID);
    info.name(SingleJointPositionActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionActionFeedback::DATA_VERSION);
    info.md5Key(SingleJointPositionActionFeedback::VERSION_MD5);
    info.xmlSource(SingleJointPositionActionFeedback::XML_SOURCE);
    info.flat(SingleJointPositionActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionActionGoal::ID);
    info.name(SingleJointPositionActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionActionGoal::DATA_VERSION);
    info.md5Key(SingleJointPositionActionGoal::VERSION_MD5);
    info.xmlSource(SingleJointPositionActionGoal::XML_SOURCE);
    info.flat(SingleJointPositionActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionActionResult::ID);
    info.name(SingleJointPositionActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionActionResult::DATA_VERSION);
    info.md5Key(SingleJointPositionActionResult::VERSION_MD5);
    info.xmlSource(SingleJointPositionActionResult::XML_SOURCE);
    info.flat(SingleJointPositionActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionFeedback::ID);
    info.name(SingleJointPositionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionFeedback::DATA_VERSION);
    info.md5Key(SingleJointPositionFeedback::VERSION_MD5);
    info.xmlSource(SingleJointPositionFeedback::XML_SOURCE);
    info.flat(SingleJointPositionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionGoal::ID);
    info.name(SingleJointPositionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionGoal::DATA_VERSION);
    info.md5Key(SingleJointPositionGoal::VERSION_MD5);
    info.xmlSource(SingleJointPositionGoal::XML_SOURCE);
    info.flat(SingleJointPositionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionResult::ID);
    info.name(SingleJointPositionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionResult::DATA_VERSION);
    info.md5Key(SingleJointPositionResult::VERSION_MD5);
    info.xmlSource(SingleJointPositionResult::XML_SOURCE);
    info.flat(SingleJointPositionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryCalibrationStateRequest::ID);
    info.name(QueryCalibrationStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryCalibrationStateRequest::DATA_VERSION);
    info.md5Key(QueryCalibrationStateRequest::VERSION_MD5);
    info.xmlSource(QueryCalibrationStateRequest::XML_SOURCE);
    info.flat(QueryCalibrationStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryCalibrationStateResponse::ID);
    info.name(QueryCalibrationStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryCalibrationStateResponse::DATA_VERSION);
    info.md5Key(QueryCalibrationStateResponse::VERSION_MD5);
    info.xmlSource(QueryCalibrationStateResponse::XML_SOURCE);
    info.flat(QueryCalibrationStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryCalibrationState::ID);
    info.name(QueryCalibrationState::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryCalibrationState::DATA_VERSION);
    info.md5Key(QueryCalibrationState::VERSION_MD5);
    info.xmlSource(QueryCalibrationState::XML_SOURCE);
    info.flat(QueryCalibrationState::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryTrajectoryStateRequest::ID);
    info.name(QueryTrajectoryStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryTrajectoryStateRequest::DATA_VERSION);
    info.md5Key(QueryTrajectoryStateRequest::VERSION_MD5);
    info.xmlSource(QueryTrajectoryStateRequest::XML_SOURCE);
    info.flat(QueryTrajectoryStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryTrajectoryStateResponse::ID);
    info.name(QueryTrajectoryStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryTrajectoryStateResponse::DATA_VERSION);
    info.md5Key(QueryTrajectoryStateResponse::VERSION_MD5);
    info.xmlSource(QueryTrajectoryStateResponse::XML_SOURCE);
    info.flat(QueryTrajectoryStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryTrajectoryState::ID);
    info.name(QueryTrajectoryState::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryTrajectoryState::DATA_VERSION);
    info.md5Key(QueryTrajectoryState::VERSION_MD5);
    info.xmlSource(QueryTrajectoryState::XML_SOURCE);
    info.flat(QueryTrajectoryState::dataTypeFlat());
    ids.push_back(info);

}

int control_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case FollowJointTrajectoryAction::ID:
        {
            //FollowJointTrajectoryActionNML * newmsg = new FollowJointTrajectoryActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryActionNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            //FollowJointTrajectoryActionFeedbackNML * newmsg = new FollowJointTrajectoryActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryActionFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            //FollowJointTrajectoryActionGoalNML * newmsg = new FollowJointTrajectoryActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryActionGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            //FollowJointTrajectoryActionResultNML * newmsg = new FollowJointTrajectoryActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryActionResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            //FollowJointTrajectoryFeedbackNML * newmsg = new FollowJointTrajectoryFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FollowJointTrajectoryGoal::ID:
        {
            //FollowJointTrajectoryGoalNML * newmsg = new FollowJointTrajectoryGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case FollowJointTrajectoryResult::ID:
        {
            //FollowJointTrajectoryResultNML * newmsg = new FollowJointTrajectoryResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new FollowJointTrajectoryResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommand::ID:
        {
            //GripperCommandNML * newmsg = new GripperCommandNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandAction::ID:
        {
            //GripperCommandActionNML * newmsg = new GripperCommandActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandActionNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandActionFeedback::ID:
        {
            //GripperCommandActionFeedbackNML * newmsg = new GripperCommandActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandActionFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            //GripperCommandActionGoalNML * newmsg = new GripperCommandActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandActionGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandActionResult::ID:
        {
            //GripperCommandActionResultNML * newmsg = new GripperCommandActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandActionResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandFeedback::ID:
        {
            //GripperCommandFeedbackNML * newmsg = new GripperCommandFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandGoal::ID:
        {
            //GripperCommandGoalNML * newmsg = new GripperCommandGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case GripperCommandResult::ID:
        {
            //GripperCommandResultNML * newmsg = new GripperCommandResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new GripperCommandResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointControllerState::ID:
        {
            //JointControllerStateNML * newmsg = new JointControllerStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointControllerStateNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTolerance::ID:
        {
            //JointToleranceNML * newmsg = new JointToleranceNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointToleranceNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryAction::ID:
        {
            //JointTrajectoryActionNML * newmsg = new JointTrajectoryActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryActionNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryActionFeedback::ID:
        {
            //JointTrajectoryActionFeedbackNML * newmsg = new JointTrajectoryActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryActionFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            //JointTrajectoryActionGoalNML * newmsg = new JointTrajectoryActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryActionGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            //JointTrajectoryActionResultNML * newmsg = new JointTrajectoryActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryActionResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            //JointTrajectoryControllerStateNML * newmsg = new JointTrajectoryControllerStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryControllerStateNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryFeedback::ID:
        {
            //JointTrajectoryFeedbackNML * newmsg = new JointTrajectoryFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryGoal::ID:
        {
            //JointTrajectoryGoalNML * newmsg = new JointTrajectoryGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case JointTrajectoryResult::ID:
        {
            //JointTrajectoryResultNML * newmsg = new JointTrajectoryResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new JointTrajectoryResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadAction::ID:
        {
            //PointHeadActionNML * newmsg = new PointHeadActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadActionNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadActionFeedback::ID:
        {
            //PointHeadActionFeedbackNML * newmsg = new PointHeadActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadActionFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadActionGoal::ID:
        {
            //PointHeadActionGoalNML * newmsg = new PointHeadActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadActionGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadActionResult::ID:
        {
            //PointHeadActionResultNML * newmsg = new PointHeadActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadActionResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadFeedback::ID:
        {
            //PointHeadFeedbackNML * newmsg = new PointHeadFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadGoal::ID:
        {
            //PointHeadGoalNML * newmsg = new PointHeadGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case PointHeadResult::ID:
        {
            //PointHeadResultNML * newmsg = new PointHeadResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new PointHeadResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionAction::ID:
        {
            //SingleJointPositionActionNML * newmsg = new SingleJointPositionActionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionActionNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionActionFeedback::ID:
        {
            //SingleJointPositionActionFeedbackNML * newmsg = new SingleJointPositionActionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionActionFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            //SingleJointPositionActionGoalNML * newmsg = new SingleJointPositionActionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionActionGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            //SingleJointPositionActionResultNML * newmsg = new SingleJointPositionActionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionActionResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            //SingleJointPositionFeedbackNML * newmsg = new SingleJointPositionFeedbackNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionFeedbackNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionGoal::ID:
        {
            //SingleJointPositionGoalNML * newmsg = new SingleJointPositionGoalNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionGoalNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case SingleJointPositionResult::ID:
        {
            //SingleJointPositionResultNML * newmsg = new SingleJointPositionResultNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new SingleJointPositionResultNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QueryCalibrationStateRequest::ID:
        {
            //QueryCalibrationStateRequestNML * newmsg = new QueryCalibrationStateRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QueryCalibrationStateRequestNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QueryCalibrationStateResponse::ID:
        {
            //QueryCalibrationStateResponseNML * newmsg = new QueryCalibrationStateResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QueryCalibrationStateResponseNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QueryCalibrationState::ID:
        {
            //QueryCalibrationStateNML * newmsg = new QueryCalibrationStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QueryCalibrationStateNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QueryTrajectoryStateRequest::ID:
        {
            //QueryTrajectoryStateRequestNML * newmsg = new QueryTrajectoryStateRequestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QueryTrajectoryStateRequestNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QueryTrajectoryStateResponse::ID:
        {
            //QueryTrajectoryStateResponseNML * newmsg = new QueryTrajectoryStateResponseNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QueryTrajectoryStateResponseNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case QueryTrajectoryState::ID:
        {
            //QueryTrajectoryStateNML * newmsg = new QueryTrajectoryStateNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new QueryTrajectoryStateNML(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int control_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case FollowJointTrajectoryAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryAction>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryActionFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryActionGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryActionResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommand::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommand>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandAction>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandActionFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandActionGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandActionResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointControllerState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointControllerState>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTolerance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTolerance>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryAction>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryActionFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryActionGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryActionResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryControllerState>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadAction>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadActionFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadActionGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadActionResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionAction>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionActionFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionActionGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionActionResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionFeedback>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionGoal>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionResult>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryCalibrationStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryCalibrationStateRequest>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryCalibrationStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryCalibrationStateResponse>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryCalibrationState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryCalibrationState>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryTrajectoryStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryTrajectoryStateRequest>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryTrajectoryStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryTrajectoryStateResponse>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryTrajectoryState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryTrajectoryState>(),std::bind(&control_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int control_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int control_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case FollowJointTrajectoryAction::ID:
            {
                FollowJointTrajectoryActionNML * tempmsg = static_cast<FollowJointTrajectoryActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FollowJointTrajectoryActionFeedback::ID:
            {
                FollowJointTrajectoryActionFeedbackNML * tempmsg = static_cast<FollowJointTrajectoryActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FollowJointTrajectoryActionGoal::ID:
            {
                FollowJointTrajectoryActionGoalNML * tempmsg = static_cast<FollowJointTrajectoryActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FollowJointTrajectoryActionResult::ID:
            {
                FollowJointTrajectoryActionResultNML * tempmsg = static_cast<FollowJointTrajectoryActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FollowJointTrajectoryFeedback::ID:
            {
                FollowJointTrajectoryFeedbackNML * tempmsg = static_cast<FollowJointTrajectoryFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FollowJointTrajectoryGoal::ID:
            {
                FollowJointTrajectoryGoalNML * tempmsg = static_cast<FollowJointTrajectoryGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case FollowJointTrajectoryResult::ID:
            {
                FollowJointTrajectoryResultNML * tempmsg = static_cast<FollowJointTrajectoryResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommand::ID:
            {
                GripperCommandNML * tempmsg = static_cast<GripperCommandNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandAction::ID:
            {
                GripperCommandActionNML * tempmsg = static_cast<GripperCommandActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandActionFeedback::ID:
            {
                GripperCommandActionFeedbackNML * tempmsg = static_cast<GripperCommandActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandActionGoal::ID:
            {
                GripperCommandActionGoalNML * tempmsg = static_cast<GripperCommandActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandActionResult::ID:
            {
                GripperCommandActionResultNML * tempmsg = static_cast<GripperCommandActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandFeedback::ID:
            {
                GripperCommandFeedbackNML * tempmsg = static_cast<GripperCommandFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandGoal::ID:
            {
                GripperCommandGoalNML * tempmsg = static_cast<GripperCommandGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case GripperCommandResult::ID:
            {
                GripperCommandResultNML * tempmsg = static_cast<GripperCommandResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointControllerState::ID:
            {
                JointControllerStateNML * tempmsg = static_cast<JointControllerStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTolerance::ID:
            {
                JointToleranceNML * tempmsg = static_cast<JointToleranceNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryAction::ID:
            {
                JointTrajectoryActionNML * tempmsg = static_cast<JointTrajectoryActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryActionFeedback::ID:
            {
                JointTrajectoryActionFeedbackNML * tempmsg = static_cast<JointTrajectoryActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryActionGoal::ID:
            {
                JointTrajectoryActionGoalNML * tempmsg = static_cast<JointTrajectoryActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryActionResult::ID:
            {
                JointTrajectoryActionResultNML * tempmsg = static_cast<JointTrajectoryActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryControllerState::ID:
            {
                JointTrajectoryControllerStateNML * tempmsg = static_cast<JointTrajectoryControllerStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryFeedback::ID:
            {
                JointTrajectoryFeedbackNML * tempmsg = static_cast<JointTrajectoryFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryGoal::ID:
            {
                JointTrajectoryGoalNML * tempmsg = static_cast<JointTrajectoryGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case JointTrajectoryResult::ID:
            {
                JointTrajectoryResultNML * tempmsg = static_cast<JointTrajectoryResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadAction::ID:
            {
                PointHeadActionNML * tempmsg = static_cast<PointHeadActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadActionFeedback::ID:
            {
                PointHeadActionFeedbackNML * tempmsg = static_cast<PointHeadActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadActionGoal::ID:
            {
                PointHeadActionGoalNML * tempmsg = static_cast<PointHeadActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadActionResult::ID:
            {
                PointHeadActionResultNML * tempmsg = static_cast<PointHeadActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadFeedback::ID:
            {
                PointHeadFeedbackNML * tempmsg = static_cast<PointHeadFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadGoal::ID:
            {
                PointHeadGoalNML * tempmsg = static_cast<PointHeadGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case PointHeadResult::ID:
            {
                PointHeadResultNML * tempmsg = static_cast<PointHeadResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionAction::ID:
            {
                SingleJointPositionActionNML * tempmsg = static_cast<SingleJointPositionActionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionActionFeedback::ID:
            {
                SingleJointPositionActionFeedbackNML * tempmsg = static_cast<SingleJointPositionActionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionActionGoal::ID:
            {
                SingleJointPositionActionGoalNML * tempmsg = static_cast<SingleJointPositionActionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionActionResult::ID:
            {
                SingleJointPositionActionResultNML * tempmsg = static_cast<SingleJointPositionActionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionFeedback::ID:
            {
                SingleJointPositionFeedbackNML * tempmsg = static_cast<SingleJointPositionFeedbackNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionGoal::ID:
            {
                SingleJointPositionGoalNML * tempmsg = static_cast<SingleJointPositionGoalNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case SingleJointPositionResult::ID:
            {
                SingleJointPositionResultNML * tempmsg = static_cast<SingleJointPositionResultNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QueryCalibrationStateRequest::ID:
            {
                QueryCalibrationStateRequestNML * tempmsg = static_cast<QueryCalibrationStateRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QueryCalibrationStateResponse::ID:
            {
                QueryCalibrationStateResponseNML * tempmsg = static_cast<QueryCalibrationStateResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QueryCalibrationState::ID:
            {
                QueryCalibrationStateNML * tempmsg = static_cast<QueryCalibrationStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QueryTrajectoryStateRequest::ID:
            {
                QueryTrajectoryStateRequestNML * tempmsg = static_cast<QueryTrajectoryStateRequestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QueryTrajectoryStateResponse::ID:
            {
                QueryTrajectoryStateResponseNML * tempmsg = static_cast<QueryTrajectoryStateResponseNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case QueryTrajectoryState::ID:
            {
                QueryTrajectoryStateNML * tempmsg = static_cast<QueryTrajectoryStateNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int control_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case FollowJointTrajectoryAction::ID:
            {
                FollowJointTrajectoryActionNML & tempDst = static_cast<FollowJointTrajectoryActionNML&>(dst);
                Message<FollowJointTrajectoryAction > & tempSrc = static_cast<Message<FollowJointTrajectoryAction>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryAction: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryAction: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FollowJointTrajectoryActionFeedback::ID:
            {
                FollowJointTrajectoryActionFeedbackNML & tempDst = static_cast<FollowJointTrajectoryActionFeedbackNML&>(dst);
                Message<FollowJointTrajectoryActionFeedback > & tempSrc = static_cast<Message<FollowJointTrajectoryActionFeedback>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryActionFeedback: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryActionFeedback: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FollowJointTrajectoryActionGoal::ID:
            {
                FollowJointTrajectoryActionGoalNML & tempDst = static_cast<FollowJointTrajectoryActionGoalNML&>(dst);
                Message<FollowJointTrajectoryActionGoal > & tempSrc = static_cast<Message<FollowJointTrajectoryActionGoal>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryActionGoal: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryActionGoal: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FollowJointTrajectoryActionResult::ID:
            {
                FollowJointTrajectoryActionResultNML & tempDst = static_cast<FollowJointTrajectoryActionResultNML&>(dst);
                Message<FollowJointTrajectoryActionResult > & tempSrc = static_cast<Message<FollowJointTrajectoryActionResult>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryActionResult: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryActionResult: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FollowJointTrajectoryFeedback::ID:
            {
                FollowJointTrajectoryFeedbackNML & tempDst = static_cast<FollowJointTrajectoryFeedbackNML&>(dst);
                Message<FollowJointTrajectoryFeedback > & tempSrc = static_cast<Message<FollowJointTrajectoryFeedback>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryFeedback: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryFeedback: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FollowJointTrajectoryGoal::ID:
            {
                FollowJointTrajectoryGoalNML & tempDst = static_cast<FollowJointTrajectoryGoalNML&>(dst);
                Message<FollowJointTrajectoryGoal > & tempSrc = static_cast<Message<FollowJointTrajectoryGoal>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryGoal: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryGoal: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case FollowJointTrajectoryResult::ID:
            {
                FollowJointTrajectoryResultNML & tempDst = static_cast<FollowJointTrajectoryResultNML&>(dst);
                Message<FollowJointTrajectoryResult > & tempSrc = static_cast<Message<FollowJointTrajectoryResult>&>(src);

                if (tempSrc.version() != FollowJointTrajectoryResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of FollowJointTrajectoryResult: " << __FILE__ << " expected: " 
                             << FollowJointTrajectoryResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of FollowJointTrajectoryResult: " << __FILE__ << " expected: " 
                         << FollowJointTrajectoryResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommand::ID:
            {
                GripperCommandNML & tempDst = static_cast<GripperCommandNML&>(dst);
                Message<GripperCommand > & tempSrc = static_cast<Message<GripperCommand>&>(src);

                if (tempSrc.version() != GripperCommand::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommand: " << __FILE__ << " expected: " 
                             << GripperCommand::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommand: " << __FILE__ << " expected: " 
                         << GripperCommand::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandAction::ID:
            {
                GripperCommandActionNML & tempDst = static_cast<GripperCommandActionNML&>(dst);
                Message<GripperCommandAction > & tempSrc = static_cast<Message<GripperCommandAction>&>(src);

                if (tempSrc.version() != GripperCommandAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandAction: " << __FILE__ << " expected: " 
                             << GripperCommandAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandAction: " << __FILE__ << " expected: " 
                         << GripperCommandAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandActionFeedback::ID:
            {
                GripperCommandActionFeedbackNML & tempDst = static_cast<GripperCommandActionFeedbackNML&>(dst);
                Message<GripperCommandActionFeedback > & tempSrc = static_cast<Message<GripperCommandActionFeedback>&>(src);

                if (tempSrc.version() != GripperCommandActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandActionFeedback: " << __FILE__ << " expected: " 
                             << GripperCommandActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandActionFeedback: " << __FILE__ << " expected: " 
                         << GripperCommandActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandActionGoal::ID:
            {
                GripperCommandActionGoalNML & tempDst = static_cast<GripperCommandActionGoalNML&>(dst);
                Message<GripperCommandActionGoal > & tempSrc = static_cast<Message<GripperCommandActionGoal>&>(src);

                if (tempSrc.version() != GripperCommandActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandActionGoal: " << __FILE__ << " expected: " 
                             << GripperCommandActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandActionGoal: " << __FILE__ << " expected: " 
                         << GripperCommandActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandActionResult::ID:
            {
                GripperCommandActionResultNML & tempDst = static_cast<GripperCommandActionResultNML&>(dst);
                Message<GripperCommandActionResult > & tempSrc = static_cast<Message<GripperCommandActionResult>&>(src);

                if (tempSrc.version() != GripperCommandActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandActionResult: " << __FILE__ << " expected: " 
                             << GripperCommandActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandActionResult: " << __FILE__ << " expected: " 
                         << GripperCommandActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandFeedback::ID:
            {
                GripperCommandFeedbackNML & tempDst = static_cast<GripperCommandFeedbackNML&>(dst);
                Message<GripperCommandFeedback > & tempSrc = static_cast<Message<GripperCommandFeedback>&>(src);

                if (tempSrc.version() != GripperCommandFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandFeedback: " << __FILE__ << " expected: " 
                             << GripperCommandFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandFeedback: " << __FILE__ << " expected: " 
                         << GripperCommandFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandGoal::ID:
            {
                GripperCommandGoalNML & tempDst = static_cast<GripperCommandGoalNML&>(dst);
                Message<GripperCommandGoal > & tempSrc = static_cast<Message<GripperCommandGoal>&>(src);

                if (tempSrc.version() != GripperCommandGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandGoal: " << __FILE__ << " expected: " 
                             << GripperCommandGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandGoal: " << __FILE__ << " expected: " 
                         << GripperCommandGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case GripperCommandResult::ID:
            {
                GripperCommandResultNML & tempDst = static_cast<GripperCommandResultNML&>(dst);
                Message<GripperCommandResult > & tempSrc = static_cast<Message<GripperCommandResult>&>(src);

                if (tempSrc.version() != GripperCommandResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of GripperCommandResult: " << __FILE__ << " expected: " 
                             << GripperCommandResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of GripperCommandResult: " << __FILE__ << " expected: " 
                         << GripperCommandResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointControllerState::ID:
            {
                JointControllerStateNML & tempDst = static_cast<JointControllerStateNML&>(dst);
                Message<JointControllerState > & tempSrc = static_cast<Message<JointControllerState>&>(src);

                if (tempSrc.version() != JointControllerState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointControllerState: " << __FILE__ << " expected: " 
                             << JointControllerState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointControllerState: " << __FILE__ << " expected: " 
                         << JointControllerState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTolerance::ID:
            {
                JointToleranceNML & tempDst = static_cast<JointToleranceNML&>(dst);
                Message<JointTolerance > & tempSrc = static_cast<Message<JointTolerance>&>(src);

                if (tempSrc.version() != JointTolerance::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTolerance: " << __FILE__ << " expected: " 
                             << JointTolerance::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTolerance: " << __FILE__ << " expected: " 
                         << JointTolerance::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryAction::ID:
            {
                JointTrajectoryActionNML & tempDst = static_cast<JointTrajectoryActionNML&>(dst);
                Message<JointTrajectoryAction > & tempSrc = static_cast<Message<JointTrajectoryAction>&>(src);

                if (tempSrc.version() != JointTrajectoryAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryAction: " << __FILE__ << " expected: " 
                             << JointTrajectoryAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryAction: " << __FILE__ << " expected: " 
                         << JointTrajectoryAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryActionFeedback::ID:
            {
                JointTrajectoryActionFeedbackNML & tempDst = static_cast<JointTrajectoryActionFeedbackNML&>(dst);
                Message<JointTrajectoryActionFeedback > & tempSrc = static_cast<Message<JointTrajectoryActionFeedback>&>(src);

                if (tempSrc.version() != JointTrajectoryActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryActionFeedback: " << __FILE__ << " expected: " 
                             << JointTrajectoryActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryActionFeedback: " << __FILE__ << " expected: " 
                         << JointTrajectoryActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryActionGoal::ID:
            {
                JointTrajectoryActionGoalNML & tempDst = static_cast<JointTrajectoryActionGoalNML&>(dst);
                Message<JointTrajectoryActionGoal > & tempSrc = static_cast<Message<JointTrajectoryActionGoal>&>(src);

                if (tempSrc.version() != JointTrajectoryActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryActionGoal: " << __FILE__ << " expected: " 
                             << JointTrajectoryActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryActionGoal: " << __FILE__ << " expected: " 
                         << JointTrajectoryActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryActionResult::ID:
            {
                JointTrajectoryActionResultNML & tempDst = static_cast<JointTrajectoryActionResultNML&>(dst);
                Message<JointTrajectoryActionResult > & tempSrc = static_cast<Message<JointTrajectoryActionResult>&>(src);

                if (tempSrc.version() != JointTrajectoryActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryActionResult: " << __FILE__ << " expected: " 
                             << JointTrajectoryActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryActionResult: " << __FILE__ << " expected: " 
                         << JointTrajectoryActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryControllerState::ID:
            {
                JointTrajectoryControllerStateNML & tempDst = static_cast<JointTrajectoryControllerStateNML&>(dst);
                Message<JointTrajectoryControllerState > & tempSrc = static_cast<Message<JointTrajectoryControllerState>&>(src);

                if (tempSrc.version() != JointTrajectoryControllerState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryControllerState: " << __FILE__ << " expected: " 
                             << JointTrajectoryControllerState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryControllerState: " << __FILE__ << " expected: " 
                         << JointTrajectoryControllerState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryFeedback::ID:
            {
                JointTrajectoryFeedbackNML & tempDst = static_cast<JointTrajectoryFeedbackNML&>(dst);
                Message<JointTrajectoryFeedback > & tempSrc = static_cast<Message<JointTrajectoryFeedback>&>(src);

                if (tempSrc.version() != JointTrajectoryFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryFeedback: " << __FILE__ << " expected: " 
                             << JointTrajectoryFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryFeedback: " << __FILE__ << " expected: " 
                         << JointTrajectoryFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryGoal::ID:
            {
                JointTrajectoryGoalNML & tempDst = static_cast<JointTrajectoryGoalNML&>(dst);
                Message<JointTrajectoryGoal > & tempSrc = static_cast<Message<JointTrajectoryGoal>&>(src);

                if (tempSrc.version() != JointTrajectoryGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryGoal: " << __FILE__ << " expected: " 
                             << JointTrajectoryGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryGoal: " << __FILE__ << " expected: " 
                         << JointTrajectoryGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case JointTrajectoryResult::ID:
            {
                JointTrajectoryResultNML & tempDst = static_cast<JointTrajectoryResultNML&>(dst);
                Message<JointTrajectoryResult > & tempSrc = static_cast<Message<JointTrajectoryResult>&>(src);

                if (tempSrc.version() != JointTrajectoryResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of JointTrajectoryResult: " << __FILE__ << " expected: " 
                             << JointTrajectoryResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of JointTrajectoryResult: " << __FILE__ << " expected: " 
                         << JointTrajectoryResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadAction::ID:
            {
                PointHeadActionNML & tempDst = static_cast<PointHeadActionNML&>(dst);
                Message<PointHeadAction > & tempSrc = static_cast<Message<PointHeadAction>&>(src);

                if (tempSrc.version() != PointHeadAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadAction: " << __FILE__ << " expected: " 
                             << PointHeadAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadAction: " << __FILE__ << " expected: " 
                         << PointHeadAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadActionFeedback::ID:
            {
                PointHeadActionFeedbackNML & tempDst = static_cast<PointHeadActionFeedbackNML&>(dst);
                Message<PointHeadActionFeedback > & tempSrc = static_cast<Message<PointHeadActionFeedback>&>(src);

                if (tempSrc.version() != PointHeadActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadActionFeedback: " << __FILE__ << " expected: " 
                             << PointHeadActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadActionFeedback: " << __FILE__ << " expected: " 
                         << PointHeadActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadActionGoal::ID:
            {
                PointHeadActionGoalNML & tempDst = static_cast<PointHeadActionGoalNML&>(dst);
                Message<PointHeadActionGoal > & tempSrc = static_cast<Message<PointHeadActionGoal>&>(src);

                if (tempSrc.version() != PointHeadActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadActionGoal: " << __FILE__ << " expected: " 
                             << PointHeadActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadActionGoal: " << __FILE__ << " expected: " 
                         << PointHeadActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadActionResult::ID:
            {
                PointHeadActionResultNML & tempDst = static_cast<PointHeadActionResultNML&>(dst);
                Message<PointHeadActionResult > & tempSrc = static_cast<Message<PointHeadActionResult>&>(src);

                if (tempSrc.version() != PointHeadActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadActionResult: " << __FILE__ << " expected: " 
                             << PointHeadActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadActionResult: " << __FILE__ << " expected: " 
                         << PointHeadActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadFeedback::ID:
            {
                PointHeadFeedbackNML & tempDst = static_cast<PointHeadFeedbackNML&>(dst);
                Message<PointHeadFeedback > & tempSrc = static_cast<Message<PointHeadFeedback>&>(src);

                if (tempSrc.version() != PointHeadFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadFeedback: " << __FILE__ << " expected: " 
                             << PointHeadFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadFeedback: " << __FILE__ << " expected: " 
                         << PointHeadFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadGoal::ID:
            {
                PointHeadGoalNML & tempDst = static_cast<PointHeadGoalNML&>(dst);
                Message<PointHeadGoal > & tempSrc = static_cast<Message<PointHeadGoal>&>(src);

                if (tempSrc.version() != PointHeadGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadGoal: " << __FILE__ << " expected: " 
                             << PointHeadGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadGoal: " << __FILE__ << " expected: " 
                         << PointHeadGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case PointHeadResult::ID:
            {
                PointHeadResultNML & tempDst = static_cast<PointHeadResultNML&>(dst);
                Message<PointHeadResult > & tempSrc = static_cast<Message<PointHeadResult>&>(src);

                if (tempSrc.version() != PointHeadResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of PointHeadResult: " << __FILE__ << " expected: " 
                             << PointHeadResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of PointHeadResult: " << __FILE__ << " expected: " 
                         << PointHeadResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionAction::ID:
            {
                SingleJointPositionActionNML & tempDst = static_cast<SingleJointPositionActionNML&>(dst);
                Message<SingleJointPositionAction > & tempSrc = static_cast<Message<SingleJointPositionAction>&>(src);

                if (tempSrc.version() != SingleJointPositionAction::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionAction: " << __FILE__ << " expected: " 
                             << SingleJointPositionAction::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionAction: " << __FILE__ << " expected: " 
                         << SingleJointPositionAction::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionActionFeedback::ID:
            {
                SingleJointPositionActionFeedbackNML & tempDst = static_cast<SingleJointPositionActionFeedbackNML&>(dst);
                Message<SingleJointPositionActionFeedback > & tempSrc = static_cast<Message<SingleJointPositionActionFeedback>&>(src);

                if (tempSrc.version() != SingleJointPositionActionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionActionFeedback: " << __FILE__ << " expected: " 
                             << SingleJointPositionActionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionActionFeedback: " << __FILE__ << " expected: " 
                         << SingleJointPositionActionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionActionGoal::ID:
            {
                SingleJointPositionActionGoalNML & tempDst = static_cast<SingleJointPositionActionGoalNML&>(dst);
                Message<SingleJointPositionActionGoal > & tempSrc = static_cast<Message<SingleJointPositionActionGoal>&>(src);

                if (tempSrc.version() != SingleJointPositionActionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionActionGoal: " << __FILE__ << " expected: " 
                             << SingleJointPositionActionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionActionGoal: " << __FILE__ << " expected: " 
                         << SingleJointPositionActionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionActionResult::ID:
            {
                SingleJointPositionActionResultNML & tempDst = static_cast<SingleJointPositionActionResultNML&>(dst);
                Message<SingleJointPositionActionResult > & tempSrc = static_cast<Message<SingleJointPositionActionResult>&>(src);

                if (tempSrc.version() != SingleJointPositionActionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionActionResult: " << __FILE__ << " expected: " 
                             << SingleJointPositionActionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionActionResult: " << __FILE__ << " expected: " 
                         << SingleJointPositionActionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionFeedback::ID:
            {
                SingleJointPositionFeedbackNML & tempDst = static_cast<SingleJointPositionFeedbackNML&>(dst);
                Message<SingleJointPositionFeedback > & tempSrc = static_cast<Message<SingleJointPositionFeedback>&>(src);

                if (tempSrc.version() != SingleJointPositionFeedback::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionFeedback: " << __FILE__ << " expected: " 
                             << SingleJointPositionFeedback::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionFeedback: " << __FILE__ << " expected: " 
                         << SingleJointPositionFeedback::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionGoal::ID:
            {
                SingleJointPositionGoalNML & tempDst = static_cast<SingleJointPositionGoalNML&>(dst);
                Message<SingleJointPositionGoal > & tempSrc = static_cast<Message<SingleJointPositionGoal>&>(src);

                if (tempSrc.version() != SingleJointPositionGoal::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionGoal: " << __FILE__ << " expected: " 
                             << SingleJointPositionGoal::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionGoal: " << __FILE__ << " expected: " 
                         << SingleJointPositionGoal::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case SingleJointPositionResult::ID:
            {
                SingleJointPositionResultNML & tempDst = static_cast<SingleJointPositionResultNML&>(dst);
                Message<SingleJointPositionResult > & tempSrc = static_cast<Message<SingleJointPositionResult>&>(src);

                if (tempSrc.version() != SingleJointPositionResult::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of SingleJointPositionResult: " << __FILE__ << " expected: " 
                             << SingleJointPositionResult::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of SingleJointPositionResult: " << __FILE__ << " expected: " 
                         << SingleJointPositionResult::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QueryCalibrationStateRequest::ID:
            {
                QueryCalibrationStateRequestNML & tempDst = static_cast<QueryCalibrationStateRequestNML&>(dst);
                Message<QueryCalibrationStateRequest > & tempSrc = static_cast<Message<QueryCalibrationStateRequest>&>(src);

                if (tempSrc.version() != QueryCalibrationStateRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QueryCalibrationStateRequest: " << __FILE__ << " expected: " 
                             << QueryCalibrationStateRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QueryCalibrationStateRequest: " << __FILE__ << " expected: " 
                         << QueryCalibrationStateRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QueryCalibrationStateResponse::ID:
            {
                QueryCalibrationStateResponseNML & tempDst = static_cast<QueryCalibrationStateResponseNML&>(dst);
                Message<QueryCalibrationStateResponse > & tempSrc = static_cast<Message<QueryCalibrationStateResponse>&>(src);

                if (tempSrc.version() != QueryCalibrationStateResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QueryCalibrationStateResponse: " << __FILE__ << " expected: " 
                             << QueryCalibrationStateResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QueryCalibrationStateResponse: " << __FILE__ << " expected: " 
                         << QueryCalibrationStateResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QueryCalibrationState::ID:
            {
                QueryCalibrationStateNML & tempDst = static_cast<QueryCalibrationStateNML&>(dst);
                Message<QueryCalibrationState > & tempSrc = static_cast<Message<QueryCalibrationState>&>(src);

                if (tempSrc.version() != QueryCalibrationState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QueryCalibrationState: " << __FILE__ << " expected: " 
                             << QueryCalibrationState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QueryCalibrationState: " << __FILE__ << " expected: " 
                         << QueryCalibrationState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QueryTrajectoryStateRequest::ID:
            {
                QueryTrajectoryStateRequestNML & tempDst = static_cast<QueryTrajectoryStateRequestNML&>(dst);
                Message<QueryTrajectoryStateRequest > & tempSrc = static_cast<Message<QueryTrajectoryStateRequest>&>(src);

                if (tempSrc.version() != QueryTrajectoryStateRequest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QueryTrajectoryStateRequest: " << __FILE__ << " expected: " 
                             << QueryTrajectoryStateRequest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QueryTrajectoryStateRequest: " << __FILE__ << " expected: " 
                         << QueryTrajectoryStateRequest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QueryTrajectoryStateResponse::ID:
            {
                QueryTrajectoryStateResponseNML & tempDst = static_cast<QueryTrajectoryStateResponseNML&>(dst);
                Message<QueryTrajectoryStateResponse > & tempSrc = static_cast<Message<QueryTrajectoryStateResponse>&>(src);

                if (tempSrc.version() != QueryTrajectoryStateResponse::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QueryTrajectoryStateResponse: " << __FILE__ << " expected: " 
                             << QueryTrajectoryStateResponse::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QueryTrajectoryStateResponse: " << __FILE__ << " expected: " 
                         << QueryTrajectoryStateResponse::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case QueryTrajectoryState::ID:
            {
                QueryTrajectoryStateNML & tempDst = static_cast<QueryTrajectoryStateNML&>(dst);
                Message<QueryTrajectoryState > & tempSrc = static_cast<Message<QueryTrajectoryState>&>(src);

                if (tempSrc.version() != QueryTrajectoryState::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of QueryTrajectoryState: " << __FILE__ << " expected: " 
                             << QueryTrajectoryState::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of QueryTrajectoryState: " << __FILE__ << " expected: " 
                         << QueryTrajectoryState::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int control_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case FollowJointTrajectoryAction::ID:
            {
                FollowJointTrajectoryActionNML & tempSrc = static_cast<FollowJointTrajectoryActionNML&>(src);
                Message<FollowJointTrajectoryAction > & tempDst = static_cast<Message<FollowJointTrajectoryAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FollowJointTrajectoryActionFeedback::ID:
            {
                FollowJointTrajectoryActionFeedbackNML & tempSrc = static_cast<FollowJointTrajectoryActionFeedbackNML&>(src);
                Message<FollowJointTrajectoryActionFeedback > & tempDst = static_cast<Message<FollowJointTrajectoryActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FollowJointTrajectoryActionGoal::ID:
            {
                FollowJointTrajectoryActionGoalNML & tempSrc = static_cast<FollowJointTrajectoryActionGoalNML&>(src);
                Message<FollowJointTrajectoryActionGoal > & tempDst = static_cast<Message<FollowJointTrajectoryActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FollowJointTrajectoryActionResult::ID:
            {
                FollowJointTrajectoryActionResultNML & tempSrc = static_cast<FollowJointTrajectoryActionResultNML&>(src);
                Message<FollowJointTrajectoryActionResult > & tempDst = static_cast<Message<FollowJointTrajectoryActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FollowJointTrajectoryFeedback::ID:
            {
                FollowJointTrajectoryFeedbackNML & tempSrc = static_cast<FollowJointTrajectoryFeedbackNML&>(src);
                Message<FollowJointTrajectoryFeedback > & tempDst = static_cast<Message<FollowJointTrajectoryFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FollowJointTrajectoryGoal::ID:
            {
                FollowJointTrajectoryGoalNML & tempSrc = static_cast<FollowJointTrajectoryGoalNML&>(src);
                Message<FollowJointTrajectoryGoal > & tempDst = static_cast<Message<FollowJointTrajectoryGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case FollowJointTrajectoryResult::ID:
            {
                FollowJointTrajectoryResultNML & tempSrc = static_cast<FollowJointTrajectoryResultNML&>(src);
                Message<FollowJointTrajectoryResult > & tempDst = static_cast<Message<FollowJointTrajectoryResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (FollowJointTrajectoryResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommand::ID:
            {
                GripperCommandNML & tempSrc = static_cast<GripperCommandNML&>(src);
                Message<GripperCommand > & tempDst = static_cast<Message<GripperCommand>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommand::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandAction::ID:
            {
                GripperCommandActionNML & tempSrc = static_cast<GripperCommandActionNML&>(src);
                Message<GripperCommandAction > & tempDst = static_cast<Message<GripperCommandAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandActionFeedback::ID:
            {
                GripperCommandActionFeedbackNML & tempSrc = static_cast<GripperCommandActionFeedbackNML&>(src);
                Message<GripperCommandActionFeedback > & tempDst = static_cast<Message<GripperCommandActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandActionGoal::ID:
            {
                GripperCommandActionGoalNML & tempSrc = static_cast<GripperCommandActionGoalNML&>(src);
                Message<GripperCommandActionGoal > & tempDst = static_cast<Message<GripperCommandActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandActionResult::ID:
            {
                GripperCommandActionResultNML & tempSrc = static_cast<GripperCommandActionResultNML&>(src);
                Message<GripperCommandActionResult > & tempDst = static_cast<Message<GripperCommandActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandFeedback::ID:
            {
                GripperCommandFeedbackNML & tempSrc = static_cast<GripperCommandFeedbackNML&>(src);
                Message<GripperCommandFeedback > & tempDst = static_cast<Message<GripperCommandFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandGoal::ID:
            {
                GripperCommandGoalNML & tempSrc = static_cast<GripperCommandGoalNML&>(src);
                Message<GripperCommandGoal > & tempDst = static_cast<Message<GripperCommandGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case GripperCommandResult::ID:
            {
                GripperCommandResultNML & tempSrc = static_cast<GripperCommandResultNML&>(src);
                Message<GripperCommandResult > & tempDst = static_cast<Message<GripperCommandResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (GripperCommandResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointControllerState::ID:
            {
                JointControllerStateNML & tempSrc = static_cast<JointControllerStateNML&>(src);
                Message<JointControllerState > & tempDst = static_cast<Message<JointControllerState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointControllerState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTolerance::ID:
            {
                JointToleranceNML & tempSrc = static_cast<JointToleranceNML&>(src);
                Message<JointTolerance > & tempDst = static_cast<Message<JointTolerance>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTolerance::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryAction::ID:
            {
                JointTrajectoryActionNML & tempSrc = static_cast<JointTrajectoryActionNML&>(src);
                Message<JointTrajectoryAction > & tempDst = static_cast<Message<JointTrajectoryAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryActionFeedback::ID:
            {
                JointTrajectoryActionFeedbackNML & tempSrc = static_cast<JointTrajectoryActionFeedbackNML&>(src);
                Message<JointTrajectoryActionFeedback > & tempDst = static_cast<Message<JointTrajectoryActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryActionGoal::ID:
            {
                JointTrajectoryActionGoalNML & tempSrc = static_cast<JointTrajectoryActionGoalNML&>(src);
                Message<JointTrajectoryActionGoal > & tempDst = static_cast<Message<JointTrajectoryActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryActionResult::ID:
            {
                JointTrajectoryActionResultNML & tempSrc = static_cast<JointTrajectoryActionResultNML&>(src);
                Message<JointTrajectoryActionResult > & tempDst = static_cast<Message<JointTrajectoryActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryControllerState::ID:
            {
                JointTrajectoryControllerStateNML & tempSrc = static_cast<JointTrajectoryControllerStateNML&>(src);
                Message<JointTrajectoryControllerState > & tempDst = static_cast<Message<JointTrajectoryControllerState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryControllerState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryFeedback::ID:
            {
                JointTrajectoryFeedbackNML & tempSrc = static_cast<JointTrajectoryFeedbackNML&>(src);
                Message<JointTrajectoryFeedback > & tempDst = static_cast<Message<JointTrajectoryFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryGoal::ID:
            {
                JointTrajectoryGoalNML & tempSrc = static_cast<JointTrajectoryGoalNML&>(src);
                Message<JointTrajectoryGoal > & tempDst = static_cast<Message<JointTrajectoryGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case JointTrajectoryResult::ID:
            {
                JointTrajectoryResultNML & tempSrc = static_cast<JointTrajectoryResultNML&>(src);
                Message<JointTrajectoryResult > & tempDst = static_cast<Message<JointTrajectoryResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (JointTrajectoryResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadAction::ID:
            {
                PointHeadActionNML & tempSrc = static_cast<PointHeadActionNML&>(src);
                Message<PointHeadAction > & tempDst = static_cast<Message<PointHeadAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadActionFeedback::ID:
            {
                PointHeadActionFeedbackNML & tempSrc = static_cast<PointHeadActionFeedbackNML&>(src);
                Message<PointHeadActionFeedback > & tempDst = static_cast<Message<PointHeadActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadActionGoal::ID:
            {
                PointHeadActionGoalNML & tempSrc = static_cast<PointHeadActionGoalNML&>(src);
                Message<PointHeadActionGoal > & tempDst = static_cast<Message<PointHeadActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadActionResult::ID:
            {
                PointHeadActionResultNML & tempSrc = static_cast<PointHeadActionResultNML&>(src);
                Message<PointHeadActionResult > & tempDst = static_cast<Message<PointHeadActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadFeedback::ID:
            {
                PointHeadFeedbackNML & tempSrc = static_cast<PointHeadFeedbackNML&>(src);
                Message<PointHeadFeedback > & tempDst = static_cast<Message<PointHeadFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadGoal::ID:
            {
                PointHeadGoalNML & tempSrc = static_cast<PointHeadGoalNML&>(src);
                Message<PointHeadGoal > & tempDst = static_cast<Message<PointHeadGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case PointHeadResult::ID:
            {
                PointHeadResultNML & tempSrc = static_cast<PointHeadResultNML&>(src);
                Message<PointHeadResult > & tempDst = static_cast<Message<PointHeadResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (PointHeadResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionAction::ID:
            {
                SingleJointPositionActionNML & tempSrc = static_cast<SingleJointPositionActionNML&>(src);
                Message<SingleJointPositionAction > & tempDst = static_cast<Message<SingleJointPositionAction>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionAction::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionActionFeedback::ID:
            {
                SingleJointPositionActionFeedbackNML & tempSrc = static_cast<SingleJointPositionActionFeedbackNML&>(src);
                Message<SingleJointPositionActionFeedback > & tempDst = static_cast<Message<SingleJointPositionActionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionActionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionActionGoal::ID:
            {
                SingleJointPositionActionGoalNML & tempSrc = static_cast<SingleJointPositionActionGoalNML&>(src);
                Message<SingleJointPositionActionGoal > & tempDst = static_cast<Message<SingleJointPositionActionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionActionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionActionResult::ID:
            {
                SingleJointPositionActionResultNML & tempSrc = static_cast<SingleJointPositionActionResultNML&>(src);
                Message<SingleJointPositionActionResult > & tempDst = static_cast<Message<SingleJointPositionActionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionActionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionFeedback::ID:
            {
                SingleJointPositionFeedbackNML & tempSrc = static_cast<SingleJointPositionFeedbackNML&>(src);
                Message<SingleJointPositionFeedback > & tempDst = static_cast<Message<SingleJointPositionFeedback>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionFeedback::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionGoal::ID:
            {
                SingleJointPositionGoalNML & tempSrc = static_cast<SingleJointPositionGoalNML&>(src);
                Message<SingleJointPositionGoal > & tempDst = static_cast<Message<SingleJointPositionGoal>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionGoal::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case SingleJointPositionResult::ID:
            {
                SingleJointPositionResultNML & tempSrc = static_cast<SingleJointPositionResultNML&>(src);
                Message<SingleJointPositionResult > & tempDst = static_cast<Message<SingleJointPositionResult>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (SingleJointPositionResult::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QueryCalibrationStateRequest::ID:
            {
                QueryCalibrationStateRequestNML & tempSrc = static_cast<QueryCalibrationStateRequestNML&>(src);
                Message<QueryCalibrationStateRequest > & tempDst = static_cast<Message<QueryCalibrationStateRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QueryCalibrationStateRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QueryCalibrationStateResponse::ID:
            {
                QueryCalibrationStateResponseNML & tempSrc = static_cast<QueryCalibrationStateResponseNML&>(src);
                Message<QueryCalibrationStateResponse > & tempDst = static_cast<Message<QueryCalibrationStateResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QueryCalibrationStateResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QueryCalibrationState::ID:
            {
                QueryCalibrationStateNML & tempSrc = static_cast<QueryCalibrationStateNML&>(src);
                Message<QueryCalibrationState > & tempDst = static_cast<Message<QueryCalibrationState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QueryCalibrationState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QueryTrajectoryStateRequest::ID:
            {
                QueryTrajectoryStateRequestNML & tempSrc = static_cast<QueryTrajectoryStateRequestNML&>(src);
                Message<QueryTrajectoryStateRequest > & tempDst = static_cast<Message<QueryTrajectoryStateRequest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QueryTrajectoryStateRequest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QueryTrajectoryStateResponse::ID:
            {
                QueryTrajectoryStateResponseNML & tempSrc = static_cast<QueryTrajectoryStateResponseNML&>(src);
                Message<QueryTrajectoryStateResponse > & tempDst = static_cast<Message<QueryTrajectoryStateResponse>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QueryTrajectoryStateResponse::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case QueryTrajectoryState::ID:
            {
                QueryTrajectoryStateNML & tempSrc = static_cast<QueryTrajectoryStateNML&>(src);
                Message<QueryTrajectoryState > & tempDst = static_cast<Message<QueryTrajectoryState>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (QueryTrajectoryState::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int control_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case FollowJointTrajectoryAction::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryAction at %p\n",buffer);
                FollowJointTrajectoryActionNML * p = static_cast<FollowJointTrajectoryActionNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryActionFeedback at %p\n",buffer);
                FollowJointTrajectoryActionFeedbackNML * p = static_cast<FollowJointTrajectoryActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryActionGoal at %p\n",buffer);
                FollowJointTrajectoryActionGoalNML * p = static_cast<FollowJointTrajectoryActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryActionResult at %p\n",buffer);
                FollowJointTrajectoryActionResultNML * p = static_cast<FollowJointTrajectoryActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryFeedback at %p\n",buffer);
                FollowJointTrajectoryFeedbackNML * p = static_cast<FollowJointTrajectoryFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryGoal::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryGoal at %p\n",buffer);
                FollowJointTrajectoryGoalNML * p = static_cast<FollowJointTrajectoryGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryResult::ID:
        {
            // only need to construct if data type is not flat
            if (FollowJointTrajectoryResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing FollowJointTrajectoryResult at %p\n",buffer);
                FollowJointTrajectoryResultNML * p = static_cast<FollowJointTrajectoryResultNML*>(buffer);
                // construct the type at pointer p
                new (p) FollowJointTrajectoryResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing FollowJointTrajectoryResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommand::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommand::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommand at %p\n",buffer);
                GripperCommandNML * p = static_cast<GripperCommandNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommand at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandAction::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandAction at %p\n",buffer);
                GripperCommandActionNML * p = static_cast<GripperCommandActionNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandActionFeedback at %p\n",buffer);
                GripperCommandActionFeedbackNML * p = static_cast<GripperCommandActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandActionGoal at %p\n",buffer);
                GripperCommandActionGoalNML * p = static_cast<GripperCommandActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandActionResult at %p\n",buffer);
                GripperCommandActionResultNML * p = static_cast<GripperCommandActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandFeedback at %p\n",buffer);
                GripperCommandFeedbackNML * p = static_cast<GripperCommandFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandGoal::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandGoal at %p\n",buffer);
                GripperCommandGoalNML * p = static_cast<GripperCommandGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandResult::ID:
        {
            // only need to construct if data type is not flat
            if (GripperCommandResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing GripperCommandResult at %p\n",buffer);
                GripperCommandResultNML * p = static_cast<GripperCommandResultNML*>(buffer);
                // construct the type at pointer p
                new (p) GripperCommandResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing GripperCommandResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointControllerState::ID:
        {
            // only need to construct if data type is not flat
            if (JointControllerState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointControllerState at %p\n",buffer);
                JointControllerStateNML * p = static_cast<JointControllerStateNML*>(buffer);
                // construct the type at pointer p
                new (p) JointControllerStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointControllerState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTolerance::ID:
        {
            // only need to construct if data type is not flat
            if (JointTolerance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTolerance at %p\n",buffer);
                JointToleranceNML * p = static_cast<JointToleranceNML*>(buffer);
                // construct the type at pointer p
                new (p) JointToleranceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTolerance at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryAction::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryAction at %p\n",buffer);
                JointTrajectoryActionNML * p = static_cast<JointTrajectoryActionNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryActionFeedback at %p\n",buffer);
                JointTrajectoryActionFeedbackNML * p = static_cast<JointTrajectoryActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryActionGoal at %p\n",buffer);
                JointTrajectoryActionGoalNML * p = static_cast<JointTrajectoryActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryActionResult at %p\n",buffer);
                JointTrajectoryActionResultNML * p = static_cast<JointTrajectoryActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryControllerState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryControllerState at %p\n",buffer);
                JointTrajectoryControllerStateNML * p = static_cast<JointTrajectoryControllerStateNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryControllerStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryControllerState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryFeedback at %p\n",buffer);
                JointTrajectoryFeedbackNML * p = static_cast<JointTrajectoryFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryGoal::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryGoal at %p\n",buffer);
                JointTrajectoryGoalNML * p = static_cast<JointTrajectoryGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryResult::ID:
        {
            // only need to construct if data type is not flat
            if (JointTrajectoryResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing JointTrajectoryResult at %p\n",buffer);
                JointTrajectoryResultNML * p = static_cast<JointTrajectoryResultNML*>(buffer);
                // construct the type at pointer p
                new (p) JointTrajectoryResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing JointTrajectoryResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadAction::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadAction at %p\n",buffer);
                PointHeadActionNML * p = static_cast<PointHeadActionNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadActionFeedback at %p\n",buffer);
                PointHeadActionFeedbackNML * p = static_cast<PointHeadActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadActionGoal at %p\n",buffer);
                PointHeadActionGoalNML * p = static_cast<PointHeadActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadActionResult at %p\n",buffer);
                PointHeadActionResultNML * p = static_cast<PointHeadActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadFeedback at %p\n",buffer);
                PointHeadFeedbackNML * p = static_cast<PointHeadFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadGoal::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadGoal at %p\n",buffer);
                PointHeadGoalNML * p = static_cast<PointHeadGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadResult::ID:
        {
            // only need to construct if data type is not flat
            if (PointHeadResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing PointHeadResult at %p\n",buffer);
                PointHeadResultNML * p = static_cast<PointHeadResultNML*>(buffer);
                // construct the type at pointer p
                new (p) PointHeadResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing PointHeadResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionAction::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionAction at %p\n",buffer);
                SingleJointPositionActionNML * p = static_cast<SingleJointPositionActionNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionAction at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionActionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionActionFeedback at %p\n",buffer);
                SingleJointPositionActionFeedbackNML * p = static_cast<SingleJointPositionActionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionActionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionActionGoal at %p\n",buffer);
                SingleJointPositionActionGoalNML * p = static_cast<SingleJointPositionActionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionActionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionActionResult at %p\n",buffer);
                SingleJointPositionActionResultNML * p = static_cast<SingleJointPositionActionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionActionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionFeedback at %p\n",buffer);
                SingleJointPositionFeedbackNML * p = static_cast<SingleJointPositionFeedbackNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionFeedback at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionGoal::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionGoal at %p\n",buffer);
                SingleJointPositionGoalNML * p = static_cast<SingleJointPositionGoalNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionGoal at %p,, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionResult::ID:
        {
            // only need to construct if data type is not flat
            if (SingleJointPositionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing SingleJointPositionResult at %p\n",buffer);
                SingleJointPositionResultNML * p = static_cast<SingleJointPositionResultNML*>(buffer);
                // construct the type at pointer p
                new (p) SingleJointPositionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing SingleJointPositionResult at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QueryCalibrationStateRequest::ID:
        {
            // only need to construct if data type is not flat
            if (QueryCalibrationStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QueryCalibrationStateRequest at %p\n",buffer);
                QueryCalibrationStateRequestNML * p = static_cast<QueryCalibrationStateRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) QueryCalibrationStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QueryCalibrationStateRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QueryCalibrationStateResponse::ID:
        {
            // only need to construct if data type is not flat
            if (QueryCalibrationStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QueryCalibrationStateResponse at %p\n",buffer);
                QueryCalibrationStateResponseNML * p = static_cast<QueryCalibrationStateResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) QueryCalibrationStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QueryCalibrationStateResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QueryCalibrationState::ID:
        {
            // only need to construct if data type is not flat
            if (QueryCalibrationState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QueryCalibrationState at %p\n",buffer);
                QueryCalibrationStateNML * p = static_cast<QueryCalibrationStateNML*>(buffer);
                // construct the type at pointer p
                new (p) QueryCalibrationStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QueryCalibrationState at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QueryTrajectoryStateRequest::ID:
        {
            // only need to construct if data type is not flat
            if (QueryTrajectoryStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QueryTrajectoryStateRequest at %p\n",buffer);
                QueryTrajectoryStateRequestNML * p = static_cast<QueryTrajectoryStateRequestNML*>(buffer);
                // construct the type at pointer p
                new (p) QueryTrajectoryStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QueryTrajectoryStateRequest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QueryTrajectoryStateResponse::ID:
        {
            // only need to construct if data type is not flat
            if (QueryTrajectoryStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QueryTrajectoryStateResponse at %p\n",buffer);
                QueryTrajectoryStateResponseNML * p = static_cast<QueryTrajectoryStateResponseNML*>(buffer);
                // construct the type at pointer p
                new (p) QueryTrajectoryStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QueryTrajectoryStateResponse at %p,, is flat\n",buffer);
            }
            break;
        } 
        case QueryTrajectoryState::ID:
        {
            // only need to construct if data type is not flat
            if (QueryTrajectoryState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing QueryTrajectoryState at %p\n",buffer);
                QueryTrajectoryStateNML * p = static_cast<QueryTrajectoryStateNML*>(buffer);
                // construct the type at pointer p
                new (p) QueryTrajectoryStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing QueryTrajectoryState at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int control_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case FollowJointTrajectoryAction::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryAction at %p\n",buffer);
                FollowJointTrajectoryActionNML * p = static_cast<FollowJointTrajectoryActionNML*>(buffer);
                p->~FollowJointTrajectoryActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryActionFeedback at %p\n",buffer);
                FollowJointTrajectoryActionFeedbackNML * p = static_cast<FollowJointTrajectoryActionFeedbackNML*>(buffer);
                p->~FollowJointTrajectoryActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryActionGoal at %p\n",buffer);
                FollowJointTrajectoryActionGoalNML * p = static_cast<FollowJointTrajectoryActionGoalNML*>(buffer);
                p->~FollowJointTrajectoryActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryActionResult at %p\n",buffer);
                FollowJointTrajectoryActionResultNML * p = static_cast<FollowJointTrajectoryActionResultNML*>(buffer);
                p->~FollowJointTrajectoryActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryFeedback at %p\n",buffer);
                FollowJointTrajectoryFeedbackNML * p = static_cast<FollowJointTrajectoryFeedbackNML*>(buffer);
                p->~FollowJointTrajectoryFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryGoal at %p\n",buffer);
                FollowJointTrajectoryGoalNML * p = static_cast<FollowJointTrajectoryGoalNML*>(buffer);
                p->~FollowJointTrajectoryGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case FollowJointTrajectoryResult::ID:
        {
            // only need to destruct if data type is not flat
            if (FollowJointTrajectoryResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing FollowJointTrajectoryResult at %p\n",buffer);
                FollowJointTrajectoryResultNML * p = static_cast<FollowJointTrajectoryResultNML*>(buffer);
                p->~FollowJointTrajectoryResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction FollowJointTrajectoryResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommand::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommand::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommand at %p\n",buffer);
                GripperCommandNML * p = static_cast<GripperCommandNML*>(buffer);
                p->~GripperCommandNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommand at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandAction::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandAction at %p\n",buffer);
                GripperCommandActionNML * p = static_cast<GripperCommandActionNML*>(buffer);
                p->~GripperCommandActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandActionFeedback at %p\n",buffer);
                GripperCommandActionFeedbackNML * p = static_cast<GripperCommandActionFeedbackNML*>(buffer);
                p->~GripperCommandActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandActionGoal at %p\n",buffer);
                GripperCommandActionGoalNML * p = static_cast<GripperCommandActionGoalNML*>(buffer);
                p->~GripperCommandActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandActionResult at %p\n",buffer);
                GripperCommandActionResultNML * p = static_cast<GripperCommandActionResultNML*>(buffer);
                p->~GripperCommandActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandFeedback at %p\n",buffer);
                GripperCommandFeedbackNML * p = static_cast<GripperCommandFeedbackNML*>(buffer);
                p->~GripperCommandFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandGoal at %p\n",buffer);
                GripperCommandGoalNML * p = static_cast<GripperCommandGoalNML*>(buffer);
                p->~GripperCommandGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case GripperCommandResult::ID:
        {
            // only need to destruct if data type is not flat
            if (GripperCommandResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing GripperCommandResult at %p\n",buffer);
                GripperCommandResultNML * p = static_cast<GripperCommandResultNML*>(buffer);
                p->~GripperCommandResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction GripperCommandResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointControllerState::ID:
        {
            // only need to destruct if data type is not flat
            if (JointControllerState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointControllerState at %p\n",buffer);
                JointControllerStateNML * p = static_cast<JointControllerStateNML*>(buffer);
                p->~JointControllerStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointControllerState at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTolerance::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTolerance::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTolerance at %p\n",buffer);
                JointToleranceNML * p = static_cast<JointToleranceNML*>(buffer);
                p->~JointToleranceNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTolerance at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryAction::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryAction at %p\n",buffer);
                JointTrajectoryActionNML * p = static_cast<JointTrajectoryActionNML*>(buffer);
                p->~JointTrajectoryActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryActionFeedback at %p\n",buffer);
                JointTrajectoryActionFeedbackNML * p = static_cast<JointTrajectoryActionFeedbackNML*>(buffer);
                p->~JointTrajectoryActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryActionGoal at %p\n",buffer);
                JointTrajectoryActionGoalNML * p = static_cast<JointTrajectoryActionGoalNML*>(buffer);
                p->~JointTrajectoryActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryActionResult at %p\n",buffer);
                JointTrajectoryActionResultNML * p = static_cast<JointTrajectoryActionResultNML*>(buffer);
                p->~JointTrajectoryActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryControllerState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryControllerState at %p\n",buffer);
                JointTrajectoryControllerStateNML * p = static_cast<JointTrajectoryControllerStateNML*>(buffer);
                p->~JointTrajectoryControllerStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryControllerState at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryFeedback at %p\n",buffer);
                JointTrajectoryFeedbackNML * p = static_cast<JointTrajectoryFeedbackNML*>(buffer);
                p->~JointTrajectoryFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryGoal at %p\n",buffer);
                JointTrajectoryGoalNML * p = static_cast<JointTrajectoryGoalNML*>(buffer);
                p->~JointTrajectoryGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case JointTrajectoryResult::ID:
        {
            // only need to destruct if data type is not flat
            if (JointTrajectoryResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing JointTrajectoryResult at %p\n",buffer);
                JointTrajectoryResultNML * p = static_cast<JointTrajectoryResultNML*>(buffer);
                p->~JointTrajectoryResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction JointTrajectoryResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadAction::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadAction at %p\n",buffer);
                PointHeadActionNML * p = static_cast<PointHeadActionNML*>(buffer);
                p->~PointHeadActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadActionFeedback at %p\n",buffer);
                PointHeadActionFeedbackNML * p = static_cast<PointHeadActionFeedbackNML*>(buffer);
                p->~PointHeadActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadActionGoal at %p\n",buffer);
                PointHeadActionGoalNML * p = static_cast<PointHeadActionGoalNML*>(buffer);
                p->~PointHeadActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadActionResult at %p\n",buffer);
                PointHeadActionResultNML * p = static_cast<PointHeadActionResultNML*>(buffer);
                p->~PointHeadActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadFeedback at %p\n",buffer);
                PointHeadFeedbackNML * p = static_cast<PointHeadFeedbackNML*>(buffer);
                p->~PointHeadFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadGoal at %p\n",buffer);
                PointHeadGoalNML * p = static_cast<PointHeadGoalNML*>(buffer);
                p->~PointHeadGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case PointHeadResult::ID:
        {
            // only need to destruct if data type is not flat
            if (PointHeadResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing PointHeadResult at %p\n",buffer);
                PointHeadResultNML * p = static_cast<PointHeadResultNML*>(buffer);
                p->~PointHeadResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction PointHeadResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionAction::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionAction::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionAction at %p\n",buffer);
                SingleJointPositionActionNML * p = static_cast<SingleJointPositionActionNML*>(buffer);
                p->~SingleJointPositionActionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionAction at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionActionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionActionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionActionFeedback at %p\n",buffer);
                SingleJointPositionActionFeedbackNML * p = static_cast<SingleJointPositionActionFeedbackNML*>(buffer);
                p->~SingleJointPositionActionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionActionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionActionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionActionGoal at %p\n",buffer);
                SingleJointPositionActionGoalNML * p = static_cast<SingleJointPositionActionGoalNML*>(buffer);
                p->~SingleJointPositionActionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionActionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionActionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionActionResult at %p\n",buffer);
                SingleJointPositionActionResultNML * p = static_cast<SingleJointPositionActionResultNML*>(buffer);
                p->~SingleJointPositionActionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionActionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionFeedback::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionFeedback at %p\n",buffer);
                SingleJointPositionFeedbackNML * p = static_cast<SingleJointPositionFeedbackNML*>(buffer);
                p->~SingleJointPositionFeedbackNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionFeedback at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionGoal::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionGoal::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionGoal at %p\n",buffer);
                SingleJointPositionGoalNML * p = static_cast<SingleJointPositionGoalNML*>(buffer);
                p->~SingleJointPositionGoalNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionGoal at %p, is flat\n",buffer);
            }
            break;
        } 
        case SingleJointPositionResult::ID:
        {
            // only need to destruct if data type is not flat
            if (SingleJointPositionResult::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing SingleJointPositionResult at %p\n",buffer);
                SingleJointPositionResultNML * p = static_cast<SingleJointPositionResultNML*>(buffer);
                p->~SingleJointPositionResultNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction SingleJointPositionResult at %p, is flat\n",buffer);
            }
            break;
        } 
        case QueryCalibrationStateRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (QueryCalibrationStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QueryCalibrationStateRequest at %p\n",buffer);
                QueryCalibrationStateRequestNML * p = static_cast<QueryCalibrationStateRequestNML*>(buffer);
                p->~QueryCalibrationStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QueryCalibrationStateRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case QueryCalibrationStateResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (QueryCalibrationStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QueryCalibrationStateResponse at %p\n",buffer);
                QueryCalibrationStateResponseNML * p = static_cast<QueryCalibrationStateResponseNML*>(buffer);
                p->~QueryCalibrationStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QueryCalibrationStateResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case QueryCalibrationState::ID:
        {
            // only need to destruct if data type is not flat
            if (QueryCalibrationState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QueryCalibrationState at %p\n",buffer);
                QueryCalibrationStateNML * p = static_cast<QueryCalibrationStateNML*>(buffer);
                p->~QueryCalibrationStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QueryCalibrationState at %p, is flat\n",buffer);
            }
            break;
        } 
        case QueryTrajectoryStateRequest::ID:
        {
            // only need to destruct if data type is not flat
            if (QueryTrajectoryStateRequest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QueryTrajectoryStateRequest at %p\n",buffer);
                QueryTrajectoryStateRequestNML * p = static_cast<QueryTrajectoryStateRequestNML*>(buffer);
                p->~QueryTrajectoryStateRequestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QueryTrajectoryStateRequest at %p, is flat\n",buffer);
            }
            break;
        } 
        case QueryTrajectoryStateResponse::ID:
        {
            // only need to destruct if data type is not flat
            if (QueryTrajectoryStateResponse::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QueryTrajectoryStateResponse at %p\n",buffer);
                QueryTrajectoryStateResponseNML * p = static_cast<QueryTrajectoryStateResponseNML*>(buffer);
                p->~QueryTrajectoryStateResponseNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QueryTrajectoryStateResponse at %p, is flat\n",buffer);
            }
            break;
        } 
        case QueryTrajectoryState::ID:
        {
            // only need to destruct if data type is not flat
            if (QueryTrajectoryState::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing QueryTrajectoryState at %p\n",buffer);
                QueryTrajectoryStateNML * p = static_cast<QueryTrajectoryStateNML*>(buffer);
                p->~QueryTrajectoryStateNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction QueryTrajectoryState at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

FollowJointTrajectoryActionNML::FollowJointTrajectoryActionNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryAction::ID,sizeof(FollowJointTrajectoryActionNML)), nmlVersion(FollowJointTrajectoryAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryAction()*/)
{
};

FollowJointTrajectoryActionNML::~FollowJointTrajectoryActionNML()
{
};

FollowJointTrajectoryActionNML & FollowJointTrajectoryActionNML::operator=(const FollowJointTrajectoryActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryActionNML & FollowJointTrajectoryActionNML::operator=(const FollowJointTrajectoryAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryAction> temp(new FollowJointTrajectoryAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryAction Message version mismatch, expected " << FollowJointTrajectoryAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryAction Message version mismatch, expected " << FollowJointTrajectoryAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

FollowJointTrajectoryActionFeedbackNML::FollowJointTrajectoryActionFeedbackNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryActionFeedback::ID,sizeof(FollowJointTrajectoryActionFeedbackNML)), nmlVersion(FollowJointTrajectoryActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryActionFeedback()*/)
{
};

FollowJointTrajectoryActionFeedbackNML::~FollowJointTrajectoryActionFeedbackNML()
{
};

FollowJointTrajectoryActionFeedbackNML & FollowJointTrajectoryActionFeedbackNML::operator=(const FollowJointTrajectoryActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryActionFeedbackNML & FollowJointTrajectoryActionFeedbackNML::operator=(const FollowJointTrajectoryActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryActionFeedback> temp(new FollowJointTrajectoryActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryActionFeedback Message version mismatch, expected " << FollowJointTrajectoryActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryActionFeedback Message version mismatch, expected " << FollowJointTrajectoryActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

FollowJointTrajectoryActionGoalNML::FollowJointTrajectoryActionGoalNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryActionGoal::ID,sizeof(FollowJointTrajectoryActionGoalNML)), nmlVersion(FollowJointTrajectoryActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryActionGoal()*/)
{
};

FollowJointTrajectoryActionGoalNML::~FollowJointTrajectoryActionGoalNML()
{
};

FollowJointTrajectoryActionGoalNML & FollowJointTrajectoryActionGoalNML::operator=(const FollowJointTrajectoryActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryActionGoalNML & FollowJointTrajectoryActionGoalNML::operator=(const FollowJointTrajectoryActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryActionGoal> temp(new FollowJointTrajectoryActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryActionGoal Message version mismatch, expected " << FollowJointTrajectoryActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryActionGoal Message version mismatch, expected " << FollowJointTrajectoryActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

FollowJointTrajectoryActionResultNML::FollowJointTrajectoryActionResultNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryActionResult::ID,sizeof(FollowJointTrajectoryActionResultNML)), nmlVersion(FollowJointTrajectoryActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryActionResult()*/)
{
};

FollowJointTrajectoryActionResultNML::~FollowJointTrajectoryActionResultNML()
{
};

FollowJointTrajectoryActionResultNML & FollowJointTrajectoryActionResultNML::operator=(const FollowJointTrajectoryActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryActionResultNML & FollowJointTrajectoryActionResultNML::operator=(const FollowJointTrajectoryActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryActionResult> temp(new FollowJointTrajectoryActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryActionResult Message version mismatch, expected " << FollowJointTrajectoryActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryActionResult Message version mismatch, expected " << FollowJointTrajectoryActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.desired);
        nmlupdate(cms,inobj.actual);
        nmlupdate(cms,inobj.error);

    }  
 }

FollowJointTrajectoryFeedbackNML::FollowJointTrajectoryFeedbackNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryFeedback::ID,sizeof(FollowJointTrajectoryFeedbackNML)), nmlVersion(FollowJointTrajectoryFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryFeedback()*/)
{
};

FollowJointTrajectoryFeedbackNML::~FollowJointTrajectoryFeedbackNML()
{
};

FollowJointTrajectoryFeedbackNML & FollowJointTrajectoryFeedbackNML::operator=(const FollowJointTrajectoryFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryFeedbackNML & FollowJointTrajectoryFeedbackNML::operator=(const FollowJointTrajectoryFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryFeedback> temp(new FollowJointTrajectoryFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryFeedback Message version mismatch, expected " << FollowJointTrajectoryFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryFeedback Message version mismatch, expected " << FollowJointTrajectoryFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.trajectory);
        nmlupdate(cms,inobj.path_tolerance);
        nmlupdate(cms,inobj.goal_tolerance);
        nmlupdate(cms,inobj.goal_time_tolerance);

    }  
 }

FollowJointTrajectoryGoalNML::FollowJointTrajectoryGoalNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryGoal::ID,sizeof(FollowJointTrajectoryGoalNML)), nmlVersion(FollowJointTrajectoryGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryGoal()*/)
{
};

FollowJointTrajectoryGoalNML::~FollowJointTrajectoryGoalNML()
{
};

FollowJointTrajectoryGoalNML & FollowJointTrajectoryGoalNML::operator=(const FollowJointTrajectoryGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryGoalNML & FollowJointTrajectoryGoalNML::operator=(const FollowJointTrajectoryGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryGoal> temp(new FollowJointTrajectoryGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryGoal Message version mismatch, expected " << FollowJointTrajectoryGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryGoal Message version mismatch, expected " << FollowJointTrajectoryGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, FollowJointTrajectoryResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate FollowJointTrajectoryResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.error_code);
        nmlupdate(cms,inobj.error_string);

    }  
 }

FollowJointTrajectoryResultNML::FollowJointTrajectoryResultNML() : NMLmsg((NMLTYPE)FollowJointTrajectoryResult::ID,sizeof(FollowJointTrajectoryResultNML)), nmlVersion(FollowJointTrajectoryResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new FollowJointTrajectoryResult()*/)
{
};

FollowJointTrajectoryResultNML::~FollowJointTrajectoryResultNML()
{
};

FollowJointTrajectoryResultNML & FollowJointTrajectoryResultNML::operator=(const FollowJointTrajectoryResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

FollowJointTrajectoryResultNML & FollowJointTrajectoryResultNML::operator=(const FollowJointTrajectoryResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(FollowJointTrajectoryResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void FollowJointTrajectoryResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<FollowJointTrajectoryResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: FollowJointTrajectoryResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<FollowJointTrajectoryResult> temp(new FollowJointTrajectoryResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (FollowJointTrajectoryResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: FollowJointTrajectoryResult Message version mismatch, expected " << FollowJointTrajectoryResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: FollowJointTrajectoryResult Message version mismatch, expected " << FollowJointTrajectoryResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommand & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommand, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.position);
        cms->update(inobj.max_effort);

    }  
 }

GripperCommandNML::GripperCommandNML() : NMLmsg((NMLTYPE)GripperCommand::ID,sizeof(GripperCommandNML)), nmlVersion(GripperCommand::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommand()*/)
{
};

GripperCommandNML::~GripperCommandNML()
{
};

GripperCommandNML & GripperCommandNML::operator=(const GripperCommandNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandNML & GripperCommandNML::operator=(const GripperCommand & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommand);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommand&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommand> temp(new GripperCommand());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommand::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommand Message version mismatch, expected " << GripperCommand::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommand Message version mismatch, expected " << GripperCommand::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

GripperCommandActionNML::GripperCommandActionNML() : NMLmsg((NMLTYPE)GripperCommandAction::ID,sizeof(GripperCommandActionNML)), nmlVersion(GripperCommandAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandAction()*/)
{
};

GripperCommandActionNML::~GripperCommandActionNML()
{
};

GripperCommandActionNML & GripperCommandActionNML::operator=(const GripperCommandActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandActionNML & GripperCommandActionNML::operator=(const GripperCommandAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandAction> temp(new GripperCommandAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandAction Message version mismatch, expected " << GripperCommandAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandAction Message version mismatch, expected " << GripperCommandAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

GripperCommandActionFeedbackNML::GripperCommandActionFeedbackNML() : NMLmsg((NMLTYPE)GripperCommandActionFeedback::ID,sizeof(GripperCommandActionFeedbackNML)), nmlVersion(GripperCommandActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandActionFeedback()*/)
{
};

GripperCommandActionFeedbackNML::~GripperCommandActionFeedbackNML()
{
};

GripperCommandActionFeedbackNML & GripperCommandActionFeedbackNML::operator=(const GripperCommandActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandActionFeedbackNML & GripperCommandActionFeedbackNML::operator=(const GripperCommandActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandActionFeedback> temp(new GripperCommandActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandActionFeedback Message version mismatch, expected " << GripperCommandActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandActionFeedback Message version mismatch, expected " << GripperCommandActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

GripperCommandActionGoalNML::GripperCommandActionGoalNML() : NMLmsg((NMLTYPE)GripperCommandActionGoal::ID,sizeof(GripperCommandActionGoalNML)), nmlVersion(GripperCommandActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandActionGoal()*/)
{
};

GripperCommandActionGoalNML::~GripperCommandActionGoalNML()
{
};

GripperCommandActionGoalNML & GripperCommandActionGoalNML::operator=(const GripperCommandActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandActionGoalNML & GripperCommandActionGoalNML::operator=(const GripperCommandActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandActionGoal> temp(new GripperCommandActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandActionGoal Message version mismatch, expected " << GripperCommandActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandActionGoal Message version mismatch, expected " << GripperCommandActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

GripperCommandActionResultNML::GripperCommandActionResultNML() : NMLmsg((NMLTYPE)GripperCommandActionResult::ID,sizeof(GripperCommandActionResultNML)), nmlVersion(GripperCommandActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandActionResult()*/)
{
};

GripperCommandActionResultNML::~GripperCommandActionResultNML()
{
};

GripperCommandActionResultNML & GripperCommandActionResultNML::operator=(const GripperCommandActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandActionResultNML & GripperCommandActionResultNML::operator=(const GripperCommandActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandActionResult> temp(new GripperCommandActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandActionResult Message version mismatch, expected " << GripperCommandActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandActionResult Message version mismatch, expected " << GripperCommandActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.position);
        cms->update(inobj.effort);
        cms->update(inobj.stalled);
        cms->update(inobj.reached_goal);

    }  
 }

GripperCommandFeedbackNML::GripperCommandFeedbackNML() : NMLmsg((NMLTYPE)GripperCommandFeedback::ID,sizeof(GripperCommandFeedbackNML)), nmlVersion(GripperCommandFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandFeedback()*/)
{
};

GripperCommandFeedbackNML::~GripperCommandFeedbackNML()
{
};

GripperCommandFeedbackNML & GripperCommandFeedbackNML::operator=(const GripperCommandFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandFeedbackNML & GripperCommandFeedbackNML::operator=(const GripperCommandFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandFeedback> temp(new GripperCommandFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandFeedback Message version mismatch, expected " << GripperCommandFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandFeedback Message version mismatch, expected " << GripperCommandFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.command);

    }  
 }

GripperCommandGoalNML::GripperCommandGoalNML() : NMLmsg((NMLTYPE)GripperCommandGoal::ID,sizeof(GripperCommandGoalNML)), nmlVersion(GripperCommandGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandGoal()*/)
{
};

GripperCommandGoalNML::~GripperCommandGoalNML()
{
};

GripperCommandGoalNML & GripperCommandGoalNML::operator=(const GripperCommandGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandGoalNML & GripperCommandGoalNML::operator=(const GripperCommandGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandGoal> temp(new GripperCommandGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandGoal Message version mismatch, expected " << GripperCommandGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandGoal Message version mismatch, expected " << GripperCommandGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, GripperCommandResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate GripperCommandResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.position);
        cms->update(inobj.effort);
        cms->update(inobj.stalled);
        cms->update(inobj.reached_goal);

    }  
 }

GripperCommandResultNML::GripperCommandResultNML() : NMLmsg((NMLTYPE)GripperCommandResult::ID,sizeof(GripperCommandResultNML)), nmlVersion(GripperCommandResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new GripperCommandResult()*/)
{
};

GripperCommandResultNML::~GripperCommandResultNML()
{
};

GripperCommandResultNML & GripperCommandResultNML::operator=(const GripperCommandResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

GripperCommandResultNML & GripperCommandResultNML::operator=(const GripperCommandResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(GripperCommandResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void GripperCommandResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<GripperCommandResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: GripperCommandResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<GripperCommandResult> temp(new GripperCommandResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (GripperCommandResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: GripperCommandResult Message version mismatch, expected " << GripperCommandResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: GripperCommandResult Message version mismatch, expected " << GripperCommandResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointControllerState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointControllerState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.set_point);
        cms->update(inobj.process_value);
        cms->update(inobj.process_value_dot);
        cms->update(inobj.error);
        cms->update(inobj.time_step);
        cms->update(inobj.command);
        cms->update(inobj.p);
        cms->update(inobj.i);
        cms->update(inobj.d);
        cms->update(inobj.i_clamp);

    }  
 }

JointControllerStateNML::JointControllerStateNML() : NMLmsg((NMLTYPE)JointControllerState::ID,sizeof(JointControllerStateNML)), nmlVersion(JointControllerState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointControllerState()*/)
{
};

JointControllerStateNML::~JointControllerStateNML()
{
};

JointControllerStateNML & JointControllerStateNML::operator=(const JointControllerStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointControllerStateNML & JointControllerStateNML::operator=(const JointControllerState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointControllerState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointControllerStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointControllerState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointControllerStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointControllerState> temp(new JointControllerState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointControllerState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointControllerState Message version mismatch, expected " << JointControllerState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointControllerState Message version mismatch, expected " << JointControllerState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTolerance & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTolerance, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        cms->update(inobj.position);
        cms->update(inobj.velocity);
        cms->update(inobj.acceleration);

    }  
 }

JointToleranceNML::JointToleranceNML() : NMLmsg((NMLTYPE)JointTolerance::ID,sizeof(JointToleranceNML)), nmlVersion(JointTolerance::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTolerance()*/)
{
};

JointToleranceNML::~JointToleranceNML()
{
};

JointToleranceNML & JointToleranceNML::operator=(const JointToleranceNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointToleranceNML & JointToleranceNML::operator=(const JointTolerance & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTolerance);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointToleranceNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTolerance&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointToleranceNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTolerance> temp(new JointTolerance());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTolerance::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTolerance Message version mismatch, expected " << JointTolerance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTolerance Message version mismatch, expected " << JointTolerance::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

JointTrajectoryActionNML::JointTrajectoryActionNML() : NMLmsg((NMLTYPE)JointTrajectoryAction::ID,sizeof(JointTrajectoryActionNML)), nmlVersion(JointTrajectoryAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryAction()*/)
{
};

JointTrajectoryActionNML::~JointTrajectoryActionNML()
{
};

JointTrajectoryActionNML & JointTrajectoryActionNML::operator=(const JointTrajectoryActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryActionNML & JointTrajectoryActionNML::operator=(const JointTrajectoryAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryAction> temp(new JointTrajectoryAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryAction Message version mismatch, expected " << JointTrajectoryAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryAction Message version mismatch, expected " << JointTrajectoryAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

JointTrajectoryActionFeedbackNML::JointTrajectoryActionFeedbackNML() : NMLmsg((NMLTYPE)JointTrajectoryActionFeedback::ID,sizeof(JointTrajectoryActionFeedbackNML)), nmlVersion(JointTrajectoryActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryActionFeedback()*/)
{
};

JointTrajectoryActionFeedbackNML::~JointTrajectoryActionFeedbackNML()
{
};

JointTrajectoryActionFeedbackNML & JointTrajectoryActionFeedbackNML::operator=(const JointTrajectoryActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryActionFeedbackNML & JointTrajectoryActionFeedbackNML::operator=(const JointTrajectoryActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryActionFeedback> temp(new JointTrajectoryActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryActionFeedback Message version mismatch, expected " << JointTrajectoryActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryActionFeedback Message version mismatch, expected " << JointTrajectoryActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

JointTrajectoryActionGoalNML::JointTrajectoryActionGoalNML() : NMLmsg((NMLTYPE)JointTrajectoryActionGoal::ID,sizeof(JointTrajectoryActionGoalNML)), nmlVersion(JointTrajectoryActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryActionGoal()*/)
{
};

JointTrajectoryActionGoalNML::~JointTrajectoryActionGoalNML()
{
};

JointTrajectoryActionGoalNML & JointTrajectoryActionGoalNML::operator=(const JointTrajectoryActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryActionGoalNML & JointTrajectoryActionGoalNML::operator=(const JointTrajectoryActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryActionGoal> temp(new JointTrajectoryActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryActionGoal Message version mismatch, expected " << JointTrajectoryActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryActionGoal Message version mismatch, expected " << JointTrajectoryActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

JointTrajectoryActionResultNML::JointTrajectoryActionResultNML() : NMLmsg((NMLTYPE)JointTrajectoryActionResult::ID,sizeof(JointTrajectoryActionResultNML)), nmlVersion(JointTrajectoryActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryActionResult()*/)
{
};

JointTrajectoryActionResultNML::~JointTrajectoryActionResultNML()
{
};

JointTrajectoryActionResultNML & JointTrajectoryActionResultNML::operator=(const JointTrajectoryActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryActionResultNML & JointTrajectoryActionResultNML::operator=(const JointTrajectoryActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryActionResult> temp(new JointTrajectoryActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryActionResult Message version mismatch, expected " << JointTrajectoryActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryActionResult Message version mismatch, expected " << JointTrajectoryActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryControllerState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryControllerState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.joint_names);
        nmlupdate(cms,inobj.desired);
        nmlupdate(cms,inobj.actual);
        nmlupdate(cms,inobj.error);

    }  
 }

JointTrajectoryControllerStateNML::JointTrajectoryControllerStateNML() : NMLmsg((NMLTYPE)JointTrajectoryControllerState::ID,sizeof(JointTrajectoryControllerStateNML)), nmlVersion(JointTrajectoryControllerState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryControllerState()*/)
{
};

JointTrajectoryControllerStateNML::~JointTrajectoryControllerStateNML()
{
};

JointTrajectoryControllerStateNML & JointTrajectoryControllerStateNML::operator=(const JointTrajectoryControllerStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryControllerStateNML & JointTrajectoryControllerStateNML::operator=(const JointTrajectoryControllerState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryControllerState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryControllerStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryControllerState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryControllerStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryControllerState> temp(new JointTrajectoryControllerState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryControllerState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryControllerState Message version mismatch, expected " << JointTrajectoryControllerState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryControllerState Message version mismatch, expected " << JointTrajectoryControllerState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

JointTrajectoryFeedbackNML::JointTrajectoryFeedbackNML() : NMLmsg((NMLTYPE)JointTrajectoryFeedback::ID,sizeof(JointTrajectoryFeedbackNML)), nmlVersion(JointTrajectoryFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryFeedback()*/)
{
};

JointTrajectoryFeedbackNML::~JointTrajectoryFeedbackNML()
{
};

JointTrajectoryFeedbackNML & JointTrajectoryFeedbackNML::operator=(const JointTrajectoryFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryFeedbackNML & JointTrajectoryFeedbackNML::operator=(const JointTrajectoryFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryFeedback> temp(new JointTrajectoryFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryFeedback Message version mismatch, expected " << JointTrajectoryFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryFeedback Message version mismatch, expected " << JointTrajectoryFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.trajectory);

    }  
 }

JointTrajectoryGoalNML::JointTrajectoryGoalNML() : NMLmsg((NMLTYPE)JointTrajectoryGoal::ID,sizeof(JointTrajectoryGoalNML)), nmlVersion(JointTrajectoryGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryGoal()*/)
{
};

JointTrajectoryGoalNML::~JointTrajectoryGoalNML()
{
};

JointTrajectoryGoalNML & JointTrajectoryGoalNML::operator=(const JointTrajectoryGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryGoalNML & JointTrajectoryGoalNML::operator=(const JointTrajectoryGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryGoal> temp(new JointTrajectoryGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryGoal Message version mismatch, expected " << JointTrajectoryGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryGoal Message version mismatch, expected " << JointTrajectoryGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, JointTrajectoryResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate JointTrajectoryResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

JointTrajectoryResultNML::JointTrajectoryResultNML() : NMLmsg((NMLTYPE)JointTrajectoryResult::ID,sizeof(JointTrajectoryResultNML)), nmlVersion(JointTrajectoryResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new JointTrajectoryResult()*/)
{
};

JointTrajectoryResultNML::~JointTrajectoryResultNML()
{
};

JointTrajectoryResultNML & JointTrajectoryResultNML::operator=(const JointTrajectoryResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

JointTrajectoryResultNML & JointTrajectoryResultNML::operator=(const JointTrajectoryResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(JointTrajectoryResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void JointTrajectoryResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<JointTrajectoryResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: JointTrajectoryResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<JointTrajectoryResult> temp(new JointTrajectoryResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (JointTrajectoryResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: JointTrajectoryResult Message version mismatch, expected " << JointTrajectoryResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: JointTrajectoryResult Message version mismatch, expected " << JointTrajectoryResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

PointHeadActionNML::PointHeadActionNML() : NMLmsg((NMLTYPE)PointHeadAction::ID,sizeof(PointHeadActionNML)), nmlVersion(PointHeadAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadAction()*/)
{
};

PointHeadActionNML::~PointHeadActionNML()
{
};

PointHeadActionNML & PointHeadActionNML::operator=(const PointHeadActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadActionNML & PointHeadActionNML::operator=(const PointHeadAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadAction> temp(new PointHeadAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadAction Message version mismatch, expected " << PointHeadAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadAction Message version mismatch, expected " << PointHeadAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

PointHeadActionFeedbackNML::PointHeadActionFeedbackNML() : NMLmsg((NMLTYPE)PointHeadActionFeedback::ID,sizeof(PointHeadActionFeedbackNML)), nmlVersion(PointHeadActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadActionFeedback()*/)
{
};

PointHeadActionFeedbackNML::~PointHeadActionFeedbackNML()
{
};

PointHeadActionFeedbackNML & PointHeadActionFeedbackNML::operator=(const PointHeadActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadActionFeedbackNML & PointHeadActionFeedbackNML::operator=(const PointHeadActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadActionFeedback> temp(new PointHeadActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadActionFeedback Message version mismatch, expected " << PointHeadActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadActionFeedback Message version mismatch, expected " << PointHeadActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

PointHeadActionGoalNML::PointHeadActionGoalNML() : NMLmsg((NMLTYPE)PointHeadActionGoal::ID,sizeof(PointHeadActionGoalNML)), nmlVersion(PointHeadActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadActionGoal()*/)
{
};

PointHeadActionGoalNML::~PointHeadActionGoalNML()
{
};

PointHeadActionGoalNML & PointHeadActionGoalNML::operator=(const PointHeadActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadActionGoalNML & PointHeadActionGoalNML::operator=(const PointHeadActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadActionGoal> temp(new PointHeadActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadActionGoal Message version mismatch, expected " << PointHeadActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadActionGoal Message version mismatch, expected " << PointHeadActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

PointHeadActionResultNML::PointHeadActionResultNML() : NMLmsg((NMLTYPE)PointHeadActionResult::ID,sizeof(PointHeadActionResultNML)), nmlVersion(PointHeadActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadActionResult()*/)
{
};

PointHeadActionResultNML::~PointHeadActionResultNML()
{
};

PointHeadActionResultNML & PointHeadActionResultNML::operator=(const PointHeadActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadActionResultNML & PointHeadActionResultNML::operator=(const PointHeadActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadActionResult> temp(new PointHeadActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadActionResult Message version mismatch, expected " << PointHeadActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadActionResult Message version mismatch, expected " << PointHeadActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.pointing_angle_error);

    }  
 }

PointHeadFeedbackNML::PointHeadFeedbackNML() : NMLmsg((NMLTYPE)PointHeadFeedback::ID,sizeof(PointHeadFeedbackNML)), nmlVersion(PointHeadFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadFeedback()*/)
{
};

PointHeadFeedbackNML::~PointHeadFeedbackNML()
{
};

PointHeadFeedbackNML & PointHeadFeedbackNML::operator=(const PointHeadFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadFeedbackNML & PointHeadFeedbackNML::operator=(const PointHeadFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadFeedback> temp(new PointHeadFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadFeedback Message version mismatch, expected " << PointHeadFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadFeedback Message version mismatch, expected " << PointHeadFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.target);
        nmlupdate(cms,inobj.pointing_axis);
        nmlupdate(cms,inobj.pointing_frame);
        nmlupdate(cms,inobj.min_duration);
        cms->update(inobj.max_velocity);

    }  
 }

PointHeadGoalNML::PointHeadGoalNML() : NMLmsg((NMLTYPE)PointHeadGoal::ID,sizeof(PointHeadGoalNML)), nmlVersion(PointHeadGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadGoal()*/)
{
};

PointHeadGoalNML::~PointHeadGoalNML()
{
};

PointHeadGoalNML & PointHeadGoalNML::operator=(const PointHeadGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadGoalNML & PointHeadGoalNML::operator=(const PointHeadGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadGoal> temp(new PointHeadGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadGoal Message version mismatch, expected " << PointHeadGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadGoal Message version mismatch, expected " << PointHeadGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, PointHeadResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate PointHeadResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

PointHeadResultNML::PointHeadResultNML() : NMLmsg((NMLTYPE)PointHeadResult::ID,sizeof(PointHeadResultNML)), nmlVersion(PointHeadResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new PointHeadResult()*/)
{
};

PointHeadResultNML::~PointHeadResultNML()
{
};

PointHeadResultNML & PointHeadResultNML::operator=(const PointHeadResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

PointHeadResultNML & PointHeadResultNML::operator=(const PointHeadResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(PointHeadResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void PointHeadResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<PointHeadResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: PointHeadResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<PointHeadResult> temp(new PointHeadResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (PointHeadResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: PointHeadResult Message version mismatch, expected " << PointHeadResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: PointHeadResult Message version mismatch, expected " << PointHeadResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionAction & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionAction, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.action_goal);
        nmlupdate(cms,inobj.action_result);
        nmlupdate(cms,inobj.action_feedback);

    }  
 }

SingleJointPositionActionNML::SingleJointPositionActionNML() : NMLmsg((NMLTYPE)SingleJointPositionAction::ID,sizeof(SingleJointPositionActionNML)), nmlVersion(SingleJointPositionAction::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionAction()*/)
{
};

SingleJointPositionActionNML::~SingleJointPositionActionNML()
{
};

SingleJointPositionActionNML & SingleJointPositionActionNML::operator=(const SingleJointPositionActionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionActionNML & SingleJointPositionActionNML::operator=(const SingleJointPositionAction & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionAction);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionActionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionAction&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionActionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionAction> temp(new SingleJointPositionAction());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionAction::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionAction Message version mismatch, expected " << SingleJointPositionAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionAction Message version mismatch, expected " << SingleJointPositionAction::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionActionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionActionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.feedback);

    }  
 }

SingleJointPositionActionFeedbackNML::SingleJointPositionActionFeedbackNML() : NMLmsg((NMLTYPE)SingleJointPositionActionFeedback::ID,sizeof(SingleJointPositionActionFeedbackNML)), nmlVersion(SingleJointPositionActionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionActionFeedback()*/)
{
};

SingleJointPositionActionFeedbackNML::~SingleJointPositionActionFeedbackNML()
{
};

SingleJointPositionActionFeedbackNML & SingleJointPositionActionFeedbackNML::operator=(const SingleJointPositionActionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionActionFeedbackNML & SingleJointPositionActionFeedbackNML::operator=(const SingleJointPositionActionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionActionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionActionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionActionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionActionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionActionFeedback> temp(new SingleJointPositionActionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionActionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionActionFeedback Message version mismatch, expected " << SingleJointPositionActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionActionFeedback Message version mismatch, expected " << SingleJointPositionActionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionActionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionActionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.goal_id);
        nmlupdate(cms,inobj.goal);

    }  
 }

SingleJointPositionActionGoalNML::SingleJointPositionActionGoalNML() : NMLmsg((NMLTYPE)SingleJointPositionActionGoal::ID,sizeof(SingleJointPositionActionGoalNML)), nmlVersion(SingleJointPositionActionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionActionGoal()*/)
{
};

SingleJointPositionActionGoalNML::~SingleJointPositionActionGoalNML()
{
};

SingleJointPositionActionGoalNML & SingleJointPositionActionGoalNML::operator=(const SingleJointPositionActionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionActionGoalNML & SingleJointPositionActionGoalNML::operator=(const SingleJointPositionActionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionActionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionActionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionActionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionActionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionActionGoal> temp(new SingleJointPositionActionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionActionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionActionGoal Message version mismatch, expected " << SingleJointPositionActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionActionGoal Message version mismatch, expected " << SingleJointPositionActionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionActionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionActionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.status);
        nmlupdate(cms,inobj.result);

    }  
 }

SingleJointPositionActionResultNML::SingleJointPositionActionResultNML() : NMLmsg((NMLTYPE)SingleJointPositionActionResult::ID,sizeof(SingleJointPositionActionResultNML)), nmlVersion(SingleJointPositionActionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionActionResult()*/)
{
};

SingleJointPositionActionResultNML::~SingleJointPositionActionResultNML()
{
};

SingleJointPositionActionResultNML & SingleJointPositionActionResultNML::operator=(const SingleJointPositionActionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionActionResultNML & SingleJointPositionActionResultNML::operator=(const SingleJointPositionActionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionActionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionActionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionActionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionActionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionActionResult> temp(new SingleJointPositionActionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionActionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionActionResult Message version mismatch, expected " << SingleJointPositionActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionActionResult Message version mismatch, expected " << SingleJointPositionActionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionFeedback & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionFeedback, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        cms->update(inobj.position);
        cms->update(inobj.velocity);
        cms->update(inobj.error);

    }  
 }

SingleJointPositionFeedbackNML::SingleJointPositionFeedbackNML() : NMLmsg((NMLTYPE)SingleJointPositionFeedback::ID,sizeof(SingleJointPositionFeedbackNML)), nmlVersion(SingleJointPositionFeedback::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionFeedback()*/)
{
};

SingleJointPositionFeedbackNML::~SingleJointPositionFeedbackNML()
{
};

SingleJointPositionFeedbackNML & SingleJointPositionFeedbackNML::operator=(const SingleJointPositionFeedbackNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionFeedbackNML & SingleJointPositionFeedbackNML::operator=(const SingleJointPositionFeedback & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionFeedback);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionFeedbackNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionFeedback&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionFeedbackNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionFeedback> temp(new SingleJointPositionFeedback());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionFeedback::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionFeedback Message version mismatch, expected " << SingleJointPositionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionFeedback Message version mismatch, expected " << SingleJointPositionFeedback::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionGoal & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionGoal, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.position);
        nmlupdate(cms,inobj.min_duration);
        cms->update(inobj.max_velocity);

    }  
 }

SingleJointPositionGoalNML::SingleJointPositionGoalNML() : NMLmsg((NMLTYPE)SingleJointPositionGoal::ID,sizeof(SingleJointPositionGoalNML)), nmlVersion(SingleJointPositionGoal::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionGoal()*/)
{
};

SingleJointPositionGoalNML::~SingleJointPositionGoalNML()
{
};

SingleJointPositionGoalNML & SingleJointPositionGoalNML::operator=(const SingleJointPositionGoalNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionGoalNML & SingleJointPositionGoalNML::operator=(const SingleJointPositionGoal & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionGoal);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionGoalNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionGoal&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionGoalNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionGoal> temp(new SingleJointPositionGoal());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionGoal::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionGoal Message version mismatch, expected " << SingleJointPositionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionGoal Message version mismatch, expected " << SingleJointPositionGoal::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, SingleJointPositionResult & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate SingleJointPositionResult, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

SingleJointPositionResultNML::SingleJointPositionResultNML() : NMLmsg((NMLTYPE)SingleJointPositionResult::ID,sizeof(SingleJointPositionResultNML)), nmlVersion(SingleJointPositionResult::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new SingleJointPositionResult()*/)
{
};

SingleJointPositionResultNML::~SingleJointPositionResultNML()
{
};

SingleJointPositionResultNML & SingleJointPositionResultNML::operator=(const SingleJointPositionResultNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

SingleJointPositionResultNML & SingleJointPositionResultNML::operator=(const SingleJointPositionResult & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(SingleJointPositionResult);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void SingleJointPositionResultNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<SingleJointPositionResult&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: SingleJointPositionResultNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<SingleJointPositionResult> temp(new SingleJointPositionResult());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (SingleJointPositionResult::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: SingleJointPositionResult Message version mismatch, expected " << SingleJointPositionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: SingleJointPositionResult Message version mismatch, expected " << SingleJointPositionResult::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, QueryCalibrationStateRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QueryCalibrationStateRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

QueryCalibrationStateRequestNML::QueryCalibrationStateRequestNML() : NMLmsg((NMLTYPE)QueryCalibrationStateRequest::ID,sizeof(QueryCalibrationStateRequestNML)), nmlVersion(QueryCalibrationStateRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QueryCalibrationStateRequest()*/)
{
};

QueryCalibrationStateRequestNML::~QueryCalibrationStateRequestNML()
{
};

QueryCalibrationStateRequestNML & QueryCalibrationStateRequestNML::operator=(const QueryCalibrationStateRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QueryCalibrationStateRequestNML & QueryCalibrationStateRequestNML::operator=(const QueryCalibrationStateRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QueryCalibrationStateRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QueryCalibrationStateRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QueryCalibrationStateRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QueryCalibrationStateRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QueryCalibrationStateRequest> temp(new QueryCalibrationStateRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QueryCalibrationStateRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QueryCalibrationStateRequest Message version mismatch, expected " << QueryCalibrationStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QueryCalibrationStateRequest Message version mismatch, expected " << QueryCalibrationStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, QueryCalibrationStateResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QueryCalibrationStateResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.is_calibrated);

    }  
 }

QueryCalibrationStateResponseNML::QueryCalibrationStateResponseNML() : NMLmsg((NMLTYPE)QueryCalibrationStateResponse::ID,sizeof(QueryCalibrationStateResponseNML)), nmlVersion(QueryCalibrationStateResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QueryCalibrationStateResponse()*/)
{
};

QueryCalibrationStateResponseNML::~QueryCalibrationStateResponseNML()
{
};

QueryCalibrationStateResponseNML & QueryCalibrationStateResponseNML::operator=(const QueryCalibrationStateResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QueryCalibrationStateResponseNML & QueryCalibrationStateResponseNML::operator=(const QueryCalibrationStateResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QueryCalibrationStateResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QueryCalibrationStateResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QueryCalibrationStateResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QueryCalibrationStateResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QueryCalibrationStateResponse> temp(new QueryCalibrationStateResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QueryCalibrationStateResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QueryCalibrationStateResponse Message version mismatch, expected " << QueryCalibrationStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QueryCalibrationStateResponse Message version mismatch, expected " << QueryCalibrationStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, QueryCalibrationState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QueryCalibrationState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

QueryCalibrationStateNML::QueryCalibrationStateNML() : NMLmsg((NMLTYPE)QueryCalibrationState::ID,sizeof(QueryCalibrationStateNML)), nmlVersion(QueryCalibrationState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QueryCalibrationState()*/)
{
};

QueryCalibrationStateNML::~QueryCalibrationStateNML()
{
};

QueryCalibrationStateNML & QueryCalibrationStateNML::operator=(const QueryCalibrationStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QueryCalibrationStateNML & QueryCalibrationStateNML::operator=(const QueryCalibrationState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QueryCalibrationState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QueryCalibrationStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QueryCalibrationState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QueryCalibrationStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QueryCalibrationState> temp(new QueryCalibrationState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QueryCalibrationState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QueryCalibrationState Message version mismatch, expected " << QueryCalibrationState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QueryCalibrationState Message version mismatch, expected " << QueryCalibrationState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, QueryTrajectoryStateRequest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QueryTrajectoryStateRequest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.time);

    }  
 }

QueryTrajectoryStateRequestNML::QueryTrajectoryStateRequestNML() : NMLmsg((NMLTYPE)QueryTrajectoryStateRequest::ID,sizeof(QueryTrajectoryStateRequestNML)), nmlVersion(QueryTrajectoryStateRequest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QueryTrajectoryStateRequest()*/)
{
};

QueryTrajectoryStateRequestNML::~QueryTrajectoryStateRequestNML()
{
};

QueryTrajectoryStateRequestNML & QueryTrajectoryStateRequestNML::operator=(const QueryTrajectoryStateRequestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QueryTrajectoryStateRequestNML & QueryTrajectoryStateRequestNML::operator=(const QueryTrajectoryStateRequest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QueryTrajectoryStateRequest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QueryTrajectoryStateRequestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QueryTrajectoryStateRequest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QueryTrajectoryStateRequestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QueryTrajectoryStateRequest> temp(new QueryTrajectoryStateRequest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QueryTrajectoryStateRequest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QueryTrajectoryStateRequest Message version mismatch, expected " << QueryTrajectoryStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QueryTrajectoryStateRequest Message version mismatch, expected " << QueryTrajectoryStateRequest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, QueryTrajectoryStateResponse & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QueryTrajectoryStateResponse, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.name);
        nmlupdate(cms,inobj.position);
        nmlupdate(cms,inobj.velocity);
        nmlupdate(cms,inobj.acceleration);

    }  
 }

QueryTrajectoryStateResponseNML::QueryTrajectoryStateResponseNML() : NMLmsg((NMLTYPE)QueryTrajectoryStateResponse::ID,sizeof(QueryTrajectoryStateResponseNML)), nmlVersion(QueryTrajectoryStateResponse::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QueryTrajectoryStateResponse()*/)
{
};

QueryTrajectoryStateResponseNML::~QueryTrajectoryStateResponseNML()
{
};

QueryTrajectoryStateResponseNML & QueryTrajectoryStateResponseNML::operator=(const QueryTrajectoryStateResponseNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QueryTrajectoryStateResponseNML & QueryTrajectoryStateResponseNML::operator=(const QueryTrajectoryStateResponse & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QueryTrajectoryStateResponse);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QueryTrajectoryStateResponseNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QueryTrajectoryStateResponse&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QueryTrajectoryStateResponseNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QueryTrajectoryStateResponse> temp(new QueryTrajectoryStateResponse());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QueryTrajectoryStateResponse::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QueryTrajectoryStateResponse Message version mismatch, expected " << QueryTrajectoryStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QueryTrajectoryStateResponse Message version mismatch, expected " << QueryTrajectoryStateResponse::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void control_msgs::nmlupdate(CMS * cms, QueryTrajectoryState & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate QueryTrajectoryState, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.request);
        nmlupdate(cms,inobj.response);

    }  
 }

QueryTrajectoryStateNML::QueryTrajectoryStateNML() : NMLmsg((NMLTYPE)QueryTrajectoryState::ID,sizeof(QueryTrajectoryStateNML)), nmlVersion(QueryTrajectoryState::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new QueryTrajectoryState()*/)
{
};

QueryTrajectoryStateNML::~QueryTrajectoryStateNML()
{
};

QueryTrajectoryStateNML & QueryTrajectoryStateNML::operator=(const QueryTrajectoryStateNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

QueryTrajectoryStateNML & QueryTrajectoryStateNML::operator=(const QueryTrajectoryState & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(QueryTrajectoryState);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void QueryTrajectoryStateNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<QueryTrajectoryState&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: QueryTrajectoryStateNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<QueryTrajectoryState> temp(new QueryTrajectoryState());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: control_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (QueryTrajectoryState::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: QueryTrajectoryState Message version mismatch, expected " << QueryTrajectoryState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: QueryTrajectoryState Message version mismatch, expected " << QueryTrajectoryState::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int control_msgs::control_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("control_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case FollowJointTrajectoryAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryAction, id " << FollowJointTrajectoryAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryActionFeedback, id " << FollowJointTrajectoryActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryActionGoal, id " << FollowJointTrajectoryActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryActionResult, id " << FollowJointTrajectoryActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryFeedback, id " << FollowJointTrajectoryFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FollowJointTrajectoryGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryGoal, id " << FollowJointTrajectoryGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case FollowJointTrajectoryResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for FollowJointTrajectoryResult, id " << FollowJointTrajectoryResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((FollowJointTrajectoryResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommand::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommand, id " << GripperCommand::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandAction, id " << GripperCommandAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandActionFeedback, id " << GripperCommandActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandActionGoal, id " << GripperCommandActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandActionResult, id " << GripperCommandActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandFeedback, id " << GripperCommandFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandGoal, id " << GripperCommandGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case GripperCommandResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for GripperCommandResult, id " << GripperCommandResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((GripperCommandResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointControllerState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointControllerState, id " << JointControllerState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointControllerStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTolerance::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTolerance, id " << JointTolerance::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointToleranceNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryAction, id " << JointTrajectoryAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryActionFeedback, id " << JointTrajectoryActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryActionGoal, id " << JointTrajectoryActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryActionResult, id " << JointTrajectoryActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryControllerState, id " << JointTrajectoryControllerState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryControllerStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryFeedback, id " << JointTrajectoryFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryGoal, id " << JointTrajectoryGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case JointTrajectoryResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for JointTrajectoryResult, id " << JointTrajectoryResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((JointTrajectoryResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadAction, id " << PointHeadAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadActionFeedback, id " << PointHeadActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadActionGoal, id " << PointHeadActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadActionResult, id " << PointHeadActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadFeedback, id " << PointHeadFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadGoal, id " << PointHeadGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case PointHeadResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for PointHeadResult, id " << PointHeadResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((PointHeadResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionAction::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionAction, id " << SingleJointPositionAction::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionActionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionActionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionActionFeedback, id " << SingleJointPositionActionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionActionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionActionGoal, id " << SingleJointPositionActionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionActionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionActionResult, id " << SingleJointPositionActionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionActionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionFeedback, id " << SingleJointPositionFeedback::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionFeedbackNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionGoal::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionGoal, id " << SingleJointPositionGoal::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionGoalNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case SingleJointPositionResult::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for SingleJointPositionResult, id " << SingleJointPositionResult::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((SingleJointPositionResultNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QueryCalibrationStateRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QueryCalibrationStateRequest, id " << QueryCalibrationStateRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QueryCalibrationStateRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QueryCalibrationStateResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QueryCalibrationStateResponse, id " << QueryCalibrationStateResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QueryCalibrationStateResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QueryCalibrationState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QueryCalibrationState, id " << QueryCalibrationState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QueryCalibrationStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QueryTrajectoryStateRequest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QueryTrajectoryStateRequest, id " << QueryTrajectoryStateRequest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QueryTrajectoryStateRequestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QueryTrajectoryStateResponse::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QueryTrajectoryStateResponse, id " << QueryTrajectoryStateResponse::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QueryTrajectoryStateResponseNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case QueryTrajectoryState::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for QueryTrajectoryState, id " << QueryTrajectoryState::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_control_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"control_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((QueryTrajectoryStateNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

