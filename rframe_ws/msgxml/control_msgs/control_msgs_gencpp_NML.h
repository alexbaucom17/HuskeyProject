// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:04 -0500
//  From Template/Script: data_templates/NMLHeaderTemplate.h
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#ifndef _CODEGEN_CONTROL_MSGS_GENCPPNML_H_
#define _CODEGEN_CONTROL_MSGS_GENCPPNML_H_

#include <messaging/nml/NMLMessageFactory.h>
//#include <DataTypeInfo.h>
#include <messaging/Message.h>

#include "control_msgs_gencpp_NMLSupport.h"

namespace rframe { class DataTypeInfo; };

#include "FollowJointTrajectoryAction.h"
#include "FollowJointTrajectoryActionFeedback.h"
#include "FollowJointTrajectoryActionGoal.h"
#include "FollowJointTrajectoryActionResult.h"
#include "FollowJointTrajectoryFeedback.h"
#include "FollowJointTrajectoryGoal.h"
#include "FollowJointTrajectoryResult.h"
#include "GripperCommand.h"
#include "GripperCommandAction.h"
#include "GripperCommandActionFeedback.h"
#include "GripperCommandActionGoal.h"
#include "GripperCommandActionResult.h"
#include "GripperCommandFeedback.h"
#include "GripperCommandGoal.h"
#include "GripperCommandResult.h"
#include "JointControllerState.h"
#include "JointTolerance.h"
#include "JointTrajectoryAction.h"
#include "JointTrajectoryActionFeedback.h"
#include "JointTrajectoryActionGoal.h"
#include "JointTrajectoryActionResult.h"
#include "JointTrajectoryControllerState.h"
#include "JointTrajectoryFeedback.h"
#include "JointTrajectoryGoal.h"
#include "JointTrajectoryResult.h"
#include "PointHeadAction.h"
#include "PointHeadActionFeedback.h"
#include "PointHeadActionGoal.h"
#include "PointHeadActionResult.h"
#include "PointHeadFeedback.h"
#include "PointHeadGoal.h"
#include "PointHeadResult.h"
#include "SingleJointPositionAction.h"
#include "SingleJointPositionActionFeedback.h"
#include "SingleJointPositionActionGoal.h"
#include "SingleJointPositionActionResult.h"
#include "SingleJointPositionFeedback.h"
#include "SingleJointPositionGoal.h"
#include "SingleJointPositionResult.h"
#include "QueryCalibrationStateRequest.h"
#include "QueryCalibrationStateResponse.h"
#include "QueryCalibrationState.h"
#include "QueryTrajectoryStateRequest.h"
#include "QueryTrajectoryStateResponse.h"
#include "QueryTrajectoryState.h"

namespace control_msgs {

    /** definition of message factory for control_msgs_gencpp */
    class control_msgs_gencppNMLMessageFactory : public NMLMessageFactory
    {
    public:
        /** constructor */
        control_msgs_gencppNMLMessageFactory();
        /** destructor */
        virtual ~control_msgs_gencppNMLMessageFactory();

        /** see  rframe::MessageFactoryInterface */
        virtual void dataTypes(std::vector<DataTypeInfo> & ids);
        /** see  rframe::MessageFactoryInterface */
        virtual int dataType(NMLmsg & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateTransport(NMLmsg * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int deallocateMessage(MessageBase * msg);
        /** see  rframe::MessageFactoryInterface */
        virtual int toTransport( MessageBase & src, NMLmsg & dst);
        /** see  rframe::MessageFactoryInterface */
        virtual int fromTransport( NMLmsg & src, MessageBase & dst);

        /** \return poitner to nml format function */
        virtual NML_FORMAT_PTR FormatPointer();
        /** run constructor for class of type id in the provided buffer */
        virtual int constructBuffer(rframe::ID_TYPE id, void * buffer);
        /** run destructor for class of type id in the buffer */
        virtual int destructBuffer(rframe::ID_TYPE id, void * buffer);
    };

    /** factory allocation function for use when not dynamically loading the factory library  */
    NMLMessageFactory * allocate_control_msgs_gencpp();

    /** NML interface for FollowJointTrajectoryAction 

    */
    class FollowJointTrajectoryActionNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryActionNML();
        /** destructor */
        ~FollowJointTrajectoryActionNML();

        /** assignment operator */
        FollowJointTrajectoryActionNML & operator=(const FollowJointTrajectoryActionNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryActionNML & operator=(const FollowJointTrajectoryAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryAction nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FollowJointTrajectoryActionFeedback 

    */
    class FollowJointTrajectoryActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryActionFeedbackNML();
        /** destructor */
        ~FollowJointTrajectoryActionFeedbackNML();

        /** assignment operator */
        FollowJointTrajectoryActionFeedbackNML & operator=(const FollowJointTrajectoryActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryActionFeedbackNML & operator=(const FollowJointTrajectoryActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryActionFeedback nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FollowJointTrajectoryActionGoal 

    */
    class FollowJointTrajectoryActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryActionGoalNML();
        /** destructor */
        ~FollowJointTrajectoryActionGoalNML();

        /** assignment operator */
        FollowJointTrajectoryActionGoalNML & operator=(const FollowJointTrajectoryActionGoalNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryActionGoalNML & operator=(const FollowJointTrajectoryActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryActionGoal nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FollowJointTrajectoryActionResult 

    */
    class FollowJointTrajectoryActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryActionResultNML();
        /** destructor */
        ~FollowJointTrajectoryActionResultNML();

        /** assignment operator */
        FollowJointTrajectoryActionResultNML & operator=(const FollowJointTrajectoryActionResultNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryActionResultNML & operator=(const FollowJointTrajectoryActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryActionResult nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FollowJointTrajectoryFeedback 

    */
    class FollowJointTrajectoryFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryFeedbackNML();
        /** destructor */
        ~FollowJointTrajectoryFeedbackNML();

        /** assignment operator */
        FollowJointTrajectoryFeedbackNML & operator=(const FollowJointTrajectoryFeedbackNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryFeedbackNML & operator=(const FollowJointTrajectoryFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryFeedback nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FollowJointTrajectoryGoal 

    */
    class FollowJointTrajectoryGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryGoalNML();
        /** destructor */
        ~FollowJointTrajectoryGoalNML();

        /** assignment operator */
        FollowJointTrajectoryGoalNML & operator=(const FollowJointTrajectoryGoalNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryGoalNML & operator=(const FollowJointTrajectoryGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryGoal nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for FollowJointTrajectoryResult 

    */
    class FollowJointTrajectoryResultNML : public NMLmsg
    {
    public:

        /** constructor */
        FollowJointTrajectoryResultNML();
        /** destructor */
        ~FollowJointTrajectoryResultNML();

        /** assignment operator */
        FollowJointTrajectoryResultNML & operator=(const FollowJointTrajectoryResultNML &inobj);
        /** assignment operator for base data class */
        FollowJointTrajectoryResultNML & operator=(const FollowJointTrajectoryResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        FollowJointTrajectoryResult nmlPayload;

        /** set payload */
        void payload(const FollowJointTrajectoryResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<FollowJointTrajectoryResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        FollowJointTrajectoryResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<FollowJointTrajectoryResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommand 

    */
    class GripperCommandNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandNML();
        /** destructor */
        ~GripperCommandNML();

        /** assignment operator */
        GripperCommandNML & operator=(const GripperCommandNML &inobj);
        /** assignment operator for base data class */
        GripperCommandNML & operator=(const GripperCommand &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommand nmlPayload;

        /** set payload */
        void payload(const GripperCommand &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommand> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommand * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommand> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandAction 

    */
    class GripperCommandActionNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandActionNML();
        /** destructor */
        ~GripperCommandActionNML();

        /** assignment operator */
        GripperCommandActionNML & operator=(const GripperCommandActionNML &inobj);
        /** assignment operator for base data class */
        GripperCommandActionNML & operator=(const GripperCommandAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandAction nmlPayload;

        /** set payload */
        void payload(const GripperCommandAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandActionFeedback 

    */
    class GripperCommandActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandActionFeedbackNML();
        /** destructor */
        ~GripperCommandActionFeedbackNML();

        /** assignment operator */
        GripperCommandActionFeedbackNML & operator=(const GripperCommandActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        GripperCommandActionFeedbackNML & operator=(const GripperCommandActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandActionFeedback nmlPayload;

        /** set payload */
        void payload(const GripperCommandActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandActionGoal 

    */
    class GripperCommandActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandActionGoalNML();
        /** destructor */
        ~GripperCommandActionGoalNML();

        /** assignment operator */
        GripperCommandActionGoalNML & operator=(const GripperCommandActionGoalNML &inobj);
        /** assignment operator for base data class */
        GripperCommandActionGoalNML & operator=(const GripperCommandActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandActionGoal nmlPayload;

        /** set payload */
        void payload(const GripperCommandActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandActionResult 

    */
    class GripperCommandActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandActionResultNML();
        /** destructor */
        ~GripperCommandActionResultNML();

        /** assignment operator */
        GripperCommandActionResultNML & operator=(const GripperCommandActionResultNML &inobj);
        /** assignment operator for base data class */
        GripperCommandActionResultNML & operator=(const GripperCommandActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandActionResult nmlPayload;

        /** set payload */
        void payload(const GripperCommandActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandFeedback 

    */
    class GripperCommandFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandFeedbackNML();
        /** destructor */
        ~GripperCommandFeedbackNML();

        /** assignment operator */
        GripperCommandFeedbackNML & operator=(const GripperCommandFeedbackNML &inobj);
        /** assignment operator for base data class */
        GripperCommandFeedbackNML & operator=(const GripperCommandFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandFeedback nmlPayload;

        /** set payload */
        void payload(const GripperCommandFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandGoal 

    */
    class GripperCommandGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandGoalNML();
        /** destructor */
        ~GripperCommandGoalNML();

        /** assignment operator */
        GripperCommandGoalNML & operator=(const GripperCommandGoalNML &inobj);
        /** assignment operator for base data class */
        GripperCommandGoalNML & operator=(const GripperCommandGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandGoal nmlPayload;

        /** set payload */
        void payload(const GripperCommandGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for GripperCommandResult 

    */
    class GripperCommandResultNML : public NMLmsg
    {
    public:

        /** constructor */
        GripperCommandResultNML();
        /** destructor */
        ~GripperCommandResultNML();

        /** assignment operator */
        GripperCommandResultNML & operator=(const GripperCommandResultNML &inobj);
        /** assignment operator for base data class */
        GripperCommandResultNML & operator=(const GripperCommandResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        GripperCommandResult nmlPayload;

        /** set payload */
        void payload(const GripperCommandResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<GripperCommandResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        GripperCommandResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<GripperCommandResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointControllerState 

    */
    class JointControllerStateNML : public NMLmsg
    {
    public:

        /** constructor */
        JointControllerStateNML();
        /** destructor */
        ~JointControllerStateNML();

        /** assignment operator */
        JointControllerStateNML & operator=(const JointControllerStateNML &inobj);
        /** assignment operator for base data class */
        JointControllerStateNML & operator=(const JointControllerState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointControllerState nmlPayload;

        /** set payload */
        void payload(const JointControllerState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointControllerState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointControllerState * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointControllerState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTolerance 

    */
    class JointToleranceNML : public NMLmsg
    {
    public:

        /** constructor */
        JointToleranceNML();
        /** destructor */
        ~JointToleranceNML();

        /** assignment operator */
        JointToleranceNML & operator=(const JointToleranceNML &inobj);
        /** assignment operator for base data class */
        JointToleranceNML & operator=(const JointTolerance &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTolerance nmlPayload;

        /** set payload */
        void payload(const JointTolerance &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTolerance> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTolerance * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTolerance> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryAction 

    */
    class JointTrajectoryActionNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryActionNML();
        /** destructor */
        ~JointTrajectoryActionNML();

        /** assignment operator */
        JointTrajectoryActionNML & operator=(const JointTrajectoryActionNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryActionNML & operator=(const JointTrajectoryAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryAction nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryActionFeedback 

    */
    class JointTrajectoryActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryActionFeedbackNML();
        /** destructor */
        ~JointTrajectoryActionFeedbackNML();

        /** assignment operator */
        JointTrajectoryActionFeedbackNML & operator=(const JointTrajectoryActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryActionFeedbackNML & operator=(const JointTrajectoryActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryActionFeedback nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryActionGoal 

    */
    class JointTrajectoryActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryActionGoalNML();
        /** destructor */
        ~JointTrajectoryActionGoalNML();

        /** assignment operator */
        JointTrajectoryActionGoalNML & operator=(const JointTrajectoryActionGoalNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryActionGoalNML & operator=(const JointTrajectoryActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryActionGoal nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryActionResult 

    */
    class JointTrajectoryActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryActionResultNML();
        /** destructor */
        ~JointTrajectoryActionResultNML();

        /** assignment operator */
        JointTrajectoryActionResultNML & operator=(const JointTrajectoryActionResultNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryActionResultNML & operator=(const JointTrajectoryActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryActionResult nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryControllerState 

    */
    class JointTrajectoryControllerStateNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryControllerStateNML();
        /** destructor */
        ~JointTrajectoryControllerStateNML();

        /** assignment operator */
        JointTrajectoryControllerStateNML & operator=(const JointTrajectoryControllerStateNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryControllerStateNML & operator=(const JointTrajectoryControllerState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryControllerState nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryControllerState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryControllerState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryControllerState * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryControllerState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryFeedback 

    */
    class JointTrajectoryFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryFeedbackNML();
        /** destructor */
        ~JointTrajectoryFeedbackNML();

        /** assignment operator */
        JointTrajectoryFeedbackNML & operator=(const JointTrajectoryFeedbackNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryFeedbackNML & operator=(const JointTrajectoryFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryFeedback nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryGoal 

    */
    class JointTrajectoryGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryGoalNML();
        /** destructor */
        ~JointTrajectoryGoalNML();

        /** assignment operator */
        JointTrajectoryGoalNML & operator=(const JointTrajectoryGoalNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryGoalNML & operator=(const JointTrajectoryGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryGoal nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for JointTrajectoryResult 

    */
    class JointTrajectoryResultNML : public NMLmsg
    {
    public:

        /** constructor */
        JointTrajectoryResultNML();
        /** destructor */
        ~JointTrajectoryResultNML();

        /** assignment operator */
        JointTrajectoryResultNML & operator=(const JointTrajectoryResultNML &inobj);
        /** assignment operator for base data class */
        JointTrajectoryResultNML & operator=(const JointTrajectoryResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        JointTrajectoryResult nmlPayload;

        /** set payload */
        void payload(const JointTrajectoryResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<JointTrajectoryResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        JointTrajectoryResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<JointTrajectoryResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadAction 

    */
    class PointHeadActionNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadActionNML();
        /** destructor */
        ~PointHeadActionNML();

        /** assignment operator */
        PointHeadActionNML & operator=(const PointHeadActionNML &inobj);
        /** assignment operator for base data class */
        PointHeadActionNML & operator=(const PointHeadAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadAction nmlPayload;

        /** set payload */
        void payload(const PointHeadAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadActionFeedback 

    */
    class PointHeadActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadActionFeedbackNML();
        /** destructor */
        ~PointHeadActionFeedbackNML();

        /** assignment operator */
        PointHeadActionFeedbackNML & operator=(const PointHeadActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        PointHeadActionFeedbackNML & operator=(const PointHeadActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadActionFeedback nmlPayload;

        /** set payload */
        void payload(const PointHeadActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadActionGoal 

    */
    class PointHeadActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadActionGoalNML();
        /** destructor */
        ~PointHeadActionGoalNML();

        /** assignment operator */
        PointHeadActionGoalNML & operator=(const PointHeadActionGoalNML &inobj);
        /** assignment operator for base data class */
        PointHeadActionGoalNML & operator=(const PointHeadActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadActionGoal nmlPayload;

        /** set payload */
        void payload(const PointHeadActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadActionResult 

    */
    class PointHeadActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadActionResultNML();
        /** destructor */
        ~PointHeadActionResultNML();

        /** assignment operator */
        PointHeadActionResultNML & operator=(const PointHeadActionResultNML &inobj);
        /** assignment operator for base data class */
        PointHeadActionResultNML & operator=(const PointHeadActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadActionResult nmlPayload;

        /** set payload */
        void payload(const PointHeadActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadFeedback 

    */
    class PointHeadFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadFeedbackNML();
        /** destructor */
        ~PointHeadFeedbackNML();

        /** assignment operator */
        PointHeadFeedbackNML & operator=(const PointHeadFeedbackNML &inobj);
        /** assignment operator for base data class */
        PointHeadFeedbackNML & operator=(const PointHeadFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadFeedback nmlPayload;

        /** set payload */
        void payload(const PointHeadFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadGoal 

    */
    class PointHeadGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadGoalNML();
        /** destructor */
        ~PointHeadGoalNML();

        /** assignment operator */
        PointHeadGoalNML & operator=(const PointHeadGoalNML &inobj);
        /** assignment operator for base data class */
        PointHeadGoalNML & operator=(const PointHeadGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadGoal nmlPayload;

        /** set payload */
        void payload(const PointHeadGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for PointHeadResult 

    */
    class PointHeadResultNML : public NMLmsg
    {
    public:

        /** constructor */
        PointHeadResultNML();
        /** destructor */
        ~PointHeadResultNML();

        /** assignment operator */
        PointHeadResultNML & operator=(const PointHeadResultNML &inobj);
        /** assignment operator for base data class */
        PointHeadResultNML & operator=(const PointHeadResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        PointHeadResult nmlPayload;

        /** set payload */
        void payload(const PointHeadResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<PointHeadResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        PointHeadResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<PointHeadResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionAction 

    */
    class SingleJointPositionActionNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionActionNML();
        /** destructor */
        ~SingleJointPositionActionNML();

        /** assignment operator */
        SingleJointPositionActionNML & operator=(const SingleJointPositionActionNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionActionNML & operator=(const SingleJointPositionAction &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionAction nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionAction &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionAction> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionAction * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionAction> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionActionFeedback 

    */
    class SingleJointPositionActionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionActionFeedbackNML();
        /** destructor */
        ~SingleJointPositionActionFeedbackNML();

        /** assignment operator */
        SingleJointPositionActionFeedbackNML & operator=(const SingleJointPositionActionFeedbackNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionActionFeedbackNML & operator=(const SingleJointPositionActionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionActionFeedback nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionActionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionActionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionActionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionActionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionActionGoal 

    */
    class SingleJointPositionActionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionActionGoalNML();
        /** destructor */
        ~SingleJointPositionActionGoalNML();

        /** assignment operator */
        SingleJointPositionActionGoalNML & operator=(const SingleJointPositionActionGoalNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionActionGoalNML & operator=(const SingleJointPositionActionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionActionGoal nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionActionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionActionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionActionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionActionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionActionResult 

    */
    class SingleJointPositionActionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionActionResultNML();
        /** destructor */
        ~SingleJointPositionActionResultNML();

        /** assignment operator */
        SingleJointPositionActionResultNML & operator=(const SingleJointPositionActionResultNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionActionResultNML & operator=(const SingleJointPositionActionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionActionResult nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionActionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionActionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionActionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionActionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionFeedback 

    */
    class SingleJointPositionFeedbackNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionFeedbackNML();
        /** destructor */
        ~SingleJointPositionFeedbackNML();

        /** assignment operator */
        SingleJointPositionFeedbackNML & operator=(const SingleJointPositionFeedbackNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionFeedbackNML & operator=(const SingleJointPositionFeedback &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionFeedback nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionFeedback &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionFeedback> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionFeedback * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionFeedback> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionGoal 

    */
    class SingleJointPositionGoalNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionGoalNML();
        /** destructor */
        ~SingleJointPositionGoalNML();

        /** assignment operator */
        SingleJointPositionGoalNML & operator=(const SingleJointPositionGoalNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionGoalNML & operator=(const SingleJointPositionGoal &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionGoal nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionGoal &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionGoal> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionGoal * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionGoal> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for SingleJointPositionResult 

    */
    class SingleJointPositionResultNML : public NMLmsg
    {
    public:

        /** constructor */
        SingleJointPositionResultNML();
        /** destructor */
        ~SingleJointPositionResultNML();

        /** assignment operator */
        SingleJointPositionResultNML & operator=(const SingleJointPositionResultNML &inobj);
        /** assignment operator for base data class */
        SingleJointPositionResultNML & operator=(const SingleJointPositionResult &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        SingleJointPositionResult nmlPayload;

        /** set payload */
        void payload(const SingleJointPositionResult &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<SingleJointPositionResult> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        SingleJointPositionResult * payload() { return & nmlPayload; };

    //     std::shared_ptr<SingleJointPositionResult> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for QueryCalibrationStateRequest 

    */
    class QueryCalibrationStateRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        QueryCalibrationStateRequestNML();
        /** destructor */
        ~QueryCalibrationStateRequestNML();

        /** assignment operator */
        QueryCalibrationStateRequestNML & operator=(const QueryCalibrationStateRequestNML &inobj);
        /** assignment operator for base data class */
        QueryCalibrationStateRequestNML & operator=(const QueryCalibrationStateRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        QueryCalibrationStateRequest nmlPayload;

        /** set payload */
        void payload(const QueryCalibrationStateRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<QueryCalibrationStateRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        QueryCalibrationStateRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<QueryCalibrationStateRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for QueryCalibrationStateResponse 

    */
    class QueryCalibrationStateResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        QueryCalibrationStateResponseNML();
        /** destructor */
        ~QueryCalibrationStateResponseNML();

        /** assignment operator */
        QueryCalibrationStateResponseNML & operator=(const QueryCalibrationStateResponseNML &inobj);
        /** assignment operator for base data class */
        QueryCalibrationStateResponseNML & operator=(const QueryCalibrationStateResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        QueryCalibrationStateResponse nmlPayload;

        /** set payload */
        void payload(const QueryCalibrationStateResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<QueryCalibrationStateResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        QueryCalibrationStateResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<QueryCalibrationStateResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for QueryCalibrationState 

    */
    class QueryCalibrationStateNML : public NMLmsg
    {
    public:

        /** constructor */
        QueryCalibrationStateNML();
        /** destructor */
        ~QueryCalibrationStateNML();

        /** assignment operator */
        QueryCalibrationStateNML & operator=(const QueryCalibrationStateNML &inobj);
        /** assignment operator for base data class */
        QueryCalibrationStateNML & operator=(const QueryCalibrationState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        QueryCalibrationState nmlPayload;

        /** set payload */
        void payload(const QueryCalibrationState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<QueryCalibrationState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        QueryCalibrationState * payload() { return & nmlPayload; };

    //     std::shared_ptr<QueryCalibrationState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for QueryTrajectoryStateRequest 

    */
    class QueryTrajectoryStateRequestNML : public NMLmsg
    {
    public:

        /** constructor */
        QueryTrajectoryStateRequestNML();
        /** destructor */
        ~QueryTrajectoryStateRequestNML();

        /** assignment operator */
        QueryTrajectoryStateRequestNML & operator=(const QueryTrajectoryStateRequestNML &inobj);
        /** assignment operator for base data class */
        QueryTrajectoryStateRequestNML & operator=(const QueryTrajectoryStateRequest &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        QueryTrajectoryStateRequest nmlPayload;

        /** set payload */
        void payload(const QueryTrajectoryStateRequest &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<QueryTrajectoryStateRequest> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        QueryTrajectoryStateRequest * payload() { return & nmlPayload; };

    //     std::shared_ptr<QueryTrajectoryStateRequest> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for QueryTrajectoryStateResponse 

    */
    class QueryTrajectoryStateResponseNML : public NMLmsg
    {
    public:

        /** constructor */
        QueryTrajectoryStateResponseNML();
        /** destructor */
        ~QueryTrajectoryStateResponseNML();

        /** assignment operator */
        QueryTrajectoryStateResponseNML & operator=(const QueryTrajectoryStateResponseNML &inobj);
        /** assignment operator for base data class */
        QueryTrajectoryStateResponseNML & operator=(const QueryTrajectoryStateResponse &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        QueryTrajectoryStateResponse nmlPayload;

        /** set payload */
        void payload(const QueryTrajectoryStateResponse &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<QueryTrajectoryStateResponse> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        QueryTrajectoryStateResponse * payload() { return & nmlPayload; };

    //     std::shared_ptr<QueryTrajectoryStateResponse> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    /** NML interface for QueryTrajectoryState 

    */
    class QueryTrajectoryStateNML : public NMLmsg
    {
    public:

        /** constructor */
        QueryTrajectoryStateNML();
        /** destructor */
        ~QueryTrajectoryStateNML();

        /** assignment operator */
        QueryTrajectoryStateNML & operator=(const QueryTrajectoryStateNML &inobj);
        /** assignment operator for base data class */
        QueryTrajectoryStateNML & operator=(const QueryTrajectoryState &inobj);

        /** static flag, if true boost serialization should be used to serialize this message */
        static const bool useBoost = true;

        /** nml serialization access */
        void update( CMS*);

        /** message version, used to verify message versions match on read */
        unsigned int nmlVersion;
        /** timestamp of message creation */
        double nmlTimestamp;
        /** id of module which sent the message */
        rframe::ID_TYPE nmlModuleId;

        /** nml payload */
        QueryTrajectoryState nmlPayload;

        /** set payload */
        void payload(const QueryTrajectoryState &data) 
        {
            nmlPayload = data;
        };

        /** set payload from shared_ptr */
        void payload(std::shared_ptr<QueryTrajectoryState> & data)
        {
            nmlPayload = *data.get();
        };

        /** \return pointer to nml payload */
        QueryTrajectoryState * payload() { return & nmlPayload; };

    //     std::shared_ptr<QueryTrajectoryState> nmlPayload; reminder that nmlPayload used to be a pointer
    // but the only way this could work well is if we knew to instantiate it due to dataTypeFlat()
    // which we cannot know until compile/run time...
    };

    // predeclaration of nmlupdate functions (necessary due to namespaces )

    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::FollowJointTrajectoryResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommand & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::GripperCommandResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointControllerState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTolerance & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryControllerState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::JointTrajectoryResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::PointHeadResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionAction & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionActionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionActionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionActionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionFeedback & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionGoal & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::SingleJointPositionResult & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::QueryCalibrationStateRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::QueryCalibrationStateResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::QueryCalibrationState & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::QueryTrajectoryStateRequest & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::QueryTrajectoryStateResponse & inobj);
    /** serialize a message to/from a buffer 
     \param cms buffer data structure to be serailized to/from
     \param inobj object to be serialized*/
    void nmlupdate(CMS *cms, control_msgs::QueryTrajectoryState & inobj);

    /** nml format function */
    int control_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms);

}; // end namespace control_msgs

#endif // _CONTROL_MSGS_GENCPPNML_H_
