// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:08 -0500
//  From Template/Script: data_templates/NMLClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <stdio.h>
// main rcslib header
#include <nml.hh>
// cms updater header
#include <cms_up.hh>
#include <cms_pup.hh>

#include <common/Error.h>
#include <common/Log.h>
#include <common/Common.h>
#include <common/DataTypeInfo.h>

#include "std_msgs_gencpp_NML.h"
#include "std_msgs_gencpp_Library.h"
#include <messaging/nml/NMLSupport.h>
#include <interfaces/MessageFactoryInterface.h>

#include <RosTime.h>
#include <RosDuration.h>
#include <HeaderTest.h>
#include <Bool.h>
#include <Byte.h>
#include <ByteMultiArray.h>
#include <Char.h>
#include <ColorRGBA.h>
#include <Duration.h>
#include <Empty.h>
#include <Float32.h>
#include <Float32MultiArray.h>
#include <Float64.h>
#include <Float64MultiArray.h>
#include <Header.h>
#include <Int16.h>
#include <Int16MultiArray.h>
#include <Int32.h>
#include <Int32MultiArray.h>
#include <Int64.h>
#include <Int64MultiArray.h>
#include <Int8.h>
#include <Int8MultiArray.h>
#include <MultiArrayDimension.h>
#include <MultiArrayLayout.h>
#include <String.h>
#include <Time.h>
#include <UInt16.h>
#include <UInt16MultiArray.h>
#include <UInt32.h>
#include <UInt32MultiArray.h>
#include <UInt64.h>
#include <UInt64MultiArray.h>
#include <UInt8.h>
#include <UInt8MultiArray.h>

#include <boost/iostreams/stream_buffer.hpp>
#include <boost/iostreams/stream.hpp>

#include <boost/serialization/serialization.hpp>
#include <opensource/eos/archive/portable_iarchive.hpp>
#include <opensource/eos/archive/portable_oarchive.hpp>

using namespace std;
using namespace std_msgs;

rframe::NMLMessageFactory * NML_std_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        NML_std_msgs_gencppfactory = new std_msgs_gencppNMLMessageFactory();
        return NML_std_msgs_gencppfactory;
    };
}

rframe::NMLMessageFactory * std_msgs::allocate_std_msgs_gencpp()
{
    NML_std_msgs_gencppfactory = new std_msgs_gencppNMLMessageFactory();
    return NML_std_msgs_gencppfactory;
};

std_msgs_gencppNMLMessageFactory::std_msgs_gencppNMLMessageFactory()
{
    name("std_msgs_gencpp");
    // use constructor to register data types
    std_msgs::registerLibrary();
}

std_msgs_gencppNMLMessageFactory::~std_msgs_gencppNMLMessageFactory()
{
}

NML_FORMAT_PTR std_msgs_gencppNMLMessageFactory::FormatPointer()
{
    return std_msgs_gencpp_format;
}

int std_msgs_gencppNMLMessageFactory::dataType(NMLmsg & msg)
{
    return msg.type;
}

void std_msgs_gencppNMLMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(RosTime::ID);
    info.name(RosTime::DATA_TYPE_FULL_NAME);
    info.hashKey(RosTime::DATA_VERSION);
    info.md5Key(RosTime::VERSION_MD5);
    info.xmlSource(RosTime::XML_SOURCE);
    info.flat(RosTime::dataTypeFlat());
    ids.push_back(info);

    info.id(RosDuration::ID);
    info.name(RosDuration::DATA_TYPE_FULL_NAME);
    info.hashKey(RosDuration::DATA_VERSION);
    info.md5Key(RosDuration::VERSION_MD5);
    info.xmlSource(RosDuration::XML_SOURCE);
    info.flat(RosDuration::dataTypeFlat());
    ids.push_back(info);

    info.id(HeaderTest::ID);
    info.name(HeaderTest::DATA_TYPE_FULL_NAME);
    info.hashKey(HeaderTest::DATA_VERSION);
    info.md5Key(HeaderTest::VERSION_MD5);
    info.xmlSource(HeaderTest::XML_SOURCE);
    info.flat(HeaderTest::dataTypeFlat());
    ids.push_back(info);

    info.id(Bool::ID);
    info.name(Bool::DATA_TYPE_FULL_NAME);
    info.hashKey(Bool::DATA_VERSION);
    info.md5Key(Bool::VERSION_MD5);
    info.xmlSource(Bool::XML_SOURCE);
    info.flat(Bool::dataTypeFlat());
    ids.push_back(info);

    info.id(Byte::ID);
    info.name(Byte::DATA_TYPE_FULL_NAME);
    info.hashKey(Byte::DATA_VERSION);
    info.md5Key(Byte::VERSION_MD5);
    info.xmlSource(Byte::XML_SOURCE);
    info.flat(Byte::dataTypeFlat());
    ids.push_back(info);

    info.id(ByteMultiArray::ID);
    info.name(ByteMultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(ByteMultiArray::DATA_VERSION);
    info.md5Key(ByteMultiArray::VERSION_MD5);
    info.xmlSource(ByteMultiArray::XML_SOURCE);
    info.flat(ByteMultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Char::ID);
    info.name(Char::DATA_TYPE_FULL_NAME);
    info.hashKey(Char::DATA_VERSION);
    info.md5Key(Char::VERSION_MD5);
    info.xmlSource(Char::XML_SOURCE);
    info.flat(Char::dataTypeFlat());
    ids.push_back(info);

    info.id(ColorRGBA::ID);
    info.name(ColorRGBA::DATA_TYPE_FULL_NAME);
    info.hashKey(ColorRGBA::DATA_VERSION);
    info.md5Key(ColorRGBA::VERSION_MD5);
    info.xmlSource(ColorRGBA::XML_SOURCE);
    info.flat(ColorRGBA::dataTypeFlat());
    ids.push_back(info);

    info.id(Duration::ID);
    info.name(Duration::DATA_TYPE_FULL_NAME);
    info.hashKey(Duration::DATA_VERSION);
    info.md5Key(Duration::VERSION_MD5);
    info.xmlSource(Duration::XML_SOURCE);
    info.flat(Duration::dataTypeFlat());
    ids.push_back(info);

    info.id(Empty::ID);
    info.name(Empty::DATA_TYPE_FULL_NAME);
    info.hashKey(Empty::DATA_VERSION);
    info.md5Key(Empty::VERSION_MD5);
    info.xmlSource(Empty::XML_SOURCE);
    info.flat(Empty::dataTypeFlat());
    ids.push_back(info);

    info.id(Float32::ID);
    info.name(Float32::DATA_TYPE_FULL_NAME);
    info.hashKey(Float32::DATA_VERSION);
    info.md5Key(Float32::VERSION_MD5);
    info.xmlSource(Float32::XML_SOURCE);
    info.flat(Float32::dataTypeFlat());
    ids.push_back(info);

    info.id(Float32MultiArray::ID);
    info.name(Float32MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Float32MultiArray::DATA_VERSION);
    info.md5Key(Float32MultiArray::VERSION_MD5);
    info.xmlSource(Float32MultiArray::XML_SOURCE);
    info.flat(Float32MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Float64::ID);
    info.name(Float64::DATA_TYPE_FULL_NAME);
    info.hashKey(Float64::DATA_VERSION);
    info.md5Key(Float64::VERSION_MD5);
    info.xmlSource(Float64::XML_SOURCE);
    info.flat(Float64::dataTypeFlat());
    ids.push_back(info);

    info.id(Float64MultiArray::ID);
    info.name(Float64MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Float64MultiArray::DATA_VERSION);
    info.md5Key(Float64MultiArray::VERSION_MD5);
    info.xmlSource(Float64MultiArray::XML_SOURCE);
    info.flat(Float64MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Header::ID);
    info.name(Header::DATA_TYPE_FULL_NAME);
    info.hashKey(Header::DATA_VERSION);
    info.md5Key(Header::VERSION_MD5);
    info.xmlSource(Header::XML_SOURCE);
    info.flat(Header::dataTypeFlat());
    ids.push_back(info);

    info.id(Int16::ID);
    info.name(Int16::DATA_TYPE_FULL_NAME);
    info.hashKey(Int16::DATA_VERSION);
    info.md5Key(Int16::VERSION_MD5);
    info.xmlSource(Int16::XML_SOURCE);
    info.flat(Int16::dataTypeFlat());
    ids.push_back(info);

    info.id(Int16MultiArray::ID);
    info.name(Int16MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int16MultiArray::DATA_VERSION);
    info.md5Key(Int16MultiArray::VERSION_MD5);
    info.xmlSource(Int16MultiArray::XML_SOURCE);
    info.flat(Int16MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Int32::ID);
    info.name(Int32::DATA_TYPE_FULL_NAME);
    info.hashKey(Int32::DATA_VERSION);
    info.md5Key(Int32::VERSION_MD5);
    info.xmlSource(Int32::XML_SOURCE);
    info.flat(Int32::dataTypeFlat());
    ids.push_back(info);

    info.id(Int32MultiArray::ID);
    info.name(Int32MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int32MultiArray::DATA_VERSION);
    info.md5Key(Int32MultiArray::VERSION_MD5);
    info.xmlSource(Int32MultiArray::XML_SOURCE);
    info.flat(Int32MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Int64::ID);
    info.name(Int64::DATA_TYPE_FULL_NAME);
    info.hashKey(Int64::DATA_VERSION);
    info.md5Key(Int64::VERSION_MD5);
    info.xmlSource(Int64::XML_SOURCE);
    info.flat(Int64::dataTypeFlat());
    ids.push_back(info);

    info.id(Int64MultiArray::ID);
    info.name(Int64MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int64MultiArray::DATA_VERSION);
    info.md5Key(Int64MultiArray::VERSION_MD5);
    info.xmlSource(Int64MultiArray::XML_SOURCE);
    info.flat(Int64MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Int8::ID);
    info.name(Int8::DATA_TYPE_FULL_NAME);
    info.hashKey(Int8::DATA_VERSION);
    info.md5Key(Int8::VERSION_MD5);
    info.xmlSource(Int8::XML_SOURCE);
    info.flat(Int8::dataTypeFlat());
    ids.push_back(info);

    info.id(Int8MultiArray::ID);
    info.name(Int8MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int8MultiArray::DATA_VERSION);
    info.md5Key(Int8MultiArray::VERSION_MD5);
    info.xmlSource(Int8MultiArray::XML_SOURCE);
    info.flat(Int8MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiArrayDimension::ID);
    info.name(MultiArrayDimension::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiArrayDimension::DATA_VERSION);
    info.md5Key(MultiArrayDimension::VERSION_MD5);
    info.xmlSource(MultiArrayDimension::XML_SOURCE);
    info.flat(MultiArrayDimension::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiArrayLayout::ID);
    info.name(MultiArrayLayout::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiArrayLayout::DATA_VERSION);
    info.md5Key(MultiArrayLayout::VERSION_MD5);
    info.xmlSource(MultiArrayLayout::XML_SOURCE);
    info.flat(MultiArrayLayout::dataTypeFlat());
    ids.push_back(info);

    info.id(String::ID);
    info.name(String::DATA_TYPE_FULL_NAME);
    info.hashKey(String::DATA_VERSION);
    info.md5Key(String::VERSION_MD5);
    info.xmlSource(String::XML_SOURCE);
    info.flat(String::dataTypeFlat());
    ids.push_back(info);

    info.id(Time::ID);
    info.name(Time::DATA_TYPE_FULL_NAME);
    info.hashKey(Time::DATA_VERSION);
    info.md5Key(Time::VERSION_MD5);
    info.xmlSource(Time::XML_SOURCE);
    info.flat(Time::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt16::ID);
    info.name(UInt16::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt16::DATA_VERSION);
    info.md5Key(UInt16::VERSION_MD5);
    info.xmlSource(UInt16::XML_SOURCE);
    info.flat(UInt16::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt16MultiArray::ID);
    info.name(UInt16MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt16MultiArray::DATA_VERSION);
    info.md5Key(UInt16MultiArray::VERSION_MD5);
    info.xmlSource(UInt16MultiArray::XML_SOURCE);
    info.flat(UInt16MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt32::ID);
    info.name(UInt32::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt32::DATA_VERSION);
    info.md5Key(UInt32::VERSION_MD5);
    info.xmlSource(UInt32::XML_SOURCE);
    info.flat(UInt32::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt32MultiArray::ID);
    info.name(UInt32MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt32MultiArray::DATA_VERSION);
    info.md5Key(UInt32MultiArray::VERSION_MD5);
    info.xmlSource(UInt32MultiArray::XML_SOURCE);
    info.flat(UInt32MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt64::ID);
    info.name(UInt64::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt64::DATA_VERSION);
    info.md5Key(UInt64::VERSION_MD5);
    info.xmlSource(UInt64::XML_SOURCE);
    info.flat(UInt64::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt64MultiArray::ID);
    info.name(UInt64MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt64MultiArray::DATA_VERSION);
    info.md5Key(UInt64MultiArray::VERSION_MD5);
    info.xmlSource(UInt64MultiArray::XML_SOURCE);
    info.flat(UInt64MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt8::ID);
    info.name(UInt8::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt8::DATA_VERSION);
    info.md5Key(UInt8::VERSION_MD5);
    info.xmlSource(UInt8::XML_SOURCE);
    info.flat(UInt8::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt8MultiArray::ID);
    info.name(UInt8MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt8MultiArray::DATA_VERSION);
    info.md5Key(UInt8MultiArray::VERSION_MD5);
    info.xmlSource(UInt8MultiArray::XML_SOURCE);
    info.flat(UInt8MultiArray::dataTypeFlat());
    ids.push_back(info);

}

int std_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<NMLmsg> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case RosTime::ID:
        {
            //RosTimeNML * newmsg = new RosTimeNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new RosTimeNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case RosDuration::ID:
        {
            //RosDurationNML * newmsg = new RosDurationNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new RosDurationNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case HeaderTest::ID:
        {
            //HeaderTestNML * newmsg = new HeaderTestNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new HeaderTestNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Bool::ID:
        {
            //BoolNML * newmsg = new BoolNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new BoolNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Byte::ID:
        {
            //ByteNML * newmsg = new ByteNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ByteNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ByteMultiArray::ID:
        {
            //ByteMultiArrayNML * newmsg = new ByteMultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ByteMultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Char::ID:
        {
            //CharNML * newmsg = new CharNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new CharNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case ColorRGBA::ID:
        {
            //ColorRGBANML * newmsg = new ColorRGBANML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new ColorRGBANML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Duration::ID:
        {
            //DurationNML * newmsg = new DurationNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new DurationNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Empty::ID:
        {
            //EmptyNML * newmsg = new EmptyNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new EmptyNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Float32::ID:
        {
            //Float32NML * newmsg = new Float32NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Float32NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Float32MultiArray::ID:
        {
            //Float32MultiArrayNML * newmsg = new Float32MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Float32MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Float64::ID:
        {
            //Float64NML * newmsg = new Float64NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Float64NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Float64MultiArray::ID:
        {
            //Float64MultiArrayNML * newmsg = new Float64MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Float64MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Header::ID:
        {
            //HeaderNML * newmsg = new HeaderNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new HeaderNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int16::ID:
        {
            //Int16NML * newmsg = new Int16NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int16NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int16MultiArray::ID:
        {
            //Int16MultiArrayNML * newmsg = new Int16MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int16MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int32::ID:
        {
            //Int32NML * newmsg = new Int32NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int32NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int32MultiArray::ID:
        {
            //Int32MultiArrayNML * newmsg = new Int32MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int32MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int64::ID:
        {
            //Int64NML * newmsg = new Int64NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int64NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int64MultiArray::ID:
        {
            //Int64MultiArrayNML * newmsg = new Int64MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int64MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int8::ID:
        {
            //Int8NML * newmsg = new Int8NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int8NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Int8MultiArray::ID:
        {
            //Int8MultiArrayNML * newmsg = new Int8MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new Int8MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MultiArrayDimension::ID:
        {
            //MultiArrayDimensionNML * newmsg = new MultiArrayDimensionNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MultiArrayDimensionNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case MultiArrayLayout::ID:
        {
            //MultiArrayLayoutNML * newmsg = new MultiArrayLayoutNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new MultiArrayLayoutNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case String::ID:
        {
            //StringNML * newmsg = new StringNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new StringNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case Time::ID:
        {
            //TimeNML * newmsg = new TimeNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new TimeNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt16::ID:
        {
            //UInt16NML * newmsg = new UInt16NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt16NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt16MultiArray::ID:
        {
            //UInt16MultiArrayNML * newmsg = new UInt16MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt16MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt32::ID:
        {
            //UInt32NML * newmsg = new UInt32NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt32NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt32MultiArray::ID:
        {
            //UInt32MultiArrayNML * newmsg = new UInt32MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt32MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt64::ID:
        {
            //UInt64NML * newmsg = new UInt64NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt64NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt64MultiArray::ID:
        {
            //UInt64MultiArrayNML * newmsg = new UInt64MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt64MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt8::ID:
        {
            //UInt8NML * newmsg = new UInt8NML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt8NML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        case UInt8MultiArray::ID:
        {
            //UInt8MultiArrayNML * newmsg = new UInt8MultiArrayNML();
            // allocate new data member, with link to appropriate destroy callback
            // what bind does is create a callback into this specific instance for the deallcoateTransport
            // member.
            std::shared_ptr<NMLmsg> newmsg(new UInt8MultiArrayNML(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateTransport,this,std::placeholders::_1));

            if (newmsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(newmsg);
                    /*                    *msg = static_cast<NMLmsg*>(newmsg);

                    if (*msg == NULL)
                    {
                        delete newmsg;
                        retval = rframe::Error::CAST;
                    }
                    */

            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int std_msgs_gencppNMLMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;
    bool found = true;

    switch (id)
    { 
        case RosTime::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<RosTime>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case RosDuration::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<RosDuration>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case HeaderTest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<HeaderTest>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Bool::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Bool>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Byte::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Byte>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ByteMultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ByteMultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Char::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Char>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ColorRGBA::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ColorRGBA>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Duration::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Duration>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Empty::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Empty>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float32>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float32MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float32MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float64::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float64>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float64MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float64MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Header::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Header>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int16::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int16>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int16MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int16MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int32>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int32MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int32MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int64::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int64>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int64MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int64MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int8::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int8>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int8MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int8MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiArrayDimension::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiArrayDimension>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiArrayLayout::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiArrayLayout>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case String::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<String>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Time::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Time>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt16::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt16>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt16MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt16MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt32>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt32MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt32MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt64::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt64>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt64MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt64MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt8::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt8>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt8MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt8MultiArray>(),std::bind(&std_msgs_gencppNMLMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            found = false;
        }
    }

    if (found == false)
    {
        retval = rframe::Error::PARAM_RANGE;
    }
    else if (msg.get() == NULL)
    {
        retval = rframe::Error::MEMORY_ALLOC;
    }
    else if (msg.get() != NULL)
    {
        retval = rframe::Error::SUCCESS;
    }

    return retval;
}

int std_msgs_gencppNMLMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    delete msg;

    return retval;
}

int std_msgs_gencppNMLMessageFactory::deallocateTransport(NMLmsg * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        switch (msg->type)
        { 
            case RosTime::ID:
            {
                RosTimeNML * tempmsg = static_cast<RosTimeNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case RosDuration::ID:
            {
                RosDurationNML * tempmsg = static_cast<RosDurationNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case HeaderTest::ID:
            {
                HeaderTestNML * tempmsg = static_cast<HeaderTestNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Bool::ID:
            {
                BoolNML * tempmsg = static_cast<BoolNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Byte::ID:
            {
                ByteNML * tempmsg = static_cast<ByteNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ByteMultiArray::ID:
            {
                ByteMultiArrayNML * tempmsg = static_cast<ByteMultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Char::ID:
            {
                CharNML * tempmsg = static_cast<CharNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case ColorRGBA::ID:
            {
                ColorRGBANML * tempmsg = static_cast<ColorRGBANML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Duration::ID:
            {
                DurationNML * tempmsg = static_cast<DurationNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Empty::ID:
            {
                EmptyNML * tempmsg = static_cast<EmptyNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Float32::ID:
            {
                Float32NML * tempmsg = static_cast<Float32NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Float32MultiArray::ID:
            {
                Float32MultiArrayNML * tempmsg = static_cast<Float32MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Float64::ID:
            {
                Float64NML * tempmsg = static_cast<Float64NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Float64MultiArray::ID:
            {
                Float64MultiArrayNML * tempmsg = static_cast<Float64MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Header::ID:
            {
                HeaderNML * tempmsg = static_cast<HeaderNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int16::ID:
            {
                Int16NML * tempmsg = static_cast<Int16NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int16MultiArray::ID:
            {
                Int16MultiArrayNML * tempmsg = static_cast<Int16MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int32::ID:
            {
                Int32NML * tempmsg = static_cast<Int32NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int32MultiArray::ID:
            {
                Int32MultiArrayNML * tempmsg = static_cast<Int32MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int64::ID:
            {
                Int64NML * tempmsg = static_cast<Int64NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int64MultiArray::ID:
            {
                Int64MultiArrayNML * tempmsg = static_cast<Int64MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int8::ID:
            {
                Int8NML * tempmsg = static_cast<Int8NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Int8MultiArray::ID:
            {
                Int8MultiArrayNML * tempmsg = static_cast<Int8MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MultiArrayDimension::ID:
            {
                MultiArrayDimensionNML * tempmsg = static_cast<MultiArrayDimensionNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case MultiArrayLayout::ID:
            {
                MultiArrayLayoutNML * tempmsg = static_cast<MultiArrayLayoutNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case String::ID:
            {
                StringNML * tempmsg = static_cast<StringNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case Time::ID:
            {
                TimeNML * tempmsg = static_cast<TimeNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt16::ID:
            {
                UInt16NML * tempmsg = static_cast<UInt16NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt16MultiArray::ID:
            {
                UInt16MultiArrayNML * tempmsg = static_cast<UInt16MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt32::ID:
            {
                UInt32NML * tempmsg = static_cast<UInt32NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt32MultiArray::ID:
            {
                UInt32MultiArrayNML * tempmsg = static_cast<UInt32MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt64::ID:
            {
                UInt64NML * tempmsg = static_cast<UInt64NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt64MultiArray::ID:
            {
                UInt64MultiArrayNML * tempmsg = static_cast<UInt64MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt8::ID:
            {
                UInt8NML * tempmsg = static_cast<UInt8NML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            case UInt8MultiArray::ID:
            {
                UInt8MultiArrayNML * tempmsg = static_cast<UInt8MultiArrayNML*>(msg);

                if (tempmsg != NULL)
                {
                    delete tempmsg;
                }
                break;
            } 
            default:
            {
                retval = Error::NOT_FOUND;
                break;
            }
        }
    }

    return retval;
}

int std_msgs_gencppNMLMessageFactory::toTransport(MessageBase & src, NMLmsg & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)dst.type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.type)
        { 
            case RosTime::ID:
            {
                RosTimeNML & tempDst = static_cast<RosTimeNML&>(dst);
                Message<RosTime > & tempSrc = static_cast<Message<RosTime>&>(src);

                if (tempSrc.version() != RosTime::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of RosTime: " << __FILE__ << " expected: " 
                             << RosTime::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of RosTime: " << __FILE__ << " expected: " 
                         << RosTime::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case RosDuration::ID:
            {
                RosDurationNML & tempDst = static_cast<RosDurationNML&>(dst);
                Message<RosDuration > & tempSrc = static_cast<Message<RosDuration>&>(src);

                if (tempSrc.version() != RosDuration::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of RosDuration: " << __FILE__ << " expected: " 
                             << RosDuration::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of RosDuration: " << __FILE__ << " expected: " 
                         << RosDuration::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case HeaderTest::ID:
            {
                HeaderTestNML & tempDst = static_cast<HeaderTestNML&>(dst);
                Message<HeaderTest > & tempSrc = static_cast<Message<HeaderTest>&>(src);

                if (tempSrc.version() != HeaderTest::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of HeaderTest: " << __FILE__ << " expected: " 
                             << HeaderTest::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of HeaderTest: " << __FILE__ << " expected: " 
                         << HeaderTest::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Bool::ID:
            {
                BoolNML & tempDst = static_cast<BoolNML&>(dst);
                Message<Bool > & tempSrc = static_cast<Message<Bool>&>(src);

                if (tempSrc.version() != Bool::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Bool: " << __FILE__ << " expected: " 
                             << Bool::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Bool: " << __FILE__ << " expected: " 
                         << Bool::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Byte::ID:
            {
                ByteNML & tempDst = static_cast<ByteNML&>(dst);
                Message<Byte > & tempSrc = static_cast<Message<Byte>&>(src);

                if (tempSrc.version() != Byte::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Byte: " << __FILE__ << " expected: " 
                             << Byte::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Byte: " << __FILE__ << " expected: " 
                         << Byte::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ByteMultiArray::ID:
            {
                ByteMultiArrayNML & tempDst = static_cast<ByteMultiArrayNML&>(dst);
                Message<ByteMultiArray > & tempSrc = static_cast<Message<ByteMultiArray>&>(src);

                if (tempSrc.version() != ByteMultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ByteMultiArray: " << __FILE__ << " expected: " 
                             << ByteMultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ByteMultiArray: " << __FILE__ << " expected: " 
                         << ByteMultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Char::ID:
            {
                CharNML & tempDst = static_cast<CharNML&>(dst);
                Message<Char > & tempSrc = static_cast<Message<Char>&>(src);

                if (tempSrc.version() != Char::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Char: " << __FILE__ << " expected: " 
                             << Char::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Char: " << __FILE__ << " expected: " 
                         << Char::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case ColorRGBA::ID:
            {
                ColorRGBANML & tempDst = static_cast<ColorRGBANML&>(dst);
                Message<ColorRGBA > & tempSrc = static_cast<Message<ColorRGBA>&>(src);

                if (tempSrc.version() != ColorRGBA::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of ColorRGBA: " << __FILE__ << " expected: " 
                             << ColorRGBA::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of ColorRGBA: " << __FILE__ << " expected: " 
                         << ColorRGBA::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Duration::ID:
            {
                DurationNML & tempDst = static_cast<DurationNML&>(dst);
                Message<Duration > & tempSrc = static_cast<Message<Duration>&>(src);

                if (tempSrc.version() != Duration::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Duration: " << __FILE__ << " expected: " 
                             << Duration::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Duration: " << __FILE__ << " expected: " 
                         << Duration::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Empty::ID:
            {
                EmptyNML & tempDst = static_cast<EmptyNML&>(dst);
                Message<Empty > & tempSrc = static_cast<Message<Empty>&>(src);

                if (tempSrc.version() != Empty::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Empty: " << __FILE__ << " expected: " 
                             << Empty::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Empty: " << __FILE__ << " expected: " 
                         << Empty::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Float32::ID:
            {
                Float32NML & tempDst = static_cast<Float32NML&>(dst);
                Message<Float32 > & tempSrc = static_cast<Message<Float32>&>(src);

                if (tempSrc.version() != Float32::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Float32: " << __FILE__ << " expected: " 
                             << Float32::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Float32: " << __FILE__ << " expected: " 
                         << Float32::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Float32MultiArray::ID:
            {
                Float32MultiArrayNML & tempDst = static_cast<Float32MultiArrayNML&>(dst);
                Message<Float32MultiArray > & tempSrc = static_cast<Message<Float32MultiArray>&>(src);

                if (tempSrc.version() != Float32MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Float32MultiArray: " << __FILE__ << " expected: " 
                             << Float32MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Float32MultiArray: " << __FILE__ << " expected: " 
                         << Float32MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Float64::ID:
            {
                Float64NML & tempDst = static_cast<Float64NML&>(dst);
                Message<Float64 > & tempSrc = static_cast<Message<Float64>&>(src);

                if (tempSrc.version() != Float64::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Float64: " << __FILE__ << " expected: " 
                             << Float64::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Float64: " << __FILE__ << " expected: " 
                         << Float64::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Float64MultiArray::ID:
            {
                Float64MultiArrayNML & tempDst = static_cast<Float64MultiArrayNML&>(dst);
                Message<Float64MultiArray > & tempSrc = static_cast<Message<Float64MultiArray>&>(src);

                if (tempSrc.version() != Float64MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Float64MultiArray: " << __FILE__ << " expected: " 
                             << Float64MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Float64MultiArray: " << __FILE__ << " expected: " 
                         << Float64MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Header::ID:
            {
                HeaderNML & tempDst = static_cast<HeaderNML&>(dst);
                Message<Header > & tempSrc = static_cast<Message<Header>&>(src);

                if (tempSrc.version() != Header::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Header: " << __FILE__ << " expected: " 
                             << Header::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Header: " << __FILE__ << " expected: " 
                         << Header::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int16::ID:
            {
                Int16NML & tempDst = static_cast<Int16NML&>(dst);
                Message<Int16 > & tempSrc = static_cast<Message<Int16>&>(src);

                if (tempSrc.version() != Int16::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int16: " << __FILE__ << " expected: " 
                             << Int16::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int16: " << __FILE__ << " expected: " 
                         << Int16::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int16MultiArray::ID:
            {
                Int16MultiArrayNML & tempDst = static_cast<Int16MultiArrayNML&>(dst);
                Message<Int16MultiArray > & tempSrc = static_cast<Message<Int16MultiArray>&>(src);

                if (tempSrc.version() != Int16MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int16MultiArray: " << __FILE__ << " expected: " 
                             << Int16MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int16MultiArray: " << __FILE__ << " expected: " 
                         << Int16MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int32::ID:
            {
                Int32NML & tempDst = static_cast<Int32NML&>(dst);
                Message<Int32 > & tempSrc = static_cast<Message<Int32>&>(src);

                if (tempSrc.version() != Int32::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int32: " << __FILE__ << " expected: " 
                             << Int32::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int32: " << __FILE__ << " expected: " 
                         << Int32::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int32MultiArray::ID:
            {
                Int32MultiArrayNML & tempDst = static_cast<Int32MultiArrayNML&>(dst);
                Message<Int32MultiArray > & tempSrc = static_cast<Message<Int32MultiArray>&>(src);

                if (tempSrc.version() != Int32MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int32MultiArray: " << __FILE__ << " expected: " 
                             << Int32MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int32MultiArray: " << __FILE__ << " expected: " 
                         << Int32MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int64::ID:
            {
                Int64NML & tempDst = static_cast<Int64NML&>(dst);
                Message<Int64 > & tempSrc = static_cast<Message<Int64>&>(src);

                if (tempSrc.version() != Int64::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int64: " << __FILE__ << " expected: " 
                             << Int64::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int64: " << __FILE__ << " expected: " 
                         << Int64::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int64MultiArray::ID:
            {
                Int64MultiArrayNML & tempDst = static_cast<Int64MultiArrayNML&>(dst);
                Message<Int64MultiArray > & tempSrc = static_cast<Message<Int64MultiArray>&>(src);

                if (tempSrc.version() != Int64MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int64MultiArray: " << __FILE__ << " expected: " 
                             << Int64MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int64MultiArray: " << __FILE__ << " expected: " 
                         << Int64MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int8::ID:
            {
                Int8NML & tempDst = static_cast<Int8NML&>(dst);
                Message<Int8 > & tempSrc = static_cast<Message<Int8>&>(src);

                if (tempSrc.version() != Int8::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int8: " << __FILE__ << " expected: " 
                             << Int8::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int8: " << __FILE__ << " expected: " 
                         << Int8::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Int8MultiArray::ID:
            {
                Int8MultiArrayNML & tempDst = static_cast<Int8MultiArrayNML&>(dst);
                Message<Int8MultiArray > & tempSrc = static_cast<Message<Int8MultiArray>&>(src);

                if (tempSrc.version() != Int8MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Int8MultiArray: " << __FILE__ << " expected: " 
                             << Int8MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Int8MultiArray: " << __FILE__ << " expected: " 
                         << Int8MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MultiArrayDimension::ID:
            {
                MultiArrayDimensionNML & tempDst = static_cast<MultiArrayDimensionNML&>(dst);
                Message<MultiArrayDimension > & tempSrc = static_cast<Message<MultiArrayDimension>&>(src);

                if (tempSrc.version() != MultiArrayDimension::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MultiArrayDimension: " << __FILE__ << " expected: " 
                             << MultiArrayDimension::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MultiArrayDimension: " << __FILE__ << " expected: " 
                         << MultiArrayDimension::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case MultiArrayLayout::ID:
            {
                MultiArrayLayoutNML & tempDst = static_cast<MultiArrayLayoutNML&>(dst);
                Message<MultiArrayLayout > & tempSrc = static_cast<Message<MultiArrayLayout>&>(src);

                if (tempSrc.version() != MultiArrayLayout::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of MultiArrayLayout: " << __FILE__ << " expected: " 
                             << MultiArrayLayout::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of MultiArrayLayout: " << __FILE__ << " expected: " 
                         << MultiArrayLayout::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case String::ID:
            {
                StringNML & tempDst = static_cast<StringNML&>(dst);
                Message<String > & tempSrc = static_cast<Message<String>&>(src);

                if (tempSrc.version() != String::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of String: " << __FILE__ << " expected: " 
                             << String::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of String: " << __FILE__ << " expected: " 
                         << String::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case Time::ID:
            {
                TimeNML & tempDst = static_cast<TimeNML&>(dst);
                Message<Time > & tempSrc = static_cast<Message<Time>&>(src);

                if (tempSrc.version() != Time::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of Time: " << __FILE__ << " expected: " 
                             << Time::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of Time: " << __FILE__ << " expected: " 
                         << Time::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt16::ID:
            {
                UInt16NML & tempDst = static_cast<UInt16NML&>(dst);
                Message<UInt16 > & tempSrc = static_cast<Message<UInt16>&>(src);

                if (tempSrc.version() != UInt16::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt16: " << __FILE__ << " expected: " 
                             << UInt16::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt16: " << __FILE__ << " expected: " 
                         << UInt16::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt16MultiArray::ID:
            {
                UInt16MultiArrayNML & tempDst = static_cast<UInt16MultiArrayNML&>(dst);
                Message<UInt16MultiArray > & tempSrc = static_cast<Message<UInt16MultiArray>&>(src);

                if (tempSrc.version() != UInt16MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt16MultiArray: " << __FILE__ << " expected: " 
                             << UInt16MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt16MultiArray: " << __FILE__ << " expected: " 
                         << UInt16MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt32::ID:
            {
                UInt32NML & tempDst = static_cast<UInt32NML&>(dst);
                Message<UInt32 > & tempSrc = static_cast<Message<UInt32>&>(src);

                if (tempSrc.version() != UInt32::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt32: " << __FILE__ << " expected: " 
                             << UInt32::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt32: " << __FILE__ << " expected: " 
                         << UInt32::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt32MultiArray::ID:
            {
                UInt32MultiArrayNML & tempDst = static_cast<UInt32MultiArrayNML&>(dst);
                Message<UInt32MultiArray > & tempSrc = static_cast<Message<UInt32MultiArray>&>(src);

                if (tempSrc.version() != UInt32MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt32MultiArray: " << __FILE__ << " expected: " 
                             << UInt32MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt32MultiArray: " << __FILE__ << " expected: " 
                         << UInt32MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt64::ID:
            {
                UInt64NML & tempDst = static_cast<UInt64NML&>(dst);
                Message<UInt64 > & tempSrc = static_cast<Message<UInt64>&>(src);

                if (tempSrc.version() != UInt64::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt64: " << __FILE__ << " expected: " 
                             << UInt64::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt64: " << __FILE__ << " expected: " 
                         << UInt64::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt64MultiArray::ID:
            {
                UInt64MultiArrayNML & tempDst = static_cast<UInt64MultiArrayNML&>(dst);
                Message<UInt64MultiArray > & tempSrc = static_cast<Message<UInt64MultiArray>&>(src);

                if (tempSrc.version() != UInt64MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt64MultiArray: " << __FILE__ << " expected: " 
                             << UInt64MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt64MultiArray: " << __FILE__ << " expected: " 
                         << UInt64MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt8::ID:
            {
                UInt8NML & tempDst = static_cast<UInt8NML&>(dst);
                Message<UInt8 > & tempSrc = static_cast<Message<UInt8>&>(src);

                if (tempSrc.version() != UInt8::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt8: " << __FILE__ << " expected: " 
                             << UInt8::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt8: " << __FILE__ << " expected: " 
                         << UInt8::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            case UInt8MultiArray::ID:
            {
                UInt8MultiArrayNML & tempDst = static_cast<UInt8MultiArrayNML&>(dst);
                Message<UInt8MultiArray > & tempSrc = static_cast<Message<UInt8MultiArray>&>(src);

                if (tempSrc.version() != UInt8MultiArray::DATA_VERSION)
                {
                    LOG_CRIT(__FUNCTION__ << " version mismatch on write of UInt8MultiArray: " << __FILE__ << " expected: " 
                             << UInt8MultiArray::DATA_VERSION << " got: " << tempSrc.version());
                    cout << __FUNCTION__ << " version mismatch on write of UInt8MultiArray: " << __FILE__ << " expected: " 
                         << UInt8MultiArray::DATA_VERSION << " got: " << tempSrc.version() << endl;
                    retval = rframe::Error::MSG_VERSION;
                }
                else
                {

                    // set version
                    tempDst.nmlVersion = tempSrc.version();
                    // set timestamp
                    tempDst.nmlTimestamp = tempSrc.timestamp();
                    // set module id
                    tempDst.nmlModuleId = tempSrc.moduleId();

                    tempDst.nmlPayload = tempSrc.payload();   
                }
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int std_msgs_gencppNMLMessageFactory::fromTransport(NMLmsg & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.type)
        { 
            case RosTime::ID:
            {
                RosTimeNML & tempSrc = static_cast<RosTimeNML&>(src);
                Message<RosTime > & tempDst = static_cast<Message<RosTime>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (RosTime::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case RosDuration::ID:
            {
                RosDurationNML & tempSrc = static_cast<RosDurationNML&>(src);
                Message<RosDuration > & tempDst = static_cast<Message<RosDuration>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (RosDuration::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case HeaderTest::ID:
            {
                HeaderTestNML & tempSrc = static_cast<HeaderTestNML&>(src);
                Message<HeaderTest > & tempDst = static_cast<Message<HeaderTest>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (HeaderTest::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Bool::ID:
            {
                BoolNML & tempSrc = static_cast<BoolNML&>(src);
                Message<Bool > & tempDst = static_cast<Message<Bool>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Bool::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Byte::ID:
            {
                ByteNML & tempSrc = static_cast<ByteNML&>(src);
                Message<Byte > & tempDst = static_cast<Message<Byte>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Byte::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ByteMultiArray::ID:
            {
                ByteMultiArrayNML & tempSrc = static_cast<ByteMultiArrayNML&>(src);
                Message<ByteMultiArray > & tempDst = static_cast<Message<ByteMultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ByteMultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Char::ID:
            {
                CharNML & tempSrc = static_cast<CharNML&>(src);
                Message<Char > & tempDst = static_cast<Message<Char>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Char::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case ColorRGBA::ID:
            {
                ColorRGBANML & tempSrc = static_cast<ColorRGBANML&>(src);
                Message<ColorRGBA > & tempDst = static_cast<Message<ColorRGBA>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (ColorRGBA::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Duration::ID:
            {
                DurationNML & tempSrc = static_cast<DurationNML&>(src);
                Message<Duration > & tempDst = static_cast<Message<Duration>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Duration::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Empty::ID:
            {
                EmptyNML & tempSrc = static_cast<EmptyNML&>(src);
                Message<Empty > & tempDst = static_cast<Message<Empty>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Empty::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Float32::ID:
            {
                Float32NML & tempSrc = static_cast<Float32NML&>(src);
                Message<Float32 > & tempDst = static_cast<Message<Float32>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Float32::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Float32MultiArray::ID:
            {
                Float32MultiArrayNML & tempSrc = static_cast<Float32MultiArrayNML&>(src);
                Message<Float32MultiArray > & tempDst = static_cast<Message<Float32MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Float32MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Float64::ID:
            {
                Float64NML & tempSrc = static_cast<Float64NML&>(src);
                Message<Float64 > & tempDst = static_cast<Message<Float64>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Float64::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Float64MultiArray::ID:
            {
                Float64MultiArrayNML & tempSrc = static_cast<Float64MultiArrayNML&>(src);
                Message<Float64MultiArray > & tempDst = static_cast<Message<Float64MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Float64MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Header::ID:
            {
                HeaderNML & tempSrc = static_cast<HeaderNML&>(src);
                Message<Header > & tempDst = static_cast<Message<Header>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Header::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int16::ID:
            {
                Int16NML & tempSrc = static_cast<Int16NML&>(src);
                Message<Int16 > & tempDst = static_cast<Message<Int16>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int16::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int16MultiArray::ID:
            {
                Int16MultiArrayNML & tempSrc = static_cast<Int16MultiArrayNML&>(src);
                Message<Int16MultiArray > & tempDst = static_cast<Message<Int16MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int16MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int32::ID:
            {
                Int32NML & tempSrc = static_cast<Int32NML&>(src);
                Message<Int32 > & tempDst = static_cast<Message<Int32>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int32::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int32MultiArray::ID:
            {
                Int32MultiArrayNML & tempSrc = static_cast<Int32MultiArrayNML&>(src);
                Message<Int32MultiArray > & tempDst = static_cast<Message<Int32MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int32MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int64::ID:
            {
                Int64NML & tempSrc = static_cast<Int64NML&>(src);
                Message<Int64 > & tempDst = static_cast<Message<Int64>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int64::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int64MultiArray::ID:
            {
                Int64MultiArrayNML & tempSrc = static_cast<Int64MultiArrayNML&>(src);
                Message<Int64MultiArray > & tempDst = static_cast<Message<Int64MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int64MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int8::ID:
            {
                Int8NML & tempSrc = static_cast<Int8NML&>(src);
                Message<Int8 > & tempDst = static_cast<Message<Int8>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int8::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Int8MultiArray::ID:
            {
                Int8MultiArrayNML & tempSrc = static_cast<Int8MultiArrayNML&>(src);
                Message<Int8MultiArray > & tempDst = static_cast<Message<Int8MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Int8MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MultiArrayDimension::ID:
            {
                MultiArrayDimensionNML & tempSrc = static_cast<MultiArrayDimensionNML&>(src);
                Message<MultiArrayDimension > & tempDst = static_cast<Message<MultiArrayDimension>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MultiArrayDimension::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case MultiArrayLayout::ID:
            {
                MultiArrayLayoutNML & tempSrc = static_cast<MultiArrayLayoutNML&>(src);
                Message<MultiArrayLayout > & tempDst = static_cast<Message<MultiArrayLayout>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (MultiArrayLayout::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case String::ID:
            {
                StringNML & tempSrc = static_cast<StringNML&>(src);
                Message<String > & tempDst = static_cast<Message<String>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (String::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case Time::ID:
            {
                TimeNML & tempSrc = static_cast<TimeNML&>(src);
                Message<Time > & tempDst = static_cast<Message<Time>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (Time::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt16::ID:
            {
                UInt16NML & tempSrc = static_cast<UInt16NML&>(src);
                Message<UInt16 > & tempDst = static_cast<Message<UInt16>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt16::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt16MultiArray::ID:
            {
                UInt16MultiArrayNML & tempSrc = static_cast<UInt16MultiArrayNML&>(src);
                Message<UInt16MultiArray > & tempDst = static_cast<Message<UInt16MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt16MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt32::ID:
            {
                UInt32NML & tempSrc = static_cast<UInt32NML&>(src);
                Message<UInt32 > & tempDst = static_cast<Message<UInt32>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt32::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt32MultiArray::ID:
            {
                UInt32MultiArrayNML & tempSrc = static_cast<UInt32MultiArrayNML&>(src);
                Message<UInt32MultiArray > & tempDst = static_cast<Message<UInt32MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt32MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt64::ID:
            {
                UInt64NML & tempSrc = static_cast<UInt64NML&>(src);
                Message<UInt64 > & tempDst = static_cast<Message<UInt64>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt64::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt64MultiArray::ID:
            {
                UInt64MultiArrayNML & tempSrc = static_cast<UInt64MultiArrayNML&>(src);
                Message<UInt64MultiArray > & tempDst = static_cast<Message<UInt64MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt64MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt8::ID:
            {
                UInt8NML & tempSrc = static_cast<UInt8NML&>(src);
                Message<UInt8 > & tempDst = static_cast<Message<UInt8>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt8::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            case UInt8MultiArray::ID:
            {
                UInt8MultiArrayNML & tempSrc = static_cast<UInt8MultiArrayNML&>(src);
                Message<UInt8MultiArray > & tempDst = static_cast<Message<UInt8MultiArray>&>(dst);

                // check data version BEFORE tryinng to unpack
                if (UInt8MultiArray::DATA_VERSION != tempSrc.nmlVersion)
                {
                    retval = rframe::Error::MSG_VERSION;
                    break; // skip unpacking of payload
                }

                tempDst.moduleId(tempSrc.nmlModuleId);
                tempDst.timestamp(tempSrc.nmlTimestamp);

                tempDst.payload(tempSrc.nmlPayload);
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int std_msgs_gencppNMLMessageFactory::constructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    switch (id)
    { 
        case RosTime::ID:
        {
            // only need to construct if data type is not flat
            if (RosTime::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing RosTime at %p\n",buffer);
                RosTimeNML * p = static_cast<RosTimeNML*>(buffer);
                // construct the type at pointer p
                new (p) RosTimeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing RosTime at %p,, is flat\n",buffer);
            }
            break;
        } 
        case RosDuration::ID:
        {
            // only need to construct if data type is not flat
            if (RosDuration::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing RosDuration at %p\n",buffer);
                RosDurationNML * p = static_cast<RosDurationNML*>(buffer);
                // construct the type at pointer p
                new (p) RosDurationNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing RosDuration at %p,, is flat\n",buffer);
            }
            break;
        } 
        case HeaderTest::ID:
        {
            // only need to construct if data type is not flat
            if (HeaderTest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing HeaderTest at %p\n",buffer);
                HeaderTestNML * p = static_cast<HeaderTestNML*>(buffer);
                // construct the type at pointer p
                new (p) HeaderTestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing HeaderTest at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Bool::ID:
        {
            // only need to construct if data type is not flat
            if (Bool::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Bool at %p\n",buffer);
                BoolNML * p = static_cast<BoolNML*>(buffer);
                // construct the type at pointer p
                new (p) BoolNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Bool at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Byte::ID:
        {
            // only need to construct if data type is not flat
            if (Byte::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Byte at %p\n",buffer);
                ByteNML * p = static_cast<ByteNML*>(buffer);
                // construct the type at pointer p
                new (p) ByteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Byte at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ByteMultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (ByteMultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ByteMultiArray at %p\n",buffer);
                ByteMultiArrayNML * p = static_cast<ByteMultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) ByteMultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ByteMultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Char::ID:
        {
            // only need to construct if data type is not flat
            if (Char::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Char at %p\n",buffer);
                CharNML * p = static_cast<CharNML*>(buffer);
                // construct the type at pointer p
                new (p) CharNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Char at %p,, is flat\n",buffer);
            }
            break;
        } 
        case ColorRGBA::ID:
        {
            // only need to construct if data type is not flat
            if (ColorRGBA::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing ColorRGBA at %p\n",buffer);
                ColorRGBANML * p = static_cast<ColorRGBANML*>(buffer);
                // construct the type at pointer p
                new (p) ColorRGBANML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing ColorRGBA at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Duration::ID:
        {
            // only need to construct if data type is not flat
            if (Duration::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Duration at %p\n",buffer);
                DurationNML * p = static_cast<DurationNML*>(buffer);
                // construct the type at pointer p
                new (p) DurationNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Duration at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Empty::ID:
        {
            // only need to construct if data type is not flat
            if (Empty::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Empty at %p\n",buffer);
                EmptyNML * p = static_cast<EmptyNML*>(buffer);
                // construct the type at pointer p
                new (p) EmptyNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Empty at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Float32::ID:
        {
            // only need to construct if data type is not flat
            if (Float32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Float32 at %p\n",buffer);
                Float32NML * p = static_cast<Float32NML*>(buffer);
                // construct the type at pointer p
                new (p) Float32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Float32 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Float32MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (Float32MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Float32MultiArray at %p\n",buffer);
                Float32MultiArrayNML * p = static_cast<Float32MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) Float32MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Float32MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Float64::ID:
        {
            // only need to construct if data type is not flat
            if (Float64::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Float64 at %p\n",buffer);
                Float64NML * p = static_cast<Float64NML*>(buffer);
                // construct the type at pointer p
                new (p) Float64NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Float64 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Float64MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (Float64MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Float64MultiArray at %p\n",buffer);
                Float64MultiArrayNML * p = static_cast<Float64MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) Float64MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Float64MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Header::ID:
        {
            // only need to construct if data type is not flat
            if (Header::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Header at %p\n",buffer);
                HeaderNML * p = static_cast<HeaderNML*>(buffer);
                // construct the type at pointer p
                new (p) HeaderNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Header at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int16::ID:
        {
            // only need to construct if data type is not flat
            if (Int16::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int16 at %p\n",buffer);
                Int16NML * p = static_cast<Int16NML*>(buffer);
                // construct the type at pointer p
                new (p) Int16NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int16 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int16MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (Int16MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int16MultiArray at %p\n",buffer);
                Int16MultiArrayNML * p = static_cast<Int16MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) Int16MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int16MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int32::ID:
        {
            // only need to construct if data type is not flat
            if (Int32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int32 at %p\n",buffer);
                Int32NML * p = static_cast<Int32NML*>(buffer);
                // construct the type at pointer p
                new (p) Int32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int32 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int32MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (Int32MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int32MultiArray at %p\n",buffer);
                Int32MultiArrayNML * p = static_cast<Int32MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) Int32MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int32MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int64::ID:
        {
            // only need to construct if data type is not flat
            if (Int64::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int64 at %p\n",buffer);
                Int64NML * p = static_cast<Int64NML*>(buffer);
                // construct the type at pointer p
                new (p) Int64NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int64 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int64MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (Int64MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int64MultiArray at %p\n",buffer);
                Int64MultiArrayNML * p = static_cast<Int64MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) Int64MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int64MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int8::ID:
        {
            // only need to construct if data type is not flat
            if (Int8::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int8 at %p\n",buffer);
                Int8NML * p = static_cast<Int8NML*>(buffer);
                // construct the type at pointer p
                new (p) Int8NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int8 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Int8MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (Int8MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Int8MultiArray at %p\n",buffer);
                Int8MultiArrayNML * p = static_cast<Int8MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) Int8MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Int8MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MultiArrayDimension::ID:
        {
            // only need to construct if data type is not flat
            if (MultiArrayDimension::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MultiArrayDimension at %p\n",buffer);
                MultiArrayDimensionNML * p = static_cast<MultiArrayDimensionNML*>(buffer);
                // construct the type at pointer p
                new (p) MultiArrayDimensionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MultiArrayDimension at %p,, is flat\n",buffer);
            }
            break;
        } 
        case MultiArrayLayout::ID:
        {
            // only need to construct if data type is not flat
            if (MultiArrayLayout::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing MultiArrayLayout at %p\n",buffer);
                MultiArrayLayoutNML * p = static_cast<MultiArrayLayoutNML*>(buffer);
                // construct the type at pointer p
                new (p) MultiArrayLayoutNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing MultiArrayLayout at %p,, is flat\n",buffer);
            }
            break;
        } 
        case String::ID:
        {
            // only need to construct if data type is not flat
            if (String::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing String at %p\n",buffer);
                StringNML * p = static_cast<StringNML*>(buffer);
                // construct the type at pointer p
                new (p) StringNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing String at %p,, is flat\n",buffer);
            }
            break;
        } 
        case Time::ID:
        {
            // only need to construct if data type is not flat
            if (Time::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing Time at %p\n",buffer);
                TimeNML * p = static_cast<TimeNML*>(buffer);
                // construct the type at pointer p
                new (p) TimeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing Time at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt16::ID:
        {
            // only need to construct if data type is not flat
            if (UInt16::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt16 at %p\n",buffer);
                UInt16NML * p = static_cast<UInt16NML*>(buffer);
                // construct the type at pointer p
                new (p) UInt16NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt16 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt16MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (UInt16MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt16MultiArray at %p\n",buffer);
                UInt16MultiArrayNML * p = static_cast<UInt16MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) UInt16MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt16MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt32::ID:
        {
            // only need to construct if data type is not flat
            if (UInt32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt32 at %p\n",buffer);
                UInt32NML * p = static_cast<UInt32NML*>(buffer);
                // construct the type at pointer p
                new (p) UInt32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt32 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt32MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (UInt32MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt32MultiArray at %p\n",buffer);
                UInt32MultiArrayNML * p = static_cast<UInt32MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) UInt32MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt32MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt64::ID:
        {
            // only need to construct if data type is not flat
            if (UInt64::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt64 at %p\n",buffer);
                UInt64NML * p = static_cast<UInt64NML*>(buffer);
                // construct the type at pointer p
                new (p) UInt64NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt64 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt64MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (UInt64MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt64MultiArray at %p\n",buffer);
                UInt64MultiArrayNML * p = static_cast<UInt64MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) UInt64MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt64MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt8::ID:
        {
            // only need to construct if data type is not flat
            if (UInt8::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt8 at %p\n",buffer);
                UInt8NML * p = static_cast<UInt8NML*>(buffer);
                // construct the type at pointer p
                new (p) UInt8NML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt8 at %p,, is flat\n",buffer);
            }
            break;
        } 
        case UInt8MultiArray::ID:
        {
            // only need to construct if data type is not flat
            if (UInt8MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("constructing UInt8MultiArray at %p\n",buffer);
                UInt8MultiArrayNML * p = static_cast<UInt8MultiArrayNML*>(buffer);
                // construct the type at pointer p
                new (p) UInt8MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping constructing UInt8MultiArray at %p,, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

int std_msgs_gencppNMLMessageFactory::destructBuffer(rframe::ID_TYPE id, void * buffer)
{
    int retval = Error::SUCCESS;

    if (buffer == nullptr) return retval;

    switch (id)
    { 
        case RosTime::ID:
        {
            // only need to destruct if data type is not flat
            if (RosTime::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing RosTime at %p\n",buffer);
                RosTimeNML * p = static_cast<RosTimeNML*>(buffer);
                p->~RosTimeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction RosTime at %p, is flat\n",buffer);
            }
            break;
        } 
        case RosDuration::ID:
        {
            // only need to destruct if data type is not flat
            if (RosDuration::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing RosDuration at %p\n",buffer);
                RosDurationNML * p = static_cast<RosDurationNML*>(buffer);
                p->~RosDurationNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction RosDuration at %p, is flat\n",buffer);
            }
            break;
        } 
        case HeaderTest::ID:
        {
            // only need to destruct if data type is not flat
            if (HeaderTest::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing HeaderTest at %p\n",buffer);
                HeaderTestNML * p = static_cast<HeaderTestNML*>(buffer);
                p->~HeaderTestNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction HeaderTest at %p, is flat\n",buffer);
            }
            break;
        } 
        case Bool::ID:
        {
            // only need to destruct if data type is not flat
            if (Bool::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Bool at %p\n",buffer);
                BoolNML * p = static_cast<BoolNML*>(buffer);
                p->~BoolNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Bool at %p, is flat\n",buffer);
            }
            break;
        } 
        case Byte::ID:
        {
            // only need to destruct if data type is not flat
            if (Byte::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Byte at %p\n",buffer);
                ByteNML * p = static_cast<ByteNML*>(buffer);
                p->~ByteNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Byte at %p, is flat\n",buffer);
            }
            break;
        } 
        case ByteMultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (ByteMultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ByteMultiArray at %p\n",buffer);
                ByteMultiArrayNML * p = static_cast<ByteMultiArrayNML*>(buffer);
                p->~ByteMultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ByteMultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case Char::ID:
        {
            // only need to destruct if data type is not flat
            if (Char::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Char at %p\n",buffer);
                CharNML * p = static_cast<CharNML*>(buffer);
                p->~CharNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Char at %p, is flat\n",buffer);
            }
            break;
        } 
        case ColorRGBA::ID:
        {
            // only need to destruct if data type is not flat
            if (ColorRGBA::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing ColorRGBA at %p\n",buffer);
                ColorRGBANML * p = static_cast<ColorRGBANML*>(buffer);
                p->~ColorRGBANML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction ColorRGBA at %p, is flat\n",buffer);
            }
            break;
        } 
        case Duration::ID:
        {
            // only need to destruct if data type is not flat
            if (Duration::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Duration at %p\n",buffer);
                DurationNML * p = static_cast<DurationNML*>(buffer);
                p->~DurationNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Duration at %p, is flat\n",buffer);
            }
            break;
        } 
        case Empty::ID:
        {
            // only need to destruct if data type is not flat
            if (Empty::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Empty at %p\n",buffer);
                EmptyNML * p = static_cast<EmptyNML*>(buffer);
                p->~EmptyNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Empty at %p, is flat\n",buffer);
            }
            break;
        } 
        case Float32::ID:
        {
            // only need to destruct if data type is not flat
            if (Float32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Float32 at %p\n",buffer);
                Float32NML * p = static_cast<Float32NML*>(buffer);
                p->~Float32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Float32 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Float32MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (Float32MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Float32MultiArray at %p\n",buffer);
                Float32MultiArrayNML * p = static_cast<Float32MultiArrayNML*>(buffer);
                p->~Float32MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Float32MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case Float64::ID:
        {
            // only need to destruct if data type is not flat
            if (Float64::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Float64 at %p\n",buffer);
                Float64NML * p = static_cast<Float64NML*>(buffer);
                p->~Float64NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Float64 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Float64MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (Float64MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Float64MultiArray at %p\n",buffer);
                Float64MultiArrayNML * p = static_cast<Float64MultiArrayNML*>(buffer);
                p->~Float64MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Float64MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case Header::ID:
        {
            // only need to destruct if data type is not flat
            if (Header::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Header at %p\n",buffer);
                HeaderNML * p = static_cast<HeaderNML*>(buffer);
                p->~HeaderNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Header at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int16::ID:
        {
            // only need to destruct if data type is not flat
            if (Int16::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int16 at %p\n",buffer);
                Int16NML * p = static_cast<Int16NML*>(buffer);
                p->~Int16NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int16 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int16MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (Int16MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int16MultiArray at %p\n",buffer);
                Int16MultiArrayNML * p = static_cast<Int16MultiArrayNML*>(buffer);
                p->~Int16MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int16MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int32::ID:
        {
            // only need to destruct if data type is not flat
            if (Int32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int32 at %p\n",buffer);
                Int32NML * p = static_cast<Int32NML*>(buffer);
                p->~Int32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int32 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int32MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (Int32MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int32MultiArray at %p\n",buffer);
                Int32MultiArrayNML * p = static_cast<Int32MultiArrayNML*>(buffer);
                p->~Int32MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int32MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int64::ID:
        {
            // only need to destruct if data type is not flat
            if (Int64::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int64 at %p\n",buffer);
                Int64NML * p = static_cast<Int64NML*>(buffer);
                p->~Int64NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int64 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int64MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (Int64MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int64MultiArray at %p\n",buffer);
                Int64MultiArrayNML * p = static_cast<Int64MultiArrayNML*>(buffer);
                p->~Int64MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int64MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int8::ID:
        {
            // only need to destruct if data type is not flat
            if (Int8::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int8 at %p\n",buffer);
                Int8NML * p = static_cast<Int8NML*>(buffer);
                p->~Int8NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int8 at %p, is flat\n",buffer);
            }
            break;
        } 
        case Int8MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (Int8MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Int8MultiArray at %p\n",buffer);
                Int8MultiArrayNML * p = static_cast<Int8MultiArrayNML*>(buffer);
                p->~Int8MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Int8MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case MultiArrayDimension::ID:
        {
            // only need to destruct if data type is not flat
            if (MultiArrayDimension::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MultiArrayDimension at %p\n",buffer);
                MultiArrayDimensionNML * p = static_cast<MultiArrayDimensionNML*>(buffer);
                p->~MultiArrayDimensionNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MultiArrayDimension at %p, is flat\n",buffer);
            }
            break;
        } 
        case MultiArrayLayout::ID:
        {
            // only need to destruct if data type is not flat
            if (MultiArrayLayout::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing MultiArrayLayout at %p\n",buffer);
                MultiArrayLayoutNML * p = static_cast<MultiArrayLayoutNML*>(buffer);
                p->~MultiArrayLayoutNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction MultiArrayLayout at %p, is flat\n",buffer);
            }
            break;
        } 
        case String::ID:
        {
            // only need to destruct if data type is not flat
            if (String::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing String at %p\n",buffer);
                StringNML * p = static_cast<StringNML*>(buffer);
                p->~StringNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction String at %p, is flat\n",buffer);
            }
            break;
        } 
        case Time::ID:
        {
            // only need to destruct if data type is not flat
            if (Time::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing Time at %p\n",buffer);
                TimeNML * p = static_cast<TimeNML*>(buffer);
                p->~TimeNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction Time at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt16::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt16::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt16 at %p\n",buffer);
                UInt16NML * p = static_cast<UInt16NML*>(buffer);
                p->~UInt16NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt16 at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt16MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt16MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt16MultiArray at %p\n",buffer);
                UInt16MultiArrayNML * p = static_cast<UInt16MultiArrayNML*>(buffer);
                p->~UInt16MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt16MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt32::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt32::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt32 at %p\n",buffer);
                UInt32NML * p = static_cast<UInt32NML*>(buffer);
                p->~UInt32NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt32 at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt32MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt32MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt32MultiArray at %p\n",buffer);
                UInt32MultiArrayNML * p = static_cast<UInt32MultiArrayNML*>(buffer);
                p->~UInt32MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt32MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt64::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt64::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt64 at %p\n",buffer);
                UInt64NML * p = static_cast<UInt64NML*>(buffer);
                p->~UInt64NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt64 at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt64MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt64MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt64MultiArray at %p\n",buffer);
                UInt64MultiArrayNML * p = static_cast<UInt64MultiArrayNML*>(buffer);
                p->~UInt64MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt64MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt8::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt8::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt8 at %p\n",buffer);
                UInt8NML * p = static_cast<UInt8NML*>(buffer);
                p->~UInt8NML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt8 at %p, is flat\n",buffer);
            }
            break;
        } 
        case UInt8MultiArray::ID:
        {
            // only need to destruct if data type is not flat
            if (UInt8MultiArray::dataTypeFlat() == false)
            {
                FLOG_DEBUG3("destructing UInt8MultiArray at %p\n",buffer);
                UInt8MultiArrayNML * p = static_cast<UInt8MultiArrayNML*>(buffer);
                p->~UInt8MultiArrayNML();
            }
            else
            {
                FLOG_DEBUG3("skipping destruction UInt8MultiArray at %p, is flat\n",buffer);
            }
            break;
        } 
        default:
        {
            retval = Error::NOT_FOUND;
        }
    }

    return retval;
}

void std_msgs::nmlupdate(CMS * cms, RosTime & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate RosTime, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.sec);
        cms->update(inobj.nsec);

    }  
 }

RosTimeNML::RosTimeNML() : NMLmsg((NMLTYPE)RosTime::ID,sizeof(RosTimeNML)), nmlVersion(RosTime::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new RosTime()*/)
{
};

RosTimeNML::~RosTimeNML()
{
};

RosTimeNML & RosTimeNML::operator=(const RosTimeNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

RosTimeNML & RosTimeNML::operator=(const RosTime & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(RosTime);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void RosTimeNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<RosTime&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: RosTimeNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<RosTime> temp(new RosTime());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (RosTime::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: RosTime Message version mismatch, expected " << RosTime::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: RosTime Message version mismatch, expected " << RosTime::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, RosDuration & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate RosDuration, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.sec);
        cms->update(inobj.nsec);

    }  
 }

RosDurationNML::RosDurationNML() : NMLmsg((NMLTYPE)RosDuration::ID,sizeof(RosDurationNML)), nmlVersion(RosDuration::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new RosDuration()*/)
{
};

RosDurationNML::~RosDurationNML()
{
};

RosDurationNML & RosDurationNML::operator=(const RosDurationNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

RosDurationNML & RosDurationNML::operator=(const RosDuration & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(RosDuration);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void RosDurationNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<RosDuration&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: RosDurationNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<RosDuration> temp(new RosDuration());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (RosDuration::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: RosDuration Message version mismatch, expected " << RosDuration::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: RosDuration Message version mismatch, expected " << RosDuration::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, HeaderTest & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate HeaderTest, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.header);
        nmlupdate(cms,inobj.header2);

    }  
 }

HeaderTestNML::HeaderTestNML() : NMLmsg((NMLTYPE)HeaderTest::ID,sizeof(HeaderTestNML)), nmlVersion(HeaderTest::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new HeaderTest()*/)
{
};

HeaderTestNML::~HeaderTestNML()
{
};

HeaderTestNML & HeaderTestNML::operator=(const HeaderTestNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

HeaderTestNML & HeaderTestNML::operator=(const HeaderTest & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(HeaderTest);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void HeaderTestNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<HeaderTest&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: HeaderTestNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<HeaderTest> temp(new HeaderTest());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (HeaderTest::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: HeaderTest Message version mismatch, expected " << HeaderTest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: HeaderTest Message version mismatch, expected " << HeaderTest::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Bool & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Bool, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

BoolNML::BoolNML() : NMLmsg((NMLTYPE)Bool::ID,sizeof(BoolNML)), nmlVersion(Bool::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Bool()*/)
{
};

BoolNML::~BoolNML()
{
};

BoolNML & BoolNML::operator=(const BoolNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

BoolNML & BoolNML::operator=(const Bool & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Bool);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void BoolNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Bool&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: BoolNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Bool> temp(new Bool());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Bool::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Bool Message version mismatch, expected " << Bool::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Bool Message version mismatch, expected " << Bool::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Byte & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Byte, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

ByteNML::ByteNML() : NMLmsg((NMLTYPE)Byte::ID,sizeof(ByteNML)), nmlVersion(Byte::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Byte()*/)
{
};

ByteNML::~ByteNML()
{
};

ByteNML & ByteNML::operator=(const ByteNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ByteNML & ByteNML::operator=(const Byte & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Byte);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ByteNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Byte&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ByteNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Byte> temp(new Byte());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Byte::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Byte Message version mismatch, expected " << Byte::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Byte Message version mismatch, expected " << Byte::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, ByteMultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ByteMultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

ByteMultiArrayNML::ByteMultiArrayNML() : NMLmsg((NMLTYPE)ByteMultiArray::ID,sizeof(ByteMultiArrayNML)), nmlVersion(ByteMultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ByteMultiArray()*/)
{
};

ByteMultiArrayNML::~ByteMultiArrayNML()
{
};

ByteMultiArrayNML & ByteMultiArrayNML::operator=(const ByteMultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ByteMultiArrayNML & ByteMultiArrayNML::operator=(const ByteMultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ByteMultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ByteMultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ByteMultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ByteMultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ByteMultiArray> temp(new ByteMultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ByteMultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ByteMultiArray Message version mismatch, expected " << ByteMultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ByteMultiArray Message version mismatch, expected " << ByteMultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Char & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Char, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

CharNML::CharNML() : NMLmsg((NMLTYPE)Char::ID,sizeof(CharNML)), nmlVersion(Char::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Char()*/)
{
};

CharNML::~CharNML()
{
};

CharNML & CharNML::operator=(const CharNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

CharNML & CharNML::operator=(const Char & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Char);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void CharNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Char&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: CharNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Char> temp(new Char());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Char::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Char Message version mismatch, expected " << Char::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Char Message version mismatch, expected " << Char::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, ColorRGBA & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate ColorRGBA, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.r);
        cms->update(inobj.g);
        cms->update(inobj.b);
        cms->update(inobj.a);

    }  
 }

ColorRGBANML::ColorRGBANML() : NMLmsg((NMLTYPE)ColorRGBA::ID,sizeof(ColorRGBANML)), nmlVersion(ColorRGBA::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new ColorRGBA()*/)
{
};

ColorRGBANML::~ColorRGBANML()
{
};

ColorRGBANML & ColorRGBANML::operator=(const ColorRGBANML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

ColorRGBANML & ColorRGBANML::operator=(const ColorRGBA & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(ColorRGBA);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void ColorRGBANML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<ColorRGBA&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: ColorRGBANML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<ColorRGBA> temp(new ColorRGBA());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (ColorRGBA::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: ColorRGBA Message version mismatch, expected " << ColorRGBA::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: ColorRGBA Message version mismatch, expected " << ColorRGBA::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Duration & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Duration, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.data);

    }  
 }

DurationNML::DurationNML() : NMLmsg((NMLTYPE)Duration::ID,sizeof(DurationNML)), nmlVersion(Duration::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Duration()*/)
{
};

DurationNML::~DurationNML()
{
};

DurationNML & DurationNML::operator=(const DurationNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

DurationNML & DurationNML::operator=(const Duration & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Duration);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void DurationNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Duration&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: DurationNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Duration> temp(new Duration());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Duration::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Duration Message version mismatch, expected " << Duration::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Duration Message version mismatch, expected " << Duration::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Empty & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Empty, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

    }  
 }

EmptyNML::EmptyNML() : NMLmsg((NMLTYPE)Empty::ID,sizeof(EmptyNML)), nmlVersion(Empty::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Empty()*/)
{
};

EmptyNML::~EmptyNML()
{
};

EmptyNML & EmptyNML::operator=(const EmptyNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

EmptyNML & EmptyNML::operator=(const Empty & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Empty);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void EmptyNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Empty&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: EmptyNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Empty> temp(new Empty());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Empty::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Empty Message version mismatch, expected " << Empty::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Empty Message version mismatch, expected " << Empty::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Float32 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Float32, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

Float32NML::Float32NML() : NMLmsg((NMLTYPE)Float32::ID,sizeof(Float32NML)), nmlVersion(Float32::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Float32()*/)
{
};

Float32NML::~Float32NML()
{
};

Float32NML & Float32NML::operator=(const Float32NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Float32NML & Float32NML::operator=(const Float32 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Float32);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Float32NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Float32&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Float32NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Float32> temp(new Float32());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Float32::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Float32 Message version mismatch, expected " << Float32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Float32 Message version mismatch, expected " << Float32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Float32MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Float32MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

Float32MultiArrayNML::Float32MultiArrayNML() : NMLmsg((NMLTYPE)Float32MultiArray::ID,sizeof(Float32MultiArrayNML)), nmlVersion(Float32MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Float32MultiArray()*/)
{
};

Float32MultiArrayNML::~Float32MultiArrayNML()
{
};

Float32MultiArrayNML & Float32MultiArrayNML::operator=(const Float32MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Float32MultiArrayNML & Float32MultiArrayNML::operator=(const Float32MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Float32MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Float32MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Float32MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Float32MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Float32MultiArray> temp(new Float32MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Float32MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Float32MultiArray Message version mismatch, expected " << Float32MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Float32MultiArray Message version mismatch, expected " << Float32MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Float64 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Float64, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

Float64NML::Float64NML() : NMLmsg((NMLTYPE)Float64::ID,sizeof(Float64NML)), nmlVersion(Float64::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Float64()*/)
{
};

Float64NML::~Float64NML()
{
};

Float64NML & Float64NML::operator=(const Float64NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Float64NML & Float64NML::operator=(const Float64 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Float64);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Float64NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Float64&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Float64NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Float64> temp(new Float64());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Float64::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Float64 Message version mismatch, expected " << Float64::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Float64 Message version mismatch, expected " << Float64::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Float64MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Float64MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

Float64MultiArrayNML::Float64MultiArrayNML() : NMLmsg((NMLTYPE)Float64MultiArray::ID,sizeof(Float64MultiArrayNML)), nmlVersion(Float64MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Float64MultiArray()*/)
{
};

Float64MultiArrayNML::~Float64MultiArrayNML()
{
};

Float64MultiArrayNML & Float64MultiArrayNML::operator=(const Float64MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Float64MultiArrayNML & Float64MultiArrayNML::operator=(const Float64MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Float64MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Float64MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Float64MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Float64MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Float64MultiArray> temp(new Float64MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Float64MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Float64MultiArray Message version mismatch, expected " << Float64MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Float64MultiArray Message version mismatch, expected " << Float64MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Header & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Header, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.seq);
        nmlupdate(cms,inobj.stamp);
        nmlupdate(cms,inobj.frame_id);

    }  
 }

HeaderNML::HeaderNML() : NMLmsg((NMLTYPE)Header::ID,sizeof(HeaderNML)), nmlVersion(Header::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Header()*/)
{
};

HeaderNML::~HeaderNML()
{
};

HeaderNML & HeaderNML::operator=(const HeaderNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

HeaderNML & HeaderNML::operator=(const Header & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Header);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void HeaderNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Header&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: HeaderNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Header> temp(new Header());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Header::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Header Message version mismatch, expected " << Header::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Header Message version mismatch, expected " << Header::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int16 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int16, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

Int16NML::Int16NML() : NMLmsg((NMLTYPE)Int16::ID,sizeof(Int16NML)), nmlVersion(Int16::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int16()*/)
{
};

Int16NML::~Int16NML()
{
};

Int16NML & Int16NML::operator=(const Int16NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int16NML & Int16NML::operator=(const Int16 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int16);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int16NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int16&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int16NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int16> temp(new Int16());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int16::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int16 Message version mismatch, expected " << Int16::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int16 Message version mismatch, expected " << Int16::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int16MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int16MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

Int16MultiArrayNML::Int16MultiArrayNML() : NMLmsg((NMLTYPE)Int16MultiArray::ID,sizeof(Int16MultiArrayNML)), nmlVersion(Int16MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int16MultiArray()*/)
{
};

Int16MultiArrayNML::~Int16MultiArrayNML()
{
};

Int16MultiArrayNML & Int16MultiArrayNML::operator=(const Int16MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int16MultiArrayNML & Int16MultiArrayNML::operator=(const Int16MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int16MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int16MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int16MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int16MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int16MultiArray> temp(new Int16MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int16MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int16MultiArray Message version mismatch, expected " << Int16MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int16MultiArray Message version mismatch, expected " << Int16MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int32 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int32, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

Int32NML::Int32NML() : NMLmsg((NMLTYPE)Int32::ID,sizeof(Int32NML)), nmlVersion(Int32::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int32()*/)
{
};

Int32NML::~Int32NML()
{
};

Int32NML & Int32NML::operator=(const Int32NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int32NML & Int32NML::operator=(const Int32 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int32);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int32NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int32&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int32NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int32> temp(new Int32());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int32::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int32 Message version mismatch, expected " << Int32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int32 Message version mismatch, expected " << Int32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int32MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int32MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

Int32MultiArrayNML::Int32MultiArrayNML() : NMLmsg((NMLTYPE)Int32MultiArray::ID,sizeof(Int32MultiArrayNML)), nmlVersion(Int32MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int32MultiArray()*/)
{
};

Int32MultiArrayNML::~Int32MultiArrayNML()
{
};

Int32MultiArrayNML & Int32MultiArrayNML::operator=(const Int32MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int32MultiArrayNML & Int32MultiArrayNML::operator=(const Int32MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int32MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int32MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int32MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int32MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int32MultiArray> temp(new Int32MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int32MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int32MultiArray Message version mismatch, expected " << Int32MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int32MultiArray Message version mismatch, expected " << Int32MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int64 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int64, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

Int64NML::Int64NML() : NMLmsg((NMLTYPE)Int64::ID,sizeof(Int64NML)), nmlVersion(Int64::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int64()*/)
{
};

Int64NML::~Int64NML()
{
};

Int64NML & Int64NML::operator=(const Int64NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int64NML & Int64NML::operator=(const Int64 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int64);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int64NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int64&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int64NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int64> temp(new Int64());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int64::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int64 Message version mismatch, expected " << Int64::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int64 Message version mismatch, expected " << Int64::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int64MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int64MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

Int64MultiArrayNML::Int64MultiArrayNML() : NMLmsg((NMLTYPE)Int64MultiArray::ID,sizeof(Int64MultiArrayNML)), nmlVersion(Int64MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int64MultiArray()*/)
{
};

Int64MultiArrayNML::~Int64MultiArrayNML()
{
};

Int64MultiArrayNML & Int64MultiArrayNML::operator=(const Int64MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int64MultiArrayNML & Int64MultiArrayNML::operator=(const Int64MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int64MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int64MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int64MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int64MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int64MultiArray> temp(new Int64MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int64MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int64MultiArray Message version mismatch, expected " << Int64MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int64MultiArray Message version mismatch, expected " << Int64MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int8 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int8, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

Int8NML::Int8NML() : NMLmsg((NMLTYPE)Int8::ID,sizeof(Int8NML)), nmlVersion(Int8::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int8()*/)
{
};

Int8NML::~Int8NML()
{
};

Int8NML & Int8NML::operator=(const Int8NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int8NML & Int8NML::operator=(const Int8 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int8);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int8NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int8&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int8NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int8> temp(new Int8());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int8::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int8 Message version mismatch, expected " << Int8::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int8 Message version mismatch, expected " << Int8::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Int8MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Int8MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

Int8MultiArrayNML::Int8MultiArrayNML() : NMLmsg((NMLTYPE)Int8MultiArray::ID,sizeof(Int8MultiArrayNML)), nmlVersion(Int8MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Int8MultiArray()*/)
{
};

Int8MultiArrayNML::~Int8MultiArrayNML()
{
};

Int8MultiArrayNML & Int8MultiArrayNML::operator=(const Int8MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

Int8MultiArrayNML & Int8MultiArrayNML::operator=(const Int8MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Int8MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void Int8MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Int8MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: Int8MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Int8MultiArray> temp(new Int8MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Int8MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Int8MultiArray Message version mismatch, expected " << Int8MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Int8MultiArray Message version mismatch, expected " << Int8MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, MultiArrayDimension & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MultiArrayDimension, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.label);
        cms->update(inobj.size);
        cms->update(inobj.stride);

    }  
 }

MultiArrayDimensionNML::MultiArrayDimensionNML() : NMLmsg((NMLTYPE)MultiArrayDimension::ID,sizeof(MultiArrayDimensionNML)), nmlVersion(MultiArrayDimension::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MultiArrayDimension()*/)
{
};

MultiArrayDimensionNML::~MultiArrayDimensionNML()
{
};

MultiArrayDimensionNML & MultiArrayDimensionNML::operator=(const MultiArrayDimensionNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MultiArrayDimensionNML & MultiArrayDimensionNML::operator=(const MultiArrayDimension & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MultiArrayDimension);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MultiArrayDimensionNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MultiArrayDimension&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MultiArrayDimensionNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MultiArrayDimension> temp(new MultiArrayDimension());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MultiArrayDimension::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MultiArrayDimension Message version mismatch, expected " << MultiArrayDimension::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MultiArrayDimension Message version mismatch, expected " << MultiArrayDimension::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, MultiArrayLayout & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate MultiArrayLayout, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.dim);
        cms->update(inobj.data_offset);

    }  
 }

MultiArrayLayoutNML::MultiArrayLayoutNML() : NMLmsg((NMLTYPE)MultiArrayLayout::ID,sizeof(MultiArrayLayoutNML)), nmlVersion(MultiArrayLayout::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new MultiArrayLayout()*/)
{
};

MultiArrayLayoutNML::~MultiArrayLayoutNML()
{
};

MultiArrayLayoutNML & MultiArrayLayoutNML::operator=(const MultiArrayLayoutNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

MultiArrayLayoutNML & MultiArrayLayoutNML::operator=(const MultiArrayLayout & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(MultiArrayLayout);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void MultiArrayLayoutNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<MultiArrayLayout&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: MultiArrayLayoutNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<MultiArrayLayout> temp(new MultiArrayLayout());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (MultiArrayLayout::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: MultiArrayLayout Message version mismatch, expected " << MultiArrayLayout::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: MultiArrayLayout Message version mismatch, expected " << MultiArrayLayout::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, String & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate String, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.data);

    }  
 }

StringNML::StringNML() : NMLmsg((NMLTYPE)String::ID,sizeof(StringNML)), nmlVersion(String::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new String()*/)
{
};

StringNML::~StringNML()
{
};

StringNML & StringNML::operator=(const StringNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

StringNML & StringNML::operator=(const String & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(String);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void StringNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<String&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: StringNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<String> temp(new String());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (String::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: String Message version mismatch, expected " << String::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: String Message version mismatch, expected " << String::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, Time & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate Time, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.data);

    }  
 }

TimeNML::TimeNML() : NMLmsg((NMLTYPE)Time::ID,sizeof(TimeNML)), nmlVersion(Time::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new Time()*/)
{
};

TimeNML::~TimeNML()
{
};

TimeNML & TimeNML::operator=(const TimeNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

TimeNML & TimeNML::operator=(const Time & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(Time);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void TimeNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<Time&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: TimeNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<Time> temp(new Time());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (Time::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: Time Message version mismatch, expected " << Time::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: Time Message version mismatch, expected " << Time::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt16 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt16, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

UInt16NML::UInt16NML() : NMLmsg((NMLTYPE)UInt16::ID,sizeof(UInt16NML)), nmlVersion(UInt16::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt16()*/)
{
};

UInt16NML::~UInt16NML()
{
};

UInt16NML & UInt16NML::operator=(const UInt16NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt16NML & UInt16NML::operator=(const UInt16 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt16);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt16NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt16&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt16NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt16> temp(new UInt16());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt16::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt16 Message version mismatch, expected " << UInt16::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt16 Message version mismatch, expected " << UInt16::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt16MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt16MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

UInt16MultiArrayNML::UInt16MultiArrayNML() : NMLmsg((NMLTYPE)UInt16MultiArray::ID,sizeof(UInt16MultiArrayNML)), nmlVersion(UInt16MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt16MultiArray()*/)
{
};

UInt16MultiArrayNML::~UInt16MultiArrayNML()
{
};

UInt16MultiArrayNML & UInt16MultiArrayNML::operator=(const UInt16MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt16MultiArrayNML & UInt16MultiArrayNML::operator=(const UInt16MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt16MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt16MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt16MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt16MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt16MultiArray> temp(new UInt16MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt16MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt16MultiArray Message version mismatch, expected " << UInt16MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt16MultiArray Message version mismatch, expected " << UInt16MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt32 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt32, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

UInt32NML::UInt32NML() : NMLmsg((NMLTYPE)UInt32::ID,sizeof(UInt32NML)), nmlVersion(UInt32::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt32()*/)
{
};

UInt32NML::~UInt32NML()
{
};

UInt32NML & UInt32NML::operator=(const UInt32NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt32NML & UInt32NML::operator=(const UInt32 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt32);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt32NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt32&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt32NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt32> temp(new UInt32());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt32::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt32 Message version mismatch, expected " << UInt32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt32 Message version mismatch, expected " << UInt32::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt32MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt32MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

UInt32MultiArrayNML::UInt32MultiArrayNML() : NMLmsg((NMLTYPE)UInt32MultiArray::ID,sizeof(UInt32MultiArrayNML)), nmlVersion(UInt32MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt32MultiArray()*/)
{
};

UInt32MultiArrayNML::~UInt32MultiArrayNML()
{
};

UInt32MultiArrayNML & UInt32MultiArrayNML::operator=(const UInt32MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt32MultiArrayNML & UInt32MultiArrayNML::operator=(const UInt32MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt32MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt32MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt32MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt32MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt32MultiArray> temp(new UInt32MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt32MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt32MultiArray Message version mismatch, expected " << UInt32MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt32MultiArray Message version mismatch, expected " << UInt32MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt64 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt64, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

UInt64NML::UInt64NML() : NMLmsg((NMLTYPE)UInt64::ID,sizeof(UInt64NML)), nmlVersion(UInt64::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt64()*/)
{
};

UInt64NML::~UInt64NML()
{
};

UInt64NML & UInt64NML::operator=(const UInt64NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt64NML & UInt64NML::operator=(const UInt64 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt64);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt64NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt64&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt64NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt64> temp(new UInt64());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt64::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt64 Message version mismatch, expected " << UInt64::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt64 Message version mismatch, expected " << UInt64::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt64MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt64MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

UInt64MultiArrayNML::UInt64MultiArrayNML() : NMLmsg((NMLTYPE)UInt64MultiArray::ID,sizeof(UInt64MultiArrayNML)), nmlVersion(UInt64MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt64MultiArray()*/)
{
};

UInt64MultiArrayNML::~UInt64MultiArrayNML()
{
};

UInt64MultiArrayNML & UInt64MultiArrayNML::operator=(const UInt64MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt64MultiArrayNML & UInt64MultiArrayNML::operator=(const UInt64MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt64MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt64MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt64MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt64MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt64MultiArray> temp(new UInt64MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt64MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt64MultiArray Message version mismatch, expected " << UInt64MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt64MultiArray Message version mismatch, expected " << UInt64MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt8 & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt8, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        cms->update(inobj.data);

    }  
 }

UInt8NML::UInt8NML() : NMLmsg((NMLTYPE)UInt8::ID,sizeof(UInt8NML)), nmlVersion(UInt8::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt8()*/)
{
};

UInt8NML::~UInt8NML()
{
};

UInt8NML & UInt8NML::operator=(const UInt8NML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt8NML & UInt8NML::operator=(const UInt8 & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt8);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt8NML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt8&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt8NML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt8> temp(new UInt8());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt8::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt8 Message version mismatch, expected " << UInt8::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt8 Message version mismatch, expected " << UInt8::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

void std_msgs::nmlupdate(CMS * cms, UInt8MultiArray & inobj)
{
    if (cms != NULL)
    {
        //        rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"nmlupdate UInt8MultiArray, old style, cms mode is %d, neutral is %d",cms->mode,cms->neutral_encoding_method);

        nmlupdate(cms,inobj.layout);
        nmlupdate(cms,inobj.data);

    }  
 }

UInt8MultiArrayNML::UInt8MultiArrayNML() : NMLmsg((NMLTYPE)UInt8MultiArray::ID,sizeof(UInt8MultiArrayNML)), nmlVersion(UInt8MultiArray::DATA_VERSION), nmlTimestamp(rframe::timestamp()), nmlModuleId(0), nmlPayload(/*new UInt8MultiArray()*/)
{
};

UInt8MultiArrayNML::~UInt8MultiArrayNML()
{
};

UInt8MultiArrayNML & UInt8MultiArrayNML::operator=(const UInt8MultiArrayNML & inobj)
{
    if (this != &inobj)
    {
        type = inobj.type;
        size = inobj.size;
        nmlPayload = inobj.nmlPayload;

        nmlVersion = inobj.nmlVersion;
        nmlTimestamp = inobj.nmlTimestamp;
        nmlModuleId = inobj.nmlModuleId;

    }

    return *this;
}

UInt8MultiArrayNML & UInt8MultiArrayNML::operator=(const UInt8MultiArray & inobj)
{
    if (&nmlPayload != &inobj)
    {
        nmlPayload = inobj;

        type = (NMLTYPE)(inobj.ID);
        size = sizeof(UInt8MultiArray);

        nmlVersion = inobj.DATA_VERSION;
        // nmlTimestamp & module id  set in constructor

    }

    return *this;
}

void UInt8MultiArrayNML::update(CMS * cms)
{
#if 1  
    cms->update(nmlVersion);
    cms->update(nmlTimestamp);
    cms->update(nmlModuleId);
    nmlupdate(cms,static_cast<UInt8MultiArray&>(nmlPayload));
#else   // use of boost serialization is deprecated

      cout << "ERROR ERROR ERRROR: UInt8MultiArrayNML Using deprecated boost serialization within nml update!" << endl;

#if 0
      left in in case we go back to a shared_ptr<T> for nml payload, need to allocate here if necessary.
      // check to make sure we have a place for the data
      if (nmlPayload.get() == NULL)
      {
          std::shared_ptr<UInt8MultiArray> temp(new UInt8MultiArray());
          nmlPayload.swap(temp);
      }
#endif

      //    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,DBG,"ERROR: std_msgs_gencpp: nml::update called for message %d, which should use boost serialization",(int)type);

    NMLUpdaterHelper updater(cms);

    int count = 0;
    // on encode this next line reserves space, on decode it extracts the data size
    updater.storeDataStart();
    cms->update(count);
    char * buf = updater.encodedData();
    unsigned int len = updater.spaceLeft();

    if (cms->mode == CMS_ENCODE)
    {

        boost::iostreams::basic_array_sink<char> helperSink(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_sink<char> > source(helperSink);

        // boost serialize
        {
            //boost::archive::binary_oarchive oa(source,boost::archive::no_header);
            eos::portable_oarchive oa(source); // portable archives require header, but its only a byte.
            oa << nmlVersion << nmlTimestamp << nmlModuleId << nmlPayload;
        }

        int wroteSize = boost::iostreams::seek(source,0,std::ios_base::cur);

        updater.updateEncoded(wroteSize);

        updater.storeCount(wroteSize);
    }
    else
    {
        boost::iostreams::basic_array_source<char> device(buf,len);
        boost::iostreams::stream<boost::iostreams::basic_array_source<char> > source(device);

        // boost serialize
        {
            //boost::archive::binary_iarchive ia(source,boost::archive::no_header);
            eos::portable_iarchive ia(source);
            ia >> nmlVersion;

            if (UInt8MultiArray::DATA_VERSION != nmlVersion)
            {
                LOG_CRIT(__FUNCTION__ << "ERROR: UInt8MultiArray Message version mismatch, expected " << UInt8MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranted!");
                cout << __FUNCTION__ << "ERROR: UInt8MultiArray Message version mismatch, expected " << UInt8MultiArray::DATA_VERSION << " but got " << nmlVersion << " stopping read, buffer state is not guaranteed!" << endl;

            }
            else
            {
                ia >> nmlTimestamp >> nmlModuleId >> nmlPayload;
            }
        }    

    }

#endif
}

int std_msgs::std_msgs_gencpp_format(NMLTYPE type, void * buffer, CMS* cms)
{
    int retval = 1;
    int retval2 = rframe::Error::SUCCESS;

          //printf("std_msgs_gencpp_format: buffer parameters: type: %d, %p, encode: %d\n",(int)type, buffer,cms->mode);

    switch (type)
    { 
        case 0:
        {
            // do nothing, 0 is passed in on buffer creation
            break;
        }
        case RosTime::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for RosTime, id " << RosTime::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((RosTimeNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case RosDuration::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for RosDuration, id " << RosDuration::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((RosDurationNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case HeaderTest::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for HeaderTest, id " << HeaderTest::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((HeaderTestNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Bool::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Bool, id " << Bool::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((BoolNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Byte::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Byte, id " << Byte::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ByteNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ByteMultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ByteMultiArray, id " << ByteMultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ByteMultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Char::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Char, id " << Char::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((CharNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case ColorRGBA::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for ColorRGBA, id " << ColorRGBA::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((ColorRGBANML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Duration::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Duration, id " << Duration::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((DurationNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Empty::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Empty, id " << Empty::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((EmptyNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Float32::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Float32, id " << Float32::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Float32NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Float32MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Float32MultiArray, id " << Float32MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Float32MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Float64::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Float64, id " << Float64::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Float64NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Float64MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Float64MultiArray, id " << Float64MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Float64MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Header::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Header, id " << Header::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((HeaderNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int16::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int16, id " << Int16::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int16NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int16MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int16MultiArray, id " << Int16MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int16MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int32::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int32, id " << Int32::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int32NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int32MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int32MultiArray, id " << Int32MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int32MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int64::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int64, id " << Int64::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int64NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int64MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int64MultiArray, id " << Int64MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int64MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int8::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int8, id " << Int8::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int8NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Int8MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Int8MultiArray, id " << Int8MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((Int8MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MultiArrayDimension::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MultiArrayDimension, id " << MultiArrayDimension::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MultiArrayDimensionNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case MultiArrayLayout::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for MultiArrayLayout, id " << MultiArrayLayout::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((MultiArrayLayoutNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case String::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for String, id " << String::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((StringNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case Time::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for Time, id " << Time::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((TimeNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt16::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt16, id " << UInt16::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt16NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt16MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt16MultiArray, id " << UInt16MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt16MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt32::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt32, id " << UInt32::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt32NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt32MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt32MultiArray, id " << UInt32MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt32MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt64::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt64, id " << UInt64::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt64NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt64MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt64MultiArray, id " << UInt64MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt64MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt8::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt8, id " << UInt8::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt8NML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        } 
        case UInt8MultiArray::ID:
        {
            int oldPointerCheckDisabled = cms->pointer_check_disabled;
            cms->pointer_check_disabled = 1;

            //  cout << "message is for UInt8MultiArray, id " << UInt8MultiArray::ID << endl;

            if (cms->mode == CMS_DECODE)
            {

                retval2 = NML_std_msgs_gencppfactory->constructBuffer(type,buffer);
                if (retval2 != rframe::Error::SUCCESS)
                {
                    rframe::Log::instance()->logFormatted(DEFAULT_LOG_MODULE_ID,CRIT,"std_msgs_gencpp_format: failed construction: id: %d, error: %d",(int)type,retval2);
                }
            }
            else
            {

            }

            ((UInt8MultiArrayNML*)buffer)->update(cms);

            cms->pointer_check_disabled = oldPointerCheckDisabled;

            break;
        }                   
        default:
        {

            retval = 0;
            break;
        }
    }

          //   printf("format done\n");
    return retval;
}

