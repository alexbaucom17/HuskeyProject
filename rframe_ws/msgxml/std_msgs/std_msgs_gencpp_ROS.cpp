// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-26 15:57:08 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "std_msgs_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace std_msgs;

rframe::ROSMessageFactory * ROS_std_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_std_msgs_gencppfactory = new std_msgs_gencppROSMessageFactory();

        return ROS_std_msgs_gencppfactory;
    };
}

rframe::ROSMessageFactory * std_msgs::allocate_std_msgs_gencpp()
{
    ROS_std_msgs_gencppfactory = new std_msgs_gencppROSMessageFactory();
    return ROS_std_msgs_gencppfactory;
};

std_msgs_gencppROSMessageFactory::std_msgs_gencppROSMessageFactory()
{
    name("std_msgs_gencpp");
    // use constructor to register data types
    std_msgs::registerLibrary();
}

std_msgs_gencppROSMessageFactory::~std_msgs_gencppROSMessageFactory()
{
}

int std_msgs_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void std_msgs_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(RosTime::ID);
    info.name(RosTime::DATA_TYPE_FULL_NAME);
    info.hashKey(RosTime::DATA_VERSION);
    info.md5Key(RosTime::VERSION_MD5);
    info.xmlSource(RosTime::XML_SOURCE);
    info.flat(RosTime::dataTypeFlat());
    ids.push_back(info);

    info.id(RosDuration::ID);
    info.name(RosDuration::DATA_TYPE_FULL_NAME);
    info.hashKey(RosDuration::DATA_VERSION);
    info.md5Key(RosDuration::VERSION_MD5);
    info.xmlSource(RosDuration::XML_SOURCE);
    info.flat(RosDuration::dataTypeFlat());
    ids.push_back(info);

    info.id(HeaderTest::ID);
    info.name(HeaderTest::DATA_TYPE_FULL_NAME);
    info.hashKey(HeaderTest::DATA_VERSION);
    info.md5Key(HeaderTest::VERSION_MD5);
    info.xmlSource(HeaderTest::XML_SOURCE);
    info.flat(HeaderTest::dataTypeFlat());
    ids.push_back(info);

    info.id(Bool::ID);
    info.name(Bool::DATA_TYPE_FULL_NAME);
    info.hashKey(Bool::DATA_VERSION);
    info.md5Key(Bool::VERSION_MD5);
    info.xmlSource(Bool::XML_SOURCE);
    info.flat(Bool::dataTypeFlat());
    ids.push_back(info);

    info.id(Byte::ID);
    info.name(Byte::DATA_TYPE_FULL_NAME);
    info.hashKey(Byte::DATA_VERSION);
    info.md5Key(Byte::VERSION_MD5);
    info.xmlSource(Byte::XML_SOURCE);
    info.flat(Byte::dataTypeFlat());
    ids.push_back(info);

    info.id(ByteMultiArray::ID);
    info.name(ByteMultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(ByteMultiArray::DATA_VERSION);
    info.md5Key(ByteMultiArray::VERSION_MD5);
    info.xmlSource(ByteMultiArray::XML_SOURCE);
    info.flat(ByteMultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Char::ID);
    info.name(Char::DATA_TYPE_FULL_NAME);
    info.hashKey(Char::DATA_VERSION);
    info.md5Key(Char::VERSION_MD5);
    info.xmlSource(Char::XML_SOURCE);
    info.flat(Char::dataTypeFlat());
    ids.push_back(info);

    info.id(ColorRGBA::ID);
    info.name(ColorRGBA::DATA_TYPE_FULL_NAME);
    info.hashKey(ColorRGBA::DATA_VERSION);
    info.md5Key(ColorRGBA::VERSION_MD5);
    info.xmlSource(ColorRGBA::XML_SOURCE);
    info.flat(ColorRGBA::dataTypeFlat());
    ids.push_back(info);

    info.id(Duration::ID);
    info.name(Duration::DATA_TYPE_FULL_NAME);
    info.hashKey(Duration::DATA_VERSION);
    info.md5Key(Duration::VERSION_MD5);
    info.xmlSource(Duration::XML_SOURCE);
    info.flat(Duration::dataTypeFlat());
    ids.push_back(info);

    info.id(Empty::ID);
    info.name(Empty::DATA_TYPE_FULL_NAME);
    info.hashKey(Empty::DATA_VERSION);
    info.md5Key(Empty::VERSION_MD5);
    info.xmlSource(Empty::XML_SOURCE);
    info.flat(Empty::dataTypeFlat());
    ids.push_back(info);

    info.id(Float32::ID);
    info.name(Float32::DATA_TYPE_FULL_NAME);
    info.hashKey(Float32::DATA_VERSION);
    info.md5Key(Float32::VERSION_MD5);
    info.xmlSource(Float32::XML_SOURCE);
    info.flat(Float32::dataTypeFlat());
    ids.push_back(info);

    info.id(Float32MultiArray::ID);
    info.name(Float32MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Float32MultiArray::DATA_VERSION);
    info.md5Key(Float32MultiArray::VERSION_MD5);
    info.xmlSource(Float32MultiArray::XML_SOURCE);
    info.flat(Float32MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Float64::ID);
    info.name(Float64::DATA_TYPE_FULL_NAME);
    info.hashKey(Float64::DATA_VERSION);
    info.md5Key(Float64::VERSION_MD5);
    info.xmlSource(Float64::XML_SOURCE);
    info.flat(Float64::dataTypeFlat());
    ids.push_back(info);

    info.id(Float64MultiArray::ID);
    info.name(Float64MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Float64MultiArray::DATA_VERSION);
    info.md5Key(Float64MultiArray::VERSION_MD5);
    info.xmlSource(Float64MultiArray::XML_SOURCE);
    info.flat(Float64MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Header::ID);
    info.name(Header::DATA_TYPE_FULL_NAME);
    info.hashKey(Header::DATA_VERSION);
    info.md5Key(Header::VERSION_MD5);
    info.xmlSource(Header::XML_SOURCE);
    info.flat(Header::dataTypeFlat());
    ids.push_back(info);

    info.id(Int16::ID);
    info.name(Int16::DATA_TYPE_FULL_NAME);
    info.hashKey(Int16::DATA_VERSION);
    info.md5Key(Int16::VERSION_MD5);
    info.xmlSource(Int16::XML_SOURCE);
    info.flat(Int16::dataTypeFlat());
    ids.push_back(info);

    info.id(Int16MultiArray::ID);
    info.name(Int16MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int16MultiArray::DATA_VERSION);
    info.md5Key(Int16MultiArray::VERSION_MD5);
    info.xmlSource(Int16MultiArray::XML_SOURCE);
    info.flat(Int16MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Int32::ID);
    info.name(Int32::DATA_TYPE_FULL_NAME);
    info.hashKey(Int32::DATA_VERSION);
    info.md5Key(Int32::VERSION_MD5);
    info.xmlSource(Int32::XML_SOURCE);
    info.flat(Int32::dataTypeFlat());
    ids.push_back(info);

    info.id(Int32MultiArray::ID);
    info.name(Int32MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int32MultiArray::DATA_VERSION);
    info.md5Key(Int32MultiArray::VERSION_MD5);
    info.xmlSource(Int32MultiArray::XML_SOURCE);
    info.flat(Int32MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Int64::ID);
    info.name(Int64::DATA_TYPE_FULL_NAME);
    info.hashKey(Int64::DATA_VERSION);
    info.md5Key(Int64::VERSION_MD5);
    info.xmlSource(Int64::XML_SOURCE);
    info.flat(Int64::dataTypeFlat());
    ids.push_back(info);

    info.id(Int64MultiArray::ID);
    info.name(Int64MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int64MultiArray::DATA_VERSION);
    info.md5Key(Int64MultiArray::VERSION_MD5);
    info.xmlSource(Int64MultiArray::XML_SOURCE);
    info.flat(Int64MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(Int8::ID);
    info.name(Int8::DATA_TYPE_FULL_NAME);
    info.hashKey(Int8::DATA_VERSION);
    info.md5Key(Int8::VERSION_MD5);
    info.xmlSource(Int8::XML_SOURCE);
    info.flat(Int8::dataTypeFlat());
    ids.push_back(info);

    info.id(Int8MultiArray::ID);
    info.name(Int8MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(Int8MultiArray::DATA_VERSION);
    info.md5Key(Int8MultiArray::VERSION_MD5);
    info.xmlSource(Int8MultiArray::XML_SOURCE);
    info.flat(Int8MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiArrayDimension::ID);
    info.name(MultiArrayDimension::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiArrayDimension::DATA_VERSION);
    info.md5Key(MultiArrayDimension::VERSION_MD5);
    info.xmlSource(MultiArrayDimension::XML_SOURCE);
    info.flat(MultiArrayDimension::dataTypeFlat());
    ids.push_back(info);

    info.id(MultiArrayLayout::ID);
    info.name(MultiArrayLayout::DATA_TYPE_FULL_NAME);
    info.hashKey(MultiArrayLayout::DATA_VERSION);
    info.md5Key(MultiArrayLayout::VERSION_MD5);
    info.xmlSource(MultiArrayLayout::XML_SOURCE);
    info.flat(MultiArrayLayout::dataTypeFlat());
    ids.push_back(info);

    info.id(String::ID);
    info.name(String::DATA_TYPE_FULL_NAME);
    info.hashKey(String::DATA_VERSION);
    info.md5Key(String::VERSION_MD5);
    info.xmlSource(String::XML_SOURCE);
    info.flat(String::dataTypeFlat());
    ids.push_back(info);

    info.id(Time::ID);
    info.name(Time::DATA_TYPE_FULL_NAME);
    info.hashKey(Time::DATA_VERSION);
    info.md5Key(Time::VERSION_MD5);
    info.xmlSource(Time::XML_SOURCE);
    info.flat(Time::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt16::ID);
    info.name(UInt16::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt16::DATA_VERSION);
    info.md5Key(UInt16::VERSION_MD5);
    info.xmlSource(UInt16::XML_SOURCE);
    info.flat(UInt16::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt16MultiArray::ID);
    info.name(UInt16MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt16MultiArray::DATA_VERSION);
    info.md5Key(UInt16MultiArray::VERSION_MD5);
    info.xmlSource(UInt16MultiArray::XML_SOURCE);
    info.flat(UInt16MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt32::ID);
    info.name(UInt32::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt32::DATA_VERSION);
    info.md5Key(UInt32::VERSION_MD5);
    info.xmlSource(UInt32::XML_SOURCE);
    info.flat(UInt32::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt32MultiArray::ID);
    info.name(UInt32MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt32MultiArray::DATA_VERSION);
    info.md5Key(UInt32MultiArray::VERSION_MD5);
    info.xmlSource(UInt32MultiArray::XML_SOURCE);
    info.flat(UInt32MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt64::ID);
    info.name(UInt64::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt64::DATA_VERSION);
    info.md5Key(UInt64::VERSION_MD5);
    info.xmlSource(UInt64::XML_SOURCE);
    info.flat(UInt64::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt64MultiArray::ID);
    info.name(UInt64MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt64MultiArray::DATA_VERSION);
    info.md5Key(UInt64MultiArray::VERSION_MD5);
    info.xmlSource(UInt64MultiArray::XML_SOURCE);
    info.flat(UInt64MultiArray::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt8::ID);
    info.name(UInt8::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt8::DATA_VERSION);
    info.md5Key(UInt8::VERSION_MD5);
    info.xmlSource(UInt8::XML_SOURCE);
    info.flat(UInt8::dataTypeFlat());
    ids.push_back(info);

    info.id(UInt8MultiArray::ID);
    info.name(UInt8MultiArray::DATA_TYPE_FULL_NAME);
    info.hashKey(UInt8MultiArray::DATA_VERSION);
    info.md5Key(UInt8MultiArray::VERSION_MD5);
    info.xmlSource(UInt8MultiArray::XML_SOURCE);
    info.flat(UInt8MultiArray::dataTypeFlat());
    ids.push_back(info);

}

int std_msgs_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case RosTime::ID:
        {
            str = "std_msgs/RosTime";
            break;
        }
        case RosDuration::ID:
        {
            str = "std_msgs/RosDuration";
            break;
        }
        case HeaderTest::ID:
        {
            str = "std_msgs/HeaderTest";
            break;
        }
        case Bool::ID:
        {
            str = "std_msgs/Bool";
            break;
        }
        case Byte::ID:
        {
            str = "std_msgs/Byte";
            break;
        }
        case ByteMultiArray::ID:
        {
            str = "std_msgs/ByteMultiArray";
            break;
        }
        case Char::ID:
        {
            str = "std_msgs/Char";
            break;
        }
        case ColorRGBA::ID:
        {
            str = "std_msgs/ColorRGBA";
            break;
        }
        case Duration::ID:
        {
            str = "std_msgs/Duration";
            break;
        }
        case Empty::ID:
        {
            str = "std_msgs/Empty";
            break;
        }
        case Float32::ID:
        {
            str = "std_msgs/Float32";
            break;
        }
        case Float32MultiArray::ID:
        {
            str = "std_msgs/Float32MultiArray";
            break;
        }
        case Float64::ID:
        {
            str = "std_msgs/Float64";
            break;
        }
        case Float64MultiArray::ID:
        {
            str = "std_msgs/Float64MultiArray";
            break;
        }
        case Header::ID:
        {
            str = "std_msgs/Header";
            break;
        }
        case Int16::ID:
        {
            str = "std_msgs/Int16";
            break;
        }
        case Int16MultiArray::ID:
        {
            str = "std_msgs/Int16MultiArray";
            break;
        }
        case Int32::ID:
        {
            str = "std_msgs/Int32";
            break;
        }
        case Int32MultiArray::ID:
        {
            str = "std_msgs/Int32MultiArray";
            break;
        }
        case Int64::ID:
        {
            str = "std_msgs/Int64";
            break;
        }
        case Int64MultiArray::ID:
        {
            str = "std_msgs/Int64MultiArray";
            break;
        }
        case Int8::ID:
        {
            str = "std_msgs/Int8";
            break;
        }
        case Int8MultiArray::ID:
        {
            str = "std_msgs/Int8MultiArray";
            break;
        }
        case MultiArrayDimension::ID:
        {
            str = "std_msgs/MultiArrayDimension";
            break;
        }
        case MultiArrayLayout::ID:
        {
            str = "std_msgs/MultiArrayLayout";
            break;
        }
        case String::ID:
        {
            str = "std_msgs/String";
            break;
        }
        case Time::ID:
        {
            str = "std_msgs/Time";
            break;
        }
        case UInt16::ID:
        {
            str = "std_msgs/UInt16";
            break;
        }
        case UInt16MultiArray::ID:
        {
            str = "std_msgs/UInt16MultiArray";
            break;
        }
        case UInt32::ID:
        {
            str = "std_msgs/UInt32";
            break;
        }
        case UInt32MultiArray::ID:
        {
            str = "std_msgs/UInt32MultiArray";
            break;
        }
        case UInt64::ID:
        {
            str = "std_msgs/UInt64";
            break;
        }
        case UInt64MultiArray::ID:
        {
            str = "std_msgs/UInt64MultiArray";
            break;
        }
        case UInt8::ID:
        {
            str = "std_msgs/UInt8";
            break;
        }
        case UInt8MultiArray::ID:
        {
            str = "std_msgs/UInt8MultiArray";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case RosTime::ID:
        {
            str = "rframe version of ros::Time";
            break;
        }
        case RosDuration::ID:
        {
            str = "rframe version of ros::Duration";
            break;
        }
        case HeaderTest::ID:
        {
            str = "header serialization test";
            break;
        }
        case Bool::ID:
        {
            str = Bool::XML_SOURCE;
            break;
        }
        case Byte::ID:
        {
            str = "byte data\n";
            break;
        }
        case ByteMultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nbyte[]            data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case Char::ID:
        {
            str = Char::XML_SOURCE;
            break;
        }
        case ColorRGBA::ID:
        {
            str = "float32 r\nfloat32 g\nfloat32 b\nfloat32 a\n";
            break;
        }
        case Duration::ID:
        {
            str = "duration data\n";
            break;
        }
        case Empty::ID:
        {
            str = Empty::XML_SOURCE;
            break;
        }
        case Float32::ID:
        {
            str = Float32::XML_SOURCE;
            break;
        }
        case Float32MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nfloat32[]         data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case Float64::ID:
        {
            str = Float64::XML_SOURCE;
            break;
        }
        case Float64MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nfloat64[]         data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case Header::ID:
        {
            str = "# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n";
            break;
        }
        case Int16::ID:
        {
            str = "int16 data\n";
            break;
        }
        case Int16MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nint16[]           data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case Int32::ID:
        {
            str = Int32::XML_SOURCE;
            break;
        }
        case Int32MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nint32[]           data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case Int64::ID:
        {
            str = Int64::XML_SOURCE;
            break;
        }
        case Int64MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nint64[]           data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case Int8::ID:
        {
            str = "int8 data\n";
            break;
        }
        case Int8MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nint8[]            data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case MultiArrayDimension::ID:
        {
            str = "string label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case MultiArrayLayout::ID:
        {
            str = "# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case String::ID:
        {
            str = "string data\n";
            break;
        }
        case Time::ID:
        {
            str = "time data\n";
            break;
        }
        case UInt16::ID:
        {
            str = "uint16 data\n";
            break;
        }
        case UInt16MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nuint16[]            data        # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case UInt32::ID:
        {
            str = UInt32::XML_SOURCE;
            break;
        }
        case UInt32MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nuint32[]          data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case UInt64::ID:
        {
            str = UInt64::XML_SOURCE;
            break;
        }
        case UInt64MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nuint64[]          data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        case UInt8::ID:
        {
            str = "uint8 data\n";
            break;
        }
        case UInt8MultiArray::ID:
        {
            str = "# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout        # specification of data layout\nuint8[]           data          # array of data\n\n\n================================================================================\nMSG: std_msgs/MultiArrayLayout\n# The multiarray declares a generic multi-dimensional array of a\n# particular data type.  Dimensions are ordered from outer most\n# to inner most.\n\nMultiArrayDimension[] dim # Array of dimension properties\nuint32 data_offset        # padding elements at front of data\n\n# Accessors should ALWAYS be written in terms of dimension stride\n# and specified outer-most dimension first.\n# \n# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]\n#\n# A standard, 3-channel 640x480 image with interleaved color channels\n# would be specified as:\n#\n# dim[0].label  = \"height\"\n# dim[0].size   = 480\n# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)\n# dim[1].label  = \"width\"\n# dim[1].size   = 640\n# dim[1].stride = 3*640 = 1920\n# dim[2].label  = \"channel\"\n# dim[2].size   = 3\n# dim[2].stride = 3\n#\n# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.\n\n================================================================================\nMSG: std_msgs/MultiArrayDimension\nstring label   # label of given dimension\nuint32 size    # size of given dimension (in type units)\n";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case RosTime::ID:
        {
            str = "4771ad66fef816d2e4bead2f45a1cde6";
            break;
        }
        case RosDuration::ID:
        {
            str = "4771ad66fef816d2e4bead2f45a1cde6";
            break;
        }
        case HeaderTest::ID:
        {
            str = "c343c4dd01fd2a6af039d2d6bf86b09a";
            break;
        }
        case Bool::ID:
        {
            str = "8b94c1b53db61fb6aed406028ad6332a";
            break;
        }
        case Byte::ID:
        {
            str = "ad736a2e8818154c487bb80fe42ce43b";
            break;
        }
        case ByteMultiArray::ID:
        {
            str = "70ea476cbcfd65ac2f68f3cda1e891fe";
            break;
        }
        case Char::ID:
        {
            str = "1bf77f25acecdedba0e224b162199717";
            break;
        }
        case ColorRGBA::ID:
        {
            str = "a29a96539573343b1310c73607334b00";
            break;
        }
        case Duration::ID:
        {
            str = "3e286caf4241d664e55f3ad380e2ae46";
            break;
        }
        case Empty::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case Float32::ID:
        {
            str = "73fcbf46b49191e672908e50842a83d4";
            break;
        }
        case Float32MultiArray::ID:
        {
            str = "6a40e0ffa6a17a503ac3f8616991b1f6";
            break;
        }
        case Float64::ID:
        {
            str = "fdb28210bfa9d7c91146260178d9a584";
            break;
        }
        case Float64MultiArray::ID:
        {
            str = "4b7d974086d4060e7db4613a7e6c3ba4";
            break;
        }
        case Header::ID:
        {
            str = "2176decaecbce78abc3b96ef049fabed";
            break;
        }
        case Int16::ID:
        {
            str = "8524586e34fbd7cb1c08c5f5f1ca0e57";
            break;
        }
        case Int16MultiArray::ID:
        {
            str = "d9338d7f523fcb692fae9d0a0e9f067c";
            break;
        }
        case Int32::ID:
        {
            str = "da5909fbe378aeaf85e547e830cc1bb7";
            break;
        }
        case Int32MultiArray::ID:
        {
            str = "1d99f79f8b325b44fee908053e9c945b";
            break;
        }
        case Int64::ID:
        {
            str = "34add168574510e6e17f5d23ecc077ef";
            break;
        }
        case Int64MultiArray::ID:
        {
            str = "54865aa6c65be0448113a2afc6a49270";
            break;
        }
        case Int8::ID:
        {
            str = "27ffa0c9c4b8fb8492252bcad9e5c57b";
            break;
        }
        case Int8MultiArray::ID:
        {
            str = "d7c1af35a1b4781bbe79e03dd94b7c13";
            break;
        }
        case MultiArrayDimension::ID:
        {
            str = "4cd0c83a8683deae40ecdac60e53bfa8";
            break;
        }
        case MultiArrayLayout::ID:
        {
            str = "0fed2a11c13e11c5571b4e2a995a91a3";
            break;
        }
        case String::ID:
        {
            str = "992ce8a1687cec8c8bd883ec73ca41d1";
            break;
        }
        case Time::ID:
        {
            str = "cd7166c74c552c311fbcc2fe5a7bc289";
            break;
        }
        case UInt16::ID:
        {
            str = "1df79edf208b629fe6b81923a544552d";
            break;
        }
        case UInt16MultiArray::ID:
        {
            str = "52f264f1c973c4b73790d384c6cb4484";
            break;
        }
        case UInt32::ID:
        {
            str = "304a39449588c7f8ce2df6e8001c5fce";
            break;
        }
        case UInt32MultiArray::ID:
        {
            str = "4d6a180abc9be191b96a7eda6c8a233d";
            break;
        }
        case UInt64::ID:
        {
            str = "1b2a79973e8bf53d7b53acb71299cb57";
            break;
        }
        case UInt64MultiArray::ID:
        {
            str = "6088f127afb1d6c72927aa1247e945af";
            break;
        }
        case UInt8::ID:
        {
            str = "7c8164229e7d2c17eb95e9231617fdee";
            break;
        }
        case UInt8MultiArray::ID:
        {
            str = "82373f1612381bb6ee473b5cd6f5d89c";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case RosTime::ID:
        {   
		    highOrder = 0x4771ad66fef816d2ULL;
            lowOrder = 0xe4bead2f45a1cde6ULL;
            break;
        }
        case RosDuration::ID:
        {   
		    highOrder = 0x4771ad66fef816d2ULL;
            lowOrder = 0xe4bead2f45a1cde6ULL;
            break;
        }
        case HeaderTest::ID:
        {   
		    highOrder = 0xc343c4dd01fd2a6aULL;
            lowOrder = 0xf039d2d6bf86b09aULL;
            break;
        }
        case Bool::ID:
        {   
		    highOrder = 0x8b94c1b53db61fb6ULL;
            lowOrder = 0xaed406028ad6332aULL;
            break;
        }
        case Byte::ID:
        {   
		    highOrder = 0xad736a2e8818154cULL;
            lowOrder = 0x487bb80fe42ce43bULL;
            break;
        }
        case ByteMultiArray::ID:
        {   
		    highOrder = 0x70ea476cbcfd65acULL;
            lowOrder = 0x2f68f3cda1e891feULL;
            break;
        }
        case Char::ID:
        {   
		    highOrder = 0x1bf77f25acecdedbULL;
            lowOrder = 0xa0e224b162199717ULL;
            break;
        }
        case ColorRGBA::ID:
        {   
		    highOrder = 0xa29a96539573343bULL;
            lowOrder = 0x1310c73607334b00ULL;
            break;
        }
        case Duration::ID:
        {   
		    highOrder = 0x3e286caf4241d664ULL;
            lowOrder = 0xe55f3ad380e2ae46ULL;
            break;
        }
        case Empty::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case Float32::ID:
        {   
		    highOrder = 0x73fcbf46b49191e6ULL;
            lowOrder = 0x72908e50842a83d4ULL;
            break;
        }
        case Float32MultiArray::ID:
        {   
		    highOrder = 0x6a40e0ffa6a17a50ULL;
            lowOrder = 0x3ac3f8616991b1f6ULL;
            break;
        }
        case Float64::ID:
        {   
		    highOrder = 0xfdb28210bfa9d7c9ULL;
            lowOrder = 0x1146260178d9a584ULL;
            break;
        }
        case Float64MultiArray::ID:
        {   
		    highOrder = 0x4b7d974086d4060eULL;
            lowOrder = 0x7db4613a7e6c3ba4ULL;
            break;
        }
        case Header::ID:
        {   
		    highOrder = 0x2176decaecbce78aULL;
            lowOrder = 0xbc3b96ef049fabedULL;
            break;
        }
        case Int16::ID:
        {   
		    highOrder = 0x8524586e34fbd7cbULL;
            lowOrder = 0x1c08c5f5f1ca0e57ULL;
            break;
        }
        case Int16MultiArray::ID:
        {   
		    highOrder = 0xd9338d7f523fcb69ULL;
            lowOrder = 0x2fae9d0a0e9f067cULL;
            break;
        }
        case Int32::ID:
        {   
		    highOrder = 0xda5909fbe378aeafULL;
            lowOrder = 0x85e547e830cc1bb7ULL;
            break;
        }
        case Int32MultiArray::ID:
        {   
		    highOrder = 0x1d99f79f8b325b44ULL;
            lowOrder = 0xfee908053e9c945bULL;
            break;
        }
        case Int64::ID:
        {   
		    highOrder = 0x34add168574510e6ULL;
            lowOrder = 0xe17f5d23ecc077efULL;
            break;
        }
        case Int64MultiArray::ID:
        {   
		    highOrder = 0x54865aa6c65be044ULL;
            lowOrder = 0x8113a2afc6a49270ULL;
            break;
        }
        case Int8::ID:
        {   
		    highOrder = 0x27ffa0c9c4b8fb84ULL;
            lowOrder = 0x92252bcad9e5c57bULL;
            break;
        }
        case Int8MultiArray::ID:
        {   
		    highOrder = 0xd7c1af35a1b4781bULL;
            lowOrder = 0xbe79e03dd94b7c13ULL;
            break;
        }
        case MultiArrayDimension::ID:
        {   
		    highOrder = 0x4cd0c83a8683deaeULL;
            lowOrder = 0x40ecdac60e53bfa8ULL;
            break;
        }
        case MultiArrayLayout::ID:
        {   
		    highOrder = 0x0fed2a11c13e11c5ULL;
            lowOrder = 0x571b4e2a995a91a3ULL;
            break;
        }
        case String::ID:
        {   
		    highOrder = 0x992ce8a1687cec8cULL;
            lowOrder = 0x8bd883ec73ca41d1ULL;
            break;
        }
        case Time::ID:
        {   
		    highOrder = 0xcd7166c74c552c31ULL;
            lowOrder = 0x1fbcc2fe5a7bc289ULL;
            break;
        }
        case UInt16::ID:
        {   
		    highOrder = 0x1df79edf208b629fULL;
            lowOrder = 0xe6b81923a544552dULL;
            break;
        }
        case UInt16MultiArray::ID:
        {   
		    highOrder = 0x52f264f1c973c4b7ULL;
            lowOrder = 0x3790d384c6cb4484ULL;
            break;
        }
        case UInt32::ID:
        {   
		    highOrder = 0x304a39449588c7f8ULL;
            lowOrder = 0xce2df6e8001c5fceULL;
            break;
        }
        case UInt32MultiArray::ID:
        {   
		    highOrder = 0x4d6a180abc9be191ULL;
            lowOrder = 0xb96a7eda6c8a233dULL;
            break;
        }
        case UInt64::ID:
        {   
		    highOrder = 0x1b2a79973e8bf53dULL;
            lowOrder = 0x7b53acb71299cb57ULL;
            break;
        }
        case UInt64MultiArray::ID:
        {   
		    highOrder = 0x6088f127afb1d6c7ULL;
            lowOrder = 0x2927aa1247e945afULL;
            break;
        }
        case UInt8::ID:
        {   
		    highOrder = 0x7c8164229e7d2c17ULL;
            lowOrder = 0xeb95e9231617fdeeULL;
            break;
        }
        case UInt8MultiArray::ID:
        {   
		    highOrder = 0x82373f1612381bb6ULL;
            lowOrder = 0xee473b5cd6f5d89cULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case RosTime::ID:
        case RosDuration::ID:
        case HeaderTest::ID:
        case Bool::ID:
        case Byte::ID:
        case ByteMultiArray::ID:
        case Char::ID:
        case ColorRGBA::ID:
        case Duration::ID:
        case Empty::ID:
        case Float32::ID:
        case Float32MultiArray::ID:
        case Float64::ID:
        case Float64MultiArray::ID:
        case Header::ID:
        case Int16::ID:
        case Int16MultiArray::ID:
        case Int32::ID:
        case Int32MultiArray::ID:
        case Int64::ID:
        case Int64MultiArray::ID:
        case Int8::ID:
        case Int8MultiArray::ID:
        case MultiArrayDimension::ID:
        case MultiArrayLayout::ID:
        case String::ID:
        case Time::ID:
        case UInt16::ID:
        case UInt16MultiArray::ID:
        case UInt32::ID:
        case UInt32MultiArray::ID:
        case UInt64::ID:
        case UInt64MultiArray::ID:
        case UInt8::ID:
        case UInt8MultiArray::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case RosTime::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<RosTime>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case RosDuration::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<RosDuration>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case HeaderTest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<HeaderTest>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Bool::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Bool>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Byte::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Byte>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ByteMultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ByteMultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Char::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Char>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ColorRGBA::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ColorRGBA>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Duration::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Duration>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Empty::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Empty>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float32>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float32MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float32MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float64::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float64>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Float64MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Float64MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Header::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Header>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int16::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int16>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int16MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int16MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int32>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int32MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int32MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int64::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int64>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int64MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int64MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int8::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int8>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Int8MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Int8MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiArrayDimension::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiArrayDimension>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case MultiArrayLayout::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<MultiArrayLayout>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case String::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<String>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case Time::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<Time>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt16::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt16>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt16MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt16MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt32::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt32>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt32MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt32MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt64::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt64>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt64MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt64MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt8::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt8>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case UInt8MultiArray::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<UInt8MultiArray>(),std::bind(&std_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case RosTime::ID:
            {
                Message<RosTime > & tempSrc = static_cast<Message<RosTime>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::RosTime buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case RosDuration::ID:
            {
                Message<RosDuration > & tempSrc = static_cast<Message<RosDuration>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::RosDuration buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case HeaderTest::ID:
            {
                Message<HeaderTest > & tempSrc = static_cast<Message<HeaderTest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::HeaderTest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Bool::ID:
            {
                Message<Bool > & tempSrc = static_cast<Message<Bool>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Bool buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Byte::ID:
            {
                Message<Byte > & tempSrc = static_cast<Message<Byte>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Byte buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ByteMultiArray::ID:
            {
                Message<ByteMultiArray > & tempSrc = static_cast<Message<ByteMultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::ByteMultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Char::ID:
            {
                Message<Char > & tempSrc = static_cast<Message<Char>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Char buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ColorRGBA::ID:
            {
                Message<ColorRGBA > & tempSrc = static_cast<Message<ColorRGBA>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::ColorRGBA buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Duration::ID:
            {
                Message<Duration > & tempSrc = static_cast<Message<Duration>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Duration buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Empty::ID:
            {
                Message<Empty > & tempSrc = static_cast<Message<Empty>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Empty buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Float32::ID:
            {
                Message<Float32 > & tempSrc = static_cast<Message<Float32>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Float32 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Float32MultiArray::ID:
            {
                Message<Float32MultiArray > & tempSrc = static_cast<Message<Float32MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Float32MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Float64::ID:
            {
                Message<Float64 > & tempSrc = static_cast<Message<Float64>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Float64 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Float64MultiArray::ID:
            {
                Message<Float64MultiArray > & tempSrc = static_cast<Message<Float64MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Float64MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Header::ID:
            {
                Message<Header > & tempSrc = static_cast<Message<Header>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Header buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int16::ID:
            {
                Message<Int16 > & tempSrc = static_cast<Message<Int16>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int16 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int16MultiArray::ID:
            {
                Message<Int16MultiArray > & tempSrc = static_cast<Message<Int16MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int16MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int32::ID:
            {
                Message<Int32 > & tempSrc = static_cast<Message<Int32>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int32 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int32MultiArray::ID:
            {
                Message<Int32MultiArray > & tempSrc = static_cast<Message<Int32MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int32MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int64::ID:
            {
                Message<Int64 > & tempSrc = static_cast<Message<Int64>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int64 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int64MultiArray::ID:
            {
                Message<Int64MultiArray > & tempSrc = static_cast<Message<Int64MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int64MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int8::ID:
            {
                Message<Int8 > & tempSrc = static_cast<Message<Int8>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int8 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Int8MultiArray::ID:
            {
                Message<Int8MultiArray > & tempSrc = static_cast<Message<Int8MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Int8MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MultiArrayDimension::ID:
            {
                Message<MultiArrayDimension > & tempSrc = static_cast<Message<MultiArrayDimension>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::MultiArrayDimension buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case MultiArrayLayout::ID:
            {
                Message<MultiArrayLayout > & tempSrc = static_cast<Message<MultiArrayLayout>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::MultiArrayLayout buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case String::ID:
            {
                Message<String > & tempSrc = static_cast<Message<String>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::String buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case Time::ID:
            {
                Message<Time > & tempSrc = static_cast<Message<Time>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::Time buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt16::ID:
            {
                Message<UInt16 > & tempSrc = static_cast<Message<UInt16>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt16 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt16MultiArray::ID:
            {
                Message<UInt16MultiArray > & tempSrc = static_cast<Message<UInt16MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt16MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt32::ID:
            {
                Message<UInt32 > & tempSrc = static_cast<Message<UInt32>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt32 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt32MultiArray::ID:
            {
                Message<UInt32MultiArray > & tempSrc = static_cast<Message<UInt32MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt32MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt64::ID:
            {
                Message<UInt64 > & tempSrc = static_cast<Message<UInt64>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt64 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt64MultiArray::ID:
            {
                Message<UInt64MultiArray > & tempSrc = static_cast<Message<UInt64MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt64MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt8::ID:
            {
                Message<UInt8 > & tempSrc = static_cast<Message<UInt8>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt8 buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case UInt8MultiArray::ID:
            {
                Message<UInt8MultiArray > & tempSrc = static_cast<Message<UInt8MultiArray>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: std_msgs_gencpp::UInt8MultiArray buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case RosTime::ID:
            {
                Message<RosTime > & tempDst = static_cast<Message<RosTime>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case RosDuration::ID:
            {
                Message<RosDuration > & tempDst = static_cast<Message<RosDuration>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case HeaderTest::ID:
            {
                Message<HeaderTest > & tempDst = static_cast<Message<HeaderTest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case Bool::ID:
            {
                Message<Bool > & tempDst = static_cast<Message<Bool>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Byte::ID:
            {
                Message<Byte > & tempDst = static_cast<Message<Byte>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ByteMultiArray::ID:
            {
                Message<ByteMultiArray > & tempDst = static_cast<Message<ByteMultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Char::ID:
            {
                Message<Char > & tempDst = static_cast<Message<Char>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ColorRGBA::ID:
            {
                Message<ColorRGBA > & tempDst = static_cast<Message<ColorRGBA>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Duration::ID:
            {
                Message<Duration > & tempDst = static_cast<Message<Duration>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Empty::ID:
            {
                Message<Empty > & tempDst = static_cast<Message<Empty>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Float32::ID:
            {
                Message<Float32 > & tempDst = static_cast<Message<Float32>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Float32MultiArray::ID:
            {
                Message<Float32MultiArray > & tempDst = static_cast<Message<Float32MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Float64::ID:
            {
                Message<Float64 > & tempDst = static_cast<Message<Float64>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Float64MultiArray::ID:
            {
                Message<Float64MultiArray > & tempDst = static_cast<Message<Float64MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Header::ID:
            {
                Message<Header > & tempDst = static_cast<Message<Header>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int16::ID:
            {
                Message<Int16 > & tempDst = static_cast<Message<Int16>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int16MultiArray::ID:
            {
                Message<Int16MultiArray > & tempDst = static_cast<Message<Int16MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int32::ID:
            {
                Message<Int32 > & tempDst = static_cast<Message<Int32>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int32MultiArray::ID:
            {
                Message<Int32MultiArray > & tempDst = static_cast<Message<Int32MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int64::ID:
            {
                Message<Int64 > & tempDst = static_cast<Message<Int64>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int64MultiArray::ID:
            {
                Message<Int64MultiArray > & tempDst = static_cast<Message<Int64MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int8::ID:
            {
                Message<Int8 > & tempDst = static_cast<Message<Int8>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Int8MultiArray::ID:
            {
                Message<Int8MultiArray > & tempDst = static_cast<Message<Int8MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MultiArrayDimension::ID:
            {
                Message<MultiArrayDimension > & tempDst = static_cast<Message<MultiArrayDimension>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case MultiArrayLayout::ID:
            {
                Message<MultiArrayLayout > & tempDst = static_cast<Message<MultiArrayLayout>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case String::ID:
            {
                Message<String > & tempDst = static_cast<Message<String>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case Time::ID:
            {
                Message<Time > & tempDst = static_cast<Message<Time>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt16::ID:
            {
                Message<UInt16 > & tempDst = static_cast<Message<UInt16>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt16MultiArray::ID:
            {
                Message<UInt16MultiArray > & tempDst = static_cast<Message<UInt16MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt32::ID:
            {
                Message<UInt32 > & tempDst = static_cast<Message<UInt32>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt32MultiArray::ID:
            {
                Message<UInt32MultiArray > & tempDst = static_cast<Message<UInt32MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt64::ID:
            {
                Message<UInt64 > & tempDst = static_cast<Message<UInt64>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt64MultiArray::ID:
            {
                Message<UInt64MultiArray > & tempDst = static_cast<Message<UInt64MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt8::ID:
            {
                Message<UInt8 > & tempDst = static_cast<Message<UInt8>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case UInt8MultiArray::ID:
            {
                Message<UInt8MultiArray > & tempDst = static_cast<Message<UInt8MultiArray>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int std_msgs_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // RosTime does not have a Header as its first member 
        // RosDuration does not have a Header as its first member 
        case HeaderTest::ID:
        {
            Message<HeaderTest > & tempMsg = static_cast<Message<HeaderTest>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // Bool does not have a Header as its first member 
        // Byte does not have a Header as its first member 
        // ByteMultiArray does not have a Header as its first member 
        // Char does not have a Header as its first member 
        // ColorRGBA does not have a Header as its first member 
        // Duration does not have a Header as its first member 
        // Float32 does not have a Header as its first member 
        // Float32MultiArray does not have a Header as its first member 
        // Float64 does not have a Header as its first member 
        // Float64MultiArray does not have a Header as its first member 
        // Header does not have a Header as its first member 
        // Int16 does not have a Header as its first member 
        // Int16MultiArray does not have a Header as its first member 
        // Int32 does not have a Header as its first member 
        // Int32MultiArray does not have a Header as its first member 
        // Int64 does not have a Header as its first member 
        // Int64MultiArray does not have a Header as its first member 
        // Int8 does not have a Header as its first member 
        // Int8MultiArray does not have a Header as its first member 
        // MultiArrayDimension does not have a Header as its first member 
        // MultiArrayLayout does not have a Header as its first member 
        // String does not have a Header as its first member 
        // Time does not have a Header as its first member 
        // UInt16 does not have a Header as its first member 
        // UInt16MultiArray does not have a Header as its first member 
        // UInt32 does not have a Header as its first member 
        // UInt32MultiArray does not have a Header as its first member 
        // UInt64 does not have a Header as its first member 
        // UInt64MultiArray does not have a Header as its first member 
        // UInt8 does not have a Header as its first member 
        // UInt8MultiArray does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
