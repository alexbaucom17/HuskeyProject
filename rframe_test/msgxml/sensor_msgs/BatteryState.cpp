// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:53 -0500
//  From Template/Script: data_templates/DataClassTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include <math.h> // to allow use of common constants...
#include <common/Error.h>
#include "sensor_msgs/BatteryState.h"

#include <common/JsonIo.h> // include here so container types are included by the class header 

using namespace std;

const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_STATUS_UNKNOWN = 0;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_STATUS_CHARGING = 1;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_STATUS_DISCHARGING = 2;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_STATUS_NOT_CHARGING = 3;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_STATUS_FULL = 4;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_UNKNOWN = 0;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_GOOD = 1;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_OVERHEAT = 2;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_DEAD = 3;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_COLD = 6;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_NIMH = 1;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_LION = 2;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_LIPO = 3;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_LIFE = 4;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_NICD = 5;
const unsigned char sensor_msgs::BatteryState::POWER_SUPPLY_TECHNOLOGY_LIMN = 6;

const unsigned int sensor_msgs::BatteryState::ID;
const unsigned int sensor_msgs::BatteryState::DATA_VERSION;
const std::string sensor_msgs::BatteryState::DATA_TYPE_NAME = "BatteryState";
const std::string sensor_msgs::BatteryState::DATA_TYPE_FULL_NAME = "sensor_msgs::BatteryState";
const std::string sensor_msgs::BatteryState::VERSION_MD5 = "1d0bbb62774e09d9566e966ca9dce76f";
/* xml source for this class */
const std::string sensor_msgs::BatteryState::XML_SOURCE = "<class name=\"BatteryState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"476f837fa6771f6e16e3bf4ef96f8770\" rosDesc=\"\\n# Constants are chosen to match the enums in the linux kernel\\n# defined in include/linux/power_supply.h as of version 3.7\\n# The one difference is for style reasons the constants are\\n# all uppercase not mixed case.\\n\\n# Power supply status constants\\nuint8 POWER_SUPPLY_STATUS_UNKNOWN = 0\\nuint8 POWER_SUPPLY_STATUS_CHARGING = 1\\nuint8 POWER_SUPPLY_STATUS_DISCHARGING = 2\\nuint8 POWER_SUPPLY_STATUS_NOT_CHARGING = 3\\nuint8 POWER_SUPPLY_STATUS_FULL = 4\\n\\n# Power supply health constants\\nuint8 POWER_SUPPLY_HEALTH_UNKNOWN = 0\\nuint8 POWER_SUPPLY_HEALTH_GOOD = 1\\nuint8 POWER_SUPPLY_HEALTH_OVERHEAT = 2\\nuint8 POWER_SUPPLY_HEALTH_DEAD = 3\\nuint8 POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4\\nuint8 POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5\\nuint8 POWER_SUPPLY_HEALTH_COLD = 6\\nuint8 POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7\\nuint8 POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8\\n\\n# Power supply technology (chemistry) constants\\nuint8 POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0\\nuint8 POWER_SUPPLY_TECHNOLOGY_NIMH = 1\\nuint8 POWER_SUPPLY_TECHNOLOGY_LION = 2\\nuint8 POWER_SUPPLY_TECHNOLOGY_LIPO = 3\\nuint8 POWER_SUPPLY_TECHNOLOGY_LIFE = 4\\nuint8 POWER_SUPPLY_TECHNOLOGY_NICD = 5\\nuint8 POWER_SUPPLY_TECHNOLOGY_LIMN = 6\\n\\nHeader  header\\nfloat32 voltage          # Voltage in Volts (Mandatory)\\nfloat32 current          # Negative when discharging (A)  (If unmeasured NaN)\\nfloat32 charge           # Current charge in Ah  (If unmeasured NaN)\\nfloat32 capacity         # Capacity in Ah (last full capacity)  (If unmeasured NaN)\\nfloat32 design_capacity  # Capacity in Ah (design capacity)  (If unmeasured NaN)\\nfloat32 percentage       # Charge percentage on 0 to 1 range  (If unmeasured NaN)\\nuint8   power_supply_status     # The charging status as reported. Values defined above\\nuint8   power_supply_health     # The battery health metric. Values defined above\\nuint8   power_supply_technology # The battery chemistry. Values defined above\\nbool    present          # True if the battery is present\\n\\nfloat32[] cell_voltage   # An array of individual cell voltages for each cell in the pack\\n                         # If individual voltages unknown but number of cells known set each to NaN\\nstring location          # The location into which the battery is inserted. (slot number or plug)\\nstring serial_number     # The best approximation of the battery serial number\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\" comment=\"\" id=\"237354210\">\
  <constant init=\"0\" name=\"POWER_SUPPLY_STATUS_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"POWER_SUPPLY_STATUS_CHARGING\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"POWER_SUPPLY_STATUS_DISCHARGING\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"POWER_SUPPLY_STATUS_NOT_CHARGING\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"POWER_SUPPLY_STATUS_FULL\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"Power supply health constants\"/>\
  <constant init=\"0\" name=\"POWER_SUPPLY_HEALTH_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"POWER_SUPPLY_HEALTH_GOOD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"POWER_SUPPLY_HEALTH_OVERHEAT\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"POWER_SUPPLY_HEALTH_DEAD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"POWER_SUPPLY_HEALTH_OVERVOLTAGE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"5\" name=\"POWER_SUPPLY_HEALTH_UNSPEC_FAILURE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"6\" name=\"POWER_SUPPLY_HEALTH_COLD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"7\" name=\"POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"8\" name=\"POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"Power supply technology (chemistry) constants\"/>\
  <constant init=\"0\" name=\"POWER_SUPPLY_TECHNOLOGY_UNKNOWN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"1\" name=\"POWER_SUPPLY_TECHNOLOGY_NIMH\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"2\" name=\"POWER_SUPPLY_TECHNOLOGY_LION\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"3\" name=\"POWER_SUPPLY_TECHNOLOGY_LIPO\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"4\" name=\"POWER_SUPPLY_TECHNOLOGY_LIFE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"5\" name=\"POWER_SUPPLY_TECHNOLOGY_NICD\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"6\" name=\"POWER_SUPPLY_TECHNOLOGY_LIMN\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"\"/>\
  <field name=\"voltage\" type=\"float\" sourceType=\"float32\" comment=\"Voltage in Volts (Mandatory)\"/>\
  <field name=\"current\" type=\"float\" sourceType=\"float32\" comment=\"Negative when discharging (A)  (If unmeasured NaN)\"/>\
  <field name=\"charge\" type=\"float\" sourceType=\"float32\" comment=\"Current charge in Ah  (If unmeasured NaN)\"/>\
  <field name=\"capacity\" type=\"float\" sourceType=\"float32\" comment=\"Capacity in Ah (last full capacity)  (If unmeasured NaN)\"/>\
  <field name=\"design_capacity\" type=\"float\" sourceType=\"float32\" comment=\"Capacity in Ah (design capacity)  (If unmeasured NaN)\"/>\
  <field name=\"percentage\" type=\"float\" sourceType=\"float32\" comment=\"Charge percentage on 0 to 1 range  (If unmeasured NaN)\"/>\
  <field name=\"power_supply_status\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"The charging status as reported. Values defined above\"/>\
  <field name=\"power_supply_health\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"The battery health metric. Values defined above\"/>\
  <field name=\"power_supply_technology\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"The battery chemistry. Values defined above\"/>\
  <field name=\"present\" type=\"bool\" sourceType=\"bool\" comment=\"True if the battery is present\"/>\
  <field name=\"cell_voltage\" type=\"vector(float)\" sourceType=\"float32\" comment=\"An array of individual cell voltages for each cell in the pack  If individual voltages unknown but number of cells known set each to NaN\"/>\
  <field name=\"location\" type=\"string\" sourceType=\"string\" comment=\"The location into which the battery is inserted. (slot number or plug)\"/>\
  <field name=\"serial_number\" type=\"string\" sourceType=\"string\" comment=\"The best approximation of the battery serial number\"/>\
</class>";

sensor_msgs::BatteryState::BatteryState() : header(), voltage(0), current(0), charge(0), capacity(0), design_capacity(0), percentage(0), power_supply_status(0), power_supply_health(0), power_supply_technology(0), present(0), cell_voltage(), location(), serial_number()
{  
};

sensor_msgs::BatteryState::BatteryState(const sensor_msgs::BatteryState & inobj) : header(inobj.header), voltage(inobj.voltage), current(inobj.current), charge(inobj.charge), capacity(inobj.capacity), design_capacity(inobj.design_capacity), percentage(inobj.percentage), power_supply_status(inobj.power_supply_status), power_supply_health(inobj.power_supply_health), power_supply_technology(inobj.power_supply_technology), present(inobj.present), cell_voltage(inobj.cell_voltage), location(inobj.location), serial_number(inobj.serial_number)
{
};

sensor_msgs::BatteryState::~BatteryState()
{
};

sensor_msgs::BatteryState * sensor_msgs::BatteryState::New()
{ 
    return new BatteryState();
};

bool sensor_msgs::BatteryState::dataTypeFlat() 
{   
    return false; 
};

sensor_msgs::BatteryState & sensor_msgs::BatteryState::operator=(const sensor_msgs::BatteryState & inobj)
{
    if (this != &inobj)
    {

        // if datatype is flat, optimize with memcpy (complier level optimiation)
              /*  if (dataTypeFlat() == true)
                  REMOVED invalid when assigning from a parent type as this is the pointer to the derived type, thus sensor_msgs::BatteryState is copied to the wrong location

        {
            memcpy(this,&inobj,sizeof(sensor_msgs::BatteryState));
        }
        else */ 
        {

            header = inobj.header;
            voltage = inobj.voltage;
            current = inobj.current;
            charge = inobj.charge;
            capacity = inobj.capacity;
            design_capacity = inobj.design_capacity;
            percentage = inobj.percentage;
            power_supply_status = inobj.power_supply_status;
            power_supply_health = inobj.power_supply_health;
            power_supply_technology = inobj.power_supply_technology;
            present = inobj.present;
            cell_voltage = inobj.cell_voltage;
            location = inobj.location;
            serial_number = inobj.serial_number;
        }
    }

    return *this;
}

bool sensor_msgs::BatteryState::operator==(const sensor_msgs::BatteryState & inobj) const
{
    bool ret = true;

    if (this != &inobj)
    { 
        ret = ret 
             && (header == inobj.header)
             && (voltage == inobj.voltage)
             && (current == inobj.current)
             && (charge == inobj.charge)
             && (capacity == inobj.capacity)
             && (design_capacity == inobj.design_capacity)
             && (percentage == inobj.percentage)
             && (power_supply_status == inobj.power_supply_status)
             && (power_supply_health == inobj.power_supply_health)
             && (power_supply_technology == inobj.power_supply_technology)
             && (present == inobj.present)
             && (cell_voltage == inobj.cell_voltage)
             && (location == inobj.location)
             && (serial_number == inobj.serial_number);
    }

    return ret;
}

bool sensor_msgs::BatteryState::operator!=(const sensor_msgs::BatteryState & inobj) const
{
    bool ret = false;

    if (this != &inobj)
    {
        ret = !operator==(inobj);
    }

    return ret;
}

bool sensor_msgs::BatteryState::operator<(const sensor_msgs::BatteryState & inobj) const
{
    bool ret = false;

    if (this == &inobj)
    {
        ret = false;
    }
    else
    {  
        // comparison algorithm based on std::lexicographical_compare algorithm

        if (header < inobj.header) return true;
        if (inobj.header <  header) return false; 
        if (voltage < inobj.voltage) return true;
        if (inobj.voltage <  voltage) return false; 
        if (current < inobj.current) return true;
        if (inobj.current <  current) return false; 
        if (charge < inobj.charge) return true;
        if (inobj.charge <  charge) return false; 
        if (capacity < inobj.capacity) return true;
        if (inobj.capacity <  capacity) return false; 
        if (design_capacity < inobj.design_capacity) return true;
        if (inobj.design_capacity <  design_capacity) return false; 
        if (percentage < inobj.percentage) return true;
        if (inobj.percentage <  percentage) return false; 
        if (power_supply_status < inobj.power_supply_status) return true;
        if (inobj.power_supply_status <  power_supply_status) return false; 
        if (power_supply_health < inobj.power_supply_health) return true;
        if (inobj.power_supply_health <  power_supply_health) return false; 
        if (power_supply_technology < inobj.power_supply_technology) return true;
        if (inobj.power_supply_technology <  power_supply_technology) return false; 
        if (present < inobj.present) return true;
        if (inobj.present <  present) return false; 
        if (cell_voltage < inobj.cell_voltage) return true;
        if (inobj.cell_voltage <  cell_voltage) return false; 
        if (location < inobj.location) return true;
        if (inobj.location <  location) return false; 
        if (serial_number < inobj.serial_number) return true;
        if (inobj.serial_number <  serial_number) return false; ;
    }

    return ret;
}

bool sensor_msgs::BatteryState::operator>(const sensor_msgs::BatteryState & inobj) const
{
    bool ret = false;

    if (this == &inobj)
    {
        ret = false;
    }
    else
    {
        // comparison algorithm based on std::lexicographical_compare algorithm

        if (header > inobj.header) return true;
        if (inobj.header >  header) return false; 
        if (voltage > inobj.voltage) return true;
        if (inobj.voltage >  voltage) return false; 
        if (current > inobj.current) return true;
        if (inobj.current >  current) return false; 
        if (charge > inobj.charge) return true;
        if (inobj.charge >  charge) return false; 
        if (capacity > inobj.capacity) return true;
        if (inobj.capacity >  capacity) return false; 
        if (design_capacity > inobj.design_capacity) return true;
        if (inobj.design_capacity >  design_capacity) return false; 
        if (percentage > inobj.percentage) return true;
        if (inobj.percentage >  percentage) return false; 
        if (power_supply_status > inobj.power_supply_status) return true;
        if (inobj.power_supply_status >  power_supply_status) return false; 
        if (power_supply_health > inobj.power_supply_health) return true;
        if (inobj.power_supply_health >  power_supply_health) return false; 
        if (power_supply_technology > inobj.power_supply_technology) return true;
        if (inobj.power_supply_technology >  power_supply_technology) return false; 
        if (present > inobj.present) return true;
        if (inobj.present >  present) return false; 
        if (cell_voltage > inobj.cell_voltage) return true;
        if (inobj.cell_voltage >  cell_voltage) return false; 
        if (location > inobj.location) return true;
        if (inobj.location >  location) return false; 
        if (serial_number > inobj.serial_number) return true;
        if (inobj.serial_number >  serial_number) return false; ;
    }

    return ret;
}

template <> void rframe::json_io::encode(std::stringstream & sstr, const char * name, const sensor_msgs::BatteryState & t, std::string & indent, bool lastItem)
{
    if ((name) && (*name != '\0')) rframe::json_io::encodeObjectStart(sstr,name,indent);

    rframe::json_io::encode(sstr,"header",t.header,indent,false);
    rframe::json_io::encode(sstr,"voltage",t.voltage,indent,false);
    rframe::json_io::encode(sstr,"current",t.current,indent,false);
    rframe::json_io::encode(sstr,"charge",t.charge,indent,false);
    rframe::json_io::encode(sstr,"capacity",t.capacity,indent,false);
    rframe::json_io::encode(sstr,"design_capacity",t.design_capacity,indent,false);
    rframe::json_io::encode(sstr,"percentage",t.percentage,indent,false);
    rframe::json_io::encode(sstr,"power_supply_status",t.power_supply_status,indent,false);
    rframe::json_io::encode(sstr,"power_supply_health",t.power_supply_health,indent,false);
    rframe::json_io::encode(sstr,"power_supply_technology",t.power_supply_technology,indent,false);
    rframe::json_io::encode(sstr,"present",t.present,indent,false);
    rframe::json_io::encode(sstr,"cell_voltage",t.cell_voltage,indent,false);
    rframe::json_io::encode(sstr,"location",t.location,indent,false);
    rframe::json_io::encode(sstr,"serial_number",t.serial_number,indent,true);

    if ((name) && (*name != '\0')) rframe::json_io::encodeObjectEnd(sstr,indent,lastItem);
}

std::string sensor_msgs::BatteryState::toStr(bool pretty) const
{

    stringstream sstr;
    string indent = (pretty == true) ? "\n" : "";

    rframe::json_io::encodeObjectStartMain(sstr,indent);
    rframe::json_io::encode(sstr,"",*this,indent,true);
    rframe::json_io::encodeObjectEnd(sstr,indent,true); // false so as to  not add , at end of string

    return sstr.str();

};

std::basic_ostream<char>& operator<<(std::basic_ostream<char> &s, const sensor_msgs::BatteryState & value)
{
    return s << value.toStr(false);
}

