<!--
 
  AUTOGENERATED FILE:   do not edit

  Generated by:         yongbo on yongbo-XPS-15-9550, 2017-01-17 11:30:48 -0500
  From Template/Script: rosToXML.rb
 

-->
<classes library_name="pcl_msgs_gencpp" namespace="pcl_msgs" >

<class name="ModelCoefficients" publicDataMembers="true" sourceIDL="ROS" ros="true" rosMD5="ca27dea75e72cb894cd36f9e5005e93e" rosDesc="Header header\nfloat32[] values\n\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called &apos;secs&apos;)\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called &apos;nsecs&apos;)\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n" comment="" >
  <field name="header" type="std_msgs::Header"  sourceType="Header" comment="" />
  <field name="values" type="vector(float)"  sourceType="float32" comment="" />
</class>

<class name="PointIndices" publicDataMembers="true" sourceIDL="ROS" ros="true" rosMD5="458c7998b7eaf99908256472e273b3d4" rosDesc="Header header\nint32[] indices\n\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called &apos;secs&apos;)\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called &apos;nsecs&apos;)\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n" comment="" >
  <field name="header" type="std_msgs::Header"  sourceType="Header" comment="" />
  <field name="indices" type="vector(int)"  sourceType="int32" comment="" />
</class>

<class name="PolygonMesh" publicDataMembers="true" sourceIDL="ROS" ros="true" rosMD5="45a5fc6ad2cde8489600a790acc9a38a" rosDesc="# Separate header for the polygonal surface\nHeader header\n# Vertices of the mesh as a point cloud\nsensor_msgs/PointCloud2 cloud\n# List of polygons\nVertices[] polygons\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called &apos;secs&apos;)\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called &apos;nsecs&apos;)\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: sensor_msgs/PointCloud2\n# This message holds a collection of N-dimensional points, which may\n# contain additional information such as normals, intensity, etc. The\n# point data is stored as a binary blob, its layout described by the\n# contents of the \&quot;fields\&quot; array.\n\n# The point cloud data may be organized 2d (image-like) or 1d\n# (unordered). Point clouds organized as 2d images may be produced by\n# camera depth sensors such as stereo or time-of-flight.\n\n# Time of sensor data acquisition, and the coordinate frame ID (for 3d\n# points).\nHeader header\n\n# 2D structure of the point cloud. If the cloud is unordered, height is\n# 1 and width is the length of the point cloud.\nuint32 height\nuint32 width\n\n# Describes the channels and their layout in the binary data blob.\nPointField[] fields\n\nbool    is_bigendian # Is this data bigendian?\nuint32  point_step   # Length of a point in bytes\nuint32  row_step     # Length of a row in bytes\nuint8[] data         # Actual point data, size is (row_step*height)\n\nbool is_dense        # True if there are no invalid points\n\n================================================================================\nMSG: sensor_msgs/PointField\n# This message holds the description of one point entry in the\n# PointCloud2 message format.\nuint8 INT8    = 1\nuint8 UINT8   = 2\nuint8 INT16   = 3\nuint8 UINT16  = 4\nuint8 INT32   = 5\nuint8 UINT32  = 6\nuint8 FLOAT32 = 7\nuint8 FLOAT64 = 8\n\nstring name      # Name of field\nuint32 offset    # Offset from start of point struct\nuint8  datatype  # Datatype enumeration, see above\nuint32 count     # How many elements in the field\n\n================================================================================\nMSG: pcl_msgs/Vertices\n# List of point indices\nuint32[] vertices\n" comment="Separate header for the polygonal surface" >
  <field name="header" type="std_msgs::Header"  sourceType="Header" comment="Vertices of the mesh as a point cloud" />
  <field name="cloud" type="sensor_msgs::PointCloud2"  sourceType="sensor_msgs::PointCloud2" comment="List of polygons" />
  <field name="polygons" type="vector(Vertices)"  sourceType="Vertices" comment="" />
</class>

<class name="Vertices" publicDataMembers="true" sourceIDL="ROS" ros="true" rosMD5="39bd7b1c23763ddd1b882b97cb7cfe11" rosDesc="# List of point indices\nuint32[] vertices\n" comment="List of point indices" >
  <field name="vertices" type="vector(unsigned int)"  sourceType="uint32" comment="" />
</class>

<dependency name="sensor_msgs_gencpp"/>
<dependency name="std_msgs_gencpp"/>
<dependency name="std_srvs_gencpp"/>

</classes>
