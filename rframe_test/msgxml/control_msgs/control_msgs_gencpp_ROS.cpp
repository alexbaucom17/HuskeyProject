// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:47 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "control_msgs_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace control_msgs;

rframe::ROSMessageFactory * ROS_control_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_control_msgs_gencppfactory = new control_msgs_gencppROSMessageFactory();

        return ROS_control_msgs_gencppfactory;
    };
}

rframe::ROSMessageFactory * control_msgs::allocate_control_msgs_gencpp()
{
    ROS_control_msgs_gencppfactory = new control_msgs_gencppROSMessageFactory();
    return ROS_control_msgs_gencppfactory;
};

control_msgs_gencppROSMessageFactory::control_msgs_gencppROSMessageFactory()
{
    name("control_msgs_gencpp");
    // use constructor to register data types
    control_msgs::registerLibrary();
}

control_msgs_gencppROSMessageFactory::~control_msgs_gencppROSMessageFactory()
{
}

int control_msgs_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void control_msgs_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(FollowJointTrajectoryAction::ID);
    info.name(FollowJointTrajectoryAction::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryAction::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryAction::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryAction::XML_SOURCE);
    info.flat(FollowJointTrajectoryAction::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryActionFeedback::ID);
    info.name(FollowJointTrajectoryActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryActionFeedback::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryActionFeedback::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryActionFeedback::XML_SOURCE);
    info.flat(FollowJointTrajectoryActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryActionGoal::ID);
    info.name(FollowJointTrajectoryActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryActionGoal::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryActionGoal::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryActionGoal::XML_SOURCE);
    info.flat(FollowJointTrajectoryActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryActionResult::ID);
    info.name(FollowJointTrajectoryActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryActionResult::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryActionResult::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryActionResult::XML_SOURCE);
    info.flat(FollowJointTrajectoryActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryFeedback::ID);
    info.name(FollowJointTrajectoryFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryFeedback::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryFeedback::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryFeedback::XML_SOURCE);
    info.flat(FollowJointTrajectoryFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryGoal::ID);
    info.name(FollowJointTrajectoryGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryGoal::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryGoal::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryGoal::XML_SOURCE);
    info.flat(FollowJointTrajectoryGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(FollowJointTrajectoryResult::ID);
    info.name(FollowJointTrajectoryResult::DATA_TYPE_FULL_NAME);
    info.hashKey(FollowJointTrajectoryResult::DATA_VERSION);
    info.md5Key(FollowJointTrajectoryResult::VERSION_MD5);
    info.xmlSource(FollowJointTrajectoryResult::XML_SOURCE);
    info.flat(FollowJointTrajectoryResult::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommand::ID);
    info.name(GripperCommand::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommand::DATA_VERSION);
    info.md5Key(GripperCommand::VERSION_MD5);
    info.xmlSource(GripperCommand::XML_SOURCE);
    info.flat(GripperCommand::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandAction::ID);
    info.name(GripperCommandAction::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandAction::DATA_VERSION);
    info.md5Key(GripperCommandAction::VERSION_MD5);
    info.xmlSource(GripperCommandAction::XML_SOURCE);
    info.flat(GripperCommandAction::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandActionFeedback::ID);
    info.name(GripperCommandActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandActionFeedback::DATA_VERSION);
    info.md5Key(GripperCommandActionFeedback::VERSION_MD5);
    info.xmlSource(GripperCommandActionFeedback::XML_SOURCE);
    info.flat(GripperCommandActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandActionGoal::ID);
    info.name(GripperCommandActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandActionGoal::DATA_VERSION);
    info.md5Key(GripperCommandActionGoal::VERSION_MD5);
    info.xmlSource(GripperCommandActionGoal::XML_SOURCE);
    info.flat(GripperCommandActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandActionResult::ID);
    info.name(GripperCommandActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandActionResult::DATA_VERSION);
    info.md5Key(GripperCommandActionResult::VERSION_MD5);
    info.xmlSource(GripperCommandActionResult::XML_SOURCE);
    info.flat(GripperCommandActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandFeedback::ID);
    info.name(GripperCommandFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandFeedback::DATA_VERSION);
    info.md5Key(GripperCommandFeedback::VERSION_MD5);
    info.xmlSource(GripperCommandFeedback::XML_SOURCE);
    info.flat(GripperCommandFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandGoal::ID);
    info.name(GripperCommandGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandGoal::DATA_VERSION);
    info.md5Key(GripperCommandGoal::VERSION_MD5);
    info.xmlSource(GripperCommandGoal::XML_SOURCE);
    info.flat(GripperCommandGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(GripperCommandResult::ID);
    info.name(GripperCommandResult::DATA_TYPE_FULL_NAME);
    info.hashKey(GripperCommandResult::DATA_VERSION);
    info.md5Key(GripperCommandResult::VERSION_MD5);
    info.xmlSource(GripperCommandResult::XML_SOURCE);
    info.flat(GripperCommandResult::dataTypeFlat());
    ids.push_back(info);

    info.id(JointControllerState::ID);
    info.name(JointControllerState::DATA_TYPE_FULL_NAME);
    info.hashKey(JointControllerState::DATA_VERSION);
    info.md5Key(JointControllerState::VERSION_MD5);
    info.xmlSource(JointControllerState::XML_SOURCE);
    info.flat(JointControllerState::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTolerance::ID);
    info.name(JointTolerance::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTolerance::DATA_VERSION);
    info.md5Key(JointTolerance::VERSION_MD5);
    info.xmlSource(JointTolerance::XML_SOURCE);
    info.flat(JointTolerance::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryAction::ID);
    info.name(JointTrajectoryAction::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryAction::DATA_VERSION);
    info.md5Key(JointTrajectoryAction::VERSION_MD5);
    info.xmlSource(JointTrajectoryAction::XML_SOURCE);
    info.flat(JointTrajectoryAction::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryActionFeedback::ID);
    info.name(JointTrajectoryActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryActionFeedback::DATA_VERSION);
    info.md5Key(JointTrajectoryActionFeedback::VERSION_MD5);
    info.xmlSource(JointTrajectoryActionFeedback::XML_SOURCE);
    info.flat(JointTrajectoryActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryActionGoal::ID);
    info.name(JointTrajectoryActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryActionGoal::DATA_VERSION);
    info.md5Key(JointTrajectoryActionGoal::VERSION_MD5);
    info.xmlSource(JointTrajectoryActionGoal::XML_SOURCE);
    info.flat(JointTrajectoryActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryActionResult::ID);
    info.name(JointTrajectoryActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryActionResult::DATA_VERSION);
    info.md5Key(JointTrajectoryActionResult::VERSION_MD5);
    info.xmlSource(JointTrajectoryActionResult::XML_SOURCE);
    info.flat(JointTrajectoryActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryControllerState::ID);
    info.name(JointTrajectoryControllerState::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryControllerState::DATA_VERSION);
    info.md5Key(JointTrajectoryControllerState::VERSION_MD5);
    info.xmlSource(JointTrajectoryControllerState::XML_SOURCE);
    info.flat(JointTrajectoryControllerState::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryFeedback::ID);
    info.name(JointTrajectoryFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryFeedback::DATA_VERSION);
    info.md5Key(JointTrajectoryFeedback::VERSION_MD5);
    info.xmlSource(JointTrajectoryFeedback::XML_SOURCE);
    info.flat(JointTrajectoryFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryGoal::ID);
    info.name(JointTrajectoryGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryGoal::DATA_VERSION);
    info.md5Key(JointTrajectoryGoal::VERSION_MD5);
    info.xmlSource(JointTrajectoryGoal::XML_SOURCE);
    info.flat(JointTrajectoryGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(JointTrajectoryResult::ID);
    info.name(JointTrajectoryResult::DATA_TYPE_FULL_NAME);
    info.hashKey(JointTrajectoryResult::DATA_VERSION);
    info.md5Key(JointTrajectoryResult::VERSION_MD5);
    info.xmlSource(JointTrajectoryResult::XML_SOURCE);
    info.flat(JointTrajectoryResult::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadAction::ID);
    info.name(PointHeadAction::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadAction::DATA_VERSION);
    info.md5Key(PointHeadAction::VERSION_MD5);
    info.xmlSource(PointHeadAction::XML_SOURCE);
    info.flat(PointHeadAction::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadActionFeedback::ID);
    info.name(PointHeadActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadActionFeedback::DATA_VERSION);
    info.md5Key(PointHeadActionFeedback::VERSION_MD5);
    info.xmlSource(PointHeadActionFeedback::XML_SOURCE);
    info.flat(PointHeadActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadActionGoal::ID);
    info.name(PointHeadActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadActionGoal::DATA_VERSION);
    info.md5Key(PointHeadActionGoal::VERSION_MD5);
    info.xmlSource(PointHeadActionGoal::XML_SOURCE);
    info.flat(PointHeadActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadActionResult::ID);
    info.name(PointHeadActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadActionResult::DATA_VERSION);
    info.md5Key(PointHeadActionResult::VERSION_MD5);
    info.xmlSource(PointHeadActionResult::XML_SOURCE);
    info.flat(PointHeadActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadFeedback::ID);
    info.name(PointHeadFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadFeedback::DATA_VERSION);
    info.md5Key(PointHeadFeedback::VERSION_MD5);
    info.xmlSource(PointHeadFeedback::XML_SOURCE);
    info.flat(PointHeadFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadGoal::ID);
    info.name(PointHeadGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadGoal::DATA_VERSION);
    info.md5Key(PointHeadGoal::VERSION_MD5);
    info.xmlSource(PointHeadGoal::XML_SOURCE);
    info.flat(PointHeadGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(PointHeadResult::ID);
    info.name(PointHeadResult::DATA_TYPE_FULL_NAME);
    info.hashKey(PointHeadResult::DATA_VERSION);
    info.md5Key(PointHeadResult::VERSION_MD5);
    info.xmlSource(PointHeadResult::XML_SOURCE);
    info.flat(PointHeadResult::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionAction::ID);
    info.name(SingleJointPositionAction::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionAction::DATA_VERSION);
    info.md5Key(SingleJointPositionAction::VERSION_MD5);
    info.xmlSource(SingleJointPositionAction::XML_SOURCE);
    info.flat(SingleJointPositionAction::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionActionFeedback::ID);
    info.name(SingleJointPositionActionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionActionFeedback::DATA_VERSION);
    info.md5Key(SingleJointPositionActionFeedback::VERSION_MD5);
    info.xmlSource(SingleJointPositionActionFeedback::XML_SOURCE);
    info.flat(SingleJointPositionActionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionActionGoal::ID);
    info.name(SingleJointPositionActionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionActionGoal::DATA_VERSION);
    info.md5Key(SingleJointPositionActionGoal::VERSION_MD5);
    info.xmlSource(SingleJointPositionActionGoal::XML_SOURCE);
    info.flat(SingleJointPositionActionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionActionResult::ID);
    info.name(SingleJointPositionActionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionActionResult::DATA_VERSION);
    info.md5Key(SingleJointPositionActionResult::VERSION_MD5);
    info.xmlSource(SingleJointPositionActionResult::XML_SOURCE);
    info.flat(SingleJointPositionActionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionFeedback::ID);
    info.name(SingleJointPositionFeedback::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionFeedback::DATA_VERSION);
    info.md5Key(SingleJointPositionFeedback::VERSION_MD5);
    info.xmlSource(SingleJointPositionFeedback::XML_SOURCE);
    info.flat(SingleJointPositionFeedback::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionGoal::ID);
    info.name(SingleJointPositionGoal::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionGoal::DATA_VERSION);
    info.md5Key(SingleJointPositionGoal::VERSION_MD5);
    info.xmlSource(SingleJointPositionGoal::XML_SOURCE);
    info.flat(SingleJointPositionGoal::dataTypeFlat());
    ids.push_back(info);

    info.id(SingleJointPositionResult::ID);
    info.name(SingleJointPositionResult::DATA_TYPE_FULL_NAME);
    info.hashKey(SingleJointPositionResult::DATA_VERSION);
    info.md5Key(SingleJointPositionResult::VERSION_MD5);
    info.xmlSource(SingleJointPositionResult::XML_SOURCE);
    info.flat(SingleJointPositionResult::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryCalibrationStateRequest::ID);
    info.name(QueryCalibrationStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryCalibrationStateRequest::DATA_VERSION);
    info.md5Key(QueryCalibrationStateRequest::VERSION_MD5);
    info.xmlSource(QueryCalibrationStateRequest::XML_SOURCE);
    info.flat(QueryCalibrationStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryCalibrationStateResponse::ID);
    info.name(QueryCalibrationStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryCalibrationStateResponse::DATA_VERSION);
    info.md5Key(QueryCalibrationStateResponse::VERSION_MD5);
    info.xmlSource(QueryCalibrationStateResponse::XML_SOURCE);
    info.flat(QueryCalibrationStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryCalibrationState::ID);
    info.name(QueryCalibrationState::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryCalibrationState::DATA_VERSION);
    info.md5Key(QueryCalibrationState::VERSION_MD5);
    info.xmlSource(QueryCalibrationState::XML_SOURCE);
    info.flat(QueryCalibrationState::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryTrajectoryStateRequest::ID);
    info.name(QueryTrajectoryStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryTrajectoryStateRequest::DATA_VERSION);
    info.md5Key(QueryTrajectoryStateRequest::VERSION_MD5);
    info.xmlSource(QueryTrajectoryStateRequest::XML_SOURCE);
    info.flat(QueryTrajectoryStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryTrajectoryStateResponse::ID);
    info.name(QueryTrajectoryStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryTrajectoryStateResponse::DATA_VERSION);
    info.md5Key(QueryTrajectoryStateResponse::VERSION_MD5);
    info.xmlSource(QueryTrajectoryStateResponse::XML_SOURCE);
    info.flat(QueryTrajectoryStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(QueryTrajectoryState::ID);
    info.name(QueryTrajectoryState::DATA_TYPE_FULL_NAME);
    info.hashKey(QueryTrajectoryState::DATA_VERSION);
    info.md5Key(QueryTrajectoryState::VERSION_MD5);
    info.xmlSource(QueryTrajectoryState::XML_SOURCE);
    info.flat(QueryTrajectoryState::dataTypeFlat());
    ids.push_back(info);

}

int control_msgs_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case FollowJointTrajectoryAction::ID:
        {
            str = "control_msgs/FollowJointTrajectoryAction";
            break;
        }
        case FollowJointTrajectoryActionFeedback::ID:
        {
            str = "control_msgs/FollowJointTrajectoryActionFeedback";
            break;
        }
        case FollowJointTrajectoryActionGoal::ID:
        {
            str = "control_msgs/FollowJointTrajectoryActionGoal";
            break;
        }
        case FollowJointTrajectoryActionResult::ID:
        {
            str = "control_msgs/FollowJointTrajectoryActionResult";
            break;
        }
        case FollowJointTrajectoryFeedback::ID:
        {
            str = "control_msgs/FollowJointTrajectoryFeedback";
            break;
        }
        case FollowJointTrajectoryGoal::ID:
        {
            str = "control_msgs/FollowJointTrajectoryGoal";
            break;
        }
        case FollowJointTrajectoryResult::ID:
        {
            str = "control_msgs/FollowJointTrajectoryResult";
            break;
        }
        case GripperCommand::ID:
        {
            str = "control_msgs/GripperCommand";
            break;
        }
        case GripperCommandAction::ID:
        {
            str = "control_msgs/GripperCommandAction";
            break;
        }
        case GripperCommandActionFeedback::ID:
        {
            str = "control_msgs/GripperCommandActionFeedback";
            break;
        }
        case GripperCommandActionGoal::ID:
        {
            str = "control_msgs/GripperCommandActionGoal";
            break;
        }
        case GripperCommandActionResult::ID:
        {
            str = "control_msgs/GripperCommandActionResult";
            break;
        }
        case GripperCommandFeedback::ID:
        {
            str = "control_msgs/GripperCommandFeedback";
            break;
        }
        case GripperCommandGoal::ID:
        {
            str = "control_msgs/GripperCommandGoal";
            break;
        }
        case GripperCommandResult::ID:
        {
            str = "control_msgs/GripperCommandResult";
            break;
        }
        case JointControllerState::ID:
        {
            str = "control_msgs/JointControllerState";
            break;
        }
        case JointTolerance::ID:
        {
            str = "control_msgs/JointTolerance";
            break;
        }
        case JointTrajectoryAction::ID:
        {
            str = "control_msgs/JointTrajectoryAction";
            break;
        }
        case JointTrajectoryActionFeedback::ID:
        {
            str = "control_msgs/JointTrajectoryActionFeedback";
            break;
        }
        case JointTrajectoryActionGoal::ID:
        {
            str = "control_msgs/JointTrajectoryActionGoal";
            break;
        }
        case JointTrajectoryActionResult::ID:
        {
            str = "control_msgs/JointTrajectoryActionResult";
            break;
        }
        case JointTrajectoryControllerState::ID:
        {
            str = "control_msgs/JointTrajectoryControllerState";
            break;
        }
        case JointTrajectoryFeedback::ID:
        {
            str = "control_msgs/JointTrajectoryFeedback";
            break;
        }
        case JointTrajectoryGoal::ID:
        {
            str = "control_msgs/JointTrajectoryGoal";
            break;
        }
        case JointTrajectoryResult::ID:
        {
            str = "control_msgs/JointTrajectoryResult";
            break;
        }
        case PointHeadAction::ID:
        {
            str = "control_msgs/PointHeadAction";
            break;
        }
        case PointHeadActionFeedback::ID:
        {
            str = "control_msgs/PointHeadActionFeedback";
            break;
        }
        case PointHeadActionGoal::ID:
        {
            str = "control_msgs/PointHeadActionGoal";
            break;
        }
        case PointHeadActionResult::ID:
        {
            str = "control_msgs/PointHeadActionResult";
            break;
        }
        case PointHeadFeedback::ID:
        {
            str = "control_msgs/PointHeadFeedback";
            break;
        }
        case PointHeadGoal::ID:
        {
            str = "control_msgs/PointHeadGoal";
            break;
        }
        case PointHeadResult::ID:
        {
            str = "control_msgs/PointHeadResult";
            break;
        }
        case SingleJointPositionAction::ID:
        {
            str = "control_msgs/SingleJointPositionAction";
            break;
        }
        case SingleJointPositionActionFeedback::ID:
        {
            str = "control_msgs/SingleJointPositionActionFeedback";
            break;
        }
        case SingleJointPositionActionGoal::ID:
        {
            str = "control_msgs/SingleJointPositionActionGoal";
            break;
        }
        case SingleJointPositionActionResult::ID:
        {
            str = "control_msgs/SingleJointPositionActionResult";
            break;
        }
        case SingleJointPositionFeedback::ID:
        {
            str = "control_msgs/SingleJointPositionFeedback";
            break;
        }
        case SingleJointPositionGoal::ID:
        {
            str = "control_msgs/SingleJointPositionGoal";
            break;
        }
        case SingleJointPositionResult::ID:
        {
            str = "control_msgs/SingleJointPositionResult";
            break;
        }
        case QueryCalibrationStateRequest::ID:
        {
            str = "control_msgs/QueryCalibrationStateRequest";
            break;
        }
        case QueryCalibrationStateResponse::ID:
        {
            str = "control_msgs/QueryCalibrationStateResponse";
            break;
        }
        case QueryCalibrationState::ID:
        {
            str = "control_msgs/QueryCalibrationState";
            break;
        }
        case QueryTrajectoryStateRequest::ID:
        {
            str = "control_msgs/QueryTrajectoryStateRequest";
            break;
        }
        case QueryTrajectoryStateResponse::ID:
        {
            str = "control_msgs/QueryTrajectoryStateResponse";
            break;
        }
        case QueryTrajectoryState::ID:
        {
            str = "control_msgs/QueryTrajectoryState";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case FollowJointTrajectoryAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nFollowJointTrajectoryActionGoal action_goal\nFollowJointTrajectoryActionResult action_result\nFollowJointTrajectoryActionFeedback action_feedback\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nFollowJointTrajectoryGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n# The joint trajectory to follow\ntrajectory_msgs/JointTrajectory trajectory\n\n# Tolerances for the trajectory.  If the measured joint values fall\n# outside the tolerances the trajectory goal is aborted.  Any\n# tolerances that are not specified (by being omitted or set to 0) are\n# set to the defaults for the action server (often taken from the\n# parameter server).\n\n# Tolerances applied to the joints as the trajectory is executed.  If\n# violated, the goal aborts with error_code set to\n# PATH_TOLERANCE_VIOLATED.\nJointTolerance[] path_tolerance\n\n# To report success, the joints must be within goal_tolerance of the\n# final trajectory value.  The goal must be achieved by time the\n# trajectory ends plus goal_time_tolerance.  (goal_time_tolerance\n# allows some leeway in time, so that the trajectory goal can still\n# succeed even if the joints reach the goal some time after the\n# precise end time of the trajectory).\n#\n# If the joints are not within goal_tolerance after \"trajectory finish\n# time\" + goal_time_tolerance, the goal aborts with error_code set to\n# GOAL_TOLERANCE_VIOLATED\nJointTolerance[] goal_tolerance\nduration goal_time_tolerance\n\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectory\nHeader header\nstring[] joint_names\nJointTrajectoryPoint[] points\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n\n================================================================================\nMSG: control_msgs/JointTolerance\n# The tolerances specify the amount the position, velocity, and\n# accelerations can vary from the setpoints.  For example, in the case\n# of trajectory control, when the actual position varies beyond\n# (desired position + position tolerance), the trajectory goal may\n# abort.\n# \n# There are two special values for tolerances:\n#  * 0 - The tolerance is unspecified and will remain at whatever the default is\n#  * -1 - The tolerance is \"erased\".  If there was a default, the joint will be\n#         allowed to move without restriction.\n\nstring name\nfloat64 position  # in radians or meters (for a revolute or prismatic joint, respectively)\nfloat64 velocity  # in rad/sec or m/sec\nfloat64 acceleration  # in rad/sec^2 or m/sec^2\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nFollowJointTrajectoryResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 error_code\nint32 SUCCESSFUL = 0\nint32 INVALID_GOAL = -1\nint32 INVALID_JOINTS = -2\nint32 OLD_HEADER_TIMESTAMP = -3\nint32 PATH_TOLERANCE_VIOLATED = -4\nint32 GOAL_TOLERANCE_VIOLATED = -5\n\n# Human readable description of the error code. Contains complementary\n# information that is especially useful when execution fails, for instance:\n# - INVALID_GOAL: The reason for the invalid goal (e.g., the requested\n#   trajectory is in the past).\n# - INVALID_JOINTS: The mismatch between the expected controller joints\n#   and those provided in the goal.\n# - PATH_TOLERANCE_VIOLATED and GOAL_TOLERANCE_VIOLATED: Which joint\n#   violated which tolerance, and by how much.\nstring error_string\n\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nFollowJointTrajectoryFeedback feedback\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nHeader header\nstring[] joint_names\ntrajectory_msgs/JointTrajectoryPoint desired\ntrajectory_msgs/JointTrajectoryPoint actual\ntrajectory_msgs/JointTrajectoryPoint error\n\n";
            break;
        }
        case FollowJointTrajectoryActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nFollowJointTrajectoryFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nHeader header\nstring[] joint_names\ntrajectory_msgs/JointTrajectoryPoint desired\ntrajectory_msgs/JointTrajectoryPoint actual\ntrajectory_msgs/JointTrajectoryPoint error\n\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n";
            break;
        }
        case FollowJointTrajectoryActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nFollowJointTrajectoryGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n# The joint trajectory to follow\ntrajectory_msgs/JointTrajectory trajectory\n\n# Tolerances for the trajectory.  If the measured joint values fall\n# outside the tolerances the trajectory goal is aborted.  Any\n# tolerances that are not specified (by being omitted or set to 0) are\n# set to the defaults for the action server (often taken from the\n# parameter server).\n\n# Tolerances applied to the joints as the trajectory is executed.  If\n# violated, the goal aborts with error_code set to\n# PATH_TOLERANCE_VIOLATED.\nJointTolerance[] path_tolerance\n\n# To report success, the joints must be within goal_tolerance of the\n# final trajectory value.  The goal must be achieved by time the\n# trajectory ends plus goal_time_tolerance.  (goal_time_tolerance\n# allows some leeway in time, so that the trajectory goal can still\n# succeed even if the joints reach the goal some time after the\n# precise end time of the trajectory).\n#\n# If the joints are not within goal_tolerance after \"trajectory finish\n# time\" + goal_time_tolerance, the goal aborts with error_code set to\n# GOAL_TOLERANCE_VIOLATED\nJointTolerance[] goal_tolerance\nduration goal_time_tolerance\n\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectory\nHeader header\nstring[] joint_names\nJointTrajectoryPoint[] points\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n\n================================================================================\nMSG: control_msgs/JointTolerance\n# The tolerances specify the amount the position, velocity, and\n# accelerations can vary from the setpoints.  For example, in the case\n# of trajectory control, when the actual position varies beyond\n# (desired position + position tolerance), the trajectory goal may\n# abort.\n# \n# There are two special values for tolerances:\n#  * 0 - The tolerance is unspecified and will remain at whatever the default is\n#  * -1 - The tolerance is \"erased\".  If there was a default, the joint will be\n#         allowed to move without restriction.\n\nstring name\nfloat64 position  # in radians or meters (for a revolute or prismatic joint, respectively)\nfloat64 velocity  # in rad/sec or m/sec\nfloat64 acceleration  # in rad/sec^2 or m/sec^2\n";
            break;
        }
        case FollowJointTrajectoryActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nFollowJointTrajectoryResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/FollowJointTrajectoryResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 error_code\nint32 SUCCESSFUL = 0\nint32 INVALID_GOAL = -1\nint32 INVALID_JOINTS = -2\nint32 OLD_HEADER_TIMESTAMP = -3\nint32 PATH_TOLERANCE_VIOLATED = -4\nint32 GOAL_TOLERANCE_VIOLATED = -5\n\n# Human readable description of the error code. Contains complementary\n# information that is especially useful when execution fails, for instance:\n# - INVALID_GOAL: The reason for the invalid goal (e.g., the requested\n#   trajectory is in the past).\n# - INVALID_JOINTS: The mismatch between the expected controller joints\n#   and those provided in the goal.\n# - PATH_TOLERANCE_VIOLATED and GOAL_TOLERANCE_VIOLATED: Which joint\n#   violated which tolerance, and by how much.\nstring error_string\n\n";
            break;
        }
        case FollowJointTrajectoryFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nHeader header\nstring[] joint_names\ntrajectory_msgs/JointTrajectoryPoint desired\ntrajectory_msgs/JointTrajectoryPoint actual\ntrajectory_msgs/JointTrajectoryPoint error\n\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n";
            break;
        }
        case FollowJointTrajectoryGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n# The joint trajectory to follow\ntrajectory_msgs/JointTrajectory trajectory\n\n# Tolerances for the trajectory.  If the measured joint values fall\n# outside the tolerances the trajectory goal is aborted.  Any\n# tolerances that are not specified (by being omitted or set to 0) are\n# set to the defaults for the action server (often taken from the\n# parameter server).\n\n# Tolerances applied to the joints as the trajectory is executed.  If\n# violated, the goal aborts with error_code set to\n# PATH_TOLERANCE_VIOLATED.\nJointTolerance[] path_tolerance\n\n# To report success, the joints must be within goal_tolerance of the\n# final trajectory value.  The goal must be achieved by time the\n# trajectory ends plus goal_time_tolerance.  (goal_time_tolerance\n# allows some leeway in time, so that the trajectory goal can still\n# succeed even if the joints reach the goal some time after the\n# precise end time of the trajectory).\n#\n# If the joints are not within goal_tolerance after \"trajectory finish\n# time\" + goal_time_tolerance, the goal aborts with error_code set to\n# GOAL_TOLERANCE_VIOLATED\nJointTolerance[] goal_tolerance\nduration goal_time_tolerance\n\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectory\nHeader header\nstring[] joint_names\nJointTrajectoryPoint[] points\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n\n================================================================================\nMSG: control_msgs/JointTolerance\n# The tolerances specify the amount the position, velocity, and\n# accelerations can vary from the setpoints.  For example, in the case\n# of trajectory control, when the actual position varies beyond\n# (desired position + position tolerance), the trajectory goal may\n# abort.\n# \n# There are two special values for tolerances:\n#  * 0 - The tolerance is unspecified and will remain at whatever the default is\n#  * -1 - The tolerance is \"erased\".  If there was a default, the joint will be\n#         allowed to move without restriction.\n\nstring name\nfloat64 position  # in radians or meters (for a revolute or prismatic joint, respectively)\nfloat64 velocity  # in rad/sec or m/sec\nfloat64 acceleration  # in rad/sec^2 or m/sec^2\n";
            break;
        }
        case FollowJointTrajectoryResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nint32 error_code\nint32 SUCCESSFUL = 0\nint32 INVALID_GOAL = -1\nint32 INVALID_JOINTS = -2\nint32 OLD_HEADER_TIMESTAMP = -3\nint32 PATH_TOLERANCE_VIOLATED = -4\nint32 GOAL_TOLERANCE_VIOLATED = -5\n\n# Human readable description of the error code. Contains complementary\n# information that is especially useful when execution fails, for instance:\n# - INVALID_GOAL: The reason for the invalid goal (e.g., the requested\n#   trajectory is in the past).\n# - INVALID_JOINTS: The mismatch between the expected controller joints\n#   and those provided in the goal.\n# - PATH_TOLERANCE_VIOLATED and GOAL_TOLERANCE_VIOLATED: Which joint\n#   violated which tolerance, and by how much.\nstring error_string\n\n";
            break;
        }
        case GripperCommand::ID:
        {
            str = "float64 position\nfloat64 max_effort\n";
            break;
        }
        case GripperCommandAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nGripperCommandActionGoal action_goal\nGripperCommandActionResult action_result\nGripperCommandActionFeedback action_feedback\n\n================================================================================\nMSG: control_msgs/GripperCommandActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nGripperCommandGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/GripperCommandGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nGripperCommand command\n\n================================================================================\nMSG: control_msgs/GripperCommand\nfloat64 position\nfloat64 max_effort\n\n================================================================================\nMSG: control_msgs/GripperCommandActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nGripperCommandResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: control_msgs/GripperCommandResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position  # The current gripper gap size (in meters)\nfloat64 effort    # The current effort exerted (in Newtons)\nbool stalled      # True iff the gripper is exerting max effort and not moving\nbool reached_goal # True iff the gripper position has reached the commanded setpoint\n\n================================================================================\nMSG: control_msgs/GripperCommandActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nGripperCommandFeedback feedback\n\n================================================================================\nMSG: control_msgs/GripperCommandFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position  # The current gripper gap size (in meters)\nfloat64 effort    # The current effort exerted (in Newtons)\nbool stalled      # True iff the gripper is exerting max effort and not moving\nbool reached_goal # True iff the gripper position has reached the commanded setpoint\n\n";
            break;
        }
        case GripperCommandActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nGripperCommandFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/GripperCommandFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position  # The current gripper gap size (in meters)\nfloat64 effort    # The current effort exerted (in Newtons)\nbool stalled      # True iff the gripper is exerting max effort and not moving\nbool reached_goal # True iff the gripper position has reached the commanded setpoint\n\n";
            break;
        }
        case GripperCommandActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nGripperCommandGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/GripperCommandGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nGripperCommand command\n\n================================================================================\nMSG: control_msgs/GripperCommand\nfloat64 position\nfloat64 max_effort\n";
            break;
        }
        case GripperCommandActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nGripperCommandResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/GripperCommandResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position  # The current gripper gap size (in meters)\nfloat64 effort    # The current effort exerted (in Newtons)\nbool stalled      # True iff the gripper is exerting max effort and not moving\nbool reached_goal # True iff the gripper position has reached the commanded setpoint\n";
            break;
        }
        case GripperCommandFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position  # The current gripper gap size (in meters)\nfloat64 effort    # The current effort exerted (in Newtons)\nbool stalled      # True iff the gripper is exerting max effort and not moving\nbool reached_goal # True iff the gripper position has reached the commanded setpoint\n\n";
            break;
        }
        case GripperCommandGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nGripperCommand command\n\n================================================================================\nMSG: control_msgs/GripperCommand\nfloat64 position\nfloat64 max_effort\n";
            break;
        }
        case GripperCommandResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position  # The current gripper gap size (in meters)\nfloat64 effort    # The current effort exerted (in Newtons)\nbool stalled      # True iff the gripper is exerting max effort and not moving\nbool reached_goal # True iff the gripper position has reached the commanded setpoint\n";
            break;
        }
        case JointControllerState::ID:
        {
            str = "Header header\nfloat64 set_point\nfloat64 process_value\nfloat64 process_value_dot\nfloat64 error\nfloat64 time_step\nfloat64 command\nfloat64 p\nfloat64 i\nfloat64 d\nfloat64 i_clamp\n\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n";
            break;
        }
        case JointTolerance::ID:
        {
            str = "# The tolerances specify the amount the position, velocity, and\n# accelerations can vary from the setpoints.  For example, in the case\n# of trajectory control, when the actual position varies beyond\n# (desired position + position tolerance), the trajectory goal may\n# abort.\n# \n# There are two special values for tolerances:\n#  * 0 - The tolerance is unspecified and will remain at whatever the default is\n#  * -1 - The tolerance is \"erased\".  If there was a default, the joint will be\n#         allowed to move without restriction.\n\nstring name\nfloat64 position  # in radians or meters (for a revolute or prismatic joint, respectively)\nfloat64 velocity  # in rad/sec or m/sec\nfloat64 acceleration  # in rad/sec^2 or m/sec^2\n";
            break;
        }
        case JointTrajectoryAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nJointTrajectoryActionGoal action_goal\nJointTrajectoryActionResult action_result\nJointTrajectoryActionFeedback action_feedback\n\n================================================================================\nMSG: control_msgs/JointTrajectoryActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nJointTrajectoryGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/JointTrajectoryGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\ntrajectory_msgs/JointTrajectory trajectory\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectory\nHeader header\nstring[] joint_names\nJointTrajectoryPoint[] points\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n\n================================================================================\nMSG: control_msgs/JointTrajectoryActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nJointTrajectoryResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: control_msgs/JointTrajectoryResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n================================================================================\nMSG: control_msgs/JointTrajectoryActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nJointTrajectoryFeedback feedback\n\n================================================================================\nMSG: control_msgs/JointTrajectoryFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case JointTrajectoryActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nJointTrajectoryFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/JointTrajectoryFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case JointTrajectoryActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nJointTrajectoryGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/JointTrajectoryGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\ntrajectory_msgs/JointTrajectory trajectory\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectory\nHeader header\nstring[] joint_names\nJointTrajectoryPoint[] points\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n";
            break;
        }
        case JointTrajectoryActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nJointTrajectoryResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/JointTrajectoryResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n";
            break;
        }
        case JointTrajectoryControllerState::ID:
        {
            str = "Header header\nstring[] joint_names\ntrajectory_msgs/JointTrajectoryPoint desired\ntrajectory_msgs/JointTrajectoryPoint actual\ntrajectory_msgs/JointTrajectoryPoint error  # Redundant, but useful\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n";
            break;
        }
        case JointTrajectoryFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n";
            break;
        }
        case JointTrajectoryGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\ntrajectory_msgs/JointTrajectory trajectory\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectory\nHeader header\nstring[] joint_names\nJointTrajectoryPoint[] points\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: trajectory_msgs/JointTrajectoryPoint\n# Each trajectory point specifies either positions[, velocities[, accelerations]]\n# or positions[, effort] for the trajectory to be executed.\n# All specified values are in the same order as the joint names in JointTrajectory.msg\n\nfloat64[] positions\nfloat64[] velocities\nfloat64[] accelerations\nfloat64[] effort\nduration time_from_start\n";
            break;
        }
        case JointTrajectoryResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n";
            break;
        }
        case PointHeadAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nPointHeadActionGoal action_goal\nPointHeadActionResult action_result\nPointHeadActionFeedback action_feedback\n\n================================================================================\nMSG: control_msgs/PointHeadActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nPointHeadGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/PointHeadGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\ngeometry_msgs/PointStamped target\ngeometry_msgs/Vector3 pointing_axis\nstring pointing_frame\nduration min_duration\nfloat64 max_velocity\n\n================================================================================\nMSG: geometry_msgs/PointStamped\n# This represents a Point with reference coordinate frame and timestamp\nHeader header\nPoint point\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\nfloat64 z\n================================================================================\nMSG: control_msgs/PointHeadActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nPointHeadResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: control_msgs/PointHeadResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n================================================================================\nMSG: control_msgs/PointHeadActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nPointHeadFeedback feedback\n\n================================================================================\nMSG: control_msgs/PointHeadFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 pointing_angle_error\n\n";
            break;
        }
        case PointHeadActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nPointHeadFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/PointHeadFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 pointing_angle_error\n\n";
            break;
        }
        case PointHeadActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nPointHeadGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/PointHeadGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\ngeometry_msgs/PointStamped target\ngeometry_msgs/Vector3 pointing_axis\nstring pointing_frame\nduration min_duration\nfloat64 max_velocity\n\n================================================================================\nMSG: geometry_msgs/PointStamped\n# This represents a Point with reference coordinate frame and timestamp\nHeader header\nPoint point\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case PointHeadActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nPointHeadResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/PointHeadResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n";
            break;
        }
        case PointHeadFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 pointing_angle_error\n\n";
            break;
        }
        case PointHeadGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\ngeometry_msgs/PointStamped target\ngeometry_msgs/Vector3 pointing_axis\nstring pointing_frame\nduration min_duration\nfloat64 max_velocity\n\n================================================================================\nMSG: geometry_msgs/PointStamped\n# This represents a Point with reference coordinate frame and timestamp\nHeader header\nPoint point\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case PointHeadResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n";
            break;
        }
        case SingleJointPositionAction::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nSingleJointPositionActionGoal action_goal\nSingleJointPositionActionResult action_result\nSingleJointPositionActionFeedback action_feedback\n\n================================================================================\nMSG: control_msgs/SingleJointPositionActionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nSingleJointPositionGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/SingleJointPositionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position\nduration min_duration\nfloat64 max_velocity\n\n================================================================================\nMSG: control_msgs/SingleJointPositionActionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nSingleJointPositionResult result\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: control_msgs/SingleJointPositionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\n================================================================================\nMSG: control_msgs/SingleJointPositionActionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nSingleJointPositionFeedback feedback\n\n================================================================================\nMSG: control_msgs/SingleJointPositionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nHeader header\nfloat64 position\nfloat64 velocity\nfloat64 error\n\n";
            break;
        }
        case SingleJointPositionActionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nSingleJointPositionFeedback feedback\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/SingleJointPositionFeedback\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nHeader header\nfloat64 position\nfloat64 velocity\nfloat64 error\n\n";
            break;
        }
        case SingleJointPositionActionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalID goal_id\nSingleJointPositionGoal goal\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/SingleJointPositionGoal\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position\nduration min_duration\nfloat64 max_velocity\n";
            break;
        }
        case SingleJointPositionActionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\nHeader header\nactionlib_msgs/GoalStatus status\nSingleJointPositionResult result\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: actionlib_msgs/GoalStatus\nGoalID goal_id\nuint8 status\nuint8 PENDING         = 0   # The goal has yet to be processed by the action server\nuint8 ACTIVE          = 1   # The goal is currently being processed by the action server\nuint8 PREEMPTED       = 2   # The goal received a cancel request after it started executing\n                            #   and has since completed its execution (Terminal State)\nuint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)\nuint8 ABORTED         = 4   # The goal was aborted during execution by the action server due\n                            #    to some failure (Terminal State)\nuint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,\n                            #    because the goal was unattainable or invalid (Terminal State)\nuint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing\n                            #    and has not yet completed execution\nuint8 RECALLING       = 7   # The goal received a cancel request before it started executing,\n                            #    but the action server has not yet confirmed that the goal is canceled\nuint8 RECALLED        = 8   # The goal received a cancel request before it started executing\n                            #    and was successfully cancelled (Terminal State)\nuint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be\n                            #    sent over the wire by an action server\n\n#Allow for the user to associate a string with GoalStatus for debugging\nstring text\n\n\n================================================================================\nMSG: actionlib_msgs/GoalID\n# The stamp should store the time at which this goal was requested.\n# It is used by an action server when it tries to preempt all\n# goals that were requested before a certain time\ntime stamp\n\n# The id provides a way to associate feedback and\n# result message with specific goal requests. The id\n# specified must be unique.\nstring id\n\n\n================================================================================\nMSG: control_msgs/SingleJointPositionResult\n# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n";
            break;
        }
        case SingleJointPositionFeedback::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nHeader header\nfloat64 position\nfloat64 velocity\nfloat64 error\n\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n";
            break;
        }
        case SingleJointPositionGoal::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\nfloat64 position\nduration min_duration\nfloat64 max_velocity\n";
            break;
        }
        case SingleJointPositionResult::ID:
        {
            str = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n";
            break;
        }
        case QueryCalibrationStateRequest::ID:
        {
            str = QueryCalibrationStateRequest::XML_SOURCE;
            break;
        }
        case QueryCalibrationStateResponse::ID:
        {
            str = QueryCalibrationStateResponse::XML_SOURCE;
            break;
        }
        case QueryCalibrationState::ID:
        {
            str = QueryCalibrationState::XML_SOURCE;
            break;
        }
        case QueryTrajectoryStateRequest::ID:
        {
            str = QueryTrajectoryStateRequest::XML_SOURCE;
            break;
        }
        case QueryTrajectoryStateResponse::ID:
        {
            str = QueryTrajectoryStateResponse::XML_SOURCE;
            break;
        }
        case QueryTrajectoryState::ID:
        {
            str = QueryTrajectoryState::XML_SOURCE;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case FollowJointTrajectoryAction::ID:
        {
            str = "bc4f9b743838566551c0390c65f1a248";
            break;
        }
        case FollowJointTrajectoryActionFeedback::ID:
        {
            str = "d8920dc4eae9fc107e00999cce4be641";
            break;
        }
        case FollowJointTrajectoryActionGoal::ID:
        {
            str = "cff5c1d533bf2f82dd0138d57f4304bb";
            break;
        }
        case FollowJointTrajectoryActionResult::ID:
        {
            str = "c4fb3b000dc9da4fd99699380efcc5d9";
            break;
        }
        case FollowJointTrajectoryFeedback::ID:
        {
            str = "10817c60c2486ef6b33e97dcd87f4474";
            break;
        }
        case FollowJointTrajectoryGoal::ID:
        {
            str = "69636787b6ecbde4d61d711979bc7ecb";
            break;
        }
        case FollowJointTrajectoryResult::ID:
        {
            str = "493383b18409bfb604b4e26c676401d2";
            break;
        }
        case GripperCommand::ID:
        {
            str = "680acaff79486f017132a7f198d40f08";
            break;
        }
        case GripperCommandAction::ID:
        {
            str = "950b2a6ebe831f5d4f4ceaba3d8be01e";
            break;
        }
        case GripperCommandActionFeedback::ID:
        {
            str = "653dff30c045f5e6ff3feb3409f4558d";
            break;
        }
        case GripperCommandActionGoal::ID:
        {
            str = "aa581f648a35ed681db2ec0bf7a82bea";
            break;
        }
        case GripperCommandActionResult::ID:
        {
            str = "143702cb2df0f163c5283cedc5efc6b6";
            break;
        }
        case GripperCommandFeedback::ID:
        {
            str = "e4cbff56d3562bcf113da5a5adeef91f";
            break;
        }
        case GripperCommandGoal::ID:
        {
            str = "86fd82f4ddc48a4cb6856cfa69217e43";
            break;
        }
        case GripperCommandResult::ID:
        {
            str = "e4cbff56d3562bcf113da5a5adeef91f";
            break;
        }
        case JointControllerState::ID:
        {
            str = "c0d034a7bf20aeb1c37f3eccb7992b69";
            break;
        }
        case JointTolerance::ID:
        {
            str = "f544fe9c16cf04547e135dd6063ff5be";
            break;
        }
        case JointTrajectoryAction::ID:
        {
            str = "a04ba3ee8f6a2d0985a6aeaf23d9d7ad";
            break;
        }
        case JointTrajectoryActionFeedback::ID:
        {
            str = "aae20e09065c3809e8a8e87c4c8953fd";
            break;
        }
        case JointTrajectoryActionGoal::ID:
        {
            str = "a99e83ef6185f9fdd7693efe99623a86";
            break;
        }
        case JointTrajectoryActionResult::ID:
        {
            str = "1eb06eeff08fa7ea874431638cb52332";
            break;
        }
        case JointTrajectoryControllerState::ID:
        {
            str = "10817c60c2486ef6b33e97dcd87f4474";
            break;
        }
        case JointTrajectoryFeedback::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case JointTrajectoryGoal::ID:
        {
            str = "2a0eff76c870e8595636c2a562ca298e";
            break;
        }
        case JointTrajectoryResult::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case PointHeadAction::ID:
        {
            str = "7252920f1243de1b741f14f214125371";
            break;
        }
        case PointHeadActionFeedback::ID:
        {
            str = "33c9244957176bbba97dd641119e8460";
            break;
        }
        case PointHeadActionGoal::ID:
        {
            str = "b53a8323d0ba7b310ba17a2d3a82a6b8";
            break;
        }
        case PointHeadActionResult::ID:
        {
            str = "1eb06eeff08fa7ea874431638cb52332";
            break;
        }
        case PointHeadFeedback::ID:
        {
            str = "cce80d27fd763682da8805a73316cab4";
            break;
        }
        case PointHeadGoal::ID:
        {
            str = "8b92b1cd5e06c8a94c917dc3209a4c1d";
            break;
        }
        case PointHeadResult::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SingleJointPositionAction::ID:
        {
            str = "c4a786b7d53e5d0983decf967a5a779e";
            break;
        }
        case SingleJointPositionActionFeedback::ID:
        {
            str = "3503b7cf8972f90d245850a5d8796cfa";
            break;
        }
        case SingleJointPositionActionGoal::ID:
        {
            str = "4b0d3d091471663e17749c1d0db90f61";
            break;
        }
        case SingleJointPositionActionResult::ID:
        {
            str = "1eb06eeff08fa7ea874431638cb52332";
            break;
        }
        case SingleJointPositionFeedback::ID:
        {
            str = "8cee65610a3d08e0a1bded82f146f1fd";
            break;
        }
        case SingleJointPositionGoal::ID:
        {
            str = "fbaaa562a23a013fd5053e5f72cbb35c";
            break;
        }
        case SingleJointPositionResult::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case QueryCalibrationStateRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case QueryCalibrationStateResponse::ID:
        {
            str = "28af3beedcb84986b8e470dc5470507d";
            break;
        }
        case QueryCalibrationState::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case QueryTrajectoryStateRequest::ID:
        {
            str = "556a4fb76023a469987922359d08a844";
            break;
        }
        case QueryTrajectoryStateResponse::ID:
        {
            str = "1f1a6554ad060f44d013e71868403c1a";
            break;
        }
        case QueryTrajectoryState::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case FollowJointTrajectoryAction::ID:
        {   
		    highOrder = 0xbc4f9b7438385665ULL;
            lowOrder = 0x51c0390c65f1a248ULL;
            break;
        }
        case FollowJointTrajectoryActionFeedback::ID:
        {   
		    highOrder = 0xd8920dc4eae9fc10ULL;
            lowOrder = 0x7e00999cce4be641ULL;
            break;
        }
        case FollowJointTrajectoryActionGoal::ID:
        {   
		    highOrder = 0xcff5c1d533bf2f82ULL;
            lowOrder = 0xdd0138d57f4304bbULL;
            break;
        }
        case FollowJointTrajectoryActionResult::ID:
        {   
		    highOrder = 0xc4fb3b000dc9da4fULL;
            lowOrder = 0xd99699380efcc5d9ULL;
            break;
        }
        case FollowJointTrajectoryFeedback::ID:
        {   
		    highOrder = 0x10817c60c2486ef6ULL;
            lowOrder = 0xb33e97dcd87f4474ULL;
            break;
        }
        case FollowJointTrajectoryGoal::ID:
        {   
		    highOrder = 0x69636787b6ecbde4ULL;
            lowOrder = 0xd61d711979bc7ecbULL;
            break;
        }
        case FollowJointTrajectoryResult::ID:
        {   
		    highOrder = 0x493383b18409bfb6ULL;
            lowOrder = 0x04b4e26c676401d2ULL;
            break;
        }
        case GripperCommand::ID:
        {   
		    highOrder = 0x680acaff79486f01ULL;
            lowOrder = 0x7132a7f198d40f08ULL;
            break;
        }
        case GripperCommandAction::ID:
        {   
		    highOrder = 0x950b2a6ebe831f5dULL;
            lowOrder = 0x4f4ceaba3d8be01eULL;
            break;
        }
        case GripperCommandActionFeedback::ID:
        {   
		    highOrder = 0x653dff30c045f5e6ULL;
            lowOrder = 0xff3feb3409f4558dULL;
            break;
        }
        case GripperCommandActionGoal::ID:
        {   
		    highOrder = 0xaa581f648a35ed68ULL;
            lowOrder = 0x1db2ec0bf7a82beaULL;
            break;
        }
        case GripperCommandActionResult::ID:
        {   
		    highOrder = 0x143702cb2df0f163ULL;
            lowOrder = 0xc5283cedc5efc6b6ULL;
            break;
        }
        case GripperCommandFeedback::ID:
        {   
		    highOrder = 0xe4cbff56d3562bcfULL;
            lowOrder = 0x113da5a5adeef91fULL;
            break;
        }
        case GripperCommandGoal::ID:
        {   
		    highOrder = 0x86fd82f4ddc48a4cULL;
            lowOrder = 0xb6856cfa69217e43ULL;
            break;
        }
        case GripperCommandResult::ID:
        {   
		    highOrder = 0xe4cbff56d3562bcfULL;
            lowOrder = 0x113da5a5adeef91fULL;
            break;
        }
        case JointControllerState::ID:
        {   
		    highOrder = 0xc0d034a7bf20aeb1ULL;
            lowOrder = 0xc37f3eccb7992b69ULL;
            break;
        }
        case JointTolerance::ID:
        {   
		    highOrder = 0xf544fe9c16cf0454ULL;
            lowOrder = 0x7e135dd6063ff5beULL;
            break;
        }
        case JointTrajectoryAction::ID:
        {   
		    highOrder = 0xa04ba3ee8f6a2d09ULL;
            lowOrder = 0x85a6aeaf23d9d7adULL;
            break;
        }
        case JointTrajectoryActionFeedback::ID:
        {   
		    highOrder = 0xaae20e09065c3809ULL;
            lowOrder = 0xe8a8e87c4c8953fdULL;
            break;
        }
        case JointTrajectoryActionGoal::ID:
        {   
		    highOrder = 0xa99e83ef6185f9fdULL;
            lowOrder = 0xd7693efe99623a86ULL;
            break;
        }
        case JointTrajectoryActionResult::ID:
        {   
		    highOrder = 0x1eb06eeff08fa7eaULL;
            lowOrder = 0x874431638cb52332ULL;
            break;
        }
        case JointTrajectoryControllerState::ID:
        {   
		    highOrder = 0x10817c60c2486ef6ULL;
            lowOrder = 0xb33e97dcd87f4474ULL;
            break;
        }
        case JointTrajectoryFeedback::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case JointTrajectoryGoal::ID:
        {   
		    highOrder = 0x2a0eff76c870e859ULL;
            lowOrder = 0x5636c2a562ca298eULL;
            break;
        }
        case JointTrajectoryResult::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case PointHeadAction::ID:
        {   
		    highOrder = 0x7252920f1243de1bULL;
            lowOrder = 0x741f14f214125371ULL;
            break;
        }
        case PointHeadActionFeedback::ID:
        {   
		    highOrder = 0x33c9244957176bbbULL;
            lowOrder = 0xa97dd641119e8460ULL;
            break;
        }
        case PointHeadActionGoal::ID:
        {   
		    highOrder = 0xb53a8323d0ba7b31ULL;
            lowOrder = 0x0ba17a2d3a82a6b8ULL;
            break;
        }
        case PointHeadActionResult::ID:
        {   
		    highOrder = 0x1eb06eeff08fa7eaULL;
            lowOrder = 0x874431638cb52332ULL;
            break;
        }
        case PointHeadFeedback::ID:
        {   
		    highOrder = 0xcce80d27fd763682ULL;
            lowOrder = 0xda8805a73316cab4ULL;
            break;
        }
        case PointHeadGoal::ID:
        {   
		    highOrder = 0x8b92b1cd5e06c8a9ULL;
            lowOrder = 0x4c917dc3209a4c1dULL;
            break;
        }
        case PointHeadResult::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SingleJointPositionAction::ID:
        {   
		    highOrder = 0xc4a786b7d53e5d09ULL;
            lowOrder = 0x83decf967a5a779eULL;
            break;
        }
        case SingleJointPositionActionFeedback::ID:
        {   
		    highOrder = 0x3503b7cf8972f90dULL;
            lowOrder = 0x245850a5d8796cfaULL;
            break;
        }
        case SingleJointPositionActionGoal::ID:
        {   
		    highOrder = 0x4b0d3d091471663eULL;
            lowOrder = 0x17749c1d0db90f61ULL;
            break;
        }
        case SingleJointPositionActionResult::ID:
        {   
		    highOrder = 0x1eb06eeff08fa7eaULL;
            lowOrder = 0x874431638cb52332ULL;
            break;
        }
        case SingleJointPositionFeedback::ID:
        {   
		    highOrder = 0x8cee65610a3d08e0ULL;
            lowOrder = 0xa1bded82f146f1fdULL;
            break;
        }
        case SingleJointPositionGoal::ID:
        {   
		    highOrder = 0xfbaaa562a23a013fULL;
            lowOrder = 0xd5053e5f72cbb35cULL;
            break;
        }
        case SingleJointPositionResult::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case QueryCalibrationStateRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case QueryCalibrationStateResponse::ID:
        {   
		    highOrder = 0x28af3beedcb84986ULL;
            lowOrder = 0xb8e470dc5470507dULL;
            break;
        }
        case QueryCalibrationState::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case QueryTrajectoryStateRequest::ID:
        {   
		    highOrder = 0x556a4fb76023a469ULL;
            lowOrder = 0x987922359d08a844ULL;
            break;
        }
        case QueryTrajectoryStateResponse::ID:
        {   
		    highOrder = 0x1f1a6554ad060f44ULL;
            lowOrder = 0xd013e71868403c1aULL;
            break;
        }
        case QueryTrajectoryState::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case FollowJointTrajectoryAction::ID:
        case FollowJointTrajectoryActionFeedback::ID:
        case FollowJointTrajectoryActionGoal::ID:
        case FollowJointTrajectoryActionResult::ID:
        case FollowJointTrajectoryFeedback::ID:
        case FollowJointTrajectoryGoal::ID:
        case FollowJointTrajectoryResult::ID:
        case GripperCommand::ID:
        case GripperCommandAction::ID:
        case GripperCommandActionFeedback::ID:
        case GripperCommandActionGoal::ID:
        case GripperCommandActionResult::ID:
        case GripperCommandFeedback::ID:
        case GripperCommandGoal::ID:
        case GripperCommandResult::ID:
        case JointControllerState::ID:
        case JointTolerance::ID:
        case JointTrajectoryAction::ID:
        case JointTrajectoryActionFeedback::ID:
        case JointTrajectoryActionGoal::ID:
        case JointTrajectoryActionResult::ID:
        case JointTrajectoryControllerState::ID:
        case JointTrajectoryFeedback::ID:
        case JointTrajectoryGoal::ID:
        case JointTrajectoryResult::ID:
        case PointHeadAction::ID:
        case PointHeadActionFeedback::ID:
        case PointHeadActionGoal::ID:
        case PointHeadActionResult::ID:
        case PointHeadFeedback::ID:
        case PointHeadGoal::ID:
        case PointHeadResult::ID:
        case SingleJointPositionAction::ID:
        case SingleJointPositionActionFeedback::ID:
        case SingleJointPositionActionGoal::ID:
        case SingleJointPositionActionResult::ID:
        case SingleJointPositionFeedback::ID:
        case SingleJointPositionGoal::ID:
        case SingleJointPositionResult::ID:
        case QueryCalibrationStateRequest::ID:
        case QueryCalibrationStateResponse::ID:
        case QueryCalibrationState::ID:
        case QueryTrajectoryStateRequest::ID:
        case QueryTrajectoryStateResponse::ID:
        case QueryTrajectoryState::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case FollowJointTrajectoryAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryAction>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryActionFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryActionGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryActionResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case FollowJointTrajectoryResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<FollowJointTrajectoryResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommand::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommand>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandAction>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandActionFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandActionGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandActionResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GripperCommandResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GripperCommandResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointControllerState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointControllerState>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTolerance::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTolerance>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryAction>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryActionFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryActionGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryActionResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryControllerState>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointTrajectoryResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointTrajectoryResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadAction>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadActionFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadActionGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadActionResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case PointHeadResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<PointHeadResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionAction::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionAction>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionActionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionActionFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionActionGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionActionResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionFeedback>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionGoal::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionGoal>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SingleJointPositionResult::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SingleJointPositionResult>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryCalibrationStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryCalibrationStateRequest>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryCalibrationStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryCalibrationStateResponse>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryCalibrationState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryCalibrationState>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryTrajectoryStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryTrajectoryStateRequest>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryTrajectoryStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryTrajectoryStateResponse>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case QueryTrajectoryState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<QueryTrajectoryState>(),std::bind(&control_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case FollowJointTrajectoryAction::ID:
            {
                Message<FollowJointTrajectoryAction > & tempSrc = static_cast<Message<FollowJointTrajectoryAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case FollowJointTrajectoryActionFeedback::ID:
            {
                Message<FollowJointTrajectoryActionFeedback > & tempSrc = static_cast<Message<FollowJointTrajectoryActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case FollowJointTrajectoryActionGoal::ID:
            {
                Message<FollowJointTrajectoryActionGoal > & tempSrc = static_cast<Message<FollowJointTrajectoryActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case FollowJointTrajectoryActionResult::ID:
            {
                Message<FollowJointTrajectoryActionResult > & tempSrc = static_cast<Message<FollowJointTrajectoryActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case FollowJointTrajectoryFeedback::ID:
            {
                Message<FollowJointTrajectoryFeedback > & tempSrc = static_cast<Message<FollowJointTrajectoryFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case FollowJointTrajectoryGoal::ID:
            {
                Message<FollowJointTrajectoryGoal > & tempSrc = static_cast<Message<FollowJointTrajectoryGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case FollowJointTrajectoryResult::ID:
            {
                Message<FollowJointTrajectoryResult > & tempSrc = static_cast<Message<FollowJointTrajectoryResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::FollowJointTrajectoryResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommand::ID:
            {
                Message<GripperCommand > & tempSrc = static_cast<Message<GripperCommand>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommand buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandAction::ID:
            {
                Message<GripperCommandAction > & tempSrc = static_cast<Message<GripperCommandAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandActionFeedback::ID:
            {
                Message<GripperCommandActionFeedback > & tempSrc = static_cast<Message<GripperCommandActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandActionGoal::ID:
            {
                Message<GripperCommandActionGoal > & tempSrc = static_cast<Message<GripperCommandActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandActionResult::ID:
            {
                Message<GripperCommandActionResult > & tempSrc = static_cast<Message<GripperCommandActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandFeedback::ID:
            {
                Message<GripperCommandFeedback > & tempSrc = static_cast<Message<GripperCommandFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandGoal::ID:
            {
                Message<GripperCommandGoal > & tempSrc = static_cast<Message<GripperCommandGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GripperCommandResult::ID:
            {
                Message<GripperCommandResult > & tempSrc = static_cast<Message<GripperCommandResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::GripperCommandResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointControllerState::ID:
            {
                Message<JointControllerState > & tempSrc = static_cast<Message<JointControllerState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointControllerState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTolerance::ID:
            {
                Message<JointTolerance > & tempSrc = static_cast<Message<JointTolerance>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTolerance buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryAction::ID:
            {
                Message<JointTrajectoryAction > & tempSrc = static_cast<Message<JointTrajectoryAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryActionFeedback::ID:
            {
                Message<JointTrajectoryActionFeedback > & tempSrc = static_cast<Message<JointTrajectoryActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryActionGoal::ID:
            {
                Message<JointTrajectoryActionGoal > & tempSrc = static_cast<Message<JointTrajectoryActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryActionResult::ID:
            {
                Message<JointTrajectoryActionResult > & tempSrc = static_cast<Message<JointTrajectoryActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryControllerState::ID:
            {
                Message<JointTrajectoryControllerState > & tempSrc = static_cast<Message<JointTrajectoryControllerState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryControllerState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryFeedback::ID:
            {
                Message<JointTrajectoryFeedback > & tempSrc = static_cast<Message<JointTrajectoryFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryGoal::ID:
            {
                Message<JointTrajectoryGoal > & tempSrc = static_cast<Message<JointTrajectoryGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointTrajectoryResult::ID:
            {
                Message<JointTrajectoryResult > & tempSrc = static_cast<Message<JointTrajectoryResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::JointTrajectoryResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadAction::ID:
            {
                Message<PointHeadAction > & tempSrc = static_cast<Message<PointHeadAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadActionFeedback::ID:
            {
                Message<PointHeadActionFeedback > & tempSrc = static_cast<Message<PointHeadActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadActionGoal::ID:
            {
                Message<PointHeadActionGoal > & tempSrc = static_cast<Message<PointHeadActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadActionResult::ID:
            {
                Message<PointHeadActionResult > & tempSrc = static_cast<Message<PointHeadActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadFeedback::ID:
            {
                Message<PointHeadFeedback > & tempSrc = static_cast<Message<PointHeadFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadGoal::ID:
            {
                Message<PointHeadGoal > & tempSrc = static_cast<Message<PointHeadGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case PointHeadResult::ID:
            {
                Message<PointHeadResult > & tempSrc = static_cast<Message<PointHeadResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::PointHeadResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionAction::ID:
            {
                Message<SingleJointPositionAction > & tempSrc = static_cast<Message<SingleJointPositionAction>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionAction buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionActionFeedback::ID:
            {
                Message<SingleJointPositionActionFeedback > & tempSrc = static_cast<Message<SingleJointPositionActionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionActionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionActionGoal::ID:
            {
                Message<SingleJointPositionActionGoal > & tempSrc = static_cast<Message<SingleJointPositionActionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionActionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionActionResult::ID:
            {
                Message<SingleJointPositionActionResult > & tempSrc = static_cast<Message<SingleJointPositionActionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionActionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionFeedback::ID:
            {
                Message<SingleJointPositionFeedback > & tempSrc = static_cast<Message<SingleJointPositionFeedback>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionFeedback buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionGoal::ID:
            {
                Message<SingleJointPositionGoal > & tempSrc = static_cast<Message<SingleJointPositionGoal>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionGoal buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SingleJointPositionResult::ID:
            {
                Message<SingleJointPositionResult > & tempSrc = static_cast<Message<SingleJointPositionResult>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::SingleJointPositionResult buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QueryCalibrationStateRequest::ID:
            {
                Message<QueryCalibrationStateRequest > & tempSrc = static_cast<Message<QueryCalibrationStateRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::QueryCalibrationStateRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QueryCalibrationStateResponse::ID:
            {
                Message<QueryCalibrationStateResponse > & tempSrc = static_cast<Message<QueryCalibrationStateResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::QueryCalibrationStateResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QueryCalibrationState::ID:
            {
                Message<QueryCalibrationState > & tempSrc = static_cast<Message<QueryCalibrationState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::QueryCalibrationState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QueryTrajectoryStateRequest::ID:
            {
                Message<QueryTrajectoryStateRequest > & tempSrc = static_cast<Message<QueryTrajectoryStateRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::QueryTrajectoryStateRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QueryTrajectoryStateResponse::ID:
            {
                Message<QueryTrajectoryStateResponse > & tempSrc = static_cast<Message<QueryTrajectoryStateResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::QueryTrajectoryStateResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case QueryTrajectoryState::ID:
            {
                Message<QueryTrajectoryState > & tempSrc = static_cast<Message<QueryTrajectoryState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: control_msgs_gencpp::QueryTrajectoryState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case FollowJointTrajectoryAction::ID:
            {
                Message<FollowJointTrajectoryAction > & tempDst = static_cast<Message<FollowJointTrajectoryAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case FollowJointTrajectoryActionFeedback::ID:
            {
                Message<FollowJointTrajectoryActionFeedback > & tempDst = static_cast<Message<FollowJointTrajectoryActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case FollowJointTrajectoryActionGoal::ID:
            {
                Message<FollowJointTrajectoryActionGoal > & tempDst = static_cast<Message<FollowJointTrajectoryActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case FollowJointTrajectoryActionResult::ID:
            {
                Message<FollowJointTrajectoryActionResult > & tempDst = static_cast<Message<FollowJointTrajectoryActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case FollowJointTrajectoryFeedback::ID:
            {
                Message<FollowJointTrajectoryFeedback > & tempDst = static_cast<Message<FollowJointTrajectoryFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case FollowJointTrajectoryGoal::ID:
            {
                Message<FollowJointTrajectoryGoal > & tempDst = static_cast<Message<FollowJointTrajectoryGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case FollowJointTrajectoryResult::ID:
            {
                Message<FollowJointTrajectoryResult > & tempDst = static_cast<Message<FollowJointTrajectoryResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GripperCommand::ID:
            {
                Message<GripperCommand > & tempDst = static_cast<Message<GripperCommand>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GripperCommandAction::ID:
            {
                Message<GripperCommandAction > & tempDst = static_cast<Message<GripperCommandAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GripperCommandActionFeedback::ID:
            {
                Message<GripperCommandActionFeedback > & tempDst = static_cast<Message<GripperCommandActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case GripperCommandActionGoal::ID:
            {
                Message<GripperCommandActionGoal > & tempDst = static_cast<Message<GripperCommandActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case GripperCommandActionResult::ID:
            {
                Message<GripperCommandActionResult > & tempDst = static_cast<Message<GripperCommandActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case GripperCommandFeedback::ID:
            {
                Message<GripperCommandFeedback > & tempDst = static_cast<Message<GripperCommandFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GripperCommandGoal::ID:
            {
                Message<GripperCommandGoal > & tempDst = static_cast<Message<GripperCommandGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GripperCommandResult::ID:
            {
                Message<GripperCommandResult > & tempDst = static_cast<Message<GripperCommandResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointControllerState::ID:
            {
                Message<JointControllerState > & tempDst = static_cast<Message<JointControllerState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case JointTolerance::ID:
            {
                Message<JointTolerance > & tempDst = static_cast<Message<JointTolerance>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointTrajectoryAction::ID:
            {
                Message<JointTrajectoryAction > & tempDst = static_cast<Message<JointTrajectoryAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointTrajectoryActionFeedback::ID:
            {
                Message<JointTrajectoryActionFeedback > & tempDst = static_cast<Message<JointTrajectoryActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case JointTrajectoryActionGoal::ID:
            {
                Message<JointTrajectoryActionGoal > & tempDst = static_cast<Message<JointTrajectoryActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case JointTrajectoryActionResult::ID:
            {
                Message<JointTrajectoryActionResult > & tempDst = static_cast<Message<JointTrajectoryActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case JointTrajectoryControllerState::ID:
            {
                Message<JointTrajectoryControllerState > & tempDst = static_cast<Message<JointTrajectoryControllerState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case JointTrajectoryFeedback::ID:
            {
                Message<JointTrajectoryFeedback > & tempDst = static_cast<Message<JointTrajectoryFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointTrajectoryGoal::ID:
            {
                Message<JointTrajectoryGoal > & tempDst = static_cast<Message<JointTrajectoryGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointTrajectoryResult::ID:
            {
                Message<JointTrajectoryResult > & tempDst = static_cast<Message<JointTrajectoryResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PointHeadAction::ID:
            {
                Message<PointHeadAction > & tempDst = static_cast<Message<PointHeadAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PointHeadActionFeedback::ID:
            {
                Message<PointHeadActionFeedback > & tempDst = static_cast<Message<PointHeadActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case PointHeadActionGoal::ID:
            {
                Message<PointHeadActionGoal > & tempDst = static_cast<Message<PointHeadActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case PointHeadActionResult::ID:
            {
                Message<PointHeadActionResult > & tempDst = static_cast<Message<PointHeadActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case PointHeadFeedback::ID:
            {
                Message<PointHeadFeedback > & tempDst = static_cast<Message<PointHeadFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PointHeadGoal::ID:
            {
                Message<PointHeadGoal > & tempDst = static_cast<Message<PointHeadGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case PointHeadResult::ID:
            {
                Message<PointHeadResult > & tempDst = static_cast<Message<PointHeadResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SingleJointPositionAction::ID:
            {
                Message<SingleJointPositionAction > & tempDst = static_cast<Message<SingleJointPositionAction>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SingleJointPositionActionFeedback::ID:
            {
                Message<SingleJointPositionActionFeedback > & tempDst = static_cast<Message<SingleJointPositionActionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case SingleJointPositionActionGoal::ID:
            {
                Message<SingleJointPositionActionGoal > & tempDst = static_cast<Message<SingleJointPositionActionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case SingleJointPositionActionResult::ID:
            {
                Message<SingleJointPositionActionResult > & tempDst = static_cast<Message<SingleJointPositionActionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case SingleJointPositionFeedback::ID:
            {
                Message<SingleJointPositionFeedback > & tempDst = static_cast<Message<SingleJointPositionFeedback>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case SingleJointPositionGoal::ID:
            {
                Message<SingleJointPositionGoal > & tempDst = static_cast<Message<SingleJointPositionGoal>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SingleJointPositionResult::ID:
            {
                Message<SingleJointPositionResult > & tempDst = static_cast<Message<SingleJointPositionResult>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QueryCalibrationStateRequest::ID:
            {
                Message<QueryCalibrationStateRequest > & tempDst = static_cast<Message<QueryCalibrationStateRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QueryCalibrationStateResponse::ID:
            {
                Message<QueryCalibrationStateResponse > & tempDst = static_cast<Message<QueryCalibrationStateResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QueryCalibrationState::ID:
            {
                Message<QueryCalibrationState > & tempDst = static_cast<Message<QueryCalibrationState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QueryTrajectoryStateRequest::ID:
            {
                Message<QueryTrajectoryStateRequest > & tempDst = static_cast<Message<QueryTrajectoryStateRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QueryTrajectoryStateResponse::ID:
            {
                Message<QueryTrajectoryStateResponse > & tempDst = static_cast<Message<QueryTrajectoryStateResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case QueryTrajectoryState::ID:
            {
                Message<QueryTrajectoryState > & tempDst = static_cast<Message<QueryTrajectoryState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int control_msgs_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // FollowJointTrajectoryAction does not have a Header as its first member 
        case FollowJointTrajectoryActionFeedback::ID:
        {
            Message<FollowJointTrajectoryActionFeedback > & tempMsg = static_cast<Message<FollowJointTrajectoryActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case FollowJointTrajectoryActionGoal::ID:
        {
            Message<FollowJointTrajectoryActionGoal > & tempMsg = static_cast<Message<FollowJointTrajectoryActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case FollowJointTrajectoryActionResult::ID:
        {
            Message<FollowJointTrajectoryActionResult > & tempMsg = static_cast<Message<FollowJointTrajectoryActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case FollowJointTrajectoryFeedback::ID:
        {
            Message<FollowJointTrajectoryFeedback > & tempMsg = static_cast<Message<FollowJointTrajectoryFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // FollowJointTrajectoryGoal does not have a Header as its first member 
        // FollowJointTrajectoryResult does not have a Header as its first member 
        // GripperCommand does not have a Header as its first member 
        // GripperCommandAction does not have a Header as its first member 
        case GripperCommandActionFeedback::ID:
        {
            Message<GripperCommandActionFeedback > & tempMsg = static_cast<Message<GripperCommandActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case GripperCommandActionGoal::ID:
        {
            Message<GripperCommandActionGoal > & tempMsg = static_cast<Message<GripperCommandActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case GripperCommandActionResult::ID:
        {
            Message<GripperCommandActionResult > & tempMsg = static_cast<Message<GripperCommandActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // GripperCommandFeedback does not have a Header as its first member 
        // GripperCommandGoal does not have a Header as its first member 
        // GripperCommandResult does not have a Header as its first member 
        case JointControllerState::ID:
        {
            Message<JointControllerState > & tempMsg = static_cast<Message<JointControllerState>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // JointTolerance does not have a Header as its first member 
        // JointTrajectoryAction does not have a Header as its first member 
        case JointTrajectoryActionFeedback::ID:
        {
            Message<JointTrajectoryActionFeedback > & tempMsg = static_cast<Message<JointTrajectoryActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case JointTrajectoryActionGoal::ID:
        {
            Message<JointTrajectoryActionGoal > & tempMsg = static_cast<Message<JointTrajectoryActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case JointTrajectoryActionResult::ID:
        {
            Message<JointTrajectoryActionResult > & tempMsg = static_cast<Message<JointTrajectoryActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case JointTrajectoryControllerState::ID:
        {
            Message<JointTrajectoryControllerState > & tempMsg = static_cast<Message<JointTrajectoryControllerState>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // JointTrajectoryGoal does not have a Header as its first member 
        // PointHeadAction does not have a Header as its first member 
        case PointHeadActionFeedback::ID:
        {
            Message<PointHeadActionFeedback > & tempMsg = static_cast<Message<PointHeadActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case PointHeadActionGoal::ID:
        {
            Message<PointHeadActionGoal > & tempMsg = static_cast<Message<PointHeadActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case PointHeadActionResult::ID:
        {
            Message<PointHeadActionResult > & tempMsg = static_cast<Message<PointHeadActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // PointHeadFeedback does not have a Header as its first member 
        // PointHeadGoal does not have a Header as its first member 
        // SingleJointPositionAction does not have a Header as its first member 
        case SingleJointPositionActionFeedback::ID:
        {
            Message<SingleJointPositionActionFeedback > & tempMsg = static_cast<Message<SingleJointPositionActionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case SingleJointPositionActionGoal::ID:
        {
            Message<SingleJointPositionActionGoal > & tempMsg = static_cast<Message<SingleJointPositionActionGoal>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case SingleJointPositionActionResult::ID:
        {
            Message<SingleJointPositionActionResult > & tempMsg = static_cast<Message<SingleJointPositionActionResult>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        case SingleJointPositionFeedback::ID:
        {
            Message<SingleJointPositionFeedback > & tempMsg = static_cast<Message<SingleJointPositionFeedback>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // SingleJointPositionGoal does not have a Header as its first member 
        // QueryCalibrationStateResponse does not have a Header as its first member 
        // QueryCalibrationState does not have a Header as its first member 
        // QueryTrajectoryStateRequest does not have a Header as its first member 
        // QueryTrajectoryStateResponse does not have a Header as its first member 
        // QueryTrajectoryState does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
