// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         alex on alex-laptop, 2016-11-23 12:44:52 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "nodelet_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace nodelet;

rframe::ROSMessageFactory * ROS_nodelet_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_nodelet_gencppfactory = new nodelet_gencppROSMessageFactory();

        return ROS_nodelet_gencppfactory;
    };
}

rframe::ROSMessageFactory * nodelet::allocate_nodelet_gencpp()
{
    ROS_nodelet_gencppfactory = new nodelet_gencppROSMessageFactory();
    return ROS_nodelet_gencppfactory;
};

nodelet_gencppROSMessageFactory::nodelet_gencppROSMessageFactory()
{
    name("nodelet_gencpp");
    // use constructor to register data types
    nodelet::registerLibrary();
}

nodelet_gencppROSMessageFactory::~nodelet_gencppROSMessageFactory()
{
}

int nodelet_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void nodelet_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(NodeletListRequest::ID);
    info.name(NodeletListRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletListRequest::DATA_VERSION);
    info.md5Key(NodeletListRequest::VERSION_MD5);
    info.xmlSource(NodeletListRequest::XML_SOURCE);
    info.flat(NodeletListRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletListResponse::ID);
    info.name(NodeletListResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletListResponse::DATA_VERSION);
    info.md5Key(NodeletListResponse::VERSION_MD5);
    info.xmlSource(NodeletListResponse::XML_SOURCE);
    info.flat(NodeletListResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletList::ID);
    info.name(NodeletList::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletList::DATA_VERSION);
    info.md5Key(NodeletList::VERSION_MD5);
    info.xmlSource(NodeletList::XML_SOURCE);
    info.flat(NodeletList::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletLoadRequest::ID);
    info.name(NodeletLoadRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletLoadRequest::DATA_VERSION);
    info.md5Key(NodeletLoadRequest::VERSION_MD5);
    info.xmlSource(NodeletLoadRequest::XML_SOURCE);
    info.flat(NodeletLoadRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletLoadResponse::ID);
    info.name(NodeletLoadResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletLoadResponse::DATA_VERSION);
    info.md5Key(NodeletLoadResponse::VERSION_MD5);
    info.xmlSource(NodeletLoadResponse::XML_SOURCE);
    info.flat(NodeletLoadResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletLoad::ID);
    info.name(NodeletLoad::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletLoad::DATA_VERSION);
    info.md5Key(NodeletLoad::VERSION_MD5);
    info.xmlSource(NodeletLoad::XML_SOURCE);
    info.flat(NodeletLoad::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletUnloadRequest::ID);
    info.name(NodeletUnloadRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletUnloadRequest::DATA_VERSION);
    info.md5Key(NodeletUnloadRequest::VERSION_MD5);
    info.xmlSource(NodeletUnloadRequest::XML_SOURCE);
    info.flat(NodeletUnloadRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletUnloadResponse::ID);
    info.name(NodeletUnloadResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletUnloadResponse::DATA_VERSION);
    info.md5Key(NodeletUnloadResponse::VERSION_MD5);
    info.xmlSource(NodeletUnloadResponse::XML_SOURCE);
    info.flat(NodeletUnloadResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(NodeletUnload::ID);
    info.name(NodeletUnload::DATA_TYPE_FULL_NAME);
    info.hashKey(NodeletUnload::DATA_VERSION);
    info.md5Key(NodeletUnload::VERSION_MD5);
    info.xmlSource(NodeletUnload::XML_SOURCE);
    info.flat(NodeletUnload::dataTypeFlat());
    ids.push_back(info);

}

int nodelet_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case NodeletListRequest::ID:
        {
            str = "nodelet/NodeletListRequest";
            break;
        }
        case NodeletListResponse::ID:
        {
            str = "nodelet/NodeletListResponse";
            break;
        }
        case NodeletList::ID:
        {
            str = "nodelet/NodeletList";
            break;
        }
        case NodeletLoadRequest::ID:
        {
            str = "nodelet/NodeletLoadRequest";
            break;
        }
        case NodeletLoadResponse::ID:
        {
            str = "nodelet/NodeletLoadResponse";
            break;
        }
        case NodeletLoad::ID:
        {
            str = "nodelet/NodeletLoad";
            break;
        }
        case NodeletUnloadRequest::ID:
        {
            str = "nodelet/NodeletUnloadRequest";
            break;
        }
        case NodeletUnloadResponse::ID:
        {
            str = "nodelet/NodeletUnloadResponse";
            break;
        }
        case NodeletUnload::ID:
        {
            str = "nodelet/NodeletUnload";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case NodeletListRequest::ID:
        {
            str = NodeletListRequest::XML_SOURCE;
            break;
        }
        case NodeletListResponse::ID:
        {
            str = NodeletListResponse::XML_SOURCE;
            break;
        }
        case NodeletList::ID:
        {
            str = NodeletList::XML_SOURCE;
            break;
        }
        case NodeletLoadRequest::ID:
        {
            str = NodeletLoadRequest::XML_SOURCE;
            break;
        }
        case NodeletLoadResponse::ID:
        {
            str = NodeletLoadResponse::XML_SOURCE;
            break;
        }
        case NodeletLoad::ID:
        {
            str = NodeletLoad::XML_SOURCE;
            break;
        }
        case NodeletUnloadRequest::ID:
        {
            str = NodeletUnloadRequest::XML_SOURCE;
            break;
        }
        case NodeletUnloadResponse::ID:
        {
            str = NodeletUnloadResponse::XML_SOURCE;
            break;
        }
        case NodeletUnload::ID:
        {
            str = NodeletUnload::XML_SOURCE;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case NodeletListRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case NodeletListResponse::ID:
        {
            str = "99c7b10e794f5600b8030e697e946ca7";
            break;
        }
        case NodeletList::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case NodeletLoadRequest::ID:
        {
            str = "c6e28cc4d2e259249d96cfb50658fbec";
            break;
        }
        case NodeletLoadResponse::ID:
        {
            str = "358e233cde0c8a8bcfea4ce193f8fc15";
            break;
        }
        case NodeletLoad::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case NodeletUnloadRequest::ID:
        {
            str = "c1f3d28f1b044c871e6eff2e9fc3c667";
            break;
        }
        case NodeletUnloadResponse::ID:
        {
            str = "358e233cde0c8a8bcfea4ce193f8fc15";
            break;
        }
        case NodeletUnload::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case NodeletListRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case NodeletListResponse::ID:
        {   
		    highOrder = 0x99c7b10e794f5600ULL;
            lowOrder = 0xb8030e697e946ca7ULL;
            break;
        }
        case NodeletList::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case NodeletLoadRequest::ID:
        {   
		    highOrder = 0xc6e28cc4d2e25924ULL;
            lowOrder = 0x9d96cfb50658fbecULL;
            break;
        }
        case NodeletLoadResponse::ID:
        {   
		    highOrder = 0x358e233cde0c8a8bULL;
            lowOrder = 0xcfea4ce193f8fc15ULL;
            break;
        }
        case NodeletLoad::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case NodeletUnloadRequest::ID:
        {   
		    highOrder = 0xc1f3d28f1b044c87ULL;
            lowOrder = 0x1e6eff2e9fc3c667ULL;
            break;
        }
        case NodeletUnloadResponse::ID:
        {   
		    highOrder = 0x358e233cde0c8a8bULL;
            lowOrder = 0xcfea4ce193f8fc15ULL;
            break;
        }
        case NodeletUnload::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case NodeletListRequest::ID:
        case NodeletListResponse::ID:
        case NodeletList::ID:
        case NodeletLoadRequest::ID:
        case NodeletLoadResponse::ID:
        case NodeletLoad::ID:
        case NodeletUnloadRequest::ID:
        case NodeletUnloadResponse::ID:
        case NodeletUnload::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case NodeletListRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletListRequest>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletListResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletListResponse>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletList::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletList>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletLoadRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletLoadRequest>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletLoadResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletLoadResponse>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletLoad::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletLoad>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletUnloadRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletUnloadRequest>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletUnloadResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletUnloadResponse>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case NodeletUnload::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<NodeletUnload>(),std::bind(&nodelet_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case NodeletListRequest::ID:
            {
                Message<NodeletListRequest > & tempSrc = static_cast<Message<NodeletListRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletListRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletListResponse::ID:
            {
                Message<NodeletListResponse > & tempSrc = static_cast<Message<NodeletListResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletListResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletList::ID:
            {
                Message<NodeletList > & tempSrc = static_cast<Message<NodeletList>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletList buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletLoadRequest::ID:
            {
                Message<NodeletLoadRequest > & tempSrc = static_cast<Message<NodeletLoadRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletLoadRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletLoadResponse::ID:
            {
                Message<NodeletLoadResponse > & tempSrc = static_cast<Message<NodeletLoadResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletLoadResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletLoad::ID:
            {
                Message<NodeletLoad > & tempSrc = static_cast<Message<NodeletLoad>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletLoad buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletUnloadRequest::ID:
            {
                Message<NodeletUnloadRequest > & tempSrc = static_cast<Message<NodeletUnloadRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletUnloadRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletUnloadResponse::ID:
            {
                Message<NodeletUnloadResponse > & tempSrc = static_cast<Message<NodeletUnloadResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletUnloadResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case NodeletUnload::ID:
            {
                Message<NodeletUnload > & tempSrc = static_cast<Message<NodeletUnload>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: nodelet_gencpp::NodeletUnload buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case NodeletListRequest::ID:
            {
                Message<NodeletListRequest > & tempDst = static_cast<Message<NodeletListRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletListResponse::ID:
            {
                Message<NodeletListResponse > & tempDst = static_cast<Message<NodeletListResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletList::ID:
            {
                Message<NodeletList > & tempDst = static_cast<Message<NodeletList>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletLoadRequest::ID:
            {
                Message<NodeletLoadRequest > & tempDst = static_cast<Message<NodeletLoadRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletLoadResponse::ID:
            {
                Message<NodeletLoadResponse > & tempDst = static_cast<Message<NodeletLoadResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletLoad::ID:
            {
                Message<NodeletLoad > & tempDst = static_cast<Message<NodeletLoad>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletUnloadRequest::ID:
            {
                Message<NodeletUnloadRequest > & tempDst = static_cast<Message<NodeletUnloadRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletUnloadResponse::ID:
            {
                Message<NodeletUnloadResponse > & tempDst = static_cast<Message<NodeletUnloadResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case NodeletUnload::ID:
            {
                Message<NodeletUnload > & tempDst = static_cast<Message<NodeletUnload>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int nodelet_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // NodeletListResponse does not have a Header as its first member 
        // NodeletList does not have a Header as its first member 
        // NodeletLoadRequest does not have a Header as its first member 
        // NodeletLoadResponse does not have a Header as its first member 
        // NodeletLoad does not have a Header as its first member 
        // NodeletUnloadRequest does not have a Header as its first member 
        // NodeletUnloadResponse does not have a Header as its first member 
        // NodeletUnload does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
