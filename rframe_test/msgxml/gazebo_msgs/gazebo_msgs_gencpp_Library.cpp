// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2016-11-23 17:33:56 -0500
//  From Template/Script: data_templates/DataLibraryTemplate.cpp
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "gazebo_msgs_gencpp_Library.h"
#include <common/Log.h>
#include <common/TypeRegistry.h>
#include <messaging/Message.h>

#include <gazebo_msgs/ContactState.h>
#include <gazebo_msgs/ContactsState.h>
#include <gazebo_msgs/LinkState.h>
#include <gazebo_msgs/LinkStates.h>
#include <gazebo_msgs/ModelState.h>
#include <gazebo_msgs/ModelStates.h>
#include <gazebo_msgs/ODEJointProperties.h>
#include <gazebo_msgs/ODEPhysics.h>
#include <gazebo_msgs/WorldState.h>
#include <gazebo_msgs/ApplyBodyWrenchRequest.h>
#include <gazebo_msgs/ApplyBodyWrenchResponse.h>
#include <gazebo_msgs/ApplyBodyWrench.h>
#include <gazebo_msgs/ApplyJointEffortRequest.h>
#include <gazebo_msgs/ApplyJointEffortResponse.h>
#include <gazebo_msgs/ApplyJointEffort.h>
#include <gazebo_msgs/BodyRequestRequest.h>
#include <gazebo_msgs/BodyRequestResponse.h>
#include <gazebo_msgs/BodyRequest.h>
#include <gazebo_msgs/DeleteModelRequest.h>
#include <gazebo_msgs/DeleteModelResponse.h>
#include <gazebo_msgs/DeleteModel.h>
#include <gazebo_msgs/GetJointPropertiesRequest.h>
#include <gazebo_msgs/GetJointPropertiesResponse.h>
#include <gazebo_msgs/GetJointProperties.h>
#include <gazebo_msgs/GetLinkPropertiesRequest.h>
#include <gazebo_msgs/GetLinkPropertiesResponse.h>
#include <gazebo_msgs/GetLinkProperties.h>
#include <gazebo_msgs/GetLinkStateRequest.h>
#include <gazebo_msgs/GetLinkStateResponse.h>
#include <gazebo_msgs/GetLinkState.h>
#include <gazebo_msgs/GetModelPropertiesRequest.h>
#include <gazebo_msgs/GetModelPropertiesResponse.h>
#include <gazebo_msgs/GetModelProperties.h>
#include <gazebo_msgs/GetModelStateRequest.h>
#include <gazebo_msgs/GetModelStateResponse.h>
#include <gazebo_msgs/GetModelState.h>
#include <gazebo_msgs/GetPhysicsPropertiesRequest.h>
#include <gazebo_msgs/GetPhysicsPropertiesResponse.h>
#include <gazebo_msgs/GetPhysicsProperties.h>
#include <gazebo_msgs/GetWorldPropertiesRequest.h>
#include <gazebo_msgs/GetWorldPropertiesResponse.h>
#include <gazebo_msgs/GetWorldProperties.h>
#include <gazebo_msgs/JointRequestRequest.h>
#include <gazebo_msgs/JointRequestResponse.h>
#include <gazebo_msgs/JointRequest.h>
#include <gazebo_msgs/SetJointPropertiesRequest.h>
#include <gazebo_msgs/SetJointPropertiesResponse.h>
#include <gazebo_msgs/SetJointProperties.h>
#include <gazebo_msgs/SetJointTrajectoryRequest.h>
#include <gazebo_msgs/SetJointTrajectoryResponse.h>
#include <gazebo_msgs/SetJointTrajectory.h>
#include <gazebo_msgs/SetLinkPropertiesRequest.h>
#include <gazebo_msgs/SetLinkPropertiesResponse.h>
#include <gazebo_msgs/SetLinkProperties.h>
#include <gazebo_msgs/SetLinkStateRequest.h>
#include <gazebo_msgs/SetLinkStateResponse.h>
#include <gazebo_msgs/SetLinkState.h>
#include <gazebo_msgs/SetModelConfigurationRequest.h>
#include <gazebo_msgs/SetModelConfigurationResponse.h>
#include <gazebo_msgs/SetModelConfiguration.h>
#include <gazebo_msgs/SetModelStateRequest.h>
#include <gazebo_msgs/SetModelStateResponse.h>
#include <gazebo_msgs/SetModelState.h>
#include <gazebo_msgs/SetPhysicsPropertiesRequest.h>
#include <gazebo_msgs/SetPhysicsPropertiesResponse.h>
#include <gazebo_msgs/SetPhysicsProperties.h>
#include <gazebo_msgs/SpawnModelRequest.h>
#include <gazebo_msgs/SpawnModelResponse.h>
#include <gazebo_msgs/SpawnModel.h>

extern "C"
{
    /** library access method */
    int rframeRegisterDataLibrary()
    {
        return gazebo_msgs::registerLibrary();
    };
}

namespace gazebo_msgs
{

    static void deallocateMessage(MessageBase * msg)
    {
        delete msg;
    }

    static int allocateMessage(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
    {
        int retval = rframe::Error::SUCCESS;
        bool found = true;
        switch (id)
        { 
            case ContactState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ContactState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ContactsState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ContactsState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case LinkState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<LinkState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case LinkStates::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<LinkStates>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ModelState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ModelState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ModelStates::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ModelStates>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ODEJointProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ODEJointProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ODEPhysics::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ODEPhysics>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case WorldState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<WorldState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ApplyBodyWrenchRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrenchRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ApplyBodyWrenchResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrenchResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ApplyBodyWrench::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrench>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ApplyJointEffortRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffortRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ApplyJointEffortResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffortResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case ApplyJointEffort::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffort>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case BodyRequestRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequestRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case BodyRequestResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequestResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case BodyRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case DeleteModelRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModelRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case DeleteModelResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModelResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case DeleteModel::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModel>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetJointPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetJointPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetJointPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetJointPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetJointProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetJointProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetLinkPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetLinkPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetLinkProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetLinkStateRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkStateRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetLinkStateResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkStateResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetLinkState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetModelPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetModelPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetModelPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetModelPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetModelProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetModelProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetModelStateRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetModelStateRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetModelStateResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetModelStateResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetModelState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetModelState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetPhysicsPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetPhysicsPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetPhysicsProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetWorldPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetWorldPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case GetWorldProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case JointRequestRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<JointRequestRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case JointRequestResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<JointRequestResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case JointRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<JointRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetJointPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetJointPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetJointPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetJointPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetJointProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetJointProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetJointTrajectoryRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectoryRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetJointTrajectoryResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectoryResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetJointTrajectory::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectory>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetLinkPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetLinkPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetLinkProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetLinkStateRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkStateRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetLinkStateResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkStateResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetLinkState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetModelConfigurationRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfigurationRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetModelConfigurationResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfigurationResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetModelConfiguration::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfiguration>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetModelStateRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetModelStateRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetModelStateResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetModelStateResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetModelState::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetModelState>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetPhysicsPropertiesRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsPropertiesRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetPhysicsPropertiesResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsPropertiesResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SetPhysicsProperties::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsProperties>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SpawnModelRequest::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModelRequest>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SpawnModelResponse::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModelResponse>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            case SpawnModel::ID:
            {
                std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModel>(),std::bind(deallocateMessage,std::placeholders::_1));
                if (tempMsg.get() == NULL)
                {
                    retval = rframe::Error::MEMORY_ALLOC;
                } 
                else
                {
                    msg.swap(tempMsg);
                }
                break;
            } 
            default:
            {
                found = false;
            }
        }

        if (found == false)
        {
            retval = rframe::Error::PARAM_RANGE;
        }
        else if (msg.get() == NULL)
        {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else if (msg.get() != NULL)
        {
            retval = rframe::Error::SUCCESS;
        }

        return retval;
    }

    /** registry this data set with the system */
    //int register_gazebo_msgs_gencpp()
    int registerLibrary()
    {
        int retval = rframe::Error::SUCCESS;
        static bool registered = false;
        rframe::TypeRegistry & reg = rframe::TypeRegistry::instance();

        LOG_INFO("registering data for library: gazebo_msgs_gencpp");

        if (registered == false)
        {
            registered = true;

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ContactState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ContactState>(
                    // boost::lambda::new_ptr<gazebo_msgs::ContactState>(),
                    [](){ return new gazebo_msgs::ContactState(); },
                                std::bind(allocateMessage,gazebo_msgs::ContactState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ContactState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ContactState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ContactState::DATA_TYPE_NAME,gazebo_msgs::ContactState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ContactState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ContactsState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ContactsState>(
                    // boost::lambda::new_ptr<gazebo_msgs::ContactsState>(),
                    [](){ return new gazebo_msgs::ContactsState(); },
                                std::bind(allocateMessage,gazebo_msgs::ContactsState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ContactsState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ContactsState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ContactsState::DATA_TYPE_NAME,gazebo_msgs::ContactsState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ContactsState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::LinkState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::LinkState>(
                    // boost::lambda::new_ptr<gazebo_msgs::LinkState>(),
                    [](){ return new gazebo_msgs::LinkState(); },
                                std::bind(allocateMessage,gazebo_msgs::LinkState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: LinkState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::LinkState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::LinkState::DATA_TYPE_NAME,gazebo_msgs::LinkState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: LinkState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::LinkStates::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::LinkStates>(
                    // boost::lambda::new_ptr<gazebo_msgs::LinkStates>(),
                    [](){ return new gazebo_msgs::LinkStates(); },
                                std::bind(allocateMessage,gazebo_msgs::LinkStates::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: LinkStates");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::LinkStates::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::LinkStates::DATA_TYPE_NAME,gazebo_msgs::LinkStates::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: LinkStates");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ModelState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ModelState>(
                    // boost::lambda::new_ptr<gazebo_msgs::ModelState>(),
                    [](){ return new gazebo_msgs::ModelState(); },
                                std::bind(allocateMessage,gazebo_msgs::ModelState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ModelState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ModelState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ModelState::DATA_TYPE_NAME,gazebo_msgs::ModelState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ModelState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ModelStates::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ModelStates>(
                    // boost::lambda::new_ptr<gazebo_msgs::ModelStates>(),
                    [](){ return new gazebo_msgs::ModelStates(); },
                                std::bind(allocateMessage,gazebo_msgs::ModelStates::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ModelStates");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ModelStates::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ModelStates::DATA_TYPE_NAME,gazebo_msgs::ModelStates::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ModelStates");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ODEJointProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ODEJointProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::ODEJointProperties>(),
                    [](){ return new gazebo_msgs::ODEJointProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::ODEJointProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ODEJointProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ODEJointProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ODEJointProperties::DATA_TYPE_NAME,gazebo_msgs::ODEJointProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ODEJointProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ODEPhysics::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ODEPhysics>(
                    // boost::lambda::new_ptr<gazebo_msgs::ODEPhysics>(),
                    [](){ return new gazebo_msgs::ODEPhysics(); },
                                std::bind(allocateMessage,gazebo_msgs::ODEPhysics::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ODEPhysics");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ODEPhysics::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ODEPhysics::DATA_TYPE_NAME,gazebo_msgs::ODEPhysics::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ODEPhysics");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::WorldState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::WorldState>(
                    // boost::lambda::new_ptr<gazebo_msgs::WorldState>(),
                    [](){ return new gazebo_msgs::WorldState(); },
                                std::bind(allocateMessage,gazebo_msgs::WorldState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: WorldState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::WorldState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::WorldState::DATA_TYPE_NAME,gazebo_msgs::WorldState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: WorldState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyBodyWrenchRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ApplyBodyWrenchRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::ApplyBodyWrenchRequest>(),
                    [](){ return new gazebo_msgs::ApplyBodyWrenchRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::ApplyBodyWrenchRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ApplyBodyWrenchRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyBodyWrenchRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ApplyBodyWrenchRequest::DATA_TYPE_NAME,gazebo_msgs::ApplyBodyWrenchRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ApplyBodyWrenchRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyBodyWrenchResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ApplyBodyWrenchResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::ApplyBodyWrenchResponse>(),
                    [](){ return new gazebo_msgs::ApplyBodyWrenchResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::ApplyBodyWrenchResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ApplyBodyWrenchResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyBodyWrenchResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ApplyBodyWrenchResponse::DATA_TYPE_NAME,gazebo_msgs::ApplyBodyWrenchResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ApplyBodyWrenchResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyBodyWrench::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ApplyBodyWrench>(
                    // boost::lambda::new_ptr<gazebo_msgs::ApplyBodyWrench>(),
                    [](){ return new gazebo_msgs::ApplyBodyWrench(); },
                                std::bind(allocateMessage,gazebo_msgs::ApplyBodyWrench::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ApplyBodyWrench");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyBodyWrench::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ApplyBodyWrench::DATA_TYPE_NAME,gazebo_msgs::ApplyBodyWrench::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ApplyBodyWrench");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyJointEffortRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ApplyJointEffortRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::ApplyJointEffortRequest>(),
                    [](){ return new gazebo_msgs::ApplyJointEffortRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::ApplyJointEffortRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ApplyJointEffortRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyJointEffortRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ApplyJointEffortRequest::DATA_TYPE_NAME,gazebo_msgs::ApplyJointEffortRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ApplyJointEffortRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyJointEffortResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ApplyJointEffortResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::ApplyJointEffortResponse>(),
                    [](){ return new gazebo_msgs::ApplyJointEffortResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::ApplyJointEffortResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ApplyJointEffortResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyJointEffortResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ApplyJointEffortResponse::DATA_TYPE_NAME,gazebo_msgs::ApplyJointEffortResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ApplyJointEffortResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyJointEffort::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::ApplyJointEffort>(
                    // boost::lambda::new_ptr<gazebo_msgs::ApplyJointEffort>(),
                    [](){ return new gazebo_msgs::ApplyJointEffort(); },
                                std::bind(allocateMessage,gazebo_msgs::ApplyJointEffort::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: ApplyJointEffort");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::ApplyJointEffort::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::ApplyJointEffort::DATA_TYPE_NAME,gazebo_msgs::ApplyJointEffort::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: ApplyJointEffort");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::BodyRequestRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::BodyRequestRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::BodyRequestRequest>(),
                    [](){ return new gazebo_msgs::BodyRequestRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::BodyRequestRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: BodyRequestRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::BodyRequestRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::BodyRequestRequest::DATA_TYPE_NAME,gazebo_msgs::BodyRequestRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: BodyRequestRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::BodyRequestResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::BodyRequestResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::BodyRequestResponse>(),
                    [](){ return new gazebo_msgs::BodyRequestResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::BodyRequestResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: BodyRequestResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::BodyRequestResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::BodyRequestResponse::DATA_TYPE_NAME,gazebo_msgs::BodyRequestResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: BodyRequestResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::BodyRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::BodyRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::BodyRequest>(),
                    [](){ return new gazebo_msgs::BodyRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::BodyRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: BodyRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::BodyRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::BodyRequest::DATA_TYPE_NAME,gazebo_msgs::BodyRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: BodyRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::DeleteModelRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::DeleteModelRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::DeleteModelRequest>(),
                    [](){ return new gazebo_msgs::DeleteModelRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::DeleteModelRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: DeleteModelRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::DeleteModelRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::DeleteModelRequest::DATA_TYPE_NAME,gazebo_msgs::DeleteModelRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: DeleteModelRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::DeleteModelResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::DeleteModelResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::DeleteModelResponse>(),
                    [](){ return new gazebo_msgs::DeleteModelResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::DeleteModelResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: DeleteModelResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::DeleteModelResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::DeleteModelResponse::DATA_TYPE_NAME,gazebo_msgs::DeleteModelResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: DeleteModelResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::DeleteModel::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::DeleteModel>(
                    // boost::lambda::new_ptr<gazebo_msgs::DeleteModel>(),
                    [](){ return new gazebo_msgs::DeleteModel(); },
                                std::bind(allocateMessage,gazebo_msgs::DeleteModel::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: DeleteModel");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::DeleteModel::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::DeleteModel::DATA_TYPE_NAME,gazebo_msgs::DeleteModel::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: DeleteModel");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetJointPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetJointPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetJointPropertiesRequest>(),
                    [](){ return new gazebo_msgs::GetJointPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetJointPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetJointPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetJointPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetJointPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::GetJointPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetJointPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetJointPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetJointPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetJointPropertiesResponse>(),
                    [](){ return new gazebo_msgs::GetJointPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetJointPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetJointPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetJointPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetJointPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::GetJointPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetJointPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetJointProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetJointProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetJointProperties>(),
                    [](){ return new gazebo_msgs::GetJointProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::GetJointProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetJointProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetJointProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetJointProperties::DATA_TYPE_NAME,gazebo_msgs::GetJointProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetJointProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetLinkPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetLinkPropertiesRequest>(),
                    [](){ return new gazebo_msgs::GetLinkPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetLinkPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetLinkPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetLinkPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::GetLinkPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetLinkPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetLinkPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetLinkPropertiesResponse>(),
                    [](){ return new gazebo_msgs::GetLinkPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetLinkPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetLinkPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetLinkPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::GetLinkPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetLinkPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetLinkProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetLinkProperties>(),
                    [](){ return new gazebo_msgs::GetLinkProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::GetLinkProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetLinkProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetLinkProperties::DATA_TYPE_NAME,gazebo_msgs::GetLinkProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetLinkProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetLinkStateRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetLinkStateRequest>(),
                    [](){ return new gazebo_msgs::GetLinkStateRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetLinkStateRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetLinkStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetLinkStateRequest::DATA_TYPE_NAME,gazebo_msgs::GetLinkStateRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetLinkStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetLinkStateResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetLinkStateResponse>(),
                    [](){ return new gazebo_msgs::GetLinkStateResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetLinkStateResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetLinkStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetLinkStateResponse::DATA_TYPE_NAME,gazebo_msgs::GetLinkStateResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetLinkStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetLinkState>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetLinkState>(),
                    [](){ return new gazebo_msgs::GetLinkState(); },
                                std::bind(allocateMessage,gazebo_msgs::GetLinkState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetLinkState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetLinkState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetLinkState::DATA_TYPE_NAME,gazebo_msgs::GetLinkState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetLinkState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetModelPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetModelPropertiesRequest>(),
                    [](){ return new gazebo_msgs::GetModelPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetModelPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetModelPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetModelPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::GetModelPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetModelPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetModelPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetModelPropertiesResponse>(),
                    [](){ return new gazebo_msgs::GetModelPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetModelPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetModelPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetModelPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::GetModelPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetModelPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetModelProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetModelProperties>(),
                    [](){ return new gazebo_msgs::GetModelProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::GetModelProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetModelProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetModelProperties::DATA_TYPE_NAME,gazebo_msgs::GetModelProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetModelProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetModelStateRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetModelStateRequest>(),
                    [](){ return new gazebo_msgs::GetModelStateRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetModelStateRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetModelStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetModelStateRequest::DATA_TYPE_NAME,gazebo_msgs::GetModelStateRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetModelStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetModelStateResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetModelStateResponse>(),
                    [](){ return new gazebo_msgs::GetModelStateResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetModelStateResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetModelStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetModelStateResponse::DATA_TYPE_NAME,gazebo_msgs::GetModelStateResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetModelStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetModelState>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetModelState>(),
                    [](){ return new gazebo_msgs::GetModelState(); },
                                std::bind(allocateMessage,gazebo_msgs::GetModelState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetModelState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetModelState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetModelState::DATA_TYPE_NAME,gazebo_msgs::GetModelState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetModelState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetPhysicsPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetPhysicsPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetPhysicsPropertiesRequest>(),
                    [](){ return new gazebo_msgs::GetPhysicsPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetPhysicsPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetPhysicsPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetPhysicsPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetPhysicsPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::GetPhysicsPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetPhysicsPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetPhysicsPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetPhysicsPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetPhysicsPropertiesResponse>(),
                    [](){ return new gazebo_msgs::GetPhysicsPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetPhysicsPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetPhysicsPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetPhysicsPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetPhysicsPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::GetPhysicsPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetPhysicsPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetPhysicsProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetPhysicsProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetPhysicsProperties>(),
                    [](){ return new gazebo_msgs::GetPhysicsProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::GetPhysicsProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetPhysicsProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetPhysicsProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetPhysicsProperties::DATA_TYPE_NAME,gazebo_msgs::GetPhysicsProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetPhysicsProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetWorldPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetWorldPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetWorldPropertiesRequest>(),
                    [](){ return new gazebo_msgs::GetWorldPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::GetWorldPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetWorldPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetWorldPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetWorldPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::GetWorldPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetWorldPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetWorldPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetWorldPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetWorldPropertiesResponse>(),
                    [](){ return new gazebo_msgs::GetWorldPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::GetWorldPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetWorldPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetWorldPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetWorldPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::GetWorldPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetWorldPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetWorldProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::GetWorldProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::GetWorldProperties>(),
                    [](){ return new gazebo_msgs::GetWorldProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::GetWorldProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: GetWorldProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::GetWorldProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::GetWorldProperties::DATA_TYPE_NAME,gazebo_msgs::GetWorldProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: GetWorldProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::JointRequestRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::JointRequestRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::JointRequestRequest>(),
                    [](){ return new gazebo_msgs::JointRequestRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::JointRequestRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: JointRequestRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::JointRequestRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::JointRequestRequest::DATA_TYPE_NAME,gazebo_msgs::JointRequestRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: JointRequestRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::JointRequestResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::JointRequestResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::JointRequestResponse>(),
                    [](){ return new gazebo_msgs::JointRequestResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::JointRequestResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: JointRequestResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::JointRequestResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::JointRequestResponse::DATA_TYPE_NAME,gazebo_msgs::JointRequestResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: JointRequestResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::JointRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::JointRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::JointRequest>(),
                    [](){ return new gazebo_msgs::JointRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::JointRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: JointRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::JointRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::JointRequest::DATA_TYPE_NAME,gazebo_msgs::JointRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: JointRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetJointPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetJointPropertiesRequest>(),
                    [](){ return new gazebo_msgs::SetJointPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetJointPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetJointPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetJointPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::SetJointPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetJointPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetJointPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetJointPropertiesResponse>(),
                    [](){ return new gazebo_msgs::SetJointPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetJointPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetJointPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetJointPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::SetJointPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetJointPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetJointProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetJointProperties>(),
                    [](){ return new gazebo_msgs::SetJointProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::SetJointProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetJointProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetJointProperties::DATA_TYPE_NAME,gazebo_msgs::SetJointProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetJointProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointTrajectoryRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetJointTrajectoryRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetJointTrajectoryRequest>(),
                    [](){ return new gazebo_msgs::SetJointTrajectoryRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetJointTrajectoryRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetJointTrajectoryRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointTrajectoryRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetJointTrajectoryRequest::DATA_TYPE_NAME,gazebo_msgs::SetJointTrajectoryRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetJointTrajectoryRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointTrajectoryResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetJointTrajectoryResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetJointTrajectoryResponse>(),
                    [](){ return new gazebo_msgs::SetJointTrajectoryResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetJointTrajectoryResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetJointTrajectoryResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointTrajectoryResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetJointTrajectoryResponse::DATA_TYPE_NAME,gazebo_msgs::SetJointTrajectoryResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetJointTrajectoryResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointTrajectory::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetJointTrajectory>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetJointTrajectory>(),
                    [](){ return new gazebo_msgs::SetJointTrajectory(); },
                                std::bind(allocateMessage,gazebo_msgs::SetJointTrajectory::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetJointTrajectory");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetJointTrajectory::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetJointTrajectory::DATA_TYPE_NAME,gazebo_msgs::SetJointTrajectory::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetJointTrajectory");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetLinkPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetLinkPropertiesRequest>(),
                    [](){ return new gazebo_msgs::SetLinkPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetLinkPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetLinkPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetLinkPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::SetLinkPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetLinkPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetLinkPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetLinkPropertiesResponse>(),
                    [](){ return new gazebo_msgs::SetLinkPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetLinkPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetLinkPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetLinkPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::SetLinkPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetLinkPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetLinkProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetLinkProperties>(),
                    [](){ return new gazebo_msgs::SetLinkProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::SetLinkProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetLinkProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetLinkProperties::DATA_TYPE_NAME,gazebo_msgs::SetLinkProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetLinkProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetLinkStateRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetLinkStateRequest>(),
                    [](){ return new gazebo_msgs::SetLinkStateRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetLinkStateRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetLinkStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetLinkStateRequest::DATA_TYPE_NAME,gazebo_msgs::SetLinkStateRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetLinkStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetLinkStateResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetLinkStateResponse>(),
                    [](){ return new gazebo_msgs::SetLinkStateResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetLinkStateResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetLinkStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetLinkStateResponse::DATA_TYPE_NAME,gazebo_msgs::SetLinkStateResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetLinkStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetLinkState>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetLinkState>(),
                    [](){ return new gazebo_msgs::SetLinkState(); },
                                std::bind(allocateMessage,gazebo_msgs::SetLinkState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetLinkState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetLinkState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetLinkState::DATA_TYPE_NAME,gazebo_msgs::SetLinkState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetLinkState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelConfigurationRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetModelConfigurationRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetModelConfigurationRequest>(),
                    [](){ return new gazebo_msgs::SetModelConfigurationRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetModelConfigurationRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetModelConfigurationRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelConfigurationRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetModelConfigurationRequest::DATA_TYPE_NAME,gazebo_msgs::SetModelConfigurationRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetModelConfigurationRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelConfigurationResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetModelConfigurationResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetModelConfigurationResponse>(),
                    [](){ return new gazebo_msgs::SetModelConfigurationResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetModelConfigurationResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetModelConfigurationResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelConfigurationResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetModelConfigurationResponse::DATA_TYPE_NAME,gazebo_msgs::SetModelConfigurationResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetModelConfigurationResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelConfiguration::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetModelConfiguration>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetModelConfiguration>(),
                    [](){ return new gazebo_msgs::SetModelConfiguration(); },
                                std::bind(allocateMessage,gazebo_msgs::SetModelConfiguration::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetModelConfiguration");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelConfiguration::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetModelConfiguration::DATA_TYPE_NAME,gazebo_msgs::SetModelConfiguration::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetModelConfiguration");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetModelStateRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetModelStateRequest>(),
                    [](){ return new gazebo_msgs::SetModelStateRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetModelStateRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetModelStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelStateRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetModelStateRequest::DATA_TYPE_NAME,gazebo_msgs::SetModelStateRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetModelStateRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetModelStateResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetModelStateResponse>(),
                    [](){ return new gazebo_msgs::SetModelStateResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetModelStateResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetModelStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelStateResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetModelStateResponse::DATA_TYPE_NAME,gazebo_msgs::SetModelStateResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetModelStateResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetModelState>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetModelState>(),
                    [](){ return new gazebo_msgs::SetModelState(); },
                                std::bind(allocateMessage,gazebo_msgs::SetModelState::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetModelState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetModelState::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetModelState::DATA_TYPE_NAME,gazebo_msgs::SetModelState::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetModelState");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetPhysicsPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetPhysicsPropertiesRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetPhysicsPropertiesRequest>(),
                    [](){ return new gazebo_msgs::SetPhysicsPropertiesRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SetPhysicsPropertiesRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetPhysicsPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetPhysicsPropertiesRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetPhysicsPropertiesRequest::DATA_TYPE_NAME,gazebo_msgs::SetPhysicsPropertiesRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetPhysicsPropertiesRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetPhysicsPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetPhysicsPropertiesResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetPhysicsPropertiesResponse>(),
                    [](){ return new gazebo_msgs::SetPhysicsPropertiesResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SetPhysicsPropertiesResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetPhysicsPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetPhysicsPropertiesResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetPhysicsPropertiesResponse::DATA_TYPE_NAME,gazebo_msgs::SetPhysicsPropertiesResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetPhysicsPropertiesResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetPhysicsProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SetPhysicsProperties>(
                    // boost::lambda::new_ptr<gazebo_msgs::SetPhysicsProperties>(),
                    [](){ return new gazebo_msgs::SetPhysicsProperties(); },
                                std::bind(allocateMessage,gazebo_msgs::SetPhysicsProperties::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SetPhysicsProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SetPhysicsProperties::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SetPhysicsProperties::DATA_TYPE_NAME,gazebo_msgs::SetPhysicsProperties::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SetPhysicsProperties");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SpawnModelRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SpawnModelRequest>(
                    // boost::lambda::new_ptr<gazebo_msgs::SpawnModelRequest>(),
                    [](){ return new gazebo_msgs::SpawnModelRequest(); },
                                std::bind(allocateMessage,gazebo_msgs::SpawnModelRequest::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SpawnModelRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SpawnModelRequest::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SpawnModelRequest::DATA_TYPE_NAME,gazebo_msgs::SpawnModelRequest::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SpawnModelRequest");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SpawnModelResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SpawnModelResponse>(
                    // boost::lambda::new_ptr<gazebo_msgs::SpawnModelResponse>(),
                    [](){ return new gazebo_msgs::SpawnModelResponse(); },
                                std::bind(allocateMessage,gazebo_msgs::SpawnModelResponse::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SpawnModelResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SpawnModelResponse::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SpawnModelResponse::DATA_TYPE_NAME,gazebo_msgs::SpawnModelResponse::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SpawnModelResponse");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SpawnModel::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerType<gazebo_msgs::SpawnModel>(
                    // boost::lambda::new_ptr<gazebo_msgs::SpawnModel>(),
                    [](){ return new gazebo_msgs::SpawnModel(); },
                                std::bind(allocateMessage,gazebo_msgs::SpawnModel::ID,
                                          std::placeholders::_1))) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class: SpawnModel");
            }

            if ((retval == rframe::Error::SUCCESS) 
                //  && ((retval = gazebo_msgs::SpawnModel::registerType()) != rframe::Error::SUCCESS))
                && ((retval = reg.registerAlias(gazebo_msgs::SpawnModel::DATA_TYPE_NAME,gazebo_msgs::SpawnModel::DATA_TYPE_FULL_NAME)) != rframe::Error::SUCCESS)
                )
            {
                LOG_CRIT("failed to register class alias to short name: SpawnModel");
            }

        }

        return retval;
    };

    std::string xmlSource()
    {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\
<!--\
 \
  AUTOGENERATED FILE:   do not edit\
\
  Generated by:         yongbo on yongbo-XPS-15-9550, 2016-11-23 17:33:50 -0500\
  From Template/Script: rosToXML.rb\
 \
\
-->\
<classes library_name=\"gazebo_msgs_gencpp\" namespace=\"gazebo_msgs\">\
\
<class name=\"ContactState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"48c0ffb054b8c444f870cecea1ee50d9\" rosDesc=\"string info                                   # text info on this contact\\nstring collision1_name                        # name of contact collision1\\nstring collision2_name                        # name of contact collision2\\ngeometry_msgs/Wrench[] wrenches               # list of forces/torques\\ngeometry_msgs/Wrench total_wrench             # sum of forces/torques in every DOF\\ngeometry_msgs/Vector3[] contact_positions     # list of contact position\\ngeometry_msgs/Vector3[] contact_normals       # list of contact normals\\nfloat64[] depths                              # list of penetration depths\\n\\n================================================================================\\nMSG: geometry_msgs/Wrench\\n# This represents force in free space, separated into\\n# its linear and angular parts.\\nVector3  force\\nVector3  torque\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"\">\
  <field name=\"info\" type=\"string\" sourceType=\"string\" comment=\"text info on this contact\"/>\
  <field name=\"collision1_name\" type=\"string\" sourceType=\"string\" comment=\"name of contact collision1\"/>\
  <field name=\"collision2_name\" type=\"string\" sourceType=\"string\" comment=\"name of contact collision2\"/>\
  <field name=\"wrenches\" type=\"vector(geometry_msgs::Wrench)\" sourceType=\"geometry_msgs::Wrench\" comment=\"list of forces/torques\"/>\
  <field name=\"total_wrench\" type=\"geometry_msgs::Wrench\" sourceType=\"geometry_msgs::Wrench\" comment=\"sum of forces/torques in every DOF\"/>\
  <field name=\"contact_positions\" type=\"vector(geometry_msgs::Vector3)\" sourceType=\"geometry_msgs::Vector3\" comment=\"list of contact position\"/>\
  <field name=\"contact_normals\" type=\"vector(geometry_msgs::Vector3)\" sourceType=\"geometry_msgs::Vector3\" comment=\"list of contact normals\"/>\
  <field name=\"depths\" type=\"vector(double)\" sourceType=\"float64\" comment=\"list of penetration depths\"/>\
</class>\
\
<class name=\"ContactsState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"acbcb1601a8e525bf72509f18e6f668d\" rosDesc=\"Header header                                   # stamp\\ngazebo_msgs/ContactState[] states            # array of geom pairs in contact\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: gazebo_msgs/ContactState\\nstring info                                   # text info on this contact\\nstring collision1_name                        # name of contact collision1\\nstring collision2_name                        # name of contact collision2\\ngeometry_msgs/Wrench[] wrenches               # list of forces/torques\\ngeometry_msgs/Wrench total_wrench             # sum of forces/torques in every DOF\\ngeometry_msgs/Vector3[] contact_positions     # list of contact position\\ngeometry_msgs/Vector3[] contact_normals       # list of contact normals\\nfloat64[] depths                              # list of penetration depths\\n\\n================================================================================\\nMSG: geometry_msgs/Wrench\\n# This represents force in free space, separated into\\n# its linear and angular parts.\\nVector3  force\\nVector3  torque\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"stamp\"/>\
  <field name=\"states\" type=\"vector(gazebo_msgs::ContactState)\" sourceType=\"gazebo_msgs::ContactState\" comment=\"array of geom pairs in contact\"/>\
</class>\
\
<class name=\"LinkState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"0818ebbf28ce3a08d48ab1eaa7309ebe\" rosDesc=\"# @todo: FIXME: sets pose and twist of a link.  All children link poses/twists of the URDF tree are not updated accordingly, but should be.\\nstring link_name            # link name, link_names are in gazebo scoped name notation, [model_name::body_name]\\ngeometry_msgs/Pose pose     # desired pose in reference frame\\ngeometry_msgs/Twist twist   # desired twist in reference frame\\nstring reference_frame      # set pose/twist relative to the frame of this link/body\\n                            # leave empty or \\&quot;world\\&quot; or \\&quot;map\\&quot; defaults to world-frame\\n\\n================================================================================\\nMSG: geometry_msgs/Pose\\n# A representation of pose in free space, composed of postion and orientation. \\nPoint position\\nQuaternion orientation\\n\\n================================================================================\\nMSG: geometry_msgs/Point\\n# This contains the position of a point in free space\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Twist\\n# This expresses velocity in free space broken into its linear and angular parts.\\nVector3  linear\\nVector3  angular\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"@todo: FIXME: sets pose and twist of a link.  All children link poses/twists of the URDF tree are not updated accordingly, but should be.\">\
  <field name=\"link_name\" type=\"string\" sourceType=\"string\" comment=\"link name, link_names are in gazebo scoped name notation, [model_name::body_name]\"/>\
  <field name=\"pose\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"desired pose in reference frame\"/>\
  <field name=\"twist\" type=\"geometry_msgs::Twist\" sourceType=\"geometry_msgs::Twist\" comment=\"desired twist in reference frame\"/>\
  <field name=\"reference_frame\" type=\"string\" sourceType=\"string\" comment=\"set pose/twist relative to the frame of this link/body  leave empty or &quot;world&quot; or &quot;map&quot; defaults to world-frame\"/>\
</class>\
\
<class name=\"LinkStates\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"48c080191eb15c41858319b4d8a609c2\" rosDesc=\"# broadcast all link states in world frame\\nstring[] name                 # link names\\ngeometry_msgs/Pose[] pose     # desired pose in world frame\\ngeometry_msgs/Twist[] twist   # desired twist in world frame\\n\\n================================================================================\\nMSG: geometry_msgs/Pose\\n# A representation of pose in free space, composed of postion and orientation. \\nPoint position\\nQuaternion orientation\\n\\n================================================================================\\nMSG: geometry_msgs/Point\\n# This contains the position of a point in free space\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Twist\\n# This expresses velocity in free space broken into its linear and angular parts.\\nVector3  linear\\nVector3  angular\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"broadcast all link states in world frame\">\
  <field name=\"name\" type=\"vector(string)\" sourceType=\"string\" comment=\"link names\"/>\
  <field name=\"pose\" type=\"vector(geometry_msgs::Pose)\" sourceType=\"geometry_msgs::Pose\" comment=\"desired pose in world frame\"/>\
  <field name=\"twist\" type=\"vector(geometry_msgs::Twist)\" sourceType=\"geometry_msgs::Twist\" comment=\"desired twist in world frame\"/>\
</class>\
\
<class name=\"ModelState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"9330fd35f2fcd82d457e54bd54e10593\" rosDesc=\"# Set Gazebo Model pose and twist\\nstring model_name           # model to set state (pose and twist)\\ngeometry_msgs/Pose pose     # desired pose in reference frame\\ngeometry_msgs/Twist twist   # desired twist in reference frame\\nstring reference_frame      # set pose/twist relative to the frame of this entity (Body/Model)\\n                            # leave empty or \\&quot;world\\&quot; or \\&quot;map\\&quot; defaults to world-frame\\n\\n\\n================================================================================\\nMSG: geometry_msgs/Pose\\n# A representation of pose in free space, composed of postion and orientation. \\nPoint position\\nQuaternion orientation\\n\\n================================================================================\\nMSG: geometry_msgs/Point\\n# This contains the position of a point in free space\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Twist\\n# This expresses velocity in free space broken into its linear and angular parts.\\nVector3  linear\\nVector3  angular\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"Set Gazebo Model pose and twist\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"model to set state (pose and twist)\"/>\
  <field name=\"pose\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"desired pose in reference frame\"/>\
  <field name=\"twist\" type=\"geometry_msgs::Twist\" sourceType=\"geometry_msgs::Twist\" comment=\"desired twist in reference frame\"/>\
  <field name=\"reference_frame\" type=\"string\" sourceType=\"string\" comment=\"set pose/twist relative to the frame of this entity (Body/Model)  leave empty or &quot;world&quot; or &quot;map&quot; defaults to world-frame\"/>\
</class>\
\
<class name=\"ModelStates\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"48c080191eb15c41858319b4d8a609c2\" rosDesc=\"# broadcast all model states in world frame\\nstring[] name                 # model names\\ngeometry_msgs/Pose[] pose     # desired pose in world frame\\ngeometry_msgs/Twist[] twist   # desired twist in world frame\\n\\n================================================================================\\nMSG: geometry_msgs/Pose\\n# A representation of pose in free space, composed of postion and orientation. \\nPoint position\\nQuaternion orientation\\n\\n================================================================================\\nMSG: geometry_msgs/Point\\n# This contains the position of a point in free space\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Twist\\n# This expresses velocity in free space broken into its linear and angular parts.\\nVector3  linear\\nVector3  angular\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\n\" comment=\"broadcast all model states in world frame\">\
  <field name=\"name\" type=\"vector(string)\" sourceType=\"string\" comment=\"model names\"/>\
  <field name=\"pose\" type=\"vector(geometry_msgs::Pose)\" sourceType=\"geometry_msgs::Pose\" comment=\"desired pose in world frame\"/>\
  <field name=\"twist\" type=\"vector(geometry_msgs::Twist)\" sourceType=\"geometry_msgs::Twist\" comment=\"desired twist in world frame\"/>\
</class>\
\
<class name=\"ODEJointProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"1b744c32a920af979f53afe2f9c3511f\" rosDesc=\"# access to low level joint properties, change these at your own risk\\nfloat64[] damping             # joint damping\\nfloat64[] hiStop              # joint limit\\nfloat64[] loStop              # joint limit\\nfloat64[] erp                 # set joint erp\\nfloat64[] cfm                 # set joint cfm\\nfloat64[] stop_erp            # set joint erp for joint limit \\&quot;contact\\&quot; joint\\nfloat64[] stop_cfm            # set joint cfm for joint limit \\&quot;contact\\&quot; joint\\nfloat64[] fudge_factor        # joint fudge_factor applied at limits, see ODE manual for info.\\nfloat64[] fmax                # ode joint param fmax\\nfloat64[] vel                 # ode joint param vel\\n\" comment=\"access to low level joint properties, change these at your own risk\">\
  <field name=\"damping\" type=\"vector(double)\" sourceType=\"float64\" comment=\"joint damping\"/>\
  <field name=\"hiStop\" type=\"vector(double)\" sourceType=\"float64\" comment=\"joint limit\"/>\
  <field name=\"loStop\" type=\"vector(double)\" sourceType=\"float64\" comment=\"joint limit\"/>\
  <field name=\"erp\" type=\"vector(double)\" sourceType=\"float64\" comment=\"set joint erp\"/>\
  <field name=\"cfm\" type=\"vector(double)\" sourceType=\"float64\" comment=\"set joint cfm\"/>\
  <field name=\"stop_erp\" type=\"vector(double)\" sourceType=\"float64\" comment=\"set joint erp for joint limit &quot;contact&quot; joint\"/>\
  <field name=\"stop_cfm\" type=\"vector(double)\" sourceType=\"float64\" comment=\"set joint cfm for joint limit &quot;contact&quot; joint\"/>\
  <field name=\"fudge_factor\" type=\"vector(double)\" sourceType=\"float64\" comment=\"joint fudge_factor applied at limits, see ODE manual for info.\"/>\
  <field name=\"fmax\" type=\"vector(double)\" sourceType=\"float64\" comment=\"ode joint param fmax\"/>\
  <field name=\"vel\" type=\"vector(double)\" sourceType=\"float64\" comment=\"ode joint param vel\"/>\
</class>\
\
<class name=\"ODEPhysics\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"667d56ddbd547918c32d1934503dc335\" rosDesc=\"bool auto_disable_bodies           # enable auto disabling of bodies, default false\\nuint32 sor_pgs_precon_iters        # preconditioning inner iterations when uisng projected Gauss Seidel\\nuint32 sor_pgs_iters               # inner iterations when uisng projected Gauss Seidel\\nfloat64 sor_pgs_w                  # relaxation parameter when using projected Gauss Seidel, 1 = no relaxation\\nfloat64 sor_pgs_rms_error_tol      # rms error tolerance before stopping inner iterations\\nfloat64 contact_surface_layer      # contact \\&quot;dead-band\\&quot; width\\nfloat64 contact_max_correcting_vel # contact maximum correction velocity\\nfloat64 cfm                        # global constraint force mixing\\nfloat64 erp                        # global error reduction parameter\\nuint32 max_contacts                # maximum contact joints between two geoms\\n\" comment=\"\">\
  <field name=\"auto_disable_bodies\" type=\"bool\" sourceType=\"bool\" comment=\"enable auto disabling of bodies, default false\"/>\
  <field name=\"sor_pgs_precon_iters\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"preconditioning inner iterations when uisng projected Gauss Seidel\"/>\
  <field name=\"sor_pgs_iters\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"inner iterations when uisng projected Gauss Seidel\"/>\
  <field name=\"sor_pgs_w\" type=\"double\" sourceType=\"float64\" comment=\"relaxation parameter when using projected Gauss Seidel, 1 = no relaxation\"/>\
  <field name=\"sor_pgs_rms_error_tol\" type=\"double\" sourceType=\"float64\" comment=\"rms error tolerance before stopping inner iterations\"/>\
  <field name=\"contact_surface_layer\" type=\"double\" sourceType=\"float64\" comment=\"contact &quot;dead-band&quot; width\"/>\
  <field name=\"contact_max_correcting_vel\" type=\"double\" sourceType=\"float64\" comment=\"contact maximum correction velocity\"/>\
  <field name=\"cfm\" type=\"double\" sourceType=\"float64\" comment=\"global constraint force mixing\"/>\
  <field name=\"erp\" type=\"double\" sourceType=\"float64\" comment=\"global error reduction parameter\"/>\
  <field name=\"max_contacts\" type=\"unsigned int\" sourceType=\"uint32\" comment=\"maximum contact joints between two geoms\"/>\
</class>\
\
<class name=\"WorldState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" rosMD5=\"de1a9de3ab7ba97ac0e9ec01a4eb481e\" rosDesc=\"# This is a message that holds data necessary to reconstruct a snapshot of the world\\n#\\n# = Approach to Message Passing =\\n# The state of the world is defined by either\\n#   1. Inertial Model pose, twist\\n#      * kinematic data - connectivity graph from Model to each Link\\n#      * joint angles\\n#      * joint velocities\\n#      * Applied forces - Body wrench\\n#        * relative transform from Body to each collision Geom\\n# Or\\n#   2. Inertial (absolute) Body pose, twist, wrench\\n#      * relative transform from Body to each collision Geom - constant, so not sent over wire\\n#      * back compute from canonical body info to get Model pose and twist.\\n#\\n# Chooing (2.) because it matches most physics engines out there\\n#   and is simpler.\\n#\\n# = Future =\\n# Consider impacts on using reduced coordinates / graph (parent/child links) approach\\n#   constraint and physics solvers.\\n#\\n# = Application =\\n# This message is used to do the following:\\n#   * reconstruct the world and objects for sensor generation\\n#   * stop / start simulation - need pose, twist, wrench of each body\\n#   * collision detection - need pose of each collision geometry.  velocity/acceleration if \\n#\\n# = Assumptions =\\n# Assuming that each (physics) processor node locally already has\\n#   * collision information - Trimesh for Geoms, etc\\n#   * relative transforms from Body to Geom - this is assumed to be fixed, do not send oved wire\\n#   * inertial information - does not vary in time\\n#   * visual information - does not vary in time\\n#\\n\\nHeader header\\n\\nstring[] name\\ngeometry_msgs/Pose[] pose\\ngeometry_msgs/Twist[] twist\\ngeometry_msgs/Wrench[] wrench\\n\\n================================================================================\\nMSG: std_msgs/Header\\n# Standard metadata for higher-level stamped data types.\\n# This is generally used to communicate timestamped data \\n# in a particular coordinate frame.\\n# \\n# sequence ID: consecutively increasing ID \\nuint32 seq\\n#Two-integer timestamp that is expressed as:\\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\\n# time-handling sugar is provided by the client library\\ntime stamp\\n#Frame this data is associated with\\n# 0: no frame\\n# 1: global frame\\nstring frame_id\\n\\n================================================================================\\nMSG: geometry_msgs/Pose\\n# A representation of pose in free space, composed of postion and orientation. \\nPoint position\\nQuaternion orientation\\n\\n================================================================================\\nMSG: geometry_msgs/Point\\n# This contains the position of a point in free space\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n\\n================================================================================\\nMSG: geometry_msgs/Quaternion\\n# This represents an orientation in free space in quaternion form.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\nfloat64 w\\n\\n================================================================================\\nMSG: geometry_msgs/Twist\\n# This expresses velocity in free space broken into its linear and angular parts.\\nVector3  linear\\nVector3  angular\\n\\n================================================================================\\nMSG: geometry_msgs/Vector3\\n# This represents a vector in free space. \\n# It is only meant to represent a direction. Therefore, it does not\\n# make sense to apply a translation to it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 will only apply the\\n# rotation). If you want your data to be translatable too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 y\\nfloat64 z\\n================================================================================\\nMSG: geometry_msgs/Wrench\\n# This represents force in free space, separated into\\n# its linear and angular parts.\\nVector3  force\\nVector3  torque\\n\" comment=\"This is a message that holds data necessary to reconstruct a snapshot of the world   = Approach to Message Passing =  The state of the world is defined by either    1. Inertial Model pose, twist       * kinematic data - connectivity graph from Model to each Link       * joint angles       * joint velocities       * Applied forces - Body wrench         * relative transform from Body to each collision Geom  Or    2. Inertial (absolute) Body pose, twist, wrench       * relative transform from Body to each collision Geom - constant, so not sent over wire       * back compute from canonical body info to get Model pose and twist.   Chooing (2.) because it matches most physics engines out there    and is simpler.   = Future =  Consider impacts on using reduced coordinates / graph (parent/child links) approach    constraint and physics solvers.   = Application =  This message is used to do the following:    * reconstruct the world and objects for sensor generation    * stop / start simulation - need pose, twist, wrench of each body    * collision detection - need pose of each collision geometry.  velocity/acceleration if    = Assumptions =  Assuming that each (physics) processor node locally already has    * collision information - Trimesh for Geoms, etc    * relative transforms from Body to Geom - this is assumed to be fixed, do not send oved wire    * inertial information - does not vary in time    * visual information - does not vary in time\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"\"/>\
  <field name=\"name\" type=\"vector(string)\" sourceType=\"string\" comment=\"\"/>\
  <field name=\"pose\" type=\"vector(geometry_msgs::Pose)\" sourceType=\"geometry_msgs::Pose\" comment=\"\"/>\
  <field name=\"twist\" type=\"vector(geometry_msgs::Twist)\" sourceType=\"geometry_msgs::Twist\" comment=\"\"/>\
  <field name=\"wrench\" type=\"vector(geometry_msgs::Wrench)\" sourceType=\"geometry_msgs::Wrench\" comment=\"\"/>\
</class>\
\
<class name=\"ApplyBodyWrenchRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"Apply Wrench to Gazebo Body.  via the callback mechanism  all Gazebo operations are made in world frame\">\
  <field name=\"body_name\" type=\"string\" sourceType=\"string\" comment=\"Gazebo body to apply wrench (linear force and torque)  wrench is applied in the gazebo world by default  body names are prefixed by model name, e.g. pr2::base_link\"/>\
  <field name=\"reference_frame\" type=\"string\" sourceType=\"string\" comment=\"wrench is defined in the reference frame of this entity  use inertial frame if left empty  frame names are bodies prefixed by model name, e.g. pr2::base_link\"/>\
  <field name=\"reference_point\" type=\"geometry_msgs::Point\" sourceType=\"geometry_msgs::Point\" comment=\"wrench is defined at this location in the reference frame\"/>\
  <field name=\"wrench\" type=\"geometry_msgs::Wrench\" sourceType=\"geometry_msgs::Wrench\" comment=\"wrench applied to the origin of the body\"/>\
  <field name=\"start_time\" type=\"std_msgs::RosTime\" sourceType=\"time\" comment=\"(optional) wrench application start time (seconds)  if start_time is not specified, or  start_time &lt; current time, start as soon as possible\"/>\
  <field name=\"duration\" type=\"std_msgs::RosDuration\" sourceType=\"duration\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"ApplyBodyWrenchResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"Apply Wrench to Gazebo Body.  via the callback mechanism  all Gazebo operations are made in world frame\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if set wrench successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"ApplyBodyWrench\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"Apply Wrench to Gazebo Body.  via the callback mechanism  all Gazebo operations are made in world frame\">\
  <definition name=\"Request\" type=\"ApplyBodyWrenchRequest\"/>\
  <definition name=\"Response\" type=\"ApplyBodyWrenchResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"ApplyJointEffortRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"set urdf joint effort\">\
  <field name=\"joint_name\" type=\"string\" sourceType=\"string\" comment=\"joint to apply wrench (linear force and torque)\"/>\
  <field name=\"effort\" type=\"double\" sourceType=\"float64\" comment=\"effort to apply\"/>\
  <field name=\"start_time\" type=\"std_msgs::RosTime\" sourceType=\"time\" comment=\"optional wrench application start time (seconds)  if start_time &lt; current time, start as soon as possible\"/>\
  <field name=\"duration\" type=\"std_msgs::RosDuration\" sourceType=\"duration\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"ApplyJointEffortResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"set urdf joint effort\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if effort application is successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"ApplyJointEffort\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"set urdf joint effort\">\
  <definition name=\"Request\" type=\"ApplyJointEffortRequest\"/>\
  <definition name=\"Response\" type=\"ApplyJointEffortResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"BodyRequestRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"body_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"BodyRequestResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
</class>\
\
<class name=\"BodyRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"BodyRequestRequest\"/>\
  <definition name=\"Response\" type=\"BodyRequestResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"DeleteModelRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"DeleteModelResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if deletion is successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"DeleteModel\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"DeleteModelRequest\"/>\
  <definition name=\"Response\" type=\"DeleteModelResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetJointPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"joint_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"GetJointPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"type\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"\"/>\
  <constant init=\"0\" name=\"REVOLUTE\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"single DOF\"/>\
  <constant init=\"1\" name=\"CONTINUOUS\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"single DOF (revolute w/o joints)\"/>\
  <constant init=\"2\" name=\"PRISMATIC\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"single DOF\"/>\
  <constant init=\"3\" name=\"FIXED\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"0 DOF\"/>\
  <constant init=\"4\" name=\"BALL\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"3 DOF\"/>\
  <constant init=\"5\" name=\"UNIVERSAL\" type=\"unsigned char\" sourceType=\"uint8\" comment=\"2 DOF  dynamics properties\"/>\
  <field name=\"damping\" type=\"vector(double)\" sourceType=\"float64\" comment=\"joint state\"/>\
  <field name=\"position\" type=\"vector(double)\" sourceType=\"float64\" comment=\"\"/>\
  <field name=\"rate\" type=\"vector(double)\" sourceType=\"float64\" comment=\"service return status\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetJointProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"GetJointPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"GetJointPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetLinkPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"link_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"GetLinkPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"com\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"center of mass location in link frame  and orientation of the moment of inertias  relative to the link frame\"/>\
  <field name=\"gravity_mode\" type=\"bool\" sourceType=\"bool\" comment=\"set gravity mode on/off\"/>\
  <field name=\"mass\" type=\"double\" sourceType=\"float64\" comment=\"linear mass of link\"/>\
  <field name=\"ixx\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"ixy\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"ixz\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"iyy\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"iyz\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"izz\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get info is successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetLinkProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"GetLinkPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"GetLinkPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetLinkStateRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"link_name\" type=\"string\" sourceType=\"string\" comment=\"name of link  link names are prefixed by model name, e.g. pr2::base_link\"/>\
  <field name=\"reference_frame\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"GetLinkStateResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"link_state\" type=\"gazebo_msgs::LinkState\" sourceType=\"gazebo_msgs::LinkState\" comment=\"\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get info is successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetLinkState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"GetLinkStateRequest\"/>\
  <definition name=\"Response\" type=\"GetLinkStateResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetModelPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"GetModelPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"parent_model_name\" type=\"string\" sourceType=\"string\" comment=\"parent model\"/>\
  <field name=\"canonical_body_name\" type=\"string\" sourceType=\"string\" comment=\"name of canonical body, body names are prefixed by model name, e.g. pr2::base_link\"/>\
  <field name=\"body_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"list of bodies, body names are prefixed by model name, e.g. pr2::base_link\"/>\
  <field name=\"geom_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"list of geoms\"/>\
  <field name=\"joint_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"list of joints attached to the model\"/>\
  <field name=\"child_model_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"list of child models\"/>\
  <field name=\"is_static\" type=\"bool\" sourceType=\"bool\" comment=\"returns true if model is static\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetModelProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"GetModelPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"GetModelPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetModelStateRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"name of Gazebo Model\"/>\
  <field name=\"relative_entity_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"GetModelStateResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"header\" type=\"std_msgs::Header\" sourceType=\"Header\" comment=\"Standard metadata for higher-level stamped data types.  * header.seq holds the number of requests since the plugin started  * header.stamp timestamp related to the pose  * header.frame_id not used but currently filled with the relative_entity_name\"/>\
  <field name=\"pose\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"pose of model in relative entity frame\"/>\
  <field name=\"twist\" type=\"geometry_msgs::Twist\" sourceType=\"geometry_msgs::Twist\" comment=\"twist of model in relative entity frame\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetModelState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"GetModelStateRequest\"/>\
  <definition name=\"Response\" type=\"GetModelStateResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetPhysicsPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"sets pose and twist of a link.  All children link poses/twists of the URDF tree will be updated accordingly\">\
</class>\
\
<class name=\"GetPhysicsPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"sets pose and twist of a link.  All children link poses/twists of the URDF tree will be updated accordingly\">\
  <field name=\"time_step\" type=\"double\" sourceType=\"float64\" comment=\"dt in seconds\"/>\
  <field name=\"pause\" type=\"bool\" sourceType=\"bool\" comment=\"true if physics engine is paused\"/>\
  <field name=\"max_update_rate\" type=\"double\" sourceType=\"float64\" comment=\"throttle maximum physics update rate\"/>\
  <field name=\"gravity\" type=\"geometry_msgs::Vector3\" sourceType=\"geometry_msgs::Vector3\" comment=\"gravity vector (e.g. earth ~[0,0,-9.81])\"/>\
  <field name=\"ode_config\" type=\"gazebo_msgs::ODEPhysics\" sourceType=\"gazebo_msgs::ODEPhysics\" comment=\"contains physics configurations pertaining to ODE\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if set wrench successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetPhysicsProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"sets pose and twist of a link.  All children link poses/twists of the URDF tree will be updated accordingly\">\
  <definition name=\"Request\" type=\"GetPhysicsPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"GetPhysicsPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"GetWorldPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
</class>\
\
<class name=\"GetWorldPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"sim_time\" type=\"double\" sourceType=\"float64\" comment=\"current sim time\"/>\
  <field name=\"model_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"list of models in the world\"/>\
  <field name=\"rendering_enabled\" type=\"bool\" sourceType=\"bool\" comment=\"if X is used\"/>\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"GetWorldProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"GetWorldPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"GetWorldPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"JointRequestRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"joint_name\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"JointRequestResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
</class>\
\
<class name=\"JointRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"JointRequestRequest\"/>\
  <definition name=\"Response\" type=\"JointRequestResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetJointPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"joint_name\" type=\"string\" sourceType=\"string\" comment=\"name of joint\"/>\
  <field name=\"ode_joint_config\" type=\"gazebo_msgs::ODEJointProperties\" sourceType=\"gazebo_msgs::ODEJointProperties\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetJointPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetJointProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"SetJointPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"SetJointPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetJointTrajectoryRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"\"/>\
  <field name=\"joint_trajectory\" type=\"trajectory_msgs::JointTrajectory\" sourceType=\"trajectory_msgs::JointTrajectory\" comment=\"\"/>\
  <field name=\"model_pose\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"\"/>\
  <field name=\"set_model_pose\" type=\"bool\" sourceType=\"bool\" comment=\"\"/>\
  <field name=\"disable_physics_updates\" type=\"bool\" sourceType=\"bool\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetJointTrajectoryResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if set wrench successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetJointTrajectory\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"SetJointTrajectoryRequest\"/>\
  <definition name=\"Response\" type=\"SetJointTrajectoryResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetLinkPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"link_name\" type=\"string\" sourceType=\"string\" comment=\"name of link  link names are prefixed by model name, e.g. pr2::base_link\"/>\
  <field name=\"com\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"center of mass location in link frame  and orientation of the moment of inertias  relative to the link frame\"/>\
  <field name=\"gravity_mode\" type=\"bool\" sourceType=\"bool\" comment=\"set gravity mode on/off\"/>\
  <field name=\"mass\" type=\"double\" sourceType=\"float64\" comment=\"linear mass of link\"/>\
  <field name=\"ixx\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"ixy\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"ixz\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"iyy\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"iyz\" type=\"double\" sourceType=\"float64\" comment=\"moment of inertia\"/>\
  <field name=\"izz\" type=\"double\" sourceType=\"float64\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetLinkPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if get info is successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetLinkProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"SetLinkPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"SetLinkPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetLinkStateRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"link_state\" type=\"gazebo_msgs::LinkState\" sourceType=\"gazebo_msgs::LinkState\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetLinkStateResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if set wrench successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetLinkState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"SetLinkStateRequest\"/>\
  <definition name=\"Response\" type=\"SetLinkStateResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetModelConfigurationRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"Set Gazebo Model pose and twist\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"model to set state (pose and twist)\"/>\
  <field name=\"urdf_param_name\" type=\"string\" sourceType=\"string\" comment=\"parameter name that contains the urdf XML.\"/>\
  <field name=\"joint_names\" type=\"vector(string)\" sourceType=\"string\" comment=\"list of joints to set positions.  if joint is not listed here, preserve current position.\"/>\
  <field name=\"joint_positions\" type=\"vector(double)\" sourceType=\"float64\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetModelConfigurationResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"Set Gazebo Model pose and twist\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if setting state successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetModelConfiguration\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"Set Gazebo Model pose and twist\">\
  <definition name=\"Request\" type=\"SetModelConfigurationRequest\"/>\
  <definition name=\"Response\" type=\"SetModelConfigurationResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetModelStateRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"model_state\" type=\"gazebo_msgs::ModelState\" sourceType=\"gazebo_msgs::ModelState\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetModelStateResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if setting state successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetModelState\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"SetModelStateRequest\"/>\
  <definition name=\"Response\" type=\"SetModelStateResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SetPhysicsPropertiesRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"sets pose and twist of a link.  All children link poses/twists of the URDF tree will be updated accordingly\">\
  <field name=\"time_step\" type=\"double\" sourceType=\"float64\" comment=\"dt in seconds\"/>\
  <field name=\"max_update_rate\" type=\"double\" sourceType=\"float64\" comment=\"throttle maximum physics update rate\"/>\
  <field name=\"gravity\" type=\"geometry_msgs::Vector3\" sourceType=\"geometry_msgs::Vector3\" comment=\"gravity vector (e.g. earth ~[0,0,-9.81])\"/>\
  <field name=\"ode_config\" type=\"gazebo_msgs::ODEPhysics\" sourceType=\"gazebo_msgs::ODEPhysics\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SetPhysicsPropertiesResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"sets pose and twist of a link.  All children link poses/twists of the URDF tree will be updated accordingly\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if set wrench successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SetPhysicsProperties\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"sets pose and twist of a link.  All children link poses/twists of the URDF tree will be updated accordingly\">\
  <definition name=\"Request\" type=\"SetPhysicsPropertiesRequest\"/>\
  <definition name=\"Response\" type=\"SetPhysicsPropertiesResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<class name=\"SpawnModelRequest\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"model_name\" type=\"string\" sourceType=\"string\" comment=\"name of the model to be spawn\"/>\
  <field name=\"model_xml\" type=\"string\" sourceType=\"string\" comment=\"this should be an urdf or gazebo xml\"/>\
  <field name=\"robot_namespace\" type=\"string\" sourceType=\"string\" comment=\"spawn robot and all ROS interfaces under this namespace\"/>\
  <field name=\"initial_pose\" type=\"geometry_msgs::Pose\" sourceType=\"geometry_msgs::Pose\" comment=\"only applied to canonical body\"/>\
  <field name=\"reference_frame\" type=\"string\" sourceType=\"string\" comment=\"no comment provided\"/>\
</class>\
\
<class name=\"SpawnModelResponse\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <field name=\"success\" type=\"bool\" sourceType=\"bool\" comment=\"return true if spawn successful\"/>\
  <field name=\"status_message\" type=\"string\" sourceType=\"string\" comment=\"comments if available\"/>\
</class>\
\
<class name=\"SpawnModel\" publicDataMembers=\"true\" sourceIDL=\"ROS\" ros=\"true\" comment=\"\">\
  <definition name=\"Request\" type=\"SpawnModelRequest\"/>\
  <definition name=\"Response\" type=\"SpawnModelResponse\"/>\
  <field name=\"request\" type=\"Request\" comment=\"request data type\"/>\
  <field name=\"response\" type=\"Response\" comment=\"response data type\"/>\
</class>\
\
<dependency name=\"geometry_msgs_gencpp\"/>\
<dependency name=\"std_msgs_gencpp\"/>\
<dependency name=\"std_srvs_gencpp\"/>\
<dependency name=\"trajectory_msgs_gencpp\"/>\
\
</classes>\
";
    }

}; // end namespace gazebo_msgs

