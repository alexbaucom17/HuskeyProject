// 
//  AUTOGENERATED FILE:   do not edit
//
//  Generated by:         yongbo on yongbo-XPS-15-9550, 2016-11-23 17:33:56 -0500
//  From Template/Script: data_templates/ROSTemplate.cpp.rb
 
/*
  CTA RIGHTS

  This document contains information proprietary to General Dynamics
  Robotic Systems and is not to be reproduced, transmitted, transferred,
  or otherwise used without the express written consent of General
  Dynamics Robotic Systems except as described below.

  GOVERNMENT PURPOSE RIGHTS

  Contract No.:        W911NF-10-2-0016, Articles of Collaboration,
                       Article 5, Intellectual Property
  Contractor Name:     General Dynamics Robotic Systems, Inc. (GDRS)
  Contractor Address:  1231 Tech Court, Westminster, MD  21157

  Expiration Date - None

  Technical data and computer software first created by Member(s) in
  performance of the Agreement will be disclosed to the Government.
  General Dynamics Robotic Systems retains the entire right, title, and
  interest throughout the world to each subject invention subject to the
  provisions of this clause and 37 CFR Part 401, 32 CFR 32.36, and
  34 CFR 34.25. The Government shall have the right to obtain, reproduce,
  publish or otherwise use the work for Government purposes.

  NON-EXCLUSIVE LICENSE TO CONSORTIUM PARTICIPANTS
  Consortium Members and subawardees are defined as 'Participants'
  Under Article 5.3, Participants are granted a nonexclusive, royalty-
  free, non-sublicenseable, non-assignable, license to Consortium
  Intellectual Property for the limited purpose of performing tasks under
  The Cooperative Agreement, for Government purposes only, and to make and
  have the same made solely for such use.

*/

#include "gazebo_msgs_gencpp_ROS.h"
#include <common/Log.h>
#include <common/DataTypeInfo.h>

using namespace std;
using namespace gazebo_msgs;

rframe::ROSMessageFactory * ROS_gazebo_msgs_gencppfactory = NULL;

extern "C"
{
    /** library access method */
    rframe::MessageFactoryBase * AllocateMessageFactory()
    {
        ROS_gazebo_msgs_gencppfactory = new gazebo_msgs_gencppROSMessageFactory();

        return ROS_gazebo_msgs_gencppfactory;
    };
}

rframe::ROSMessageFactory * gazebo_msgs::allocate_gazebo_msgs_gencpp()
{
    ROS_gazebo_msgs_gencppfactory = new gazebo_msgs_gencppROSMessageFactory();
    return ROS_gazebo_msgs_gencppfactory;
};

gazebo_msgs_gencppROSMessageFactory::gazebo_msgs_gencppROSMessageFactory()
{
    name("gazebo_msgs_gencpp");
    // use constructor to register data types
    gazebo_msgs::registerLibrary();
}

gazebo_msgs_gencppROSMessageFactory::~gazebo_msgs_gencppROSMessageFactory()
{
}

int gazebo_msgs_gencppROSMessageFactory::dataType(ros::SerializedMessage & msg)
{
    return msg.message_type;
}

void gazebo_msgs_gencppROSMessageFactory::dataTypes(vector<DataTypeInfo> & ids)
{
    DataTypeInfo info;

    ids.clear();

    info.id(ContactState::ID);
    info.name(ContactState::DATA_TYPE_FULL_NAME);
    info.hashKey(ContactState::DATA_VERSION);
    info.md5Key(ContactState::VERSION_MD5);
    info.xmlSource(ContactState::XML_SOURCE);
    info.flat(ContactState::dataTypeFlat());
    ids.push_back(info);

    info.id(ContactsState::ID);
    info.name(ContactsState::DATA_TYPE_FULL_NAME);
    info.hashKey(ContactsState::DATA_VERSION);
    info.md5Key(ContactsState::VERSION_MD5);
    info.xmlSource(ContactsState::XML_SOURCE);
    info.flat(ContactsState::dataTypeFlat());
    ids.push_back(info);

    info.id(LinkState::ID);
    info.name(LinkState::DATA_TYPE_FULL_NAME);
    info.hashKey(LinkState::DATA_VERSION);
    info.md5Key(LinkState::VERSION_MD5);
    info.xmlSource(LinkState::XML_SOURCE);
    info.flat(LinkState::dataTypeFlat());
    ids.push_back(info);

    info.id(LinkStates::ID);
    info.name(LinkStates::DATA_TYPE_FULL_NAME);
    info.hashKey(LinkStates::DATA_VERSION);
    info.md5Key(LinkStates::VERSION_MD5);
    info.xmlSource(LinkStates::XML_SOURCE);
    info.flat(LinkStates::dataTypeFlat());
    ids.push_back(info);

    info.id(ModelState::ID);
    info.name(ModelState::DATA_TYPE_FULL_NAME);
    info.hashKey(ModelState::DATA_VERSION);
    info.md5Key(ModelState::VERSION_MD5);
    info.xmlSource(ModelState::XML_SOURCE);
    info.flat(ModelState::dataTypeFlat());
    ids.push_back(info);

    info.id(ModelStates::ID);
    info.name(ModelStates::DATA_TYPE_FULL_NAME);
    info.hashKey(ModelStates::DATA_VERSION);
    info.md5Key(ModelStates::VERSION_MD5);
    info.xmlSource(ModelStates::XML_SOURCE);
    info.flat(ModelStates::dataTypeFlat());
    ids.push_back(info);

    info.id(ODEJointProperties::ID);
    info.name(ODEJointProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(ODEJointProperties::DATA_VERSION);
    info.md5Key(ODEJointProperties::VERSION_MD5);
    info.xmlSource(ODEJointProperties::XML_SOURCE);
    info.flat(ODEJointProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(ODEPhysics::ID);
    info.name(ODEPhysics::DATA_TYPE_FULL_NAME);
    info.hashKey(ODEPhysics::DATA_VERSION);
    info.md5Key(ODEPhysics::VERSION_MD5);
    info.xmlSource(ODEPhysics::XML_SOURCE);
    info.flat(ODEPhysics::dataTypeFlat());
    ids.push_back(info);

    info.id(WorldState::ID);
    info.name(WorldState::DATA_TYPE_FULL_NAME);
    info.hashKey(WorldState::DATA_VERSION);
    info.md5Key(WorldState::VERSION_MD5);
    info.xmlSource(WorldState::XML_SOURCE);
    info.flat(WorldState::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyBodyWrenchRequest::ID);
    info.name(ApplyBodyWrenchRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyBodyWrenchRequest::DATA_VERSION);
    info.md5Key(ApplyBodyWrenchRequest::VERSION_MD5);
    info.xmlSource(ApplyBodyWrenchRequest::XML_SOURCE);
    info.flat(ApplyBodyWrenchRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyBodyWrenchResponse::ID);
    info.name(ApplyBodyWrenchResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyBodyWrenchResponse::DATA_VERSION);
    info.md5Key(ApplyBodyWrenchResponse::VERSION_MD5);
    info.xmlSource(ApplyBodyWrenchResponse::XML_SOURCE);
    info.flat(ApplyBodyWrenchResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyBodyWrench::ID);
    info.name(ApplyBodyWrench::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyBodyWrench::DATA_VERSION);
    info.md5Key(ApplyBodyWrench::VERSION_MD5);
    info.xmlSource(ApplyBodyWrench::XML_SOURCE);
    info.flat(ApplyBodyWrench::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyJointEffortRequest::ID);
    info.name(ApplyJointEffortRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyJointEffortRequest::DATA_VERSION);
    info.md5Key(ApplyJointEffortRequest::VERSION_MD5);
    info.xmlSource(ApplyJointEffortRequest::XML_SOURCE);
    info.flat(ApplyJointEffortRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyJointEffortResponse::ID);
    info.name(ApplyJointEffortResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyJointEffortResponse::DATA_VERSION);
    info.md5Key(ApplyJointEffortResponse::VERSION_MD5);
    info.xmlSource(ApplyJointEffortResponse::XML_SOURCE);
    info.flat(ApplyJointEffortResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(ApplyJointEffort::ID);
    info.name(ApplyJointEffort::DATA_TYPE_FULL_NAME);
    info.hashKey(ApplyJointEffort::DATA_VERSION);
    info.md5Key(ApplyJointEffort::VERSION_MD5);
    info.xmlSource(ApplyJointEffort::XML_SOURCE);
    info.flat(ApplyJointEffort::dataTypeFlat());
    ids.push_back(info);

    info.id(BodyRequestRequest::ID);
    info.name(BodyRequestRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(BodyRequestRequest::DATA_VERSION);
    info.md5Key(BodyRequestRequest::VERSION_MD5);
    info.xmlSource(BodyRequestRequest::XML_SOURCE);
    info.flat(BodyRequestRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(BodyRequestResponse::ID);
    info.name(BodyRequestResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(BodyRequestResponse::DATA_VERSION);
    info.md5Key(BodyRequestResponse::VERSION_MD5);
    info.xmlSource(BodyRequestResponse::XML_SOURCE);
    info.flat(BodyRequestResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(BodyRequest::ID);
    info.name(BodyRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(BodyRequest::DATA_VERSION);
    info.md5Key(BodyRequest::VERSION_MD5);
    info.xmlSource(BodyRequest::XML_SOURCE);
    info.flat(BodyRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DeleteModelRequest::ID);
    info.name(DeleteModelRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(DeleteModelRequest::DATA_VERSION);
    info.md5Key(DeleteModelRequest::VERSION_MD5);
    info.xmlSource(DeleteModelRequest::XML_SOURCE);
    info.flat(DeleteModelRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(DeleteModelResponse::ID);
    info.name(DeleteModelResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(DeleteModelResponse::DATA_VERSION);
    info.md5Key(DeleteModelResponse::VERSION_MD5);
    info.xmlSource(DeleteModelResponse::XML_SOURCE);
    info.flat(DeleteModelResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(DeleteModel::ID);
    info.name(DeleteModel::DATA_TYPE_FULL_NAME);
    info.hashKey(DeleteModel::DATA_VERSION);
    info.md5Key(DeleteModel::VERSION_MD5);
    info.xmlSource(DeleteModel::XML_SOURCE);
    info.flat(DeleteModel::dataTypeFlat());
    ids.push_back(info);

    info.id(GetJointPropertiesRequest::ID);
    info.name(GetJointPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetJointPropertiesRequest::DATA_VERSION);
    info.md5Key(GetJointPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetJointPropertiesRequest::XML_SOURCE);
    info.flat(GetJointPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetJointPropertiesResponse::ID);
    info.name(GetJointPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetJointPropertiesResponse::DATA_VERSION);
    info.md5Key(GetJointPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetJointPropertiesResponse::XML_SOURCE);
    info.flat(GetJointPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetJointProperties::ID);
    info.name(GetJointProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetJointProperties::DATA_VERSION);
    info.md5Key(GetJointProperties::VERSION_MD5);
    info.xmlSource(GetJointProperties::XML_SOURCE);
    info.flat(GetJointProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkPropertiesRequest::ID);
    info.name(GetLinkPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkPropertiesRequest::DATA_VERSION);
    info.md5Key(GetLinkPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetLinkPropertiesRequest::XML_SOURCE);
    info.flat(GetLinkPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkPropertiesResponse::ID);
    info.name(GetLinkPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkPropertiesResponse::DATA_VERSION);
    info.md5Key(GetLinkPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetLinkPropertiesResponse::XML_SOURCE);
    info.flat(GetLinkPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkProperties::ID);
    info.name(GetLinkProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkProperties::DATA_VERSION);
    info.md5Key(GetLinkProperties::VERSION_MD5);
    info.xmlSource(GetLinkProperties::XML_SOURCE);
    info.flat(GetLinkProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkStateRequest::ID);
    info.name(GetLinkStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkStateRequest::DATA_VERSION);
    info.md5Key(GetLinkStateRequest::VERSION_MD5);
    info.xmlSource(GetLinkStateRequest::XML_SOURCE);
    info.flat(GetLinkStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkStateResponse::ID);
    info.name(GetLinkStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkStateResponse::DATA_VERSION);
    info.md5Key(GetLinkStateResponse::VERSION_MD5);
    info.xmlSource(GetLinkStateResponse::XML_SOURCE);
    info.flat(GetLinkStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetLinkState::ID);
    info.name(GetLinkState::DATA_TYPE_FULL_NAME);
    info.hashKey(GetLinkState::DATA_VERSION);
    info.md5Key(GetLinkState::VERSION_MD5);
    info.xmlSource(GetLinkState::XML_SOURCE);
    info.flat(GetLinkState::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelPropertiesRequest::ID);
    info.name(GetModelPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelPropertiesRequest::DATA_VERSION);
    info.md5Key(GetModelPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetModelPropertiesRequest::XML_SOURCE);
    info.flat(GetModelPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelPropertiesResponse::ID);
    info.name(GetModelPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelPropertiesResponse::DATA_VERSION);
    info.md5Key(GetModelPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetModelPropertiesResponse::XML_SOURCE);
    info.flat(GetModelPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelProperties::ID);
    info.name(GetModelProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelProperties::DATA_VERSION);
    info.md5Key(GetModelProperties::VERSION_MD5);
    info.xmlSource(GetModelProperties::XML_SOURCE);
    info.flat(GetModelProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelStateRequest::ID);
    info.name(GetModelStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelStateRequest::DATA_VERSION);
    info.md5Key(GetModelStateRequest::VERSION_MD5);
    info.xmlSource(GetModelStateRequest::XML_SOURCE);
    info.flat(GetModelStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelStateResponse::ID);
    info.name(GetModelStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelStateResponse::DATA_VERSION);
    info.md5Key(GetModelStateResponse::VERSION_MD5);
    info.xmlSource(GetModelStateResponse::XML_SOURCE);
    info.flat(GetModelStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetModelState::ID);
    info.name(GetModelState::DATA_TYPE_FULL_NAME);
    info.hashKey(GetModelState::DATA_VERSION);
    info.md5Key(GetModelState::VERSION_MD5);
    info.xmlSource(GetModelState::XML_SOURCE);
    info.flat(GetModelState::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPhysicsPropertiesRequest::ID);
    info.name(GetPhysicsPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPhysicsPropertiesRequest::DATA_VERSION);
    info.md5Key(GetPhysicsPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetPhysicsPropertiesRequest::XML_SOURCE);
    info.flat(GetPhysicsPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPhysicsPropertiesResponse::ID);
    info.name(GetPhysicsPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPhysicsPropertiesResponse::DATA_VERSION);
    info.md5Key(GetPhysicsPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetPhysicsPropertiesResponse::XML_SOURCE);
    info.flat(GetPhysicsPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetPhysicsProperties::ID);
    info.name(GetPhysicsProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetPhysicsProperties::DATA_VERSION);
    info.md5Key(GetPhysicsProperties::VERSION_MD5);
    info.xmlSource(GetPhysicsProperties::XML_SOURCE);
    info.flat(GetPhysicsProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(GetWorldPropertiesRequest::ID);
    info.name(GetWorldPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(GetWorldPropertiesRequest::DATA_VERSION);
    info.md5Key(GetWorldPropertiesRequest::VERSION_MD5);
    info.xmlSource(GetWorldPropertiesRequest::XML_SOURCE);
    info.flat(GetWorldPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(GetWorldPropertiesResponse::ID);
    info.name(GetWorldPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(GetWorldPropertiesResponse::DATA_VERSION);
    info.md5Key(GetWorldPropertiesResponse::VERSION_MD5);
    info.xmlSource(GetWorldPropertiesResponse::XML_SOURCE);
    info.flat(GetWorldPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(GetWorldProperties::ID);
    info.name(GetWorldProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(GetWorldProperties::DATA_VERSION);
    info.md5Key(GetWorldProperties::VERSION_MD5);
    info.xmlSource(GetWorldProperties::XML_SOURCE);
    info.flat(GetWorldProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(JointRequestRequest::ID);
    info.name(JointRequestRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(JointRequestRequest::DATA_VERSION);
    info.md5Key(JointRequestRequest::VERSION_MD5);
    info.xmlSource(JointRequestRequest::XML_SOURCE);
    info.flat(JointRequestRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(JointRequestResponse::ID);
    info.name(JointRequestResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(JointRequestResponse::DATA_VERSION);
    info.md5Key(JointRequestResponse::VERSION_MD5);
    info.xmlSource(JointRequestResponse::XML_SOURCE);
    info.flat(JointRequestResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(JointRequest::ID);
    info.name(JointRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(JointRequest::DATA_VERSION);
    info.md5Key(JointRequest::VERSION_MD5);
    info.xmlSource(JointRequest::XML_SOURCE);
    info.flat(JointRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointPropertiesRequest::ID);
    info.name(SetJointPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointPropertiesRequest::DATA_VERSION);
    info.md5Key(SetJointPropertiesRequest::VERSION_MD5);
    info.xmlSource(SetJointPropertiesRequest::XML_SOURCE);
    info.flat(SetJointPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointPropertiesResponse::ID);
    info.name(SetJointPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointPropertiesResponse::DATA_VERSION);
    info.md5Key(SetJointPropertiesResponse::VERSION_MD5);
    info.xmlSource(SetJointPropertiesResponse::XML_SOURCE);
    info.flat(SetJointPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointProperties::ID);
    info.name(SetJointProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointProperties::DATA_VERSION);
    info.md5Key(SetJointProperties::VERSION_MD5);
    info.xmlSource(SetJointProperties::XML_SOURCE);
    info.flat(SetJointProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointTrajectoryRequest::ID);
    info.name(SetJointTrajectoryRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointTrajectoryRequest::DATA_VERSION);
    info.md5Key(SetJointTrajectoryRequest::VERSION_MD5);
    info.xmlSource(SetJointTrajectoryRequest::XML_SOURCE);
    info.flat(SetJointTrajectoryRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointTrajectoryResponse::ID);
    info.name(SetJointTrajectoryResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointTrajectoryResponse::DATA_VERSION);
    info.md5Key(SetJointTrajectoryResponse::VERSION_MD5);
    info.xmlSource(SetJointTrajectoryResponse::XML_SOURCE);
    info.flat(SetJointTrajectoryResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetJointTrajectory::ID);
    info.name(SetJointTrajectory::DATA_TYPE_FULL_NAME);
    info.hashKey(SetJointTrajectory::DATA_VERSION);
    info.md5Key(SetJointTrajectory::VERSION_MD5);
    info.xmlSource(SetJointTrajectory::XML_SOURCE);
    info.flat(SetJointTrajectory::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkPropertiesRequest::ID);
    info.name(SetLinkPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkPropertiesRequest::DATA_VERSION);
    info.md5Key(SetLinkPropertiesRequest::VERSION_MD5);
    info.xmlSource(SetLinkPropertiesRequest::XML_SOURCE);
    info.flat(SetLinkPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkPropertiesResponse::ID);
    info.name(SetLinkPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkPropertiesResponse::DATA_VERSION);
    info.md5Key(SetLinkPropertiesResponse::VERSION_MD5);
    info.xmlSource(SetLinkPropertiesResponse::XML_SOURCE);
    info.flat(SetLinkPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkProperties::ID);
    info.name(SetLinkProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkProperties::DATA_VERSION);
    info.md5Key(SetLinkProperties::VERSION_MD5);
    info.xmlSource(SetLinkProperties::XML_SOURCE);
    info.flat(SetLinkProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkStateRequest::ID);
    info.name(SetLinkStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkStateRequest::DATA_VERSION);
    info.md5Key(SetLinkStateRequest::VERSION_MD5);
    info.xmlSource(SetLinkStateRequest::XML_SOURCE);
    info.flat(SetLinkStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkStateResponse::ID);
    info.name(SetLinkStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkStateResponse::DATA_VERSION);
    info.md5Key(SetLinkStateResponse::VERSION_MD5);
    info.xmlSource(SetLinkStateResponse::XML_SOURCE);
    info.flat(SetLinkStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetLinkState::ID);
    info.name(SetLinkState::DATA_TYPE_FULL_NAME);
    info.hashKey(SetLinkState::DATA_VERSION);
    info.md5Key(SetLinkState::VERSION_MD5);
    info.xmlSource(SetLinkState::XML_SOURCE);
    info.flat(SetLinkState::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelConfigurationRequest::ID);
    info.name(SetModelConfigurationRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelConfigurationRequest::DATA_VERSION);
    info.md5Key(SetModelConfigurationRequest::VERSION_MD5);
    info.xmlSource(SetModelConfigurationRequest::XML_SOURCE);
    info.flat(SetModelConfigurationRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelConfigurationResponse::ID);
    info.name(SetModelConfigurationResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelConfigurationResponse::DATA_VERSION);
    info.md5Key(SetModelConfigurationResponse::VERSION_MD5);
    info.xmlSource(SetModelConfigurationResponse::XML_SOURCE);
    info.flat(SetModelConfigurationResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelConfiguration::ID);
    info.name(SetModelConfiguration::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelConfiguration::DATA_VERSION);
    info.md5Key(SetModelConfiguration::VERSION_MD5);
    info.xmlSource(SetModelConfiguration::XML_SOURCE);
    info.flat(SetModelConfiguration::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelStateRequest::ID);
    info.name(SetModelStateRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelStateRequest::DATA_VERSION);
    info.md5Key(SetModelStateRequest::VERSION_MD5);
    info.xmlSource(SetModelStateRequest::XML_SOURCE);
    info.flat(SetModelStateRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelStateResponse::ID);
    info.name(SetModelStateResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelStateResponse::DATA_VERSION);
    info.md5Key(SetModelStateResponse::VERSION_MD5);
    info.xmlSource(SetModelStateResponse::XML_SOURCE);
    info.flat(SetModelStateResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetModelState::ID);
    info.name(SetModelState::DATA_TYPE_FULL_NAME);
    info.hashKey(SetModelState::DATA_VERSION);
    info.md5Key(SetModelState::VERSION_MD5);
    info.xmlSource(SetModelState::XML_SOURCE);
    info.flat(SetModelState::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPhysicsPropertiesRequest::ID);
    info.name(SetPhysicsPropertiesRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPhysicsPropertiesRequest::DATA_VERSION);
    info.md5Key(SetPhysicsPropertiesRequest::VERSION_MD5);
    info.xmlSource(SetPhysicsPropertiesRequest::XML_SOURCE);
    info.flat(SetPhysicsPropertiesRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPhysicsPropertiesResponse::ID);
    info.name(SetPhysicsPropertiesResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPhysicsPropertiesResponse::DATA_VERSION);
    info.md5Key(SetPhysicsPropertiesResponse::VERSION_MD5);
    info.xmlSource(SetPhysicsPropertiesResponse::XML_SOURCE);
    info.flat(SetPhysicsPropertiesResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SetPhysicsProperties::ID);
    info.name(SetPhysicsProperties::DATA_TYPE_FULL_NAME);
    info.hashKey(SetPhysicsProperties::DATA_VERSION);
    info.md5Key(SetPhysicsProperties::VERSION_MD5);
    info.xmlSource(SetPhysicsProperties::XML_SOURCE);
    info.flat(SetPhysicsProperties::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnModelRequest::ID);
    info.name(SpawnModelRequest::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnModelRequest::DATA_VERSION);
    info.md5Key(SpawnModelRequest::VERSION_MD5);
    info.xmlSource(SpawnModelRequest::XML_SOURCE);
    info.flat(SpawnModelRequest::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnModelResponse::ID);
    info.name(SpawnModelResponse::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnModelResponse::DATA_VERSION);
    info.md5Key(SpawnModelResponse::VERSION_MD5);
    info.xmlSource(SpawnModelResponse::XML_SOURCE);
    info.flat(SpawnModelResponse::dataTypeFlat());
    ids.push_back(info);

    info.id(SpawnModel::ID);
    info.name(SpawnModel::DATA_TYPE_FULL_NAME);
    info.hashKey(SpawnModel::DATA_VERSION);
    info.md5Key(SpawnModel::VERSION_MD5);
    info.xmlSource(SpawnModel::XML_SOURCE);
    info.flat(SpawnModel::dataTypeFlat());
    ids.push_back(info);

}

int gazebo_msgs_gencppROSMessageFactory::typeName(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case ContactState::ID:
        {
            str = "gazebo_msgs/ContactState";
            break;
        }
        case ContactsState::ID:
        {
            str = "gazebo_msgs/ContactsState";
            break;
        }
        case LinkState::ID:
        {
            str = "gazebo_msgs/LinkState";
            break;
        }
        case LinkStates::ID:
        {
            str = "gazebo_msgs/LinkStates";
            break;
        }
        case ModelState::ID:
        {
            str = "gazebo_msgs/ModelState";
            break;
        }
        case ModelStates::ID:
        {
            str = "gazebo_msgs/ModelStates";
            break;
        }
        case ODEJointProperties::ID:
        {
            str = "gazebo_msgs/ODEJointProperties";
            break;
        }
        case ODEPhysics::ID:
        {
            str = "gazebo_msgs/ODEPhysics";
            break;
        }
        case WorldState::ID:
        {
            str = "gazebo_msgs/WorldState";
            break;
        }
        case ApplyBodyWrenchRequest::ID:
        {
            str = "gazebo_msgs/ApplyBodyWrenchRequest";
            break;
        }
        case ApplyBodyWrenchResponse::ID:
        {
            str = "gazebo_msgs/ApplyBodyWrenchResponse";
            break;
        }
        case ApplyBodyWrench::ID:
        {
            str = "gazebo_msgs/ApplyBodyWrench";
            break;
        }
        case ApplyJointEffortRequest::ID:
        {
            str = "gazebo_msgs/ApplyJointEffortRequest";
            break;
        }
        case ApplyJointEffortResponse::ID:
        {
            str = "gazebo_msgs/ApplyJointEffortResponse";
            break;
        }
        case ApplyJointEffort::ID:
        {
            str = "gazebo_msgs/ApplyJointEffort";
            break;
        }
        case BodyRequestRequest::ID:
        {
            str = "gazebo_msgs/BodyRequestRequest";
            break;
        }
        case BodyRequestResponse::ID:
        {
            str = "gazebo_msgs/BodyRequestResponse";
            break;
        }
        case BodyRequest::ID:
        {
            str = "gazebo_msgs/BodyRequest";
            break;
        }
        case DeleteModelRequest::ID:
        {
            str = "gazebo_msgs/DeleteModelRequest";
            break;
        }
        case DeleteModelResponse::ID:
        {
            str = "gazebo_msgs/DeleteModelResponse";
            break;
        }
        case DeleteModel::ID:
        {
            str = "gazebo_msgs/DeleteModel";
            break;
        }
        case GetJointPropertiesRequest::ID:
        {
            str = "gazebo_msgs/GetJointPropertiesRequest";
            break;
        }
        case GetJointPropertiesResponse::ID:
        {
            str = "gazebo_msgs/GetJointPropertiesResponse";
            break;
        }
        case GetJointProperties::ID:
        {
            str = "gazebo_msgs/GetJointProperties";
            break;
        }
        case GetLinkPropertiesRequest::ID:
        {
            str = "gazebo_msgs/GetLinkPropertiesRequest";
            break;
        }
        case GetLinkPropertiesResponse::ID:
        {
            str = "gazebo_msgs/GetLinkPropertiesResponse";
            break;
        }
        case GetLinkProperties::ID:
        {
            str = "gazebo_msgs/GetLinkProperties";
            break;
        }
        case GetLinkStateRequest::ID:
        {
            str = "gazebo_msgs/GetLinkStateRequest";
            break;
        }
        case GetLinkStateResponse::ID:
        {
            str = "gazebo_msgs/GetLinkStateResponse";
            break;
        }
        case GetLinkState::ID:
        {
            str = "gazebo_msgs/GetLinkState";
            break;
        }
        case GetModelPropertiesRequest::ID:
        {
            str = "gazebo_msgs/GetModelPropertiesRequest";
            break;
        }
        case GetModelPropertiesResponse::ID:
        {
            str = "gazebo_msgs/GetModelPropertiesResponse";
            break;
        }
        case GetModelProperties::ID:
        {
            str = "gazebo_msgs/GetModelProperties";
            break;
        }
        case GetModelStateRequest::ID:
        {
            str = "gazebo_msgs/GetModelStateRequest";
            break;
        }
        case GetModelStateResponse::ID:
        {
            str = "gazebo_msgs/GetModelStateResponse";
            break;
        }
        case GetModelState::ID:
        {
            str = "gazebo_msgs/GetModelState";
            break;
        }
        case GetPhysicsPropertiesRequest::ID:
        {
            str = "gazebo_msgs/GetPhysicsPropertiesRequest";
            break;
        }
        case GetPhysicsPropertiesResponse::ID:
        {
            str = "gazebo_msgs/GetPhysicsPropertiesResponse";
            break;
        }
        case GetPhysicsProperties::ID:
        {
            str = "gazebo_msgs/GetPhysicsProperties";
            break;
        }
        case GetWorldPropertiesRequest::ID:
        {
            str = "gazebo_msgs/GetWorldPropertiesRequest";
            break;
        }
        case GetWorldPropertiesResponse::ID:
        {
            str = "gazebo_msgs/GetWorldPropertiesResponse";
            break;
        }
        case GetWorldProperties::ID:
        {
            str = "gazebo_msgs/GetWorldProperties";
            break;
        }
        case JointRequestRequest::ID:
        {
            str = "gazebo_msgs/JointRequestRequest";
            break;
        }
        case JointRequestResponse::ID:
        {
            str = "gazebo_msgs/JointRequestResponse";
            break;
        }
        case JointRequest::ID:
        {
            str = "gazebo_msgs/JointRequest";
            break;
        }
        case SetJointPropertiesRequest::ID:
        {
            str = "gazebo_msgs/SetJointPropertiesRequest";
            break;
        }
        case SetJointPropertiesResponse::ID:
        {
            str = "gazebo_msgs/SetJointPropertiesResponse";
            break;
        }
        case SetJointProperties::ID:
        {
            str = "gazebo_msgs/SetJointProperties";
            break;
        }
        case SetJointTrajectoryRequest::ID:
        {
            str = "gazebo_msgs/SetJointTrajectoryRequest";
            break;
        }
        case SetJointTrajectoryResponse::ID:
        {
            str = "gazebo_msgs/SetJointTrajectoryResponse";
            break;
        }
        case SetJointTrajectory::ID:
        {
            str = "gazebo_msgs/SetJointTrajectory";
            break;
        }
        case SetLinkPropertiesRequest::ID:
        {
            str = "gazebo_msgs/SetLinkPropertiesRequest";
            break;
        }
        case SetLinkPropertiesResponse::ID:
        {
            str = "gazebo_msgs/SetLinkPropertiesResponse";
            break;
        }
        case SetLinkProperties::ID:
        {
            str = "gazebo_msgs/SetLinkProperties";
            break;
        }
        case SetLinkStateRequest::ID:
        {
            str = "gazebo_msgs/SetLinkStateRequest";
            break;
        }
        case SetLinkStateResponse::ID:
        {
            str = "gazebo_msgs/SetLinkStateResponse";
            break;
        }
        case SetLinkState::ID:
        {
            str = "gazebo_msgs/SetLinkState";
            break;
        }
        case SetModelConfigurationRequest::ID:
        {
            str = "gazebo_msgs/SetModelConfigurationRequest";
            break;
        }
        case SetModelConfigurationResponse::ID:
        {
            str = "gazebo_msgs/SetModelConfigurationResponse";
            break;
        }
        case SetModelConfiguration::ID:
        {
            str = "gazebo_msgs/SetModelConfiguration";
            break;
        }
        case SetModelStateRequest::ID:
        {
            str = "gazebo_msgs/SetModelStateRequest";
            break;
        }
        case SetModelStateResponse::ID:
        {
            str = "gazebo_msgs/SetModelStateResponse";
            break;
        }
        case SetModelState::ID:
        {
            str = "gazebo_msgs/SetModelState";
            break;
        }
        case SetPhysicsPropertiesRequest::ID:
        {
            str = "gazebo_msgs/SetPhysicsPropertiesRequest";
            break;
        }
        case SetPhysicsPropertiesResponse::ID:
        {
            str = "gazebo_msgs/SetPhysicsPropertiesResponse";
            break;
        }
        case SetPhysicsProperties::ID:
        {
            str = "gazebo_msgs/SetPhysicsProperties";
            break;
        }
        case SpawnModelRequest::ID:
        {
            str = "gazebo_msgs/SpawnModelRequest";
            break;
        }
        case SpawnModelResponse::ID:
        {
            str = "gazebo_msgs/SpawnModelResponse";
            break;
        }
        case SpawnModel::ID:
        {
            str = "gazebo_msgs/SpawnModel";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::desc(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case ContactState::ID:
        {
            str = "string info                                   # text info on this contact\nstring collision1_name                        # name of contact collision1\nstring collision2_name                        # name of contact collision2\ngeometry_msgs/Wrench[] wrenches               # list of forces/torques\ngeometry_msgs/Wrench total_wrench             # sum of forces/torques in every DOF\ngeometry_msgs/Vector3[] contact_positions     # list of contact position\ngeometry_msgs/Vector3[] contact_normals       # list of contact normals\nfloat64[] depths                              # list of penetration depths\n\n================================================================================\nMSG: geometry_msgs/Wrench\n# This represents force in free space, separated into\n# its linear and angular parts.\nVector3  force\nVector3  torque\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case ContactsState::ID:
        {
            str = "Header header                                   # stamp\ngazebo_msgs/ContactState[] states            # array of geom pairs in contact\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: gazebo_msgs/ContactState\nstring info                                   # text info on this contact\nstring collision1_name                        # name of contact collision1\nstring collision2_name                        # name of contact collision2\ngeometry_msgs/Wrench[] wrenches               # list of forces/torques\ngeometry_msgs/Wrench total_wrench             # sum of forces/torques in every DOF\ngeometry_msgs/Vector3[] contact_positions     # list of contact position\ngeometry_msgs/Vector3[] contact_normals       # list of contact normals\nfloat64[] depths                              # list of penetration depths\n\n================================================================================\nMSG: geometry_msgs/Wrench\n# This represents force in free space, separated into\n# its linear and angular parts.\nVector3  force\nVector3  torque\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case LinkState::ID:
        {
            str = "# @todo: FIXME: sets pose and twist of a link.  All children link poses/twists of the URDF tree are not updated accordingly, but should be.\nstring link_name            # link name, link_names are in gazebo scoped name notation, [model_name::body_name]\ngeometry_msgs/Pose pose     # desired pose in reference frame\ngeometry_msgs/Twist twist   # desired twist in reference frame\nstring reference_frame      # set pose/twist relative to the frame of this link/body\n                            # leave empty or \"world\" or \"map\" defaults to world-frame\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case LinkStates::ID:
        {
            str = "# broadcast all link states in world frame\nstring[] name                 # link names\ngeometry_msgs/Pose[] pose     # desired pose in world frame\ngeometry_msgs/Twist[] twist   # desired twist in world frame\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case ModelState::ID:
        {
            str = "# Set Gazebo Model pose and twist\nstring model_name           # model to set state (pose and twist)\ngeometry_msgs/Pose pose     # desired pose in reference frame\ngeometry_msgs/Twist twist   # desired twist in reference frame\nstring reference_frame      # set pose/twist relative to the frame of this entity (Body/Model)\n                            # leave empty or \"world\" or \"map\" defaults to world-frame\n\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case ModelStates::ID:
        {
            str = "# broadcast all model states in world frame\nstring[] name                 # model names\ngeometry_msgs/Pose[] pose     # desired pose in world frame\ngeometry_msgs/Twist[] twist   # desired twist in world frame\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\n";
            break;
        }
        case ODEJointProperties::ID:
        {
            str = "# access to low level joint properties, change these at your own risk\nfloat64[] damping             # joint damping\nfloat64[] hiStop              # joint limit\nfloat64[] loStop              # joint limit\nfloat64[] erp                 # set joint erp\nfloat64[] cfm                 # set joint cfm\nfloat64[] stop_erp            # set joint erp for joint limit \"contact\" joint\nfloat64[] stop_cfm            # set joint cfm for joint limit \"contact\" joint\nfloat64[] fudge_factor        # joint fudge_factor applied at limits, see ODE manual for info.\nfloat64[] fmax                # ode joint param fmax\nfloat64[] vel                 # ode joint param vel\n";
            break;
        }
        case ODEPhysics::ID:
        {
            str = "bool auto_disable_bodies           # enable auto disabling of bodies, default false\nuint32 sor_pgs_precon_iters        # preconditioning inner iterations when uisng projected Gauss Seidel\nuint32 sor_pgs_iters               # inner iterations when uisng projected Gauss Seidel\nfloat64 sor_pgs_w                  # relaxation parameter when using projected Gauss Seidel, 1 = no relaxation\nfloat64 sor_pgs_rms_error_tol      # rms error tolerance before stopping inner iterations\nfloat64 contact_surface_layer      # contact \"dead-band\" width\nfloat64 contact_max_correcting_vel # contact maximum correction velocity\nfloat64 cfm                        # global constraint force mixing\nfloat64 erp                        # global error reduction parameter\nuint32 max_contacts                # maximum contact joints between two geoms\n";
            break;
        }
        case WorldState::ID:
        {
            str = "# This is a message that holds data necessary to reconstruct a snapshot of the world\n#\n# = Approach to Message Passing =\n# The state of the world is defined by either\n#   1. Inertial Model pose, twist\n#      * kinematic data - connectivity graph from Model to each Link\n#      * joint angles\n#      * joint velocities\n#      * Applied forces - Body wrench\n#        * relative transform from Body to each collision Geom\n# Or\n#   2. Inertial (absolute) Body pose, twist, wrench\n#      * relative transform from Body to each collision Geom - constant, so not sent over wire\n#      * back compute from canonical body info to get Model pose and twist.\n#\n# Chooing (2.) because it matches most physics engines out there\n#   and is simpler.\n#\n# = Future =\n# Consider impacts on using reduced coordinates / graph (parent/child links) approach\n#   constraint and physics solvers.\n#\n# = Application =\n# This message is used to do the following:\n#   * reconstruct the world and objects for sensor generation\n#   * stop / start simulation - need pose, twist, wrench of each body\n#   * collision detection - need pose of each collision geometry.  velocity/acceleration if \n#\n# = Assumptions =\n# Assuming that each (physics) processor node locally already has\n#   * collision information - Trimesh for Geoms, etc\n#   * relative transforms from Body to Geom - this is assumed to be fixed, do not send oved wire\n#   * inertial information - does not vary in time\n#   * visual information - does not vary in time\n#\n\nHeader header\n\nstring[] name\ngeometry_msgs/Pose[] pose\ngeometry_msgs/Twist[] twist\ngeometry_msgs/Wrench[] wrench\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data \n# in a particular coordinate frame.\n# \n# sequence ID: consecutively increasing ID \nuint32 seq\n#Two-integer timestamp that is expressed as:\n# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n# time-handling sugar is provided by the client library\ntime stamp\n#Frame this data is associated with\n# 0: no frame\n# 1: global frame\nstring frame_id\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of postion and orientation. \nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x\nfloat64 y\nfloat64 z\nfloat64 w\n\n================================================================================\nMSG: geometry_msgs/Twist\n# This expresses velocity in free space broken into its linear and angular parts.\nVector3  linear\nVector3  angular\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space. \n# It is only meant to represent a direction. Therefore, it does not\n# make sense to apply a translation to it (e.g., when applying a \n# generic rigid transformation to a Vector3, tf2 will only apply the\n# rotation). If you want your data to be translatable too, use the\n# geometry_msgs/Point message instead.\n\nfloat64 x\nfloat64 y\nfloat64 z\n================================================================================\nMSG: geometry_msgs/Wrench\n# This represents force in free space, separated into\n# its linear and angular parts.\nVector3  force\nVector3  torque\n";
            break;
        }
        case ApplyBodyWrenchRequest::ID:
        {
            str = ApplyBodyWrenchRequest::XML_SOURCE;
            break;
        }
        case ApplyBodyWrenchResponse::ID:
        {
            str = ApplyBodyWrenchResponse::XML_SOURCE;
            break;
        }
        case ApplyBodyWrench::ID:
        {
            str = ApplyBodyWrench::XML_SOURCE;
            break;
        }
        case ApplyJointEffortRequest::ID:
        {
            str = ApplyJointEffortRequest::XML_SOURCE;
            break;
        }
        case ApplyJointEffortResponse::ID:
        {
            str = ApplyJointEffortResponse::XML_SOURCE;
            break;
        }
        case ApplyJointEffort::ID:
        {
            str = ApplyJointEffort::XML_SOURCE;
            break;
        }
        case BodyRequestRequest::ID:
        {
            str = BodyRequestRequest::XML_SOURCE;
            break;
        }
        case BodyRequestResponse::ID:
        {
            str = BodyRequestResponse::XML_SOURCE;
            break;
        }
        case BodyRequest::ID:
        {
            str = BodyRequest::XML_SOURCE;
            break;
        }
        case DeleteModelRequest::ID:
        {
            str = DeleteModelRequest::XML_SOURCE;
            break;
        }
        case DeleteModelResponse::ID:
        {
            str = DeleteModelResponse::XML_SOURCE;
            break;
        }
        case DeleteModel::ID:
        {
            str = DeleteModel::XML_SOURCE;
            break;
        }
        case GetJointPropertiesRequest::ID:
        {
            str = GetJointPropertiesRequest::XML_SOURCE;
            break;
        }
        case GetJointPropertiesResponse::ID:
        {
            str = GetJointPropertiesResponse::XML_SOURCE;
            break;
        }
        case GetJointProperties::ID:
        {
            str = GetJointProperties::XML_SOURCE;
            break;
        }
        case GetLinkPropertiesRequest::ID:
        {
            str = GetLinkPropertiesRequest::XML_SOURCE;
            break;
        }
        case GetLinkPropertiesResponse::ID:
        {
            str = GetLinkPropertiesResponse::XML_SOURCE;
            break;
        }
        case GetLinkProperties::ID:
        {
            str = GetLinkProperties::XML_SOURCE;
            break;
        }
        case GetLinkStateRequest::ID:
        {
            str = GetLinkStateRequest::XML_SOURCE;
            break;
        }
        case GetLinkStateResponse::ID:
        {
            str = GetLinkStateResponse::XML_SOURCE;
            break;
        }
        case GetLinkState::ID:
        {
            str = GetLinkState::XML_SOURCE;
            break;
        }
        case GetModelPropertiesRequest::ID:
        {
            str = GetModelPropertiesRequest::XML_SOURCE;
            break;
        }
        case GetModelPropertiesResponse::ID:
        {
            str = GetModelPropertiesResponse::XML_SOURCE;
            break;
        }
        case GetModelProperties::ID:
        {
            str = GetModelProperties::XML_SOURCE;
            break;
        }
        case GetModelStateRequest::ID:
        {
            str = GetModelStateRequest::XML_SOURCE;
            break;
        }
        case GetModelStateResponse::ID:
        {
            str = GetModelStateResponse::XML_SOURCE;
            break;
        }
        case GetModelState::ID:
        {
            str = GetModelState::XML_SOURCE;
            break;
        }
        case GetPhysicsPropertiesRequest::ID:
        {
            str = GetPhysicsPropertiesRequest::XML_SOURCE;
            break;
        }
        case GetPhysicsPropertiesResponse::ID:
        {
            str = GetPhysicsPropertiesResponse::XML_SOURCE;
            break;
        }
        case GetPhysicsProperties::ID:
        {
            str = GetPhysicsProperties::XML_SOURCE;
            break;
        }
        case GetWorldPropertiesRequest::ID:
        {
            str = GetWorldPropertiesRequest::XML_SOURCE;
            break;
        }
        case GetWorldPropertiesResponse::ID:
        {
            str = GetWorldPropertiesResponse::XML_SOURCE;
            break;
        }
        case GetWorldProperties::ID:
        {
            str = GetWorldProperties::XML_SOURCE;
            break;
        }
        case JointRequestRequest::ID:
        {
            str = JointRequestRequest::XML_SOURCE;
            break;
        }
        case JointRequestResponse::ID:
        {
            str = JointRequestResponse::XML_SOURCE;
            break;
        }
        case JointRequest::ID:
        {
            str = JointRequest::XML_SOURCE;
            break;
        }
        case SetJointPropertiesRequest::ID:
        {
            str = SetJointPropertiesRequest::XML_SOURCE;
            break;
        }
        case SetJointPropertiesResponse::ID:
        {
            str = SetJointPropertiesResponse::XML_SOURCE;
            break;
        }
        case SetJointProperties::ID:
        {
            str = SetJointProperties::XML_SOURCE;
            break;
        }
        case SetJointTrajectoryRequest::ID:
        {
            str = SetJointTrajectoryRequest::XML_SOURCE;
            break;
        }
        case SetJointTrajectoryResponse::ID:
        {
            str = SetJointTrajectoryResponse::XML_SOURCE;
            break;
        }
        case SetJointTrajectory::ID:
        {
            str = SetJointTrajectory::XML_SOURCE;
            break;
        }
        case SetLinkPropertiesRequest::ID:
        {
            str = SetLinkPropertiesRequest::XML_SOURCE;
            break;
        }
        case SetLinkPropertiesResponse::ID:
        {
            str = SetLinkPropertiesResponse::XML_SOURCE;
            break;
        }
        case SetLinkProperties::ID:
        {
            str = SetLinkProperties::XML_SOURCE;
            break;
        }
        case SetLinkStateRequest::ID:
        {
            str = SetLinkStateRequest::XML_SOURCE;
            break;
        }
        case SetLinkStateResponse::ID:
        {
            str = SetLinkStateResponse::XML_SOURCE;
            break;
        }
        case SetLinkState::ID:
        {
            str = SetLinkState::XML_SOURCE;
            break;
        }
        case SetModelConfigurationRequest::ID:
        {
            str = SetModelConfigurationRequest::XML_SOURCE;
            break;
        }
        case SetModelConfigurationResponse::ID:
        {
            str = SetModelConfigurationResponse::XML_SOURCE;
            break;
        }
        case SetModelConfiguration::ID:
        {
            str = SetModelConfiguration::XML_SOURCE;
            break;
        }
        case SetModelStateRequest::ID:
        {
            str = SetModelStateRequest::XML_SOURCE;
            break;
        }
        case SetModelStateResponse::ID:
        {
            str = SetModelStateResponse::XML_SOURCE;
            break;
        }
        case SetModelState::ID:
        {
            str = SetModelState::XML_SOURCE;
            break;
        }
        case SetPhysicsPropertiesRequest::ID:
        {
            str = SetPhysicsPropertiesRequest::XML_SOURCE;
            break;
        }
        case SetPhysicsPropertiesResponse::ID:
        {
            str = SetPhysicsPropertiesResponse::XML_SOURCE;
            break;
        }
        case SetPhysicsProperties::ID:
        {
            str = SetPhysicsProperties::XML_SOURCE;
            break;
        }
        case SpawnModelRequest::ID:
        {
            str = SpawnModelRequest::XML_SOURCE;
            break;
        }
        case SpawnModelResponse::ID:
        {
            str = SpawnModelResponse::XML_SOURCE;
            break;
        }
        case SpawnModel::ID:
        {
            str = SpawnModel::XML_SOURCE;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::md5String(std::string & str, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case ContactState::ID:
        {
            str = "48c0ffb054b8c444f870cecea1ee50d9";
            break;
        }
        case ContactsState::ID:
        {
            str = "acbcb1601a8e525bf72509f18e6f668d";
            break;
        }
        case LinkState::ID:
        {
            str = "0818ebbf28ce3a08d48ab1eaa7309ebe";
            break;
        }
        case LinkStates::ID:
        {
            str = "48c080191eb15c41858319b4d8a609c2";
            break;
        }
        case ModelState::ID:
        {
            str = "9330fd35f2fcd82d457e54bd54e10593";
            break;
        }
        case ModelStates::ID:
        {
            str = "48c080191eb15c41858319b4d8a609c2";
            break;
        }
        case ODEJointProperties::ID:
        {
            str = "1b744c32a920af979f53afe2f9c3511f";
            break;
        }
        case ODEPhysics::ID:
        {
            str = "667d56ddbd547918c32d1934503dc335";
            break;
        }
        case WorldState::ID:
        {
            str = "de1a9de3ab7ba97ac0e9ec01a4eb481e";
            break;
        }
        case ApplyBodyWrenchRequest::ID:
        {
            str = "e37e6adf97eba5095baa77dffb71e5bd";
            break;
        }
        case ApplyBodyWrenchResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case ApplyBodyWrench::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case ApplyJointEffortRequest::ID:
        {
            str = "2c3396ab9af67a509ecd2167a8fe41a2";
            break;
        }
        case ApplyJointEffortResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case ApplyJointEffort::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case BodyRequestRequest::ID:
        {
            str = "5eade9afe7f232d78005bd0cafeab755";
            break;
        }
        case BodyRequestResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case BodyRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case DeleteModelRequest::ID:
        {
            str = "ea31c8eab6fc401383cf528a7c0984ba";
            break;
        }
        case DeleteModelResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case DeleteModel::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetJointPropertiesRequest::ID:
        {
            str = "0be1351618e1dc030eb7959d9a4902de";
            break;
        }
        case GetJointPropertiesResponse::ID:
        {
            str = "cd7b30a39faa372283dc94c5f6457f82";
            break;
        }
        case GetJointProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetLinkPropertiesRequest::ID:
        {
            str = "7d82d60381f1b66a30f2157f60884345";
            break;
        }
        case GetLinkPropertiesResponse::ID:
        {
            str = "a8619f92d17cfcc3958c0fd13299443d";
            break;
        }
        case GetLinkProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetLinkStateRequest::ID:
        {
            str = "7551675c30aaa71f7c288d4864552001";
            break;
        }
        case GetLinkStateResponse::ID:
        {
            str = "8ba55ad34f9c072e75c0de57b089753b";
            break;
        }
        case GetLinkState::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetModelPropertiesRequest::ID:
        {
            str = "ea31c8eab6fc401383cf528a7c0984ba";
            break;
        }
        case GetModelPropertiesResponse::ID:
        {
            str = "b7f370938ef77b464b95f1bab3ec5028";
            break;
        }
        case GetModelProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetModelStateRequest::ID:
        {
            str = "19d412713cefe4a67437e17a951e759e";
            break;
        }
        case GetModelStateResponse::ID:
        {
            str = "ccd51739bb00f0141629e87b792e92b9";
            break;
        }
        case GetModelState::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetPhysicsPropertiesRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetPhysicsPropertiesResponse::ID:
        {
            str = "575a5e74786981b7df2e3afc567693a6";
            break;
        }
        case GetPhysicsProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetWorldPropertiesRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case GetWorldPropertiesResponse::ID:
        {
            str = "36bb0f2eccf4d8be971410c22818ba3f";
            break;
        }
        case GetWorldProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case JointRequestRequest::ID:
        {
            str = "0be1351618e1dc030eb7959d9a4902de";
            break;
        }
        case JointRequestResponse::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case JointRequest::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetJointPropertiesRequest::ID:
        {
            str = "331fd8f35fd27e3c1421175590258e26";
            break;
        }
        case SetJointPropertiesResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetJointProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetJointTrajectoryRequest::ID:
        {
            str = "649dd2eba5ffd358069238825f9f85ab";
            break;
        }
        case SetJointTrajectoryResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetJointTrajectory::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetLinkPropertiesRequest::ID:
        {
            str = "68ac74a4be01b165bc305b5ccdc45e91";
            break;
        }
        case SetLinkPropertiesResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetLinkProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetLinkStateRequest::ID:
        {
            str = "22a2c757d56911b6f27868159e9a872d";
            break;
        }
        case SetLinkStateResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetLinkState::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetModelConfigurationRequest::ID:
        {
            str = "160eae60f51fabff255480c70afa289f";
            break;
        }
        case SetModelConfigurationResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetModelConfiguration::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetModelStateRequest::ID:
        {
            str = "cb042b0e91880f4661b29ea5b6234350";
            break;
        }
        case SetModelStateResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetModelState::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SetPhysicsPropertiesRequest::ID:
        {
            str = "abd9f82732b52b92e9d6bb36e6a82452";
            break;
        }
        case SetPhysicsPropertiesResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SetPhysicsProperties::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        case SpawnModelRequest::ID:
        {
            str = "6d0eba5753761cd57e6263a056b79930";
            break;
        }
        case SpawnModelResponse::ID:
        {
            str = "2ec6f3eff0161f4257b808b12bc830c2";
            break;
        }
        case SpawnModel::ID:
        {
            str = "d41d8cd98f00b204e9800998ecf8427e";
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::md5(unsigned long long & highOrder, unsigned long long & lowOrder, rframe::ID_TYPE id)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    {   
        case ContactState::ID:
        {   
		    highOrder = 0x48c0ffb054b8c444ULL;
            lowOrder = 0xf870cecea1ee50d9ULL;
            break;
        }
        case ContactsState::ID:
        {   
		    highOrder = 0xacbcb1601a8e525bULL;
            lowOrder = 0xf72509f18e6f668dULL;
            break;
        }
        case LinkState::ID:
        {   
		    highOrder = 0x0818ebbf28ce3a08ULL;
            lowOrder = 0xd48ab1eaa7309ebeULL;
            break;
        }
        case LinkStates::ID:
        {   
		    highOrder = 0x48c080191eb15c41ULL;
            lowOrder = 0x858319b4d8a609c2ULL;
            break;
        }
        case ModelState::ID:
        {   
		    highOrder = 0x9330fd35f2fcd82dULL;
            lowOrder = 0x457e54bd54e10593ULL;
            break;
        }
        case ModelStates::ID:
        {   
		    highOrder = 0x48c080191eb15c41ULL;
            lowOrder = 0x858319b4d8a609c2ULL;
            break;
        }
        case ODEJointProperties::ID:
        {   
		    highOrder = 0x1b744c32a920af97ULL;
            lowOrder = 0x9f53afe2f9c3511fULL;
            break;
        }
        case ODEPhysics::ID:
        {   
		    highOrder = 0x667d56ddbd547918ULL;
            lowOrder = 0xc32d1934503dc335ULL;
            break;
        }
        case WorldState::ID:
        {   
		    highOrder = 0xde1a9de3ab7ba97aULL;
            lowOrder = 0xc0e9ec01a4eb481eULL;
            break;
        }
        case ApplyBodyWrenchRequest::ID:
        {   
		    highOrder = 0xe37e6adf97eba509ULL;
            lowOrder = 0x5baa77dffb71e5bdULL;
            break;
        }
        case ApplyBodyWrenchResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case ApplyBodyWrench::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case ApplyJointEffortRequest::ID:
        {   
		    highOrder = 0x2c3396ab9af67a50ULL;
            lowOrder = 0x9ecd2167a8fe41a2ULL;
            break;
        }
        case ApplyJointEffortResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case ApplyJointEffort::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case BodyRequestRequest::ID:
        {   
		    highOrder = 0x5eade9afe7f232d7ULL;
            lowOrder = 0x8005bd0cafeab755ULL;
            break;
        }
        case BodyRequestResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case BodyRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case DeleteModelRequest::ID:
        {   
		    highOrder = 0xea31c8eab6fc4013ULL;
            lowOrder = 0x83cf528a7c0984baULL;
            break;
        }
        case DeleteModelResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case DeleteModel::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetJointPropertiesRequest::ID:
        {   
		    highOrder = 0x0be1351618e1dc03ULL;
            lowOrder = 0x0eb7959d9a4902deULL;
            break;
        }
        case GetJointPropertiesResponse::ID:
        {   
		    highOrder = 0xcd7b30a39faa3722ULL;
            lowOrder = 0x83dc94c5f6457f82ULL;
            break;
        }
        case GetJointProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetLinkPropertiesRequest::ID:
        {   
		    highOrder = 0x7d82d60381f1b66aULL;
            lowOrder = 0x30f2157f60884345ULL;
            break;
        }
        case GetLinkPropertiesResponse::ID:
        {   
		    highOrder = 0xa8619f92d17cfcc3ULL;
            lowOrder = 0x958c0fd13299443dULL;
            break;
        }
        case GetLinkProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetLinkStateRequest::ID:
        {   
		    highOrder = 0x7551675c30aaa71fULL;
            lowOrder = 0x7c288d4864552001ULL;
            break;
        }
        case GetLinkStateResponse::ID:
        {   
		    highOrder = 0x8ba55ad34f9c072eULL;
            lowOrder = 0x75c0de57b089753bULL;
            break;
        }
        case GetLinkState::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetModelPropertiesRequest::ID:
        {   
		    highOrder = 0xea31c8eab6fc4013ULL;
            lowOrder = 0x83cf528a7c0984baULL;
            break;
        }
        case GetModelPropertiesResponse::ID:
        {   
		    highOrder = 0xb7f370938ef77b46ULL;
            lowOrder = 0x4b95f1bab3ec5028ULL;
            break;
        }
        case GetModelProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetModelStateRequest::ID:
        {   
		    highOrder = 0x19d412713cefe4a6ULL;
            lowOrder = 0x7437e17a951e759eULL;
            break;
        }
        case GetModelStateResponse::ID:
        {   
		    highOrder = 0xccd51739bb00f014ULL;
            lowOrder = 0x1629e87b792e92b9ULL;
            break;
        }
        case GetModelState::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetPhysicsPropertiesRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetPhysicsPropertiesResponse::ID:
        {   
		    highOrder = 0x575a5e74786981b7ULL;
            lowOrder = 0xdf2e3afc567693a6ULL;
            break;
        }
        case GetPhysicsProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetWorldPropertiesRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case GetWorldPropertiesResponse::ID:
        {   
		    highOrder = 0x36bb0f2eccf4d8beULL;
            lowOrder = 0x971410c22818ba3fULL;
            break;
        }
        case GetWorldProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case JointRequestRequest::ID:
        {   
		    highOrder = 0x0be1351618e1dc03ULL;
            lowOrder = 0x0eb7959d9a4902deULL;
            break;
        }
        case JointRequestResponse::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case JointRequest::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetJointPropertiesRequest::ID:
        {   
		    highOrder = 0x331fd8f35fd27e3cULL;
            lowOrder = 0x1421175590258e26ULL;
            break;
        }
        case SetJointPropertiesResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetJointProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetJointTrajectoryRequest::ID:
        {   
		    highOrder = 0x649dd2eba5ffd358ULL;
            lowOrder = 0x069238825f9f85abULL;
            break;
        }
        case SetJointTrajectoryResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetJointTrajectory::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetLinkPropertiesRequest::ID:
        {   
		    highOrder = 0x68ac74a4be01b165ULL;
            lowOrder = 0xbc305b5ccdc45e91ULL;
            break;
        }
        case SetLinkPropertiesResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetLinkProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetLinkStateRequest::ID:
        {   
		    highOrder = 0x22a2c757d56911b6ULL;
            lowOrder = 0xf27868159e9a872dULL;
            break;
        }
        case SetLinkStateResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetLinkState::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetModelConfigurationRequest::ID:
        {   
		    highOrder = 0x160eae60f51fabffULL;
            lowOrder = 0x255480c70afa289fULL;
            break;
        }
        case SetModelConfigurationResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetModelConfiguration::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetModelStateRequest::ID:
        {   
		    highOrder = 0xcb042b0e91880f46ULL;
            lowOrder = 0x61b29ea5b6234350ULL;
            break;
        }
        case SetModelStateResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetModelState::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SetPhysicsPropertiesRequest::ID:
        {   
		    highOrder = 0xabd9f82732b52b92ULL;
            lowOrder = 0xe9d6bb36e6a82452ULL;
            break;
        }
        case SetPhysicsPropertiesResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SetPhysicsProperties::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        case SpawnModelRequest::ID:
        {   
		    highOrder = 0x6d0eba5753761cd5ULL;
            lowOrder = 0x7e6263a056b79930ULL;
            break;
        }
        case SpawnModelResponse::ID:
        {   
		    highOrder = 0x2ec6f3eff0161f42ULL;
            lowOrder = 0x57b808b12bc830c2ULL;
            break;
        }
        case SpawnModel::ID:
        {   
		    highOrder = 0xd41d8cd98f00b204ULL;
            lowOrder = 0xe9800998ecf8427eULL;
            break;
        }
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<ros::SerializedMessage> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case ContactState::ID:
        case ContactsState::ID:
        case LinkState::ID:
        case LinkStates::ID:
        case ModelState::ID:
        case ModelStates::ID:
        case ODEJointProperties::ID:
        case ODEPhysics::ID:
        case WorldState::ID:
        case ApplyBodyWrenchRequest::ID:
        case ApplyBodyWrenchResponse::ID:
        case ApplyBodyWrench::ID:
        case ApplyJointEffortRequest::ID:
        case ApplyJointEffortResponse::ID:
        case ApplyJointEffort::ID:
        case BodyRequestRequest::ID:
        case BodyRequestResponse::ID:
        case BodyRequest::ID:
        case DeleteModelRequest::ID:
        case DeleteModelResponse::ID:
        case DeleteModel::ID:
        case GetJointPropertiesRequest::ID:
        case GetJointPropertiesResponse::ID:
        case GetJointProperties::ID:
        case GetLinkPropertiesRequest::ID:
        case GetLinkPropertiesResponse::ID:
        case GetLinkProperties::ID:
        case GetLinkStateRequest::ID:
        case GetLinkStateResponse::ID:
        case GetLinkState::ID:
        case GetModelPropertiesRequest::ID:
        case GetModelPropertiesResponse::ID:
        case GetModelProperties::ID:
        case GetModelStateRequest::ID:
        case GetModelStateResponse::ID:
        case GetModelState::ID:
        case GetPhysicsPropertiesRequest::ID:
        case GetPhysicsPropertiesResponse::ID:
        case GetPhysicsProperties::ID:
        case GetWorldPropertiesRequest::ID:
        case GetWorldPropertiesResponse::ID:
        case GetWorldProperties::ID:
        case JointRequestRequest::ID:
        case JointRequestResponse::ID:
        case JointRequest::ID:
        case SetJointPropertiesRequest::ID:
        case SetJointPropertiesResponse::ID:
        case SetJointProperties::ID:
        case SetJointTrajectoryRequest::ID:
        case SetJointTrajectoryResponse::ID:
        case SetJointTrajectory::ID:
        case SetLinkPropertiesRequest::ID:
        case SetLinkPropertiesResponse::ID:
        case SetLinkProperties::ID:
        case SetLinkStateRequest::ID:
        case SetLinkStateResponse::ID:
        case SetLinkState::ID:
        case SetModelConfigurationRequest::ID:
        case SetModelConfigurationResponse::ID:
        case SetModelConfiguration::ID:
        case SetModelStateRequest::ID:
        case SetModelStateResponse::ID:
        case SetModelState::ID:
        case SetPhysicsPropertiesRequest::ID:
        case SetPhysicsPropertiesResponse::ID:
        case SetPhysicsProperties::ID:
        case SpawnModelRequest::ID:
        case SpawnModelResponse::ID:
        case SpawnModel::ID:
        {
            break;
        } 
        default:
	    {
            retval = rframe::Error::PARAM_RANGE;
            break;
	    }
    }

    if (retval == rframe::Error::SUCCESS)
	{
        std::shared_ptr<ros::SerializedMessage> newmsg(new ros::SerializedMessage);

        if (newmsg.get() == NULL)
	    {
            retval = rframe::Error::MEMORY_ALLOC;
        }
        else
	    {
            newmsg->message_type = id;
            msg.swap(newmsg);
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::allocate(rframe::ID_TYPE id, std::shared_ptr<MessageBase> & msg)
{
    int retval = rframe::Error::SUCCESS;

    switch (id)
    { 
        case ContactState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ContactState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ContactsState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ContactsState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LinkState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LinkState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case LinkStates::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<LinkStates>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ModelState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ModelState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ModelStates::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ModelStates>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ODEJointProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ODEJointProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ODEPhysics::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ODEPhysics>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case WorldState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<WorldState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyBodyWrenchRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrenchRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyBodyWrenchResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrenchResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyBodyWrench::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyBodyWrench>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyJointEffortRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffortRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyJointEffortResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffortResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case ApplyJointEffort::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<ApplyJointEffort>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case BodyRequestRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequestRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case BodyRequestResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequestResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case BodyRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<BodyRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DeleteModelRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModelRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DeleteModelResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModelResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case DeleteModel::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<DeleteModel>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetJointPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetJointPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetJointPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetJointPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetJointProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetJointProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkStateRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkStateResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetLinkState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetLinkState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelStateRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelStateResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetModelState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetModelState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPhysicsPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPhysicsPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetPhysicsProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetPhysicsProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetWorldPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetWorldPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case GetWorldProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<GetWorldProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointRequestRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointRequestRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointRequestResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointRequestResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case JointRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<JointRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointTrajectoryRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectoryRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointTrajectoryResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectoryResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetJointTrajectory::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetJointTrajectory>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkStateRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkStateResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetLinkState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetLinkState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelConfigurationRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfigurationRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelConfigurationResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfigurationResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelConfiguration::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelConfiguration>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelStateRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelStateRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelStateResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelStateResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetModelState::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetModelState>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPhysicsPropertiesRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsPropertiesRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPhysicsPropertiesResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsPropertiesResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SetPhysicsProperties::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SetPhysicsProperties>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnModelRequest::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModelRequest>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnModelResponse::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModelResponse>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        case SpawnModel::ID:
        {
            std::shared_ptr<MessageBase> tempMsg(new Message<SpawnModel>(),std::bind(&gazebo_msgs_gencppROSMessageFactory::deallocateMessage,this,std::placeholders::_1));

            if (tempMsg.get() == NULL)
            {
                retval = rframe::Error::MEMORY_ALLOC;
            }
            else
            {
                msg.swap(tempMsg);
            }
            break;
        } 
        default:
        {
            retval = rframe::Error::PARAM_RANGE;
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::deallocateMessage(MessageBase * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
	{
        delete msg;
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::deallocateTransport(ros::SerializedMessage * msg)
{
    int retval = Error::SUCCESS;

    if (msg != NULL)
    {
        delete msg;
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::toTransport(MessageBase & src, ros::SerializedMessage & dst)
{
    int retval = rframe::Error::SUCCESS;

    if (dst.message_type != src.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (dst.message_type)
        { 
            case ContactState::ID:
            {
                Message<ContactState > & tempSrc = static_cast<Message<ContactState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ContactState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ContactsState::ID:
            {
                Message<ContactsState > & tempSrc = static_cast<Message<ContactsState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ContactsState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case LinkState::ID:
            {
                Message<LinkState > & tempSrc = static_cast<Message<LinkState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::LinkState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case LinkStates::ID:
            {
                Message<LinkStates > & tempSrc = static_cast<Message<LinkStates>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::LinkStates buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ModelState::ID:
            {
                Message<ModelState > & tempSrc = static_cast<Message<ModelState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ModelState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ModelStates::ID:
            {
                Message<ModelStates > & tempSrc = static_cast<Message<ModelStates>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ModelStates buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ODEJointProperties::ID:
            {
                Message<ODEJointProperties > & tempSrc = static_cast<Message<ODEJointProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ODEJointProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ODEPhysics::ID:
            {
                Message<ODEPhysics > & tempSrc = static_cast<Message<ODEPhysics>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ODEPhysics buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case WorldState::ID:
            {
                Message<WorldState > & tempSrc = static_cast<Message<WorldState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::WorldState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ApplyBodyWrenchRequest::ID:
            {
                Message<ApplyBodyWrenchRequest > & tempSrc = static_cast<Message<ApplyBodyWrenchRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ApplyBodyWrenchRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ApplyBodyWrenchResponse::ID:
            {
                Message<ApplyBodyWrenchResponse > & tempSrc = static_cast<Message<ApplyBodyWrenchResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ApplyBodyWrenchResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ApplyBodyWrench::ID:
            {
                Message<ApplyBodyWrench > & tempSrc = static_cast<Message<ApplyBodyWrench>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ApplyBodyWrench buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ApplyJointEffortRequest::ID:
            {
                Message<ApplyJointEffortRequest > & tempSrc = static_cast<Message<ApplyJointEffortRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ApplyJointEffortRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ApplyJointEffortResponse::ID:
            {
                Message<ApplyJointEffortResponse > & tempSrc = static_cast<Message<ApplyJointEffortResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ApplyJointEffortResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case ApplyJointEffort::ID:
            {
                Message<ApplyJointEffort > & tempSrc = static_cast<Message<ApplyJointEffort>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::ApplyJointEffort buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case BodyRequestRequest::ID:
            {
                Message<BodyRequestRequest > & tempSrc = static_cast<Message<BodyRequestRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::BodyRequestRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case BodyRequestResponse::ID:
            {
                Message<BodyRequestResponse > & tempSrc = static_cast<Message<BodyRequestResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::BodyRequestResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case BodyRequest::ID:
            {
                Message<BodyRequest > & tempSrc = static_cast<Message<BodyRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::BodyRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DeleteModelRequest::ID:
            {
                Message<DeleteModelRequest > & tempSrc = static_cast<Message<DeleteModelRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::DeleteModelRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DeleteModelResponse::ID:
            {
                Message<DeleteModelResponse > & tempSrc = static_cast<Message<DeleteModelResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::DeleteModelResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case DeleteModel::ID:
            {
                Message<DeleteModel > & tempSrc = static_cast<Message<DeleteModel>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::DeleteModel buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetJointPropertiesRequest::ID:
            {
                Message<GetJointPropertiesRequest > & tempSrc = static_cast<Message<GetJointPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetJointPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetJointPropertiesResponse::ID:
            {
                Message<GetJointPropertiesResponse > & tempSrc = static_cast<Message<GetJointPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetJointPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetJointProperties::ID:
            {
                Message<GetJointProperties > & tempSrc = static_cast<Message<GetJointProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetJointProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetLinkPropertiesRequest::ID:
            {
                Message<GetLinkPropertiesRequest > & tempSrc = static_cast<Message<GetLinkPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetLinkPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetLinkPropertiesResponse::ID:
            {
                Message<GetLinkPropertiesResponse > & tempSrc = static_cast<Message<GetLinkPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetLinkPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetLinkProperties::ID:
            {
                Message<GetLinkProperties > & tempSrc = static_cast<Message<GetLinkProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetLinkProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetLinkStateRequest::ID:
            {
                Message<GetLinkStateRequest > & tempSrc = static_cast<Message<GetLinkStateRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetLinkStateRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetLinkStateResponse::ID:
            {
                Message<GetLinkStateResponse > & tempSrc = static_cast<Message<GetLinkStateResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetLinkStateResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetLinkState::ID:
            {
                Message<GetLinkState > & tempSrc = static_cast<Message<GetLinkState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetLinkState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetModelPropertiesRequest::ID:
            {
                Message<GetModelPropertiesRequest > & tempSrc = static_cast<Message<GetModelPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetModelPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetModelPropertiesResponse::ID:
            {
                Message<GetModelPropertiesResponse > & tempSrc = static_cast<Message<GetModelPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetModelPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetModelProperties::ID:
            {
                Message<GetModelProperties > & tempSrc = static_cast<Message<GetModelProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetModelProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetModelStateRequest::ID:
            {
                Message<GetModelStateRequest > & tempSrc = static_cast<Message<GetModelStateRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetModelStateRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetModelStateResponse::ID:
            {
                Message<GetModelStateResponse > & tempSrc = static_cast<Message<GetModelStateResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetModelStateResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetModelState::ID:
            {
                Message<GetModelState > & tempSrc = static_cast<Message<GetModelState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetModelState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetPhysicsPropertiesRequest::ID:
            {
                Message<GetPhysicsPropertiesRequest > & tempSrc = static_cast<Message<GetPhysicsPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetPhysicsPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetPhysicsPropertiesResponse::ID:
            {
                Message<GetPhysicsPropertiesResponse > & tempSrc = static_cast<Message<GetPhysicsPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetPhysicsPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetPhysicsProperties::ID:
            {
                Message<GetPhysicsProperties > & tempSrc = static_cast<Message<GetPhysicsProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetPhysicsProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetWorldPropertiesRequest::ID:
            {
                Message<GetWorldPropertiesRequest > & tempSrc = static_cast<Message<GetWorldPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetWorldPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetWorldPropertiesResponse::ID:
            {
                Message<GetWorldPropertiesResponse > & tempSrc = static_cast<Message<GetWorldPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetWorldPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case GetWorldProperties::ID:
            {
                Message<GetWorldProperties > & tempSrc = static_cast<Message<GetWorldProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::GetWorldProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointRequestRequest::ID:
            {
                Message<JointRequestRequest > & tempSrc = static_cast<Message<JointRequestRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::JointRequestRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointRequestResponse::ID:
            {
                Message<JointRequestResponse > & tempSrc = static_cast<Message<JointRequestResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::JointRequestResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case JointRequest::ID:
            {
                Message<JointRequest > & tempSrc = static_cast<Message<JointRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::JointRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetJointPropertiesRequest::ID:
            {
                Message<SetJointPropertiesRequest > & tempSrc = static_cast<Message<SetJointPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetJointPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetJointPropertiesResponse::ID:
            {
                Message<SetJointPropertiesResponse > & tempSrc = static_cast<Message<SetJointPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetJointPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetJointProperties::ID:
            {
                Message<SetJointProperties > & tempSrc = static_cast<Message<SetJointProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetJointProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetJointTrajectoryRequest::ID:
            {
                Message<SetJointTrajectoryRequest > & tempSrc = static_cast<Message<SetJointTrajectoryRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetJointTrajectoryRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetJointTrajectoryResponse::ID:
            {
                Message<SetJointTrajectoryResponse > & tempSrc = static_cast<Message<SetJointTrajectoryResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetJointTrajectoryResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetJointTrajectory::ID:
            {
                Message<SetJointTrajectory > & tempSrc = static_cast<Message<SetJointTrajectory>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetJointTrajectory buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetLinkPropertiesRequest::ID:
            {
                Message<SetLinkPropertiesRequest > & tempSrc = static_cast<Message<SetLinkPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetLinkPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetLinkPropertiesResponse::ID:
            {
                Message<SetLinkPropertiesResponse > & tempSrc = static_cast<Message<SetLinkPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetLinkPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetLinkProperties::ID:
            {
                Message<SetLinkProperties > & tempSrc = static_cast<Message<SetLinkProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetLinkProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetLinkStateRequest::ID:
            {
                Message<SetLinkStateRequest > & tempSrc = static_cast<Message<SetLinkStateRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetLinkStateRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetLinkStateResponse::ID:
            {
                Message<SetLinkStateResponse > & tempSrc = static_cast<Message<SetLinkStateResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetLinkStateResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetLinkState::ID:
            {
                Message<SetLinkState > & tempSrc = static_cast<Message<SetLinkState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetLinkState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetModelConfigurationRequest::ID:
            {
                Message<SetModelConfigurationRequest > & tempSrc = static_cast<Message<SetModelConfigurationRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetModelConfigurationRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetModelConfigurationResponse::ID:
            {
                Message<SetModelConfigurationResponse > & tempSrc = static_cast<Message<SetModelConfigurationResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetModelConfigurationResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetModelConfiguration::ID:
            {
                Message<SetModelConfiguration > & tempSrc = static_cast<Message<SetModelConfiguration>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetModelConfiguration buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetModelStateRequest::ID:
            {
                Message<SetModelStateRequest > & tempSrc = static_cast<Message<SetModelStateRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetModelStateRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetModelStateResponse::ID:
            {
                Message<SetModelStateResponse > & tempSrc = static_cast<Message<SetModelStateResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetModelStateResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetModelState::ID:
            {
                Message<SetModelState > & tempSrc = static_cast<Message<SetModelState>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetModelState buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetPhysicsPropertiesRequest::ID:
            {
                Message<SetPhysicsPropertiesRequest > & tempSrc = static_cast<Message<SetPhysicsPropertiesRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetPhysicsPropertiesRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetPhysicsPropertiesResponse::ID:
            {
                Message<SetPhysicsPropertiesResponse > & tempSrc = static_cast<Message<SetPhysicsPropertiesResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetPhysicsPropertiesResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SetPhysicsProperties::ID:
            {
                Message<SetPhysicsProperties > & tempSrc = static_cast<Message<SetPhysicsProperties>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SetPhysicsProperties buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SpawnModelRequest::ID:
            {
                Message<SpawnModelRequest > & tempSrc = static_cast<Message<SpawnModelRequest>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SpawnModelRequest buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SpawnModelResponse::ID:
            {
                Message<SpawnModelResponse > & tempSrc = static_cast<Message<SpawnModelResponse>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SpawnModelResponse buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            case SpawnModel::ID:
            {
                Message<SpawnModel > & tempSrc = static_cast<Message<SpawnModel>&>(src);
                unsigned int bufSize = ros::serialization::serializationLength(tempSrc.payload());

			    if (bufSize >= dst.buffer_max_size)
				{
                     retval = rframe::Error::BUFFER_OVERRUN;
					 LOG_CRIT("ROS::toTransport: gazebo_msgs_gencpp::SpawnModel buffer overrun " << bufSize << " vs " << dst.buffer_max_size);
				}

                // deprecated, now uses pre allocated buffers
                dst.num_bytes = bufSize+sizeof(uint32_t);

                // create stream to hold serialized data + its length
                ros::serialization::OStream stream(dst.buf.get(),dst.num_bytes);
                // encode buffer length
				ros::serialization::serialize(stream,(uint32_t)bufSize);
                // encode payload
			    dst.message_start = stream.getData();
                ros::serialization::serialize(stream,tempSrc.payload());
                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
                break;
            }
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::fromTransport(ros::SerializedMessage & src, MessageBase & dst)
{
    int retval = rframe::Error::SUCCESS;

    if ((unsigned int)src.message_type != dst.id())
    {
        retval = rframe::Error::PARAM;
    }
    else
    {
        switch (src.message_type)
        { 
            case ContactState::ID:
            {
                Message<ContactState > & tempDst = static_cast<Message<ContactState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ContactsState::ID:
            {
                Message<ContactsState > & tempDst = static_cast<Message<ContactsState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case LinkState::ID:
            {
                Message<LinkState > & tempDst = static_cast<Message<LinkState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case LinkStates::ID:
            {
                Message<LinkStates > & tempDst = static_cast<Message<LinkStates>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ModelState::ID:
            {
                Message<ModelState > & tempDst = static_cast<Message<ModelState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ModelStates::ID:
            {
                Message<ModelStates > & tempDst = static_cast<Message<ModelStates>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ODEJointProperties::ID:
            {
                Message<ODEJointProperties > & tempDst = static_cast<Message<ODEJointProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ODEPhysics::ID:
            {
                Message<ODEPhysics > & tempDst = static_cast<Message<ODEPhysics>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case WorldState::ID:
            {
                Message<WorldState > & tempDst = static_cast<Message<WorldState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case ApplyBodyWrenchRequest::ID:
            {
                Message<ApplyBodyWrenchRequest > & tempDst = static_cast<Message<ApplyBodyWrenchRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ApplyBodyWrenchResponse::ID:
            {
                Message<ApplyBodyWrenchResponse > & tempDst = static_cast<Message<ApplyBodyWrenchResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ApplyBodyWrench::ID:
            {
                Message<ApplyBodyWrench > & tempDst = static_cast<Message<ApplyBodyWrench>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ApplyJointEffortRequest::ID:
            {
                Message<ApplyJointEffortRequest > & tempDst = static_cast<Message<ApplyJointEffortRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ApplyJointEffortResponse::ID:
            {
                Message<ApplyJointEffortResponse > & tempDst = static_cast<Message<ApplyJointEffortResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case ApplyJointEffort::ID:
            {
                Message<ApplyJointEffort > & tempDst = static_cast<Message<ApplyJointEffort>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case BodyRequestRequest::ID:
            {
                Message<BodyRequestRequest > & tempDst = static_cast<Message<BodyRequestRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case BodyRequestResponse::ID:
            {
                Message<BodyRequestResponse > & tempDst = static_cast<Message<BodyRequestResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case BodyRequest::ID:
            {
                Message<BodyRequest > & tempDst = static_cast<Message<BodyRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DeleteModelRequest::ID:
            {
                Message<DeleteModelRequest > & tempDst = static_cast<Message<DeleteModelRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DeleteModelResponse::ID:
            {
                Message<DeleteModelResponse > & tempDst = static_cast<Message<DeleteModelResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case DeleteModel::ID:
            {
                Message<DeleteModel > & tempDst = static_cast<Message<DeleteModel>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetJointPropertiesRequest::ID:
            {
                Message<GetJointPropertiesRequest > & tempDst = static_cast<Message<GetJointPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetJointPropertiesResponse::ID:
            {
                Message<GetJointPropertiesResponse > & tempDst = static_cast<Message<GetJointPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetJointProperties::ID:
            {
                Message<GetJointProperties > & tempDst = static_cast<Message<GetJointProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetLinkPropertiesRequest::ID:
            {
                Message<GetLinkPropertiesRequest > & tempDst = static_cast<Message<GetLinkPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetLinkPropertiesResponse::ID:
            {
                Message<GetLinkPropertiesResponse > & tempDst = static_cast<Message<GetLinkPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetLinkProperties::ID:
            {
                Message<GetLinkProperties > & tempDst = static_cast<Message<GetLinkProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetLinkStateRequest::ID:
            {
                Message<GetLinkStateRequest > & tempDst = static_cast<Message<GetLinkStateRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetLinkStateResponse::ID:
            {
                Message<GetLinkStateResponse > & tempDst = static_cast<Message<GetLinkStateResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetLinkState::ID:
            {
                Message<GetLinkState > & tempDst = static_cast<Message<GetLinkState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetModelPropertiesRequest::ID:
            {
                Message<GetModelPropertiesRequest > & tempDst = static_cast<Message<GetModelPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetModelPropertiesResponse::ID:
            {
                Message<GetModelPropertiesResponse > & tempDst = static_cast<Message<GetModelPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetModelProperties::ID:
            {
                Message<GetModelProperties > & tempDst = static_cast<Message<GetModelProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetModelStateRequest::ID:
            {
                Message<GetModelStateRequest > & tempDst = static_cast<Message<GetModelStateRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetModelStateResponse::ID:
            {
                Message<GetModelStateResponse > & tempDst = static_cast<Message<GetModelStateResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                rframe::Time t(tempDst.payload().header.stamp.sec,tempDst.payload().header.stamp.nsec);
                tempDst.timestamp(t.toTimestamp());

                break;
            } 
            case GetModelState::ID:
            {
                Message<GetModelState > & tempDst = static_cast<Message<GetModelState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetPhysicsPropertiesRequest::ID:
            {
                Message<GetPhysicsPropertiesRequest > & tempDst = static_cast<Message<GetPhysicsPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetPhysicsPropertiesResponse::ID:
            {
                Message<GetPhysicsPropertiesResponse > & tempDst = static_cast<Message<GetPhysicsPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetPhysicsProperties::ID:
            {
                Message<GetPhysicsProperties > & tempDst = static_cast<Message<GetPhysicsProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetWorldPropertiesRequest::ID:
            {
                Message<GetWorldPropertiesRequest > & tempDst = static_cast<Message<GetWorldPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetWorldPropertiesResponse::ID:
            {
                Message<GetWorldPropertiesResponse > & tempDst = static_cast<Message<GetWorldPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case GetWorldProperties::ID:
            {
                Message<GetWorldProperties > & tempDst = static_cast<Message<GetWorldProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointRequestRequest::ID:
            {
                Message<JointRequestRequest > & tempDst = static_cast<Message<JointRequestRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointRequestResponse::ID:
            {
                Message<JointRequestResponse > & tempDst = static_cast<Message<JointRequestResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case JointRequest::ID:
            {
                Message<JointRequest > & tempDst = static_cast<Message<JointRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetJointPropertiesRequest::ID:
            {
                Message<SetJointPropertiesRequest > & tempDst = static_cast<Message<SetJointPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetJointPropertiesResponse::ID:
            {
                Message<SetJointPropertiesResponse > & tempDst = static_cast<Message<SetJointPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetJointProperties::ID:
            {
                Message<SetJointProperties > & tempDst = static_cast<Message<SetJointProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetJointTrajectoryRequest::ID:
            {
                Message<SetJointTrajectoryRequest > & tempDst = static_cast<Message<SetJointTrajectoryRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetJointTrajectoryResponse::ID:
            {
                Message<SetJointTrajectoryResponse > & tempDst = static_cast<Message<SetJointTrajectoryResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetJointTrajectory::ID:
            {
                Message<SetJointTrajectory > & tempDst = static_cast<Message<SetJointTrajectory>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetLinkPropertiesRequest::ID:
            {
                Message<SetLinkPropertiesRequest > & tempDst = static_cast<Message<SetLinkPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetLinkPropertiesResponse::ID:
            {
                Message<SetLinkPropertiesResponse > & tempDst = static_cast<Message<SetLinkPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetLinkProperties::ID:
            {
                Message<SetLinkProperties > & tempDst = static_cast<Message<SetLinkProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetLinkStateRequest::ID:
            {
                Message<SetLinkStateRequest > & tempDst = static_cast<Message<SetLinkStateRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetLinkStateResponse::ID:
            {
                Message<SetLinkStateResponse > & tempDst = static_cast<Message<SetLinkStateResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetLinkState::ID:
            {
                Message<SetLinkState > & tempDst = static_cast<Message<SetLinkState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetModelConfigurationRequest::ID:
            {
                Message<SetModelConfigurationRequest > & tempDst = static_cast<Message<SetModelConfigurationRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetModelConfigurationResponse::ID:
            {
                Message<SetModelConfigurationResponse > & tempDst = static_cast<Message<SetModelConfigurationResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetModelConfiguration::ID:
            {
                Message<SetModelConfiguration > & tempDst = static_cast<Message<SetModelConfiguration>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetModelStateRequest::ID:
            {
                Message<SetModelStateRequest > & tempDst = static_cast<Message<SetModelStateRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetModelStateResponse::ID:
            {
                Message<SetModelStateResponse > & tempDst = static_cast<Message<SetModelStateResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetModelState::ID:
            {
                Message<SetModelState > & tempDst = static_cast<Message<SetModelState>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetPhysicsPropertiesRequest::ID:
            {
                Message<SetPhysicsPropertiesRequest > & tempDst = static_cast<Message<SetPhysicsPropertiesRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetPhysicsPropertiesResponse::ID:
            {
                Message<SetPhysicsPropertiesResponse > & tempDst = static_cast<Message<SetPhysicsPropertiesResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SetPhysicsProperties::ID:
            {
                Message<SetPhysicsProperties > & tempDst = static_cast<Message<SetPhysicsProperties>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SpawnModelRequest::ID:
            {
                Message<SpawnModelRequest > & tempDst = static_cast<Message<SpawnModelRequest>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SpawnModelResponse::ID:
            {
                Message<SpawnModelResponse > & tempDst = static_cast<Message<SpawnModelResponse>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            case SpawnModel::ID:
            {
                Message<SpawnModel > & tempDst = static_cast<Message<SpawnModel>&>(dst);

                ros::serialization::IStream stream(src.buf.get()+sizeof(int32_t),src.num_bytes-sizeof(int32_t));
                ros::serialization::deserialize(stream,tempDst.payload());

                break;
            } 
            default:
            {
                retval = rframe::Error::PARAM;
            }
        }
    }

    return retval;
}

int gazebo_msgs_gencppROSMessageFactory::updateHeader(rframe::MessageBase &msg, unsigned int seqNo)
{
    int retval = rframe::Error::SUCCESS;

    switch (msg.id())
    {   
        // ContactState does not have a Header as its first member 
        case ContactsState::ID:
        {
            Message<ContactsState > & tempMsg = static_cast<Message<ContactsState>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // LinkState does not have a Header as its first member 
        // LinkStates does not have a Header as its first member 
        // ModelState does not have a Header as its first member 
        // ModelStates does not have a Header as its first member 
        // ODEJointProperties does not have a Header as its first member 
        // ODEPhysics does not have a Header as its first member 
        case WorldState::ID:
        {
            Message<WorldState > & tempMsg = static_cast<Message<WorldState>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // ApplyBodyWrenchRequest does not have a Header as its first member 
        // ApplyBodyWrenchResponse does not have a Header as its first member 
        // ApplyBodyWrench does not have a Header as its first member 
        // ApplyJointEffortRequest does not have a Header as its first member 
        // ApplyJointEffortResponse does not have a Header as its first member 
        // ApplyJointEffort does not have a Header as its first member 
        // BodyRequestRequest does not have a Header as its first member 
        // BodyRequest does not have a Header as its first member 
        // DeleteModelRequest does not have a Header as its first member 
        // DeleteModelResponse does not have a Header as its first member 
        // DeleteModel does not have a Header as its first member 
        // GetJointPropertiesRequest does not have a Header as its first member 
        // GetJointPropertiesResponse does not have a Header as its first member 
        // GetJointProperties does not have a Header as its first member 
        // GetLinkPropertiesRequest does not have a Header as its first member 
        // GetLinkPropertiesResponse does not have a Header as its first member 
        // GetLinkProperties does not have a Header as its first member 
        // GetLinkStateRequest does not have a Header as its first member 
        // GetLinkStateResponse does not have a Header as its first member 
        // GetLinkState does not have a Header as its first member 
        // GetModelPropertiesRequest does not have a Header as its first member 
        // GetModelPropertiesResponse does not have a Header as its first member 
        // GetModelProperties does not have a Header as its first member 
        // GetModelStateRequest does not have a Header as its first member 
        case GetModelStateResponse::ID:
        {
            Message<GetModelStateResponse > & tempMsg = static_cast<Message<GetModelStateResponse>&>(msg);
            rframe::Time t(rframe::Time::now());
            tempMsg.payload().header.seq = seqNo;
            tempMsg.payload().header.stamp.sec = t.sec();
            tempMsg.payload().header.stamp.nsec = t.nsec();
            break;
        } 
        // GetModelState does not have a Header as its first member 
        // GetPhysicsPropertiesResponse does not have a Header as its first member 
        // GetPhysicsProperties does not have a Header as its first member 
        // GetWorldPropertiesResponse does not have a Header as its first member 
        // GetWorldProperties does not have a Header as its first member 
        // JointRequestRequest does not have a Header as its first member 
        // JointRequest does not have a Header as its first member 
        // SetJointPropertiesRequest does not have a Header as its first member 
        // SetJointPropertiesResponse does not have a Header as its first member 
        // SetJointProperties does not have a Header as its first member 
        // SetJointTrajectoryRequest does not have a Header as its first member 
        // SetJointTrajectoryResponse does not have a Header as its first member 
        // SetJointTrajectory does not have a Header as its first member 
        // SetLinkPropertiesRequest does not have a Header as its first member 
        // SetLinkPropertiesResponse does not have a Header as its first member 
        // SetLinkProperties does not have a Header as its first member 
        // SetLinkStateRequest does not have a Header as its first member 
        // SetLinkStateResponse does not have a Header as its first member 
        // SetLinkState does not have a Header as its first member 
        // SetModelConfigurationRequest does not have a Header as its first member 
        // SetModelConfigurationResponse does not have a Header as its first member 
        // SetModelConfiguration does not have a Header as its first member 
        // SetModelStateRequest does not have a Header as its first member 
        // SetModelStateResponse does not have a Header as its first member 
        // SetModelState does not have a Header as its first member 
        // SetPhysicsPropertiesRequest does not have a Header as its first member 
        // SetPhysicsPropertiesResponse does not have a Header as its first member 
        // SetPhysicsProperties does not have a Header as its first member 
        // SpawnModelRequest does not have a Header as its first member 
        // SpawnModelResponse does not have a Header as its first member 
        // SpawnModel does not have a Header as its first member 
        default:
        {
            retval = rframe::Error::NOT_FOUND;
            break;
        }
    }

    return retval;
}
